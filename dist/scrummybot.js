var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  function log(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse(src, options) {
    const debug6 = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug6) {
        log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug6 = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug6 = true;
      }
    }
    try {
      const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug: debug6});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug6) {
          log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config;
  module2.exports.parse = parse;
});

// node_modules/discord.js/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    _from: "discord.js@^12.5.1",
    _id: "discord.js@12.5.1",
    _inBundle: false,
    _integrity: "sha512-VwZkVaUAIOB9mKdca0I5MefPMTQJTNg0qdgi1huF3iwsFwJ0L5s/Y69AQe+iPmjuV6j9rtKoG0Ta0n9vgEIL6w==",
    _location: "/discord.js",
    _phantomChildren: {},
    _requested: {
      type: "range",
      registry: true,
      raw: "discord.js@^12.5.1",
      name: "discord.js",
      escapedName: "discord.js",
      rawSpec: "^12.5.1",
      saveSpec: null,
      fetchSpec: "^12.5.1"
    },
    _requiredBy: [
      "#DEV:/"
    ],
    _resolved: "https://registry.npmjs.org/discord.js/-/discord.js-12.5.1.tgz",
    _shasum: "992b45753e3815526a279914ccc281d3496f5990",
    _spec: "discord.js@^12.5.1",
    _where: "D:\\Programming-School\\scrummy-bot",
    author: {
      name: "Amish Shah",
      email: "amishshah.2k@gmail.com"
    },
    browser: {
      "@discordjs/opus": false,
      https: false,
      ws: false,
      erlpack: false,
      "prism-media": false,
      opusscript: false,
      "node-opus": false,
      tweetnacl: false,
      sodium: false,
      worker_threads: false,
      "zlib-sync": false,
      "src/sharding/Shard.js": false,
      "src/sharding/ShardClientUtil.js": false,
      "src/sharding/ShardingManager.js": false,
      "src/client/voice/ClientVoiceManager.js": false,
      "src/client/voice/VoiceBroadcast.js": false,
      "src/client/voice/VoiceConnection.js": false,
      "src/client/voice/dispatcher/BroadcastDispatcher.js": false,
      "src/client/voice/dispatcher/StreamDispatcher.js": false,
      "src/client/voice/networking/VoiceUDPClient.js": false,
      "src/client/voice/networking/VoiceWebSocket.js": false,
      "src/client/voice/player/AudioPlayer.js": false,
      "src/client/voice/player/BasePlayer.js": false,
      "src/client/voice/player/BroadcastAudioPlayer.js": false,
      "src/client/voice/receiver/PacketHandler.js": false,
      "src/client/voice/receiver/Receiver.js": false,
      "src/client/voice/util/PlayInterface.js": false,
      "src/client/voice/util/Secretbox.js": false,
      "src/client/voice/util/Silence.js": false,
      "src/client/voice/util/VolumeInterface.js": false
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    bundleDependencies: false,
    commitlint: {
      extends: [
        "@commitlint/config-angular"
      ],
      rules: {
        "scope-case": [
          2,
          "always",
          "pascal-case"
        ],
        "type-enum": [
          2,
          "always",
          [
            "chore",
            "build",
            "ci",
            "docs",
            "feat",
            "fix",
            "perf",
            "refactor",
            "revert",
            "style",
            "test"
          ]
        ]
      }
    },
    dependencies: {
      "@discordjs/collection": "^0.1.6",
      "@discordjs/form-data": "^3.0.1",
      "abort-controller": "^3.0.0",
      "node-fetch": "^2.6.1",
      "prism-media": "^1.2.2",
      setimmediate: "^1.0.5",
      tweetnacl: "^1.0.3",
      ws: "^7.3.1"
    },
    deprecated: false,
    description: "A powerful library for interacting with the Discord API",
    devDependencies: {
      "@commitlint/cli": "^11.0.0",
      "@commitlint/config-angular": "^11.0.0",
      "@types/node": "^12.12.6",
      "@types/ws": "^7.2.7",
      "cross-env": "^7.0.2",
      "discord.js-docgen": "git+https://github.com/discordjs/docgen.git",
      dtslint: "^4.0.4",
      eslint: "^7.11.0",
      "eslint-config-prettier": "^6.13.0",
      "eslint-plugin-import": "^2.22.1",
      "eslint-plugin-prettier": "^3.1.4",
      husky: "^4.3.0",
      jest: "^26.6.0",
      "json-filter-loader": "^1.0.0",
      "lint-staged": "^10.4.2",
      prettier: "^2.1.2",
      "terser-webpack-plugin": "^4.2.3",
      tslint: "^6.1.3",
      typescript: "^4.0.3",
      webpack: "^4.44.2",
      "webpack-cli": "^3.3.12"
    },
    engines: {
      node: ">=12.0.0"
    },
    exports: {
      ".": [
        {
          require: "./src/index.js",
          import: "./esm/discord.mjs"
        },
        "./src/index.js"
      ],
      "./esm": "./esm/discord.mjs"
    },
    homepage: "https://github.com/discordjs/discord.js#readme",
    husky: {
      hooks: {
        "pre-commit": "lint-staged",
        "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
      }
    },
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    license: "Apache-2.0",
    "lint-staged": {
      "*.js": "eslint --fix",
      "*.ts": "prettier --write"
    },
    main: "./src/index",
    name: "discord.js",
    prettier: {
      singleQuote: true,
      printWidth: 120,
      trailingComma: "all",
      endOfLine: "lf",
      arrowParens: "avoid"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/discordjs/discord.js.git"
    },
    runkitExampleFilename: "./docs/examples/ping.js",
    scripts: {
      "build:browser": "webpack",
      docs: "docgen --source src --custom docs/index.yml --output docs/docs.json",
      "docs:test": "docgen --source src --custom docs/index.yml",
      lint: "eslint src",
      "lint:fix": "eslint src --fix",
      "lint:typings": "tslint typings/index.d.ts",
      prepublishOnly: "npm run test && cross-env NODE_ENV=production npm run build:browser",
      prettier: "prettier --write src/**/*.js typings/**/*.ts",
      test: "npm run lint && npm run docs:test && npm run lint:typings",
      "test:typescript": "tsc"
    },
    types: "./typings/index.d.ts",
    unpkg: "./webpack/discord.min.js",
    version: "12.5.1"
  };
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports2, module2) => {
  "use strict";
  var kCode = Symbol("code");
  var messages = new Map();
  function makeDiscordjsError(Base) {
    return class DiscordjsError extends Base {
      constructor(key, ...args) {
        super(message(key, args));
        this[kCode] = key;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this[kCode]}]`;
      }
      get code() {
        return this[kCode];
      }
    };
  }
  function message(key, args) {
    if (typeof key !== "string")
      throw new Error("Error message key must be a string");
    const msg = messages.get(key);
    if (!msg)
      throw new Error(`An invalid error message key was used: ${key}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (args === void 0 || args.length === 0)
      return msg;
    args.unshift(msg);
    return String(...args);
  }
  function register(sym, val) {
    messages.set(sym, typeof val === "function" ? val : String(val));
  }
  module2.exports = {
    register,
    Error: makeDiscordjsError(Error),
    TypeError: makeDiscordjsError(TypeError),
    RangeError: makeDiscordjsError(RangeError)
  };
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS(() => {
  "use strict";
  var {register} = require_DJSError();
  var Messages = {
    CLIENT_INVALID_OPTION: (prop, must) => `The ${prop} option must be ${must}`,
    CLIENT_INVALID_PROVIDED_SHARDS: "None of the provided shards were valid.",
    TOKEN_INVALID: "An invalid token was provided.",
    TOKEN_MISSING: "Request to use token, but token was unavailable to the client.",
    WS_CLOSE_REQUESTED: "WebSocket closed due to user request.",
    WS_CONNECTION_EXISTS: "There is already an existing WebSocket connection.",
    WS_NOT_OPEN: (data = "data") => `Websocket not open to send ${data}`,
    BITFIELD_INVALID: "Invalid bitfield flag or number.",
    SHARDING_INVALID: "Invalid shard settings were provided.",
    SHARDING_REQUIRED: "This session would have handled too many guilds - Sharding is required.",
    INVALID_INTENTS: "Invalid intent provided for WebSocket intents.",
    DISALLOWED_INTENTS: "Privileged intent provided is not enabled or whitelisted.",
    SHARDING_NO_SHARDS: "No shards have been spawned.",
    SHARDING_IN_PROCESS: "Shards are still being spawned.",
    SHARDING_SHARD_NOT_FOUND: (id) => `Shard ${id} could not be found.`,
    SHARDING_ALREADY_SPAWNED: (count) => `Already spawned ${count} shards.`,
    SHARDING_PROCESS_EXISTS: (id) => `Shard ${id} already has an active process.`,
    SHARDING_WORKER_EXISTS: (id) => `Shard ${id} already has an active worker.`,
    SHARDING_READY_TIMEOUT: (id) => `Shard ${id}'s Client took too long to become ready.`,
    SHARDING_READY_DISCONNECTED: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    SHARDING_READY_DIED: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    SHARDING_NO_CHILD_EXISTS: (id) => `Shard ${id} has no active process or worker.`,
    SHARDING_SHARD_MISCALCULATION: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    COLOR_RANGE: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    COLOR_CONVERT: "Unable to convert color to a number.",
    EMBED_FIELD_NAME: "MessageEmbed field names may not be empty.",
    EMBED_FIELD_VALUE: "MessageEmbed field values may not be empty.",
    FILE_NOT_FOUND: (file) => `File could not be found: ${file}`,
    USER_NO_DMCHANNEL: "No DM Channel exists!",
    VOICE_INVALID_HEARTBEAT: "Tried to set voice heartbeat but no valid interval was specified.",
    VOICE_USER_MISSING: "Couldn't resolve the user to create stream.",
    VOICE_JOIN_CHANNEL: (full = false) => `You do not have permission to join this voice channel${full ? "; it is full." : "."}`,
    VOICE_CONNECTION_TIMEOUT: "Connection not established within 15 seconds.",
    VOICE_TOKEN_ABSENT: "Token not provided from voice server packet.",
    VOICE_SESSION_ABSENT: "Session ID not supplied.",
    VOICE_INVALID_ENDPOINT: "Invalid endpoint received.",
    VOICE_NO_BROWSER: "Voice connections are not available in browsers.",
    VOICE_CONNECTION_ATTEMPTS_EXCEEDED: (attempts) => `Too many connection attempts (${attempts}).`,
    VOICE_JOIN_SOCKET_CLOSED: "Tried to send join packet, but the WebSocket is not open.",
    VOICE_PLAY_INTERFACE_NO_BROADCAST: "A broadcast cannot be played in this context.",
    VOICE_PLAY_INTERFACE_BAD_TYPE: "Unknown stream type",
    VOICE_PRISM_DEMUXERS_NEED_STREAM: "To play a webm/ogg stream, you need to pass a ReadableStream.",
    VOICE_STATE_UNCACHED_MEMBER: "The member of this voice state is uncached.",
    VOICE_STATE_NOT_OWN: "You cannot self-deafen/mute on VoiceStates that do not belong to the ClientUser.",
    VOICE_STATE_INVALID_TYPE: (name) => `${name} must be a boolean.`,
    UDP_SEND_FAIL: "Tried to send a UDP packet, but there is no socket available.",
    UDP_ADDRESS_MALFORMED: "Malformed UDP address or port.",
    UDP_CONNECTION_EXISTS: "There is already an existing UDP connection.",
    REQ_RESOURCE_TYPE: "The resource must be a string, Buffer or a valid file stream.",
    IMAGE_FORMAT: (format) => `Invalid image format: ${format}`,
    IMAGE_SIZE: (size) => `Invalid image size: ${size}`,
    MESSAGE_BULK_DELETE_TYPE: "The messages must be an Array, Collection, or number.",
    MESSAGE_NONCE_TYPE: "Message nonce must fit in an unsigned 64-bit integer.",
    TYPING_COUNT: "Count must be at least 1",
    SPLIT_MAX_LEN: "Chunk exceeds the max length and contains no split characters.",
    BAN_RESOLVE_ID: (ban = false) => `Couldn't resolve the user ID to ${ban ? "ban" : "unban"}.`,
    FETCH_BAN_RESOLVE_ID: "Couldn't resolve the user ID to fetch the ban.",
    PRUNE_DAYS_TYPE: "Days must be a number",
    GUILD_CHANNEL_RESOLVE: "Could not resolve channel to a guild channel.",
    GUILD_VOICE_CHANNEL_RESOLVE: "Could not resolve channel to a guild voice channel.",
    GUILD_CHANNEL_ORPHAN: "Could not find a parent to this guild channel.",
    GUILD_OWNED: "Guild is owned by the client.",
    GUILD_MEMBERS_TIMEOUT: "Members didn't arrive in time.",
    GUILD_UNCACHED_ME: "The client user as a member of this guild is uncached.",
    INVALID_TYPE: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    WEBHOOK_MESSAGE: "The message was not sent by a webhook.",
    EMOJI_TYPE: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    EMOJI_MANAGED: "Emoji is managed and has no Author.",
    MISSING_MANAGE_EMOJIS_PERMISSION: (guild) => `Client must have Manage Emoji permission in guild ${guild} to see emoji authors.`,
    REACTION_RESOLVE_USER: "Couldn't resolve the user ID to remove from the reaction.",
    VANITY_URL: "This guild does not have the VANITY_URL feature enabled.",
    DELETE_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot delete them",
    FETCH_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot fetch them",
    MEMBER_FETCH_NONCE_LENGTH: "Nonce length must not exceed 32 characters."
  };
  for (const [name, message] of Object.entries(Messages))
    register(name, message);
});

// node_modules/discord.js/src/errors/index.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_DJSError();
  module2.exports.Messages = require_Messages();
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports2) => {
  "use strict";
  var Package = exports2.Package = require_package();
  var {Error: Error2, RangeError: RangeError2} = require_errors();
  var browser2 = exports2.browser = typeof window !== "undefined";
  exports2.DefaultOptions = {
    shardCount: 1,
    messageCacheMaxSize: 200,
    messageCacheLifetime: 0,
    messageSweepInterval: 0,
    messageEditHistoryMaxSize: -1,
    fetchAllMembers: false,
    disableMentions: "none",
    partials: [],
    restWsBridgeTimeout: 5e3,
    restRequestTimeout: 15e3,
    retryLimit: 1,
    restTimeOffset: 500,
    restSweepInterval: 60,
    presence: {},
    ws: {
      large_threshold: 50,
      compress: false,
      properties: {
        $os: browser2 ? "browser" : process.platform,
        $browser: "discord.js",
        $device: "discord.js"
      },
      version: 6
    },
    http: {
      version: 7,
      api: "https://discord.com/api",
      cdn: "https://cdn.discordapp.com",
      invite: "https://discord.gg",
      template: "https://discord.new"
    }
  };
  exports2.UserAgent = browser2 ? null : `DiscordBot (${Package.homepage.split("#")[0]}, ${Package.version}) Node.js/${process.version}`;
  exports2.WSCodes = {
    1e3: "WS_CLOSE_REQUESTED",
    4004: "TOKEN_INVALID",
    4010: "SHARDING_INVALID",
    4011: "SHARDING_REQUIRED",
    4013: "INVALID_INTENTS",
    4014: "DISALLOWED_INTENTS"
  };
  var AllowedImageFormats = ["webp", "png", "jpg", "jpeg", "gif"];
  var AllowedImageSizes = Array.from({length: 9}, (e, i) => 2 ** (i + 4));
  function makeImageUrl(root, {format = "webp", size} = {}) {
    if (format && !AllowedImageFormats.includes(format))
      throw new Error2("IMAGE_FORMAT", format);
    if (size && !AllowedImageSizes.includes(size))
      throw new RangeError2("IMAGE_SIZE", size);
    return `${root}.${format}${size ? `?size=${size}` : ""}`;
  }
  exports2.Endpoints = {
    CDN(root) {
      return {
        Emoji: (emojiID, format = "png") => `${root}/emojis/${emojiID}.${format}`,
        Asset: (name) => `${root}/assets/${name}`,
        DefaultAvatar: (discriminator) => `${root}/embed/avatars/${discriminator}.png`,
        Avatar: (userID, hash, format = "webp", size, dynamic = false) => {
          if (dynamic)
            format = hash.startsWith("a_") ? "gif" : format;
          return makeImageUrl(`${root}/avatars/${userID}/${hash}`, {format, size});
        },
        Banner: (guildID, hash, format = "webp", size) => makeImageUrl(`${root}/banners/${guildID}/${hash}`, {format, size}),
        Icon: (guildID, hash, format = "webp", size, dynamic = false) => {
          if (dynamic)
            format = hash.startsWith("a_") ? "gif" : format;
          return makeImageUrl(`${root}/icons/${guildID}/${hash}`, {format, size});
        },
        AppIcon: (clientID, hash, {format = "webp", size} = {}) => makeImageUrl(`${root}/app-icons/${clientID}/${hash}`, {size, format}),
        AppAsset: (clientID, hash, {format = "webp", size} = {}) => makeImageUrl(`${root}/app-assets/${clientID}/${hash}`, {size, format}),
        GDMIcon: (channelID, hash, format = "webp", size) => makeImageUrl(`${root}/channel-icons/${channelID}/${hash}`, {size, format}),
        Splash: (guildID, hash, format = "webp", size) => makeImageUrl(`${root}/splashes/${guildID}/${hash}`, {size, format}),
        DiscoverySplash: (guildID, hash, format = "webp", size) => makeImageUrl(`${root}/discovery-splashes/${guildID}/${hash}`, {size, format}),
        TeamIcon: (teamID, hash, {format = "webp", size} = {}) => makeImageUrl(`${root}/team-icons/${teamID}/${hash}`, {size, format})
      };
    },
    invite: (root, code) => `${root}/${code}`,
    botGateway: "/gateway/bot"
  };
  exports2.Status = {
    READY: 0,
    CONNECTING: 1,
    RECONNECTING: 2,
    IDLE: 3,
    NEARLY: 4,
    DISCONNECTED: 5,
    WAITING_FOR_GUILDS: 6,
    IDENTIFYING: 7,
    RESUMING: 8
  };
  exports2.VoiceStatus = {
    CONNECTED: 0,
    CONNECTING: 1,
    AUTHENTICATING: 2,
    RECONNECTING: 3,
    DISCONNECTED: 4
  };
  exports2.OPCodes = {
    DISPATCH: 0,
    HEARTBEAT: 1,
    IDENTIFY: 2,
    STATUS_UPDATE: 3,
    VOICE_STATE_UPDATE: 4,
    VOICE_GUILD_PING: 5,
    RESUME: 6,
    RECONNECT: 7,
    REQUEST_GUILD_MEMBERS: 8,
    INVALID_SESSION: 9,
    HELLO: 10,
    HEARTBEAT_ACK: 11
  };
  exports2.VoiceOPCodes = {
    IDENTIFY: 0,
    SELECT_PROTOCOL: 1,
    READY: 2,
    HEARTBEAT: 3,
    SESSION_DESCRIPTION: 4,
    SPEAKING: 5,
    HELLO: 8,
    CLIENT_CONNECT: 12,
    CLIENT_DISCONNECT: 13
  };
  exports2.Events = {
    RATE_LIMIT: "rateLimit",
    CLIENT_READY: "ready",
    GUILD_CREATE: "guildCreate",
    GUILD_DELETE: "guildDelete",
    GUILD_UPDATE: "guildUpdate",
    GUILD_UNAVAILABLE: "guildUnavailable",
    GUILD_AVAILABLE: "guildAvailable",
    GUILD_MEMBER_ADD: "guildMemberAdd",
    GUILD_MEMBER_REMOVE: "guildMemberRemove",
    GUILD_MEMBER_UPDATE: "guildMemberUpdate",
    GUILD_MEMBER_AVAILABLE: "guildMemberAvailable",
    GUILD_MEMBER_SPEAKING: "guildMemberSpeaking",
    GUILD_MEMBERS_CHUNK: "guildMembersChunk",
    GUILD_INTEGRATIONS_UPDATE: "guildIntegrationsUpdate",
    GUILD_ROLE_CREATE: "roleCreate",
    GUILD_ROLE_DELETE: "roleDelete",
    INVITE_CREATE: "inviteCreate",
    INVITE_DELETE: "inviteDelete",
    GUILD_ROLE_UPDATE: "roleUpdate",
    GUILD_EMOJI_CREATE: "emojiCreate",
    GUILD_EMOJI_DELETE: "emojiDelete",
    GUILD_EMOJI_UPDATE: "emojiUpdate",
    GUILD_BAN_ADD: "guildBanAdd",
    GUILD_BAN_REMOVE: "guildBanRemove",
    CHANNEL_CREATE: "channelCreate",
    CHANNEL_DELETE: "channelDelete",
    CHANNEL_UPDATE: "channelUpdate",
    CHANNEL_PINS_UPDATE: "channelPinsUpdate",
    MESSAGE_CREATE: "message",
    MESSAGE_DELETE: "messageDelete",
    MESSAGE_UPDATE: "messageUpdate",
    MESSAGE_BULK_DELETE: "messageDeleteBulk",
    MESSAGE_REACTION_ADD: "messageReactionAdd",
    MESSAGE_REACTION_REMOVE: "messageReactionRemove",
    MESSAGE_REACTION_REMOVE_ALL: "messageReactionRemoveAll",
    MESSAGE_REACTION_REMOVE_EMOJI: "messageReactionRemoveEmoji",
    USER_UPDATE: "userUpdate",
    PRESENCE_UPDATE: "presenceUpdate",
    VOICE_SERVER_UPDATE: "voiceServerUpdate",
    VOICE_STATE_UPDATE: "voiceStateUpdate",
    VOICE_BROADCAST_SUBSCRIBE: "subscribe",
    VOICE_BROADCAST_UNSUBSCRIBE: "unsubscribe",
    TYPING_START: "typingStart",
    TYPING_STOP: "typingStop",
    WEBHOOKS_UPDATE: "webhookUpdate",
    ERROR: "error",
    WARN: "warn",
    DEBUG: "debug",
    SHARD_DISCONNECT: "shardDisconnect",
    SHARD_ERROR: "shardError",
    SHARD_RECONNECTING: "shardReconnecting",
    SHARD_READY: "shardReady",
    SHARD_RESUME: "shardResume",
    INVALIDATED: "invalidated",
    RAW: "raw"
  };
  exports2.ShardEvents = {
    CLOSE: "close",
    DESTROYED: "destroyed",
    INVALID_SESSION: "invalidSession",
    READY: "ready",
    RESUMED: "resumed",
    ALL_READY: "allReady"
  };
  exports2.PartialTypes = keyMirror(["USER", "CHANNEL", "GUILD_MEMBER", "MESSAGE", "REACTION"]);
  exports2.WSEvents = keyMirror([
    "READY",
    "RESUMED",
    "GUILD_CREATE",
    "GUILD_DELETE",
    "GUILD_UPDATE",
    "INVITE_CREATE",
    "INVITE_DELETE",
    "GUILD_MEMBER_ADD",
    "GUILD_MEMBER_REMOVE",
    "GUILD_MEMBER_UPDATE",
    "GUILD_MEMBERS_CHUNK",
    "GUILD_INTEGRATIONS_UPDATE",
    "GUILD_ROLE_CREATE",
    "GUILD_ROLE_DELETE",
    "GUILD_ROLE_UPDATE",
    "GUILD_BAN_ADD",
    "GUILD_BAN_REMOVE",
    "GUILD_EMOJIS_UPDATE",
    "CHANNEL_CREATE",
    "CHANNEL_DELETE",
    "CHANNEL_UPDATE",
    "CHANNEL_PINS_UPDATE",
    "MESSAGE_CREATE",
    "MESSAGE_DELETE",
    "MESSAGE_UPDATE",
    "MESSAGE_DELETE_BULK",
    "MESSAGE_REACTION_ADD",
    "MESSAGE_REACTION_REMOVE",
    "MESSAGE_REACTION_REMOVE_ALL",
    "MESSAGE_REACTION_REMOVE_EMOJI",
    "USER_UPDATE",
    "PRESENCE_UPDATE",
    "TYPING_START",
    "VOICE_STATE_UPDATE",
    "VOICE_SERVER_UPDATE",
    "WEBHOOKS_UPDATE"
  ]);
  exports2.MessageTypes = [
    "DEFAULT",
    "RECIPIENT_ADD",
    "RECIPIENT_REMOVE",
    "CALL",
    "CHANNEL_NAME_CHANGE",
    "CHANNEL_ICON_CHANGE",
    "PINS_ADD",
    "GUILD_MEMBER_JOIN",
    "USER_PREMIUM_GUILD_SUBSCRIPTION",
    "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1",
    "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2",
    "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3",
    "CHANNEL_FOLLOW_ADD",
    null,
    "GUILD_DISCOVERY_DISQUALIFIED",
    "GUILD_DISCOVERY_REQUALIFIED"
  ];
  exports2.ActivityTypes = ["PLAYING", "STREAMING", "LISTENING", "WATCHING", "CUSTOM_STATUS", "COMPETING"];
  exports2.ChannelTypes = {
    TEXT: 0,
    DM: 1,
    VOICE: 2,
    GROUP: 3,
    CATEGORY: 4,
    NEWS: 5,
    STORE: 6
  };
  exports2.ClientApplicationAssetTypes = {
    SMALL: 1,
    BIG: 2
  };
  exports2.Colors = {
    DEFAULT: 0,
    WHITE: 16777215,
    AQUA: 1752220,
    GREEN: 3066993,
    BLUE: 3447003,
    YELLOW: 16776960,
    PURPLE: 10181046,
    LUMINOUS_VIVID_PINK: 15277667,
    GOLD: 15844367,
    ORANGE: 15105570,
    RED: 15158332,
    GREY: 9807270,
    NAVY: 3426654,
    DARK_AQUA: 1146986,
    DARK_GREEN: 2067276,
    DARK_BLUE: 2123412,
    DARK_PURPLE: 7419530,
    DARK_VIVID_PINK: 11342935,
    DARK_GOLD: 12745742,
    DARK_ORANGE: 11027200,
    DARK_RED: 10038562,
    DARK_GREY: 9936031,
    DARKER_GREY: 8359053,
    LIGHT_GREY: 12370112,
    DARK_NAVY: 2899536,
    BLURPLE: 7506394,
    GREYPLE: 10070709,
    DARK_BUT_NOT_BLACK: 2895667,
    NOT_QUITE_BLACK: 2303786
  };
  exports2.ExplicitContentFilterLevels = ["DISABLED", "MEMBERS_WITHOUT_ROLES", "ALL_MEMBERS"];
  exports2.VerificationLevels = ["NONE", "LOW", "MEDIUM", "HIGH", "VERY_HIGH"];
  exports2.APIErrors = {
    UNKNOWN_ACCOUNT: 10001,
    UNKNOWN_APPLICATION: 10002,
    UNKNOWN_CHANNEL: 10003,
    UNKNOWN_GUILD: 10004,
    UNKNOWN_INTEGRATION: 10005,
    UNKNOWN_INVITE: 10006,
    UNKNOWN_MEMBER: 10007,
    UNKNOWN_MESSAGE: 10008,
    UNKNOWN_OVERWRITE: 10009,
    UNKNOWN_PROVIDER: 10010,
    UNKNOWN_ROLE: 10011,
    UNKNOWN_TOKEN: 10012,
    UNKNOWN_USER: 10013,
    UNKNOWN_EMOJI: 10014,
    UNKNOWN_WEBHOOK: 10015,
    UNKNOWN_BAN: 10026,
    UNKNOWN_GUILD_TEMPLATE: 10057,
    BOT_PROHIBITED_ENDPOINT: 20001,
    BOT_ONLY_ENDPOINT: 20002,
    CHANNEL_HIT_WRITE_RATELIMIT: 20028,
    MAXIMUM_GUILDS: 30001,
    MAXIMUM_FRIENDS: 30002,
    MAXIMUM_PINS: 30003,
    MAXIMUM_ROLES: 30005,
    MAXIMUM_WEBHOOKS: 30007,
    MAXIMUM_REACTIONS: 30010,
    MAXIMUM_CHANNELS: 30013,
    MAXIMUM_ATTACHMENTS: 30015,
    MAXIMUM_INVITES: 30016,
    GUILD_ALREADY_HAS_TEMPLATE: 30031,
    UNAUTHORIZED: 40001,
    ACCOUNT_VERIFICATION_REQUIRED: 40002,
    REQUEST_ENTITY_TOO_LARGE: 40005,
    FEATURE_TEMPORARILY_DISABLED: 40006,
    USER_BANNED: 40007,
    ALREADY_CROSSPOSTED: 40033,
    MISSING_ACCESS: 50001,
    INVALID_ACCOUNT_TYPE: 50002,
    CANNOT_EXECUTE_ON_DM: 50003,
    EMBED_DISABLED: 50004,
    CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,
    CANNOT_SEND_EMPTY_MESSAGE: 50006,
    CANNOT_MESSAGE_USER: 50007,
    CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,
    CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,
    OAUTH2_APPLICATION_BOT_ABSENT: 50010,
    MAXIMUM_OAUTH2_APPLICATIONS: 50011,
    INVALID_OAUTH_STATE: 50012,
    MISSING_PERMISSIONS: 50013,
    INVALID_AUTHENTICATION_TOKEN: 50014,
    NOTE_TOO_LONG: 50015,
    INVALID_BULK_DELETE_QUANTITY: 50016,
    CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,
    INVALID_OR_TAKEN_INVITE_CODE: 50020,
    CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,
    INVALID_OAUTH_TOKEN: 50025,
    BULK_DELETE_MESSAGE_TOO_OLD: 50034,
    INVALID_FORM_BODY: 50035,
    INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT: 50036,
    INVALID_API_VERSION: 50041,
    CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL: 50074,
    REACTION_BLOCKED: 90001,
    RESOURCE_OVERLOADED: 13e4
  };
  exports2.DefaultMessageNotifications = ["ALL", "MENTIONS"];
  exports2.MembershipStates = [
    null,
    "INVITED",
    "ACCEPTED"
  ];
  exports2.WebhookTypes = [
    null,
    "Incoming",
    "Channel Follower"
  ];
  function keyMirror(arr) {
    let tmp = Object.create(null);
    for (const value of arr)
      tmp[value] = value;
    return tmp;
  }
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Collection = void 0;
  var Collection2 = class extends Map {
    constructor(entries) {
      super(entries);
      Object.defineProperty(this, "_array", {value: null, writable: true, configurable: true});
      Object.defineProperty(this, "_keyArray", {value: null, writable: true, configurable: true});
    }
    get(key) {
      return super.get(key);
    }
    set(key, value) {
      this._array = null;
      this._keyArray = null;
      return super.set(key, value);
    }
    has(key) {
      return super.has(key);
    }
    delete(key) {
      this._array = null;
      this._keyArray = null;
      return super.delete(key);
    }
    clear() {
      return super.clear();
    }
    array() {
      if (!this._array || this._array.length !== this.size)
        this._array = [...this.values()];
      return this._array;
    }
    keyArray() {
      if (!this._keyArray || this._keyArray.length !== this.size)
        this._keyArray = [...this.keys()];
      return this._keyArray;
    }
    first(amount) {
      if (typeof amount === "undefined")
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({length: amount}, () => iter.next().value);
    }
    firstKey(amount) {
      if (typeof amount === "undefined")
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({length: amount}, () => iter.next().value);
    }
    last(amount) {
      const arr = this.array();
      if (typeof amount === "undefined")
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = this.keyArray();
      if (typeof amount === "undefined")
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    random(amount) {
      let arr = this.array();
      if (typeof amount === "undefined")
        return arr[Math.floor(Math.random() * arr.length)];
      if (arr.length === 0 || !amount)
        return [];
      arr = arr.slice();
      return Array.from({length: amount}, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      let arr = this.keyArray();
      if (typeof amount === "undefined")
        return arr[Math.floor(Math.random() * arr.length)];
      if (arr.length === 0 || !amount)
        return [];
      arr = arr.slice();
      return Array.from({length: amount}, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    find(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return void 0;
    }
    findKey(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return void 0;
    }
    sweep(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species]();
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const results = [new this.constructor[Symbol.species](), new this.constructor[Symbol.species]()];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({length: this.size}, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species]();
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      let accumulator;
      if (typeof initialValue !== "undefined") {
        accumulator = initialValue;
        for (const [key, val] of this)
          accumulator = fn(accumulator, val, key, this);
        return accumulator;
      }
      let first = true;
      for (const [key, val] of this) {
        if (first) {
          accumulator = val;
          first = false;
          continue;
        }
        accumulator = fn(accumulator, val, key, this);
      }
      if (first) {
        throw new TypeError("Reduce of empty collection with no initial value");
      }
      return accumulator;
    }
    each(fn, thisArg) {
      this.forEach(fn, thisArg);
      return this;
    }
    tap(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = (x, y) => Number(x > y) || Number(x === y) - 1) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      this._array = null;
      this._keyArray = null;
      for (const [k, v] of entries) {
        super.set(k, v);
      }
      return this;
    }
    intersect(other) {
      return other.filter((_, k) => this.has(k));
    }
    difference(other) {
      return other.filter((_, k) => !this.has(k)).concat(this.filter((_, k) => !other.has(k)));
    }
    sorted(compareFunction = (x, y) => Number(x > y) || Number(x === y) - 1) {
      return new this.constructor[Symbol.species]([...this.entries()]).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
  };
  exports2.Collection = Collection2;
  Collection2.default = Collection2;
  module2.exports = Collection2;
  exports2.default = Collection2;
});

// node_modules/discord.js/src/util/Collection.js
var require_Collection = __commonJS((exports2, module2) => {
  "use strict";
  var BaseCollection = require_dist();
  var Util = require_Util();
  var Collection2 = class extends BaseCollection {
    toJSON() {
      return this.map((e) => typeof e.toJSON === "function" ? e.toJSON() : Util.flatten(e));
    }
  };
  module2.exports = Collection2;
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports2, module2) => {
  "use strict";
  var {parse} = require("path");
  var fetch = require("node-fetch");
  var {Colors, DefaultOptions: DefaultOptions2, Endpoints} = require_Constants();
  var {Error: DiscordError, RangeError: RangeError2, TypeError: TypeError2} = require_errors();
  var has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);
  var isObject = (d) => typeof d === "object" && d !== null;
  var Util = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static flatten(obj, ...props) {
      if (!isObject(obj))
        return obj;
      const objProps = Object.keys(obj).filter((k) => !k.startsWith("_")).map((k) => ({[k]: true}));
      props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
      const out = {};
      for (let [prop, newProp] of Object.entries(props)) {
        if (!newProp)
          continue;
        newProp = newProp === true ? prop : newProp;
        const element = obj[prop];
        const elemIsObj = isObject(element);
        const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
        if (element instanceof require_Collection())
          out[newProp] = Array.from(element.keys());
        else if (valueOf instanceof require_Collection())
          out[newProp] = Array.from(valueOf.keys());
        else if (Array.isArray(element))
          out[newProp] = element.map((e) => Util.flatten(e));
        else if (typeof valueOf !== "object")
          out[newProp] = valueOf;
        else if (!elemIsObj)
          out[newProp] = element;
      }
      return out;
    }
    static splitMessage(text, {maxLength = 2e3, char = "\n", prepend = "", append = ""} = {}) {
      text = Util.resolveString(text);
      if (text.length <= maxLength)
        return [text];
      const splitText = text.split(char);
      if (splitText.some((chunk) => chunk.length > maxLength))
        throw new RangeError2("SPLIT_MAX_LEN");
      const messages = [];
      let msg = "";
      for (const chunk of splitText) {
        if (msg && (msg + char + chunk + append).length > maxLength) {
          messages.push(msg + append);
          msg = prepend;
        }
        msg += (msg && msg !== prepend ? char : "") + chunk;
      }
      return messages.concat(msg).filter((m) => m);
    }
    static escapeMarkdown(text, {
      codeBlock = true,
      inlineCode = true,
      bold = true,
      italic = true,
      underline = true,
      strikethrough = true,
      spoiler = true,
      codeBlockContent = true,
      inlineCodeContent = true
    } = {}) {
      if (!codeBlockContent) {
        return text.split("```").map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return Util.escapeMarkdown(subString, {
            inlineCode,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler,
            inlineCodeContent
          });
        }).join(codeBlock ? "\\`\\`\\`" : "```");
      }
      if (!inlineCodeContent) {
        return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return Util.escapeMarkdown(subString, {
            codeBlock,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler
          });
        }).join(inlineCode ? "\\`" : "`");
      }
      if (inlineCode)
        text = Util.escapeInlineCode(text);
      if (codeBlock)
        text = Util.escapeCodeBlock(text);
      if (italic)
        text = Util.escapeItalic(text);
      if (bold)
        text = Util.escapeBold(text);
      if (underline)
        text = Util.escapeUnderline(text);
      if (strikethrough)
        text = Util.escapeStrikethrough(text);
      if (spoiler)
        text = Util.escapeSpoiler(text);
      return text;
    }
    static escapeCodeBlock(text) {
      return text.replace(/```/g, "\\`\\`\\`");
    }
    static escapeInlineCode(text) {
      return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, "\\`");
    }
    static escapeItalic(text) {
      let i = 0;
      text = text.replace(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
        if (match === "**")
          return ++i % 2 ? `\\*${match}` : `${match}\\*`;
        return `\\*${match}`;
      });
      i = 0;
      return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {
        if (match === "__")
          return ++i % 2 ? `\\_${match}` : `${match}\\_`;
        return `\\_${match}`;
      });
    }
    static escapeBold(text) {
      let i = 0;
      return text.replace(/\*\*(\*)?/g, (_, match) => {
        if (match)
          return ++i % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
        return "\\*\\*";
      });
    }
    static escapeUnderline(text) {
      let i = 0;
      return text.replace(/__(_)?/g, (_, match) => {
        if (match)
          return ++i % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
        return "\\_\\_";
      });
    }
    static escapeStrikethrough(text) {
      return text.replace(/~~/g, "\\~\\~");
    }
    static escapeSpoiler(text) {
      return text.replace(/\|\|/g, "\\|\\|");
    }
    static fetchRecommendedShards(token, guildsPerShard = 1e3) {
      if (!token)
        throw new DiscordError("TOKEN_MISSING");
      return fetch(`${DefaultOptions2.http.api}/v${DefaultOptions2.http.version}${Endpoints.botGateway}`, {
        method: "GET",
        headers: {Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}`}
      }).then((res) => {
        if (res.ok)
          return res.json();
        if (res.status === 401)
          throw new DiscordError("TOKEN_INVALID");
        throw res;
      }).then((data) => data.shards * (1e3 / guildsPerShard));
    }
    static parseEmoji(text) {
      if (text.includes("%"))
        text = decodeURIComponent(text);
      if (!text.includes(":"))
        return {animated: false, name: text, id: null};
      const m = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
      if (!m)
        return null;
      return {animated: Boolean(m[1]), name: m[2], id: m[3] || null};
    }
    static cloneObject(obj) {
      return Object.assign(Object.create(obj), obj);
    }
    static mergeDefault(def, given) {
      if (!given)
        return def;
      for (const key in def) {
        if (!has(given, key) || given[key] === void 0) {
          given[key] = def[key];
        } else if (given[key] === Object(given[key])) {
          given[key] = Util.mergeDefault(def[key], given[key]);
        }
      }
      return given;
    }
    static convertToBuffer(ab) {
      if (typeof ab === "string")
        ab = Util.str2ab(ab);
      return Buffer.from(ab);
    }
    static str2ab(str) {
      const buffer = new ArrayBuffer(str.length * 2);
      const view = new Uint16Array(buffer);
      for (var i = 0, strLen = str.length; i < strLen; i++)
        view[i] = str.charCodeAt(i);
      return buffer;
    }
    static makeError(obj) {
      const err = new Error(obj.message);
      err.name = obj.name;
      err.stack = obj.stack;
      return err;
    }
    static makePlainError(err) {
      return {
        name: err.name,
        message: err.message,
        stack: err.stack
      };
    }
    static moveElementInArray(array, element, newIndex, offset = false) {
      const index = array.indexOf(element);
      newIndex = (offset ? index : 0) + newIndex;
      if (newIndex > -1 && newIndex < array.length) {
        const removedElement = array.splice(index, 1)[0];
        array.splice(newIndex, 0, removedElement);
      }
      return array.indexOf(element);
    }
    static resolveString(data) {
      if (typeof data === "string")
        return data;
      if (Array.isArray(data))
        return data.join("\n");
      return String(data);
    }
    static resolveColor(color) {
      if (typeof color === "string") {
        if (color === "RANDOM")
          return Math.floor(Math.random() * (16777215 + 1));
        if (color === "DEFAULT")
          return 0;
        color = Colors[color] || parseInt(color.replace("#", ""), 16);
      } else if (Array.isArray(color)) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
      }
      if (color < 0 || color > 16777215)
        throw new RangeError2("COLOR_RANGE");
      else if (color && isNaN(color))
        throw new TypeError2("COLOR_CONVERT");
      return color;
    }
    static discordSort(collection) {
      return collection.sorted((a, b) => a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)));
    }
    static setPosition(item, position, relative, sorted, route, reason) {
      let updatedItems = sorted.array();
      Util.moveElementInArray(updatedItems, item, position, relative);
      updatedItems = updatedItems.map((r, i) => ({id: r.id, position: i}));
      return route.patch({data: updatedItems, reason}).then(() => updatedItems);
    }
    static basename(path, ext) {
      let res = parse(path);
      return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
    }
    static idToBinary(num) {
      let bin = "";
      let high = parseInt(num.slice(0, -10)) || 0;
      let low = parseInt(num.slice(-10));
      while (low > 0 || high > 0) {
        bin = String(low & 1) + bin;
        low = Math.floor(low / 2);
        if (high > 0) {
          low += 5e9 * (high % 2);
          high = Math.floor(high / 2);
        }
      }
      return bin;
    }
    static binaryToID(num) {
      let dec = "";
      while (num.length > 50) {
        const high = parseInt(num.slice(0, -32), 2);
        const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);
        dec = (low % 10).toString() + dec;
        num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, "0");
      }
      num = parseInt(num, 2);
      while (num > 0) {
        dec = (num % 10).toString() + dec;
        num = Math.floor(num / 10);
      }
      return dec;
    }
    static removeMentions(str) {
      return str.replace(/@/g, "@\u200B");
    }
    static cleanContent(str, message) {
      str = str.replace(/<@!?[0-9]+>/g, (input) => {
        const id = input.replace(/<|!|>|@/g, "");
        if (message.channel.type === "dm") {
          const user = message.client.users.cache.get(id);
          return user ? Util.removeMentions(`@${user.username}`) : input;
        }
        const member = message.channel.guild.members.cache.get(id);
        if (member) {
          return Util.removeMentions(`@${member.displayName}`);
        } else {
          const user = message.client.users.cache.get(id);
          return user ? Util.removeMentions(`@${user.username}`) : input;
        }
      }).replace(/<#[0-9]+>/g, (input) => {
        const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ""));
        return channel ? `#${channel.name}` : input;
      }).replace(/<@&[0-9]+>/g, (input) => {
        if (message.channel.type === "dm")
          return input;
        const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ""));
        return role ? `@${role.name}` : input;
      });
      if (message.client.options.disableMentions === "everyone") {
        str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {
          if (target.match(/^[&!]?\d+$/)) {
            return `@${target}`;
          } else {
            return `@\u200B${target}`;
          }
        });
      }
      if (message.client.options.disableMentions === "all") {
        return Util.removeMentions(str);
      } else {
        return str;
      }
    }
    static cleanCodeBlockContent(text) {
      return text.replace(/```/g, "`\u200B``");
    }
    static delayFor(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
  };
  module2.exports = Util;
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports2) => {
  (function(global2, undefined2) {
    "use strict";
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = {callback, args};
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate2(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate2(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate2;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  var util = require("util");
  module2.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports2, module2) => {
  var util = require("util");
  var Stream = require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module2.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, {end: false});
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["ecma", "es"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana"
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/avif": {
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana"
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module2.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var db = require_mime_db();
  var extname = require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = {lookup: charset};
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports2, module2) => {
  module2.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var defer = require_defer();
  module2.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports2, module2) => {
  module2.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports2, module2) => {
  var async = require_async();
  var abort = require_abort();
  module2.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  module2.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports2, module2) => {
  var abort = require_abort();
  var async = require_async();
  module2.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = serialOrdered;
  module2.exports.ascending = ascending;
  module2.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports2, module2) => {
  var serialOrdered = require_serialOrdered();
  module2.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports2, module2) => {
  module2.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/@discordjs/form-data/lib/populate.js
var require_populate = __commonJS((exports2, module2) => {
  module2.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/@discordjs/form-data/lib/form_data.js
var require_form_data = __commonJS((exports2, module2) => {
  var CombinedStream = require_combined_stream();
  var util = require("util");
  var path = require("path");
  var http = require("http");
  var https = require("https");
  var parseUrl = require("url").parse;
  var fs = require("fs");
  var Stream = require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module2.exports = FormData;
  util.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) {
      return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData.LINE_BREAK = "\r\n";
  FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = {filename: options};
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop))
        continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
  };
  FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length; i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = {method: "post"};
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData.prototype.toString = function() {
    return "[object FormData]";
  };
});

// node_modules/discord.js/src/rest/APIRequest.js
var require_APIRequest = __commonJS((exports2, module2) => {
  "use strict";
  var https = require("https");
  var FormData = require_form_data();
  var AbortController = require("abort-controller");
  var fetch = require("node-fetch");
  var {browser: browser2, UserAgent} = require_Constants();
  if (https.Agent)
    var agent = new https.Agent({keepAlive: true});
  var APIRequest = class {
    constructor(rest, method, path, options) {
      this.rest = rest;
      this.client = rest.client;
      this.method = method;
      this.route = options.route;
      this.options = options;
      this.retries = 0;
      let queryString = "";
      if (options.query) {
        const query = Object.entries(options.query).filter(([, value]) => ![null, "null", "undefined"].includes(value) && typeof value !== "undefined").flatMap(([key, value]) => Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
        queryString = new URLSearchParams(query).toString();
      }
      this.path = `${path}${queryString && `?${queryString}`}`;
    }
    make() {
      const API = this.options.versioned === false ? this.client.options.http.api : `${this.client.options.http.api}/v${this.client.options.http.version}`;
      const url = API + this.path;
      let headers = {};
      if (this.options.auth !== false)
        headers.Authorization = this.rest.getAuth();
      if (this.options.reason)
        headers["X-Audit-Log-Reason"] = encodeURIComponent(this.options.reason);
      if (!browser2)
        headers["User-Agent"] = UserAgent;
      if (this.options.headers)
        headers = Object.assign(headers, this.options.headers);
      let body;
      if (this.options.files && this.options.files.length) {
        body = new FormData();
        for (const file of this.options.files)
          if (file && file.file)
            body.append(file.name, file.file, file.name);
        if (typeof this.options.data !== "undefined")
          body.append("payload_json", JSON.stringify(this.options.data));
        if (!browser2)
          headers = Object.assign(headers, body.getHeaders());
      } else if (this.options.data != null) {
        body = JSON.stringify(this.options.data);
        headers["Content-Type"] = "application/json";
      }
      const controller = new AbortController();
      const timeout = this.client.setTimeout(() => controller.abort(), this.client.options.restRequestTimeout);
      return fetch(url, {
        method: this.method,
        headers,
        agent,
        body,
        signal: controller.signal
      }).finally(() => this.client.clearTimeout(timeout));
    }
  };
  module2.exports = APIRequest;
});

// node_modules/discord.js/src/rest/APIRouter.js
var require_APIRouter = __commonJS((exports2, module2) => {
  "use strict";
  var noop = () => {
  };
  var methods = ["get", "post", "delete", "patch", "put"];
  var reflectors = [
    "toString",
    "valueOf",
    "inspect",
    "constructor",
    Symbol.toPrimitive,
    Symbol.for("nodejs.util.inspect.custom")
  ];
  function buildRoute(manager) {
    const route = [""];
    const handler = {
      get(target, name) {
        if (reflectors.includes(name))
          return () => route.join("/");
        if (methods.includes(name)) {
          const routeBucket = [];
          for (let i = 0; i < route.length; i++) {
            if (route[i - 1] === "reactions")
              break;
            if (/\d{16,19}/g.test(route[i]) && !/channels|guilds/.test(route[i - 1]))
              routeBucket.push(":id");
            else
              routeBucket.push(route[i]);
          }
          return (options) => manager.request(name, route.join("/"), Object.assign({
            versioned: manager.versioned,
            route: routeBucket.join("/")
          }, options));
        }
        route.push(name);
        return new Proxy(noop, handler);
      },
      apply(target, _, args) {
        route.push(...args.filter((x) => x != null));
        return new Proxy(noop, handler);
      }
    };
    return new Proxy(noop, handler);
  }
  module2.exports = buildRoute;
});

// node_modules/discord.js/src/rest/AsyncQueue.js
var require_AsyncQueue = __commonJS((exports2, module2) => {
  "use strict";
  var AsyncQueue = class {
    constructor() {
      this.promises = [];
    }
    get remaining() {
      return this.promises.length;
    }
    wait() {
      const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();
      let resolve;
      const promise = new Promise((res) => {
        resolve = res;
      });
      this.promises.push({
        resolve,
        promise
      });
      return next;
    }
    shift() {
      const deferred = this.promises.shift();
      if (typeof deferred !== "undefined")
        deferred.resolve();
    }
  };
  module2.exports = AsyncQueue;
});

// node_modules/discord.js/src/rest/DiscordAPIError.js
var require_DiscordAPIError = __commonJS((exports2, module2) => {
  "use strict";
  var DiscordAPIError = class extends Error {
    constructor(path, error, method, status) {
      super();
      const flattened = this.constructor.flattenErrors(error.errors || error).join("\n");
      this.name = "DiscordAPIError";
      this.message = error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened;
      this.method = method;
      this.path = path;
      this.code = error.code;
      this.httpStatus = status;
    }
    static flattenErrors(obj, key = "") {
      let messages = [];
      for (const [k, v] of Object.entries(obj)) {
        if (k === "message")
          continue;
        const newKey = key ? isNaN(k) ? `${key}.${k}` : `${key}[${k}]` : k;
        if (v._errors) {
          messages.push(`${newKey}: ${v._errors.map((e) => e.message).join(" ")}`);
        } else if (v.code || v.message) {
          messages.push(`${v.code ? `${v.code}: ` : ""}${v.message}`.trim());
        } else if (typeof v === "string") {
          messages.push(v);
        } else {
          messages = messages.concat(this.flattenErrors(v, newKey));
        }
      }
      return messages;
    }
  };
  module2.exports = DiscordAPIError;
});

// node_modules/discord.js/src/rest/HTTPError.js
var require_HTTPError = __commonJS((exports2, module2) => {
  "use strict";
  var HTTPError = class extends Error {
    constructor(message, name, code, method, path) {
      super(message);
      this.name = name;
      this.code = code || 500;
      this.method = method;
      this.path = path;
    }
  };
  module2.exports = HTTPError;
});

// node_modules/discord.js/src/rest/RequestHandler.js
var require_RequestHandler = __commonJS((exports2, module2) => {
  "use strict";
  var AsyncQueue = require_AsyncQueue();
  var DiscordAPIError = require_DiscordAPIError();
  var HTTPError = require_HTTPError();
  var {
    Events: {RATE_LIMIT},
    browser: browser2
  } = require_Constants();
  var Util = require_Util();
  function parseResponse(res) {
    if (res.headers.get("content-type").startsWith("application/json"))
      return res.json();
    if (browser2)
      return res.blob();
    return res.buffer();
  }
  function getAPIOffset(serverDate) {
    return new Date(serverDate).getTime() - Date.now();
  }
  function calculateReset(reset, serverDate) {
    return new Date(Number(reset) * 1e3).getTime() - getAPIOffset(serverDate);
  }
  var RequestHandler = class {
    constructor(manager) {
      this.manager = manager;
      this.queue = new AsyncQueue();
      this.reset = -1;
      this.remaining = -1;
      this.limit = -1;
      this.retryAfter = -1;
    }
    async push(request) {
      await this.queue.wait();
      try {
        return await this.execute(request);
      } finally {
        this.queue.shift();
      }
    }
    get limited() {
      return Boolean(this.manager.globalTimeout) || this.remaining <= 0 && Date.now() < this.reset;
    }
    get _inactive() {
      return this.queue.remaining === 0 && !this.limited;
    }
    async execute(request) {
      if (this.limited) {
        const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();
        if (this.manager.client.listenerCount(RATE_LIMIT)) {
          this.manager.client.emit(RATE_LIMIT, {
            timeout,
            limit: this.limit,
            method: request.method,
            path: request.path,
            route: request.route
          });
        }
        if (this.manager.globalTimeout) {
          await this.manager.globalTimeout;
        } else {
          await Util.delayFor(timeout);
        }
      }
      let res;
      try {
        res = await request.make();
      } catch (error) {
        if (request.retries === this.manager.client.options.retryLimit) {
          throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);
        }
        request.retries++;
        return this.execute(request);
      }
      if (res && res.headers) {
        const serverDate = res.headers.get("date");
        const limit = res.headers.get("x-ratelimit-limit");
        const remaining = res.headers.get("x-ratelimit-remaining");
        const reset = res.headers.get("x-ratelimit-reset");
        const retryAfter = res.headers.get("retry-after");
        this.limit = limit ? Number(limit) : Infinity;
        this.remaining = remaining ? Number(remaining) : 1;
        this.reset = reset ? calculateReset(reset, serverDate) : Date.now();
        this.retryAfter = retryAfter ? Number(retryAfter) : -1;
        if (request.route.includes("reactions")) {
          this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;
        }
        if (res.headers.get("x-ratelimit-global")) {
          this.manager.globalTimeout = Util.delayFor(this.retryAfter);
          await this.manager.globalTimeout;
          this.manager.globalTimeout = null;
        }
      }
      if (res.ok) {
        return parseResponse(res);
      }
      if (res.status >= 400 && res.status < 500) {
        if (res.status === 429) {
          this.manager.client.emit("debug", `429 hit on route ${request.route}`);
          await Util.delayFor(this.retryAfter);
          return this.execute(request);
        }
        let data;
        try {
          data = await parseResponse(res);
        } catch (err) {
          throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);
        }
        throw new DiscordAPIError(request.path, data, request.method, res.status);
      }
      if (res.status >= 500 && res.status < 600) {
        if (request.retries === this.manager.client.options.retryLimit) {
          throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);
        }
        request.retries++;
        return this.execute(request);
      }
      return null;
    }
  };
  module2.exports = RequestHandler;
});

// node_modules/discord.js/src/rest/RESTManager.js
var require_RESTManager = __commonJS((exports2, module2) => {
  "use strict";
  var APIRequest = require_APIRequest();
  var routeBuilder = require_APIRouter();
  var RequestHandler = require_RequestHandler();
  var {Error: Error2} = require_errors();
  var Collection2 = require_Collection();
  var {Endpoints} = require_Constants();
  var RESTManager = class {
    constructor(client, tokenPrefix = "Bot") {
      this.client = client;
      this.handlers = new Collection2();
      this.tokenPrefix = tokenPrefix;
      this.versioned = true;
      this.globalTimeout = null;
      if (client.options.restSweepInterval > 0) {
        client.setInterval(() => {
          this.handlers.sweep((handler) => handler._inactive);
        }, client.options.restSweepInterval * 1e3);
      }
    }
    get api() {
      return routeBuilder(this);
    }
    getAuth() {
      const token = this.client.token || this.client.accessToken;
      if (token)
        return `${this.tokenPrefix} ${token}`;
      throw new Error2("TOKEN_MISSING");
    }
    get cdn() {
      return Endpoints.CDN(this.client.options.http.cdn);
    }
    request(method, url, options = {}) {
      const apiRequest = new APIRequest(this, method, url, options);
      let handler = this.handlers.get(apiRequest.route);
      if (!handler) {
        handler = new RequestHandler(this);
        this.handlers.set(apiRequest.route, handler);
      }
      return handler.push(apiRequest);
    }
    get endpoint() {
      return this.client.options.http.api;
    }
    set endpoint(endpoint) {
      this.client.options.http.api = endpoint;
    }
  };
  module2.exports = RESTManager;
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports2, module2) => {
  "use strict";
  require_setImmediate();
  var EventEmitter = require("events");
  var RESTManager = require_RESTManager();
  var {DefaultOptions: DefaultOptions2} = require_Constants();
  var Util = require_Util();
  var BaseClient2 = class extends EventEmitter {
    constructor(options = {}) {
      super();
      this._timeouts = new Set();
      this._intervals = new Set();
      this._immediates = new Set();
      this.options = Util.mergeDefault(DefaultOptions2, options);
      this.rest = new RESTManager(this, options._tokenType);
    }
    get api() {
      return this.rest.api;
    }
    destroy() {
      for (const t of this._timeouts)
        this.clearTimeout(t);
      for (const i of this._intervals)
        this.clearInterval(i);
      for (const i of this._immediates)
        this.clearImmediate(i);
      this._timeouts.clear();
      this._intervals.clear();
      this._immediates.clear();
    }
    setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        fn(...args);
        this._timeouts.delete(timeout);
      }, delay);
      this._timeouts.add(timeout);
      return timeout;
    }
    clearTimeout(timeout) {
      clearTimeout(timeout);
      this._timeouts.delete(timeout);
    }
    setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this._intervals.add(interval);
      return interval;
    }
    clearInterval(interval) {
      clearInterval(interval);
      this._intervals.delete(interval);
    }
    setImmediate(fn, ...args) {
      const immediate = setImmediate(fn, ...args);
      this._immediates.add(immediate);
      return immediate;
    }
    clearImmediate(immediate) {
      clearImmediate(immediate);
      this._immediates.delete(immediate);
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return Util.flatten(this, {domain: false}, ...props);
    }
  };
  module2.exports = BaseClient2;
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports2, module2) => {
  "use strict";
  var {PartialTypes} = require_Constants();
  var GenericAction = class {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      const existing = manager.cache.get(id);
      if (!existing && this.client.options.partials.includes(partialType)) {
        return manager.add(data, cache);
      }
      return existing;
    }
    getChannel(data) {
      const id = data.channel_id || data.id;
      return data.channel || this.getPayload({
        id,
        guild_id: data.guild_id,
        recipients: [data.author || {id: data.user_id}]
      }, this.client.channels, id, PartialTypes.CHANNEL);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id || data.id;
      return data.message || this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id || (channel.guild ? channel.guild.id : null)
      }, channel.messages, id, PartialTypes.MESSAGE, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id || decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user ? user.id === this.client.user.id : false
      }, message.reactions, id, PartialTypes.REACTION);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, PartialTypes.GUILD_MEMBER);
    }
    getUser(data) {
      const id = data.user_id;
      return data.user || this.getPayload({id}, this.client.users, id, PartialTypes.USER);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member && data.member.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members.add(data.member).user;
        } else {
          return this.client.users.add(data.member.user);
        }
      }
      return this.getUser(data);
    }
  };
  module2.exports = GenericAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var MessageCreateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        const existing = channel.messages.cache.get(data.id);
        if (existing)
          return {message: existing};
        const message = channel.messages.add(data);
        const user = message.author;
        let member = message.member;
        channel.lastMessageID = data.id;
        if (user) {
          user.lastMessageID = data.id;
          user.lastMessageChannelID = channel.id;
        }
        if (member) {
          member.lastMessageID = data.id;
          member.lastMessageChannelID = channel.id;
        }
        client.emit(Events2.MESSAGE_CREATE, message);
        return {message};
      }
      return {};
    }
  };
  module2.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var MessageDeleteAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      let message;
      if (channel) {
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          message.deleted = true;
          client.emit(Events2.MESSAGE_DELETE, message);
        }
      }
      return {message};
    }
  };
  module2.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var Collection2 = require_Collection();
  var {Events: Events2} = require_Constants();
  var MessageDeleteBulkAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        const ids = data.ids;
        const messages = new Collection2();
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            message.deleted = true;
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events2.MESSAGE_BULK_DELETE, messages);
        return {messages};
      }
      return {};
    }
  };
  module2.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var MessageUpdateAction = class extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (channel) {
        const {id, channel_id, guild_id, author, timestamp, type} = data;
        const message = this.getMessage({id, channel_id, guild_id, author, timestamp, type}, channel);
        if (message) {
          const old = message.patch(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  };
  module2.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var {PartialTypes} = require_Constants();
  var MessageReactionAdd = class extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel || channel.type === "voice")
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      if (message.partial && !this.client.options.partials.includes(PartialTypes.REACTION))
        return false;
      const existing = message.reactions.cache.get(data.emoji.id || data.emoji.name);
      if (existing && existing.users.cache.has(user.id))
        return {message, reaction: existing, user};
      const reaction = message.reactions.add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id
      });
      if (!reaction)
        return false;
      reaction._add(user);
      this.client.emit(Events2.MESSAGE_REACTION_ADD, reaction, user);
      return {message, reaction, user};
    }
  };
  module2.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var MessageReactionRemove = class extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel || channel.type === "voice")
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user);
      this.client.emit(Events2.MESSAGE_REACTION_REMOVE, reaction, user);
      return {message, reaction, user};
    }
  };
  module2.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var MessageReactionRemoveAll = class extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel || channel.type === "voice")
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      message.reactions.cache.clear();
      this.client.emit(Events2.MESSAGE_REACTION_REMOVE_ALL, message);
      return {message};
    }
  };
  module2.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var MessageReactionRemoveEmoji = class extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel || channel.type === "voice")
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id || reaction.emoji.name);
      this.client.emit(Events2.MESSAGE_REACTION_REMOVE_EMOJI, reaction);
      return {reaction};
    }
  };
  module2.exports = MessageReactionRemoveEmoji;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var ChannelCreateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels.add(data);
      if (!existing && channel) {
        client.emit(Events2.CHANNEL_CREATE, channel);
      }
      return {channel};
    }
  };
  module2.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports2, module2) => {
  "use strict";
  var Util = require_Util();
  var Base = class {
    constructor(client) {
      Object.defineProperty(this, "client", {value: client});
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return Util.flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  };
  module2.exports = Base;
});

// node_modules/discord.js/src/util/Snowflake.js
var require_Snowflake = __commonJS((exports2, module2) => {
  "use strict";
  var Util = require_Util();
  var EPOCH = 14200704e5;
  var INCREMENT = 0;
  var SnowflakeUtil = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static generate(timestamp = Date.now()) {
      if (timestamp instanceof Date)
        timestamp = timestamp.getTime();
      if (typeof timestamp !== "number" || isNaN(timestamp)) {
        throw new TypeError(`"timestamp" argument must be a number (received ${isNaN(timestamp) ? "NaN" : typeof timestamp})`);
      }
      if (INCREMENT >= 4095)
        INCREMENT = 0;
      const BINARY = `${(timestamp - EPOCH).toString(2).padStart(42, "0")}0000100000${(INCREMENT++).toString(2).padStart(12, "0")}`;
      return Util.binaryToID(BINARY);
    }
    static deconstruct(snowflake) {
      const BINARY = Util.idToBinary(snowflake).toString(2).padStart(64, "0");
      const res = {
        timestamp: parseInt(BINARY.substring(0, 42), 2) + EPOCH,
        workerID: parseInt(BINARY.substring(42, 47), 2),
        processID: parseInt(BINARY.substring(47, 52), 2),
        increment: parseInt(BINARY.substring(52, 64), 2),
        binary: BINARY
      };
      Object.defineProperty(res, "date", {
        get: function get() {
          return new Date(this.timestamp);
        },
        enumerable: true
      });
      return res;
    }
    static get EPOCH() {
      return EPOCH;
    }
  };
  module2.exports = SnowflakeUtil;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var Snowflake = require_Snowflake();
  var Emoji = class extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated;
      this.name = emoji.name;
      this.id = emoji.id;
      this.deleted = false;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    get url() {
      if (!this.id)
        return null;
      return this.client.rest.cdn.Emoji(this.id, this.animated ? "gif" : "png");
    }
    get createdTimestamp() {
      if (!this.id)
        return null;
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      if (!this.id)
        return null;
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? `<${this.animated ? "a" : ""}:${this.name}:${this.id}>` : this.name;
    }
    toJSON() {
      return super.toJSON({
        guild: "guildID",
        createdTimestamp: true,
        url: true,
        identifier: true
      });
    }
  };
  module2.exports = Emoji;
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports2, module2) => {
  "use strict";
  var Emoji = require_Emoji();
  var BaseGuildEmoji = class extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requireColons = null;
      this.managed = null;
      this.available = null;
      Object.defineProperty(this, "_roles", {value: [], writable: true});
      this._patch(data);
    }
    _patch(data) {
      if (data.name)
        this.name = data.name;
      if (typeof data.require_colons !== "undefined") {
        this.requiresColons = data.require_colons;
      }
      if (typeof data.managed !== "undefined") {
        this.managed = data.managed;
      }
      if (typeof data.available !== "undefined") {
        this.available = data.available;
      }
      if (data.roles)
        this._roles = data.roles;
    }
  };
  module2.exports = BaseGuildEmoji;
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports2, module2) => {
  "use strict";
  var {TypeError: TypeError2} = require_errors();
  var Collection2 = require_Collection();
  var GuildEmojiRoleManager = class {
    constructor(emoji) {
      this.emoji = emoji;
      this.guild = emoji.guild;
      Object.defineProperty(this, "client", {value: emoji.client});
    }
    get _roles() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    get cache() {
      return this._roles;
    }
    add(roleOrRoles) {
      if (roleOrRoles instanceof Collection2)
        return this.add(roleOrRoles.keyArray());
      if (!Array.isArray(roleOrRoles))
        return this.add([roleOrRoles]);
      roleOrRoles = roleOrRoles.map((r) => this.guild.roles.resolve(r));
      if (roleOrRoles.includes(null)) {
        return Promise.reject(new TypeError2("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", true));
      }
      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];
      return this.set(newRoles);
    }
    remove(roleOrRoles) {
      if (roleOrRoles instanceof Collection2)
        return this.remove(roleOrRoles.keyArray());
      if (!Array.isArray(roleOrRoles))
        return this.remove([roleOrRoles]);
      roleOrRoles = roleOrRoles.map((r) => this.guild.roles.resolveID(r));
      if (roleOrRoles.includes(null)) {
        return Promise.reject(new TypeError2("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", true));
      }
      const newRoles = this._roles.keyArray().filter((role) => !roleOrRoles.includes(role));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({roles});
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch(this._roles.keyArray().slice());
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
  };
  module2.exports = GuildEmojiRoleManager;
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports2, module2) => {
  "use strict";
  var {RangeError: RangeError2} = require_errors();
  var BitField = class {
    constructor(bits) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== 0;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      if (Array.isArray(bit))
        return bit.every((p) => this.has(p));
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      if (!Array.isArray(bits))
        bits = new this.constructor(bits).toArray(false);
      return bits.filter((p) => !this.has(p, ...hasParams));
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = 0;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = 0;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.FLAGS))
        serialized[flag] = this.has(bit, ...hasParams);
      return serialized;
    }
    toArray(...hasParams) {
      return Object.keys(this.constructor.FLAGS).filter((bit) => this.has(bit, ...hasParams));
    }
    toJSON() {
      return this.bitfield;
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator]() {
      yield* this.toArray();
    }
    static resolve(bit = 0) {
      if (typeof bit === "number" && bit >= 0)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit))
        return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, 0);
      if (typeof bit === "string" && typeof this.FLAGS[bit] !== "undefined")
        return this.FLAGS[bit];
      const error = new RangeError2("BITFIELD_INVALID");
      error.bit = bit;
      throw error;
    }
  };
  BitField.FLAGS = {};
  module2.exports = BitField;
});

// node_modules/discord.js/src/util/Permissions.js
var require_Permissions = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var Permissions2 = class extends BitField {
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.has(permission);
    }
  };
  Permissions2.FLAGS = {
    CREATE_INSTANT_INVITE: 1 << 0,
    KICK_MEMBERS: 1 << 1,
    BAN_MEMBERS: 1 << 2,
    ADMINISTRATOR: 1 << 3,
    MANAGE_CHANNELS: 1 << 4,
    MANAGE_GUILD: 1 << 5,
    ADD_REACTIONS: 1 << 6,
    VIEW_AUDIT_LOG: 1 << 7,
    PRIORITY_SPEAKER: 1 << 8,
    STREAM: 1 << 9,
    VIEW_CHANNEL: 1 << 10,
    SEND_MESSAGES: 1 << 11,
    SEND_TTS_MESSAGES: 1 << 12,
    MANAGE_MESSAGES: 1 << 13,
    EMBED_LINKS: 1 << 14,
    ATTACH_FILES: 1 << 15,
    READ_MESSAGE_HISTORY: 1 << 16,
    MENTION_EVERYONE: 1 << 17,
    USE_EXTERNAL_EMOJIS: 1 << 18,
    VIEW_GUILD_INSIGHTS: 1 << 19,
    CONNECT: 1 << 20,
    SPEAK: 1 << 21,
    MUTE_MEMBERS: 1 << 22,
    DEAFEN_MEMBERS: 1 << 23,
    MOVE_MEMBERS: 1 << 24,
    USE_VAD: 1 << 25,
    CHANGE_NICKNAME: 1 << 26,
    MANAGE_NICKNAMES: 1 << 27,
    MANAGE_ROLES: 1 << 28,
    MANAGE_WEBHOOKS: 1 << 29,
    MANAGE_EMOJIS: 1 << 30
  };
  Permissions2.ALL = Object.values(Permissions2.FLAGS).reduce((all, p) => all | p, 0);
  Permissions2.DEFAULT = 104324673;
  module2.exports = Permissions2;
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports2, module2) => {
  "use strict";
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var {Error: Error2} = require_errors();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  var Permissions2 = require_Permissions();
  var GuildEmoji = class extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (typeof data.user !== "undefined")
        this.author = this.client.users.add(data.user);
    }
    get deletable() {
      if (!this.guild.me)
        throw new Error2("GUILD_UNCACHED_ME");
      return !this.managed && this.guild.me.hasPermission(Permissions2.FLAGS.MANAGE_EMOJIS);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    async fetchAuthor() {
      if (this.managed) {
        throw new Error2("EMOJI_MANAGED");
      } else {
        if (!this.guild.me)
          throw new Error2("GUILD_UNCACHED_ME");
        if (!this.guild.me.permissions.has(Permissions2.FLAGS.MANAGE_EMOJIS)) {
          throw new Error2("MISSING_MANAGE_EMOJIS_PERMISSION", this.guild);
        }
      }
      const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();
      this._patch(data);
      return this.author;
    }
    edit(data, reason) {
      const roles = data.roles ? data.roles.map((r) => r.id || r) : void 0;
      return this.client.api.guilds(this.guild.id).emojis(this.id).patch({
        data: {
          name: data.name,
          roles
        },
        reason
      }).then((newData) => {
        const clone = this._clone();
        clone._patch(newData);
        return clone;
      });
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    delete(reason) {
      return this.client.api.guilds(this.guild.id).emojis(this.id).delete({reason}).then(() => this);
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  };
  module2.exports = GuildEmoji;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {Endpoints} = require_Constants();
  var Permissions2 = require_Permissions();
  var Invite2 = class extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.guild = data.guild ? this.client.guilds.add(data.guild, false) : null;
      this.code = data.code;
      this.presenceCount = "approximate_presence_count" in data ? data.approximate_presence_count : null;
      this.memberCount = "approximate_member_count" in data ? data.approximate_member_count : null;
      this.temporary = "temporary" in data ? data.temporary : null;
      this.maxAge = "max_age" in data ? data.max_age : null;
      this.uses = "uses" in data ? data.uses : null;
      this.maxUses = "max_uses" in data ? data.max_uses : null;
      this.inviter = data.inviter ? this.client.users.add(data.inviter) : null;
      this.targetUser = data.target_user ? this.client.users.add(data.target_user) : null;
      this.targetUserType = typeof data.target_user_type === "number" ? data.target_user_type : null;
      this.channel = this.client.channels.add(data.channel, this.guild, false);
      this.createdTimestamp = "created_at" in data ? new Date(data.created_at).getTime() : null;
    }
    get createdAt() {
      return this.createdTimestamp ? new Date(this.createdTimestamp) : null;
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.me)
        throw new Error("GUILD_UNCACHED_ME");
      return this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_CHANNELS, false) || guild.me.permissions.has(Permissions2.FLAGS.MANAGE_GUILD);
    }
    get expiresTimestamp() {
      return this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1e3 : null;
    }
    get expiresAt() {
      const {expiresTimestamp} = this;
      return expiresTimestamp ? new Date(expiresTimestamp) : null;
    }
    get url() {
      return Endpoints.invite(this.client.options.http.invite, this.code);
    }
    delete(reason) {
      return this.client.api.invites[this.code].delete({reason}).then(() => this);
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelID",
        inviter: "inviterID",
        guild: "guildID"
      });
    }
    valueOf() {
      return this.code;
    }
  };
  module2.exports = Invite2;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {Error: Error2, TypeError: TypeError2} = require_errors();
  var Permissions2 = require_Permissions();
  var Snowflake = require_Snowflake();
  var Util = require_Util();
  var Role = class extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.name = data.name;
      this.color = data.color;
      this.hoist = data.hoist;
      this.rawPosition = data.position;
      this.permissions = new Permissions2(data.permissions).freeze();
      this.managed = data.managed;
      this.mentionable = data.mentionable;
      this.deleted = false;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.color.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.guild.members.cache.filter((m) => m.roles.cache.has(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.member(this.client.user);
      if (!clientMember.permissions.has(Permissions2.FLAGS.MANAGE_ROLES))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      const sorted = this.guild._sortedRoles();
      return sorted.array().indexOf(sorted.get(this.id));
    }
    comparePositionTo(role) {
      role = this.guild.roles.resolve(role);
      if (!role)
        throw new TypeError2("INVALID_TYPE", "role", "Role nor a Snowflake");
      return this.constructor.comparePositions(this, role);
    }
    async edit(data, reason) {
      if (typeof data.permissions !== "undefined")
        data.permissions = Permissions2.resolve(data.permissions);
      else
        data.permissions = this.permissions.bitfield;
      if (typeof data.position !== "undefined") {
        await Util.setPosition(this, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then((updatedRoles) => {
          this.client.actions.GuildRolesPositionUpdate.handle({
            guild_id: this.guild.id,
            roles: updatedRoles
          });
        });
      }
      return this.client.api.guilds[this.guild.id].roles[this.id].patch({
        data: {
          name: data.name || this.name,
          color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,
          hoist: typeof data.hoist !== "undefined" ? data.hoist : this.hoist,
          permissions: data.permissions,
          mentionable: typeof data.mentionable !== "undefined" ? data.mentionable : this.mentionable
        },
        reason
      }).then((role) => {
        const clone = this._clone();
        clone._patch(role);
        return clone;
      });
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new Error2("GUILD_CHANNEL_RESOLVE");
      return channel.rolePermissions(this);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setColor(color, reason) {
      return this.edit({color}, reason);
    }
    setHoist(hoist, reason) {
      return this.edit({hoist}, reason);
    }
    setPermissions(permissions, reason) {
      return this.edit({permissions}, reason);
    }
    setMentionable(mentionable, reason) {
      return this.edit({mentionable}, reason);
    }
    setPosition(position, {relative, reason} = {}) {
      return Util.setPosition(this, position, relative, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then((updatedRoles) => {
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles
        });
        return this;
      });
    }
    delete(reason) {
      return this.client.api.guilds[this.guild.id].roles[this.id].delete({reason}).then(() => {
        this.client.actions.GuildRoleDelete.handle({guild_id: this.guild.id, role_id: this.id});
        return this;
      });
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return `<@&${this.id}>`;
    }
    toJSON() {
      return super.toJSON({createdTimestamp: true});
    }
    static comparePositions(role1, role2) {
      if (role1.position === role2.position)
        return role2.id - role1.id;
      return role1.position - role2.position;
    }
  };
  module2.exports = Role;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports2, module2) => {
  "use strict";
  var Role = require_Role();
  var {TypeError: TypeError2} = require_errors();
  var Permissions2 = require_Permissions();
  var Util = require_Util();
  var PermissionOverwrites = class {
    constructor(guildChannel, data) {
      Object.defineProperty(this, "channel", {value: guildChannel});
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.type = data.type;
      this.deny = new Permissions2(data.deny).freeze();
      this.allow = new Permissions2(data.allow).freeze();
    }
    update(options, reason) {
      const {allow, deny} = this.constructor.resolveOverwriteOptions(options, this);
      return this.channel.client.api.channels(this.channel.id).permissions[this.id].put({
        data: {id: this.id, type: this.type, allow: allow.bitfield, deny: deny.bitfield},
        reason
      }).then(() => this);
    }
    delete(reason) {
      return this.channel.client.api.channels[this.channel.id].permissions[this.id].delete({reason}).then(() => this);
    }
    toJSON() {
      return Util.flatten(this);
    }
    static resolveOverwriteOptions(options, {allow, deny} = {}) {
      allow = new Permissions2(allow);
      deny = new Permissions2(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(Permissions2.FLAGS[perm]);
          deny.remove(Permissions2.FLAGS[perm]);
        } else if (value === false) {
          allow.remove(Permissions2.FLAGS[perm]);
          deny.add(Permissions2.FLAGS[perm]);
        } else if (value === null) {
          allow.remove(Permissions2.FLAGS[perm]);
          deny.remove(Permissions2.FLAGS[perm]);
        }
      }
      return {allow, deny};
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && ["role", "member"].includes(overwrite.type)) {
        return {...overwrite, allow: Permissions2.resolve(overwrite.allow), deny: Permissions2.resolve(overwrite.deny)};
      }
      const userOrRole = guild.roles.resolve(overwrite.id) || guild.client.users.resolve(overwrite.id);
      if (!userOrRole)
        throw new TypeError2("INVALID_TYPE", "parameter", "User nor a Role");
      const type = userOrRole instanceof Role ? "role" : "member";
      return {
        id: userOrRole.id,
        type,
        allow: Permissions2.resolve(overwrite.allow),
        deny: Permissions2.resolve(overwrite.deny)
      };
    }
  };
  module2.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports2, module2) => {
  "use strict";
  var Channel = require_Channel();
  var Invite2 = require_Invite();
  var PermissionOverwrites = require_PermissionOverwrites();
  var Role = require_Role();
  var {Error: Error2, TypeError: TypeError2} = require_errors();
  var Collection2 = require_Collection();
  var Permissions2 = require_Permissions();
  var Util = require_Util();
  var GuildChannel = class extends Channel {
    constructor(guild, data) {
      super(guild.client, data);
      this.guild = guild;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
      this.rawPosition = data.position;
      this.parentID = data.parent_id || null;
      this.permissionOverwrites = new Collection2();
      if (data.permission_overwrites) {
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));
        }
      }
    }
    get parent() {
      return this.guild.channels.cache.get(this.parentID) || null;
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size)
        return false;
      return this.permissionOverwrites.every((value, key) => {
        const testVal = this.parent.permissionOverwrites.get(key);
        return testVal !== void 0 && testVal.deny.bitfield === value.deny.bitfield && testVal.allow.bitfield === value.allow.bitfield;
      });
    }
    get position() {
      const sorted = this.guild._sortedChannels(this);
      return sorted.array().indexOf(sorted.get(this.id));
    }
    permissionsFor(memberOrRole) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member);
      const role = this.guild.roles.resolve(memberOrRole);
      if (role)
        return this.rolePermissions(role);
      return null;
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles = roles || member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member) {
      if (member.id === this.guild.ownerID)
        return new Permissions2(Permissions2.ALL).freeze();
      const roles = member.roles.cache;
      const permissions = new Permissions2(roles.map((role) => role.permissions));
      if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR))
        return new Permissions2(Permissions2.ALL).freeze();
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();
    }
    rolePermissions(role) {
      if (role.permissions.has(Permissions2.FLAGS.ADMINISTRATOR))
        return new Permissions2(Permissions2.ALL).freeze();
      const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.get(role.id);
      return role.permissions.remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();
    }
    overwritePermissions(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection2)) {
        return Promise.reject(new TypeError2("INVALID_TYPE", "overwrites", "Array or Collection of Permission Overwrites", true));
      }
      return this.edit({permissionOverwrites: overwrites, reason}).then(() => this);
    }
    updateOverwrite(userOrRole, options, reason) {
      userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);
      if (!userOrRole)
        return Promise.reject(new TypeError2("INVALID_TYPE", "parameter", "User nor a Role"));
      const existing = this.permissionOverwrites.get(userOrRole.id);
      if (existing)
        return existing.update(options, reason).then(() => this);
      return this.createOverwrite(userOrRole, options, reason);
    }
    createOverwrite(userOrRole, options, reason) {
      userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);
      if (!userOrRole)
        return Promise.reject(new TypeError2("INVALID_TYPE", "parameter", "User nor a Role"));
      const type = userOrRole instanceof Role ? "role" : "member";
      const {allow, deny} = PermissionOverwrites.resolveOverwriteOptions(options);
      return this.client.api.channels(this.id).permissions[userOrRole.id].put({
        data: {id: userOrRole.id, type, allow: allow.bitfield, deny: deny.bitfield},
        reason
      }).then(() => this);
    }
    lockPermissions() {
      if (!this.parent)
        return Promise.reject(new Error2("GUILD_CHANNEL_ORPHAN"));
      const permissionOverwrites = this.parent.permissionOverwrites.map((overwrite) => overwrite.toJSON());
      return this.edit({permissionOverwrites});
    }
    get members() {
      const members = new Collection2();
      for (const member of this.guild.members.cache.values()) {
        if (this.permissionsFor(member).has("VIEW_CHANNEL", false)) {
          members.set(member.id, member);
        }
      }
      return members;
    }
    async edit(data, reason) {
      if (typeof data.position !== "undefined") {
        await Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then((updatedChannels) => {
          this.client.actions.GuildChannelsPositionUpdate.handle({
            guild_id: this.guild.id,
            channels: updatedChannels
          });
        });
      }
      let permission_overwrites;
      if (data.permissionOverwrites) {
        permission_overwrites = data.permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
      }
      if (data.lockPermissions) {
        if (data.parentID) {
          const newParent = this.guild.channels.resolve(data.parentID);
          if (newParent && newParent.type === "category") {
            permission_overwrites = newParent.permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
          }
        } else if (this.parent) {
          permission_overwrites = this.parent.permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
        }
      }
      const newData = await this.client.api.channels(this.id).patch({
        data: {
          name: (data.name || this.name).trim(),
          topic: data.topic,
          nsfw: data.nsfw,
          bitrate: data.bitrate || this.bitrate,
          user_limit: typeof data.userLimit !== "undefined" ? data.userLimit : this.userLimit,
          parent_id: data.parentID,
          lock_permissions: data.lockPermissions,
          rate_limit_per_user: data.rateLimitPerUser,
          permission_overwrites
        },
        reason
      });
      const clone = this._clone();
      clone._patch(newData);
      return clone;
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setParent(channel, {lockPermissions = true, reason} = {}) {
      return this.edit({
        parentID: channel !== null ? channel.hasOwnProperty("id") ? channel.id : channel : null,
        lockPermissions
      }, reason);
    }
    setTopic(topic, reason) {
      return this.edit({topic}, reason);
    }
    setPosition(position, {relative, reason} = {}) {
      return Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then((updatedChannels) => {
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels
        });
        return this;
      });
    }
    createInvite({temporary = false, maxAge = 86400, maxUses = 0, unique, reason} = {}) {
      return this.client.api.channels(this.id).invites.post({
        data: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique
        },
        reason
      }).then((invite) => new Invite2(this.client, invite));
    }
    async fetchInvites() {
      const inviteItems = await this.client.api.channels(this.id).invites.get();
      const invites = new Collection2();
      for (const inviteItem of inviteItems) {
        const invite = new Invite2(this.client, inviteItem);
        invites.set(invite.code, invite);
      }
      return invites;
    }
    clone(options = {}) {
      Util.mergeDefault({
        name: this.name,
        permissionOverwrites: this.permissionOverwrites,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        reason: null
      }, options);
      return this.guild.channels.create(options.name, options);
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.equals(channel.permissionOverwrites);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_CHANNELS, false);
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerID)
        return true;
      if (this.type === "voice") {
        if (!this.permissionsFor(this.client.user).has(Permissions2.FLAGS.CONNECT, false)) {
          return false;
        }
      } else if (!this.viewable) {
        return false;
      }
      return this.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_CHANNELS, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerID)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(Permissions2.FLAGS.VIEW_CHANNEL, false);
    }
    delete(reason) {
      return this.client.api.channels(this.id).delete({reason}).then(() => this);
    }
  };
  module2.exports = GuildChannel;
});

// node_modules/discord.js/src/structures/MessageAttachment.js
var require_MessageAttachment = __commonJS((exports2, module2) => {
  "use strict";
  var Util = require_Util();
  var MessageAttachment = class {
    constructor(attachment, name = null, data) {
      this.attachment = attachment;
      this.name = name;
      if (data)
        this._patch(data);
    }
    setFile(attachment, name = null) {
      this.attachment = attachment;
      this.name = name;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    _patch(data) {
      this.id = data.id;
      this.size = data.size;
      this.url = data.url;
      this.proxyURL = data.proxy_url;
      this.height = typeof data.height !== "undefined" ? data.height : null;
      this.width = typeof data.width !== "undefined" ? data.width : null;
    }
    get spoiler() {
      return Util.basename(this.url).startsWith("SPOILER_");
    }
    toJSON() {
      return Util.flatten(this);
    }
  };
  module2.exports = MessageAttachment;
});

// node_modules/discord.js/src/structures/MessageEmbed.js
var require_MessageEmbed = __commonJS((exports2, module2) => {
  "use strict";
  var {RangeError: RangeError2} = require_errors();
  var Util = require_Util();
  var MessageEmbed = class {
    constructor(data = {}, skipValidation = false) {
      this.setup(data, skipValidation);
    }
    setup(data, skipValidation) {
      this.type = data.type || "rich";
      this.title = "title" in data ? data.title : null;
      this.description = "description" in data ? data.description : null;
      this.url = "url" in data ? data.url : null;
      this.color = "color" in data ? Util.resolveColor(data.color) : null;
      this.timestamp = "timestamp" in data ? new Date(data.timestamp).getTime() : null;
      this.fields = [];
      if (data.fields) {
        this.fields = skipValidation ? data.fields.map(Util.cloneObject) : this.constructor.normalizeFields(data.fields);
      }
      this.thumbnail = data.thumbnail ? {
        url: data.thumbnail.url,
        proxyURL: data.thumbnail.proxyURL || data.thumbnail.proxy_url,
        height: data.thumbnail.height,
        width: data.thumbnail.width
      } : null;
      this.image = data.image ? {
        url: data.image.url,
        proxyURL: data.image.proxyURL || data.image.proxy_url,
        height: data.image.height,
        width: data.image.width
      } : null;
      this.video = data.video ? {
        url: data.video.url,
        proxyURL: data.video.proxyURL || data.video.proxy_url,
        height: data.video.height,
        width: data.video.width
      } : null;
      this.author = data.author ? {
        name: data.author.name,
        url: data.author.url,
        iconURL: data.author.iconURL || data.author.icon_url,
        proxyIconURL: data.author.proxyIconURL || data.author.proxy_icon_url
      } : null;
      this.provider = data.provider ? {
        name: data.provider.name,
        url: data.provider.name
      } : null;
      this.footer = data.footer ? {
        text: data.footer.text,
        iconURL: data.footer.iconURL || data.footer.icon_url,
        proxyIconURL: data.footer.proxyIconURL || data.footer.proxy_icon_url
      } : null;
      this.files = data.files || [];
    }
    get createdAt() {
      return this.timestamp ? new Date(this.timestamp) : null;
    }
    get hexColor() {
      return this.color ? `#${this.color.toString(16).padStart(6, "0")}` : null;
    }
    get length() {
      return (this.title ? this.title.length : 0) + (this.description ? this.description.length : 0) + (this.fields.length >= 1 ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) : 0) + (this.footer ? this.footer.text.length : 0);
    }
    addField(name, value, inline) {
      return this.addFields({name, value, inline});
    }
    addFields(...fields) {
      this.fields.push(...this.constructor.normalizeFields(fields));
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      this.fields.splice(index, deleteCount, ...this.constructor.normalizeFields(...fields));
      return this;
    }
    attachFiles(files) {
      this.files = this.files.concat(files);
      return this;
    }
    setAuthor(name, iconURL, url) {
      this.author = {name: Util.resolveString(name), iconURL, url};
      return this;
    }
    setColor(color) {
      this.color = Util.resolveColor(color);
      return this;
    }
    setDescription(description) {
      description = Util.resolveString(description);
      this.description = description;
      return this;
    }
    setFooter(text, iconURL) {
      text = Util.resolveString(text);
      this.footer = {text, iconURL};
      return this;
    }
    setImage(url) {
      this.image = {url};
      return this;
    }
    setThumbnail(url) {
      this.thumbnail = {url};
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      if (timestamp instanceof Date)
        timestamp = timestamp.getTime();
      this.timestamp = timestamp;
      return this;
    }
    setTitle(title) {
      title = Util.resolveString(title);
      this.title = title;
      return this;
    }
    setURL(url) {
      this.url = url;
      return this;
    }
    toJSON() {
      return {
        title: this.title,
        type: "rich",
        description: this.description,
        url: this.url,
        timestamp: this.timestamp ? new Date(this.timestamp) : null,
        color: this.color,
        fields: this.fields,
        thumbnail: this.thumbnail,
        image: this.image,
        author: this.author ? {
          name: this.author.name,
          url: this.author.url,
          icon_url: this.author.iconURL
        } : null,
        footer: this.footer ? {
          text: this.footer.text,
          icon_url: this.footer.iconURL
        } : null
      };
    }
    static normalizeField(name, value, inline = false) {
      name = Util.resolveString(name);
      if (!name)
        throw new RangeError2("EMBED_FIELD_NAME");
      value = Util.resolveString(value);
      if (!value)
        throw new RangeError2("EMBED_FIELD_VALUE");
      return {name, value, inline};
    }
    static normalizeFields(...fields) {
      return fields.flat(2).map((field) => this.normalizeField(field && field.name, field && field.value, field && typeof field.inline === "boolean" ? field.inline : false));
    }
  };
  module2.exports = MessageEmbed;
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var path = require("path");
  var stream = require("stream");
  var fetch = require("node-fetch");
  var {Error: DiscordError, TypeError: TypeError2} = require_errors();
  var {browser: browser2} = require_Constants();
  var Util = require_Util();
  var DataResolver2 = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static resolveCode(data, regex) {
      const match = regex.exec(data);
      return match ? match[1] || data : data;
    }
    static resolveInviteCode(data) {
      return this.resolveCode(data, /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/([\w-]{2,255})/i);
    }
    static resolveGuildTemplateCode(data) {
      return this.resolveCode(data, /discord(?:app)?\.(?:com\/template|new)\/([\w-]{2,255})/i);
    }
    static async resolveImage(image) {
      if (!image)
        return null;
      if (typeof image === "string" && image.startsWith("data:")) {
        return image;
      }
      const file = await this.resolveFileAsBuffer(image);
      return DataResolver2.resolveBase64(file);
    }
    static resolveBase64(data) {
      if (Buffer.isBuffer(data))
        return `data:image/jpg;base64,${data.toString("base64")}`;
      return data;
    }
    static async resolveFile(resource) {
      if (!browser2 && Buffer.isBuffer(resource))
        return resource;
      if (browser2 && resource instanceof ArrayBuffer)
        return Util.convertToBuffer(resource);
      if (browser2 && resource instanceof Blob)
        return resource;
      if (resource instanceof stream.Readable)
        return resource;
      if (typeof resource === "string") {
        if (/^https?:\/\//.test(resource)) {
          const res = await fetch(resource);
          return browser2 ? res.blob() : res.body;
        } else if (!browser2) {
          return new Promise((resolve, reject) => {
            const file = path.resolve(resource);
            fs.stat(file, (err, stats) => {
              if (err)
                return reject(err);
              if (!stats.isFile())
                return reject(new DiscordError("FILE_NOT_FOUND", file));
              return resolve(fs.createReadStream(file));
            });
          });
        }
      }
      throw new TypeError2("REQ_RESOURCE_TYPE");
    }
    static async resolveFileAsBuffer(resource) {
      const file = await this.resolveFile(resource);
      if (Buffer.isBuffer(file))
        return file;
      const buffers = [];
      for await (const data of file)
        buffers.push(data);
      return Buffer.concat(buffers);
    }
  };
  module2.exports = DataResolver2;
});

// node_modules/discord.js/src/util/MessageFlags.js
var require_MessageFlags = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var MessageFlags = class extends BitField {
  };
  MessageFlags.FLAGS = {
    CROSSPOSTED: 1 << 0,
    IS_CROSSPOST: 1 << 1,
    SUPPRESS_EMBEDS: 1 << 2,
    SOURCE_MESSAGE_DELETED: 1 << 3,
    URGENT: 1 << 4
  };
  module2.exports = MessageFlags;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports2, module2) => {
  "use strict";
  var BaseClient2 = require_BaseClient();
  var Webhook2 = require_Webhook();
  var WebhookClient = class extends BaseClient2 {
    constructor(id, token, options) {
      super(options);
      Object.defineProperty(this, "client", {value: this});
      this.id = id;
      Object.defineProperty(this, "token", {value: token, writable: true, configurable: true});
    }
  };
  Webhook2.applyToClass(WebhookClient);
  module2.exports = WebhookClient;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var Collection2 = require_Collection();
  var Util = require_Util();
  var Collector = class extends EventEmitter {
    constructor(client, filter, options = {}) {
      super();
      Object.defineProperty(this, "client", {value: client});
      this.filter = filter;
      this.options = options;
      this.collected = new Collection2();
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = this.client.setTimeout(() => this.stop("time"), options.time);
      if (options.idle)
        this._idletimeout = this.client.setTimeout(() => this.stop("idle"), options.idle);
    }
    async handleCollect(...args) {
      const collect = this.collect(...args);
      if (collect && await this.filter(...args, this.collected)) {
        this.collected.set(collect, args[0]);
        this.emit("collect", ...args);
        if (this._idletimeout) {
          this.client.clearTimeout(this._idletimeout);
          this._idletimeout = this.client.setTimeout(() => this.stop("idle"), this.options.idle);
        }
      }
      this.checkEnd();
    }
    handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        this.client.clearTimeout(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        this.client.clearTimeout(this._idletimeout);
        this._idletimeout = null;
      }
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({time, idle} = {}) {
      if (this._timeout) {
        this.client.clearTimeout(this._timeout);
        this._timeout = this.client.setTimeout(() => this.stop("time"), time || this.options.time);
      }
      if (this._idletimeout) {
        this.client.clearTimeout(this._idletimeout);
        this._idletimeout = this.client.setTimeout(() => this.stop("idle"), idle || this.options.idle);
      }
    }
    checkEnd() {
      const reason = this.endReason();
      if (reason)
        this.stop(reason);
    }
    async *[Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return Util.flatten(this);
    }
    collect() {
    }
    dispose() {
    }
    endReason() {
    }
  };
  module2.exports = Collector;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports2, module2) => {
  "use strict";
  var Collector = require_Collector();
  var {Events: Events2} = require_Constants();
  var MessageCollector = class extends Collector {
    constructor(channel, filter, options = {}) {
      super(channel.client, filter, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events2.MESSAGE_CREATE, this.handleCollect);
      this.client.on(Events2.MESSAGE_DELETE, this.handleDispose);
      this.client.on(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
      this.client.on(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
      this.client.on(Events2.GUILD_DELETE, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events2.MESSAGE_CREATE, this.handleCollect);
        this.client.removeListener(Events2.MESSAGE_DELETE, this.handleDispose);
        this.client.removeListener(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
        this.client.removeListener(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
        this.client.removeListener(Events2.GUILD_DELETE, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channel.id !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channel.id === this.channel.id ? message.id : null;
    }
    endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return null;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id) {
        this.stop("channelDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (this.channel.guild && guild.id === this.channel.guild.id) {
        this.stop("guildDelete");
      }
    }
  };
  module2.exports = MessageCollector;
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports2, module2) => {
  "use strict";
  var {TypeError: TypeError2} = require_errors();
  var Collection2 = require_Collection();
  var GuildMemberRoleManager = class {
    constructor(member) {
      this.member = member;
      this.guild = member.guild;
      Object.defineProperty(this, "client", {value: member.client});
    }
    get _roles() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get cache() {
      return this._roles;
    }
    get hoist() {
      const hoistedRoles = this._roles.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this._roles.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this._roles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this._roles.first());
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
        roleOrRoles = roleOrRoles.map((r) => this.guild.roles.resolve(r));
        if (roleOrRoles.includes(null)) {
          throw new TypeError2("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolve(roleOrRoles);
        if (roleOrRoles === null) {
          throw new TypeError2("INVALID_TYPE", "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({reason});
        const clone = this.member._clone();
        clone._roles = [...this._roles.keys(), roleOrRoles.id];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
        roleOrRoles = roleOrRoles.map((r) => this.guild.roles.resolve(r));
        if (roleOrRoles.includes(null)) {
          throw new TypeError2("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const newRoles = this._roles.filter((role) => !roleOrRoles.includes(role));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolve(roleOrRoles);
        if (roleOrRoles === null) {
          throw new TypeError2("INVALID_TYPE", "roles", "Array or Collection of Roles or Snowflakes", true);
        }
        await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({reason});
        const clone = this.member._clone();
        const newRoles = this._roles.filter((role) => role.id !== roleOrRoles.id);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({roles}, reason);
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this._roles.keyArray()];
      return clone;
    }
  };
  module2.exports = GuildMemberRoleManager;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var Role = require_Role();
  var TextBasedChannel = require_TextBasedChannel();
  var {Error: Error2} = require_errors();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var Permissions2 = require_Permissions();
  var Structures2;
  var GuildMember = class extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.lastMessageID = null;
      this.lastMessageChannelID = null;
      this.premiumSinceTimestamp = null;
      this.deleted = false;
      this.nickname = null;
      this._roles = [];
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users.add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("joined_at" in data)
        this.joinedTimestamp = new Date(data.joined_at).getTime();
      if ("premium_since" in data)
        this.premiumSinceTimestamp = new Date(data.premium_since).getTime();
      if ("roles" in data)
        this._roles = data.roles;
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return !this.joinedTimestamp;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get lastMessage() {
      const channel = this.guild.channels.cache.get(this.lastMessageChannelID);
      return channel && channel.messages.cache.get(this.lastMessageID) || null;
    }
    get voice() {
      if (!Structures2)
        Structures2 = require_Structures();
      const VoiceState = Structures2.get("VoiceState");
      return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, {user_id: this.id});
    }
    get joinedAt() {
      return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;
    }
    get premiumSince() {
      return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;
    }
    get presence() {
      if (!Structures2)
        Structures2 = require_Structures();
      const Presence = Structures2.get("Presence");
      return this.guild.presences.cache.get(this.id) || new Presence(this.client, {
        user: {
          id: this.id
        },
        guild: this.guild
      });
    }
    get displayColor() {
      const role = this.roles.color;
      return role && role.color || 0;
    }
    get displayHexColor() {
      const role = this.roles.color;
      return role && role.hexColor || "#000000";
    }
    get id() {
      return this.user.id;
    }
    get displayName() {
      return this.nickname || this.user.username;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerID)
        return new Permissions2(Permissions2.ALL).freeze();
      return new Permissions2(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerID)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerID)
        return true;
      if (!this.guild.me)
        throw new Error2("GUILD_UNCACHED_ME");
      return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      return this.manageable && this.guild.me.permissions.has(Permissions2.FLAGS.KICK_MEMBERS);
    }
    get bannable() {
      return this.manageable && this.guild.me.permissions.has(Permissions2.FLAGS.BAN_MEMBERS);
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new Error2("GUILD_CHANNEL_RESOLVE");
      return channel.memberPermissions(this);
    }
    hasPermission(permission, {checkAdmin = true, checkOwner = true} = {}) {
      if (checkOwner && this.user.id === this.guild.ownerID)
        return true;
      const permissions = new Permissions2(this.roles.cache.map((role) => role.permissions));
      return permissions.has(permission, checkAdmin);
    }
    async edit(data, reason) {
      if (data.channel) {
        data.channel = this.guild.channels.resolve(data.channel);
        if (!data.channel || data.channel.type !== "voice") {
          throw new Error2("GUILD_VOICE_CHANNEL_RESOLVE");
        }
        data.channel_id = data.channel.id;
        data.channel = void 0;
      } else if (data.channel === null) {
        data.channel_id = null;
        data.channel = void 0;
      }
      if (data.roles)
        data.roles = data.roles.map((role) => role instanceof Role ? role.id : role);
      let endpoint = this.client.api.guilds(this.guild.id);
      if (this.user.id === this.client.user.id) {
        const keys = Object.keys(data);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = endpoint.members("@me").nick;
        else
          endpoint = endpoint.members(this.id);
      } else {
        endpoint = endpoint.members(this.id);
      }
      await endpoint.patch({data, reason});
      const clone = this._clone();
      data.user = this.user;
      clone._patch(data);
      return clone;
    }
    setNickname(nick, reason) {
      return this.edit({nick}, reason);
    }
    createDM() {
      return this.user.createDM();
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.client.api.guilds(this.guild.id).members(this.user.id).delete({reason}).then(() => this);
    }
    ban(options) {
      return this.guild.members.ban(this, options);
    }
    fetch(force = false) {
      return this.guild.members.fetch({user: this.id, cache: true, force});
    }
    toString() {
      return `<@${this.nickname ? "!" : ""}${this.user.id}>`;
    }
    toJSON() {
      return super.toJSON({
        guild: "guildID",
        user: "userID",
        displayName: true,
        speaking: false,
        lastMessage: false,
        lastMessageID: false,
        roles: true
      });
    }
    send() {
    }
  };
  TextBasedChannel.applyToClass(GuildMember);
  module2.exports = GuildMember;
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports2, module2) => {
  "use strict";
  var Collection2 = require_Collection();
  var Structures2;
  var BaseManager = class {
    constructor(client, iterable, holds, cacheType = Collection2, ...cacheOptions) {
      if (!Structures2)
        Structures2 = require_Structures();
      Object.defineProperty(this, "holds", {value: Structures2.get(holds.name) || holds});
      Object.defineProperty(this, "client", {value: client});
      this.cacheType = cacheType;
      this.cache = new cacheType(...cacheOptions);
      if (iterable)
        for (const i of iterable)
          this.add(i);
    }
    add(data, cache = true, {id, extras = []} = {}) {
      const existing = this.cache.get(id || data.id);
      if (existing && existing._patch && cache)
        existing._patch(data);
      if (existing)
        return existing;
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id || entry.id, entry);
      return entry;
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) || null;
      return null;
    }
    resolveID(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  };
  module2.exports = BaseManager;
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {MembershipStates} = require_Constants();
  var TeamMember = class extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      this.permissions = data.permissions;
      this.membershipState = MembershipStates[data.membership_state];
      this.user = this.client.users.add(data.user);
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  };
  module2.exports = TeamMember;
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var TeamMember = require_TeamMember();
  var Collection2 = require_Collection();
  var Snowflake = require_Snowflake();
  var Team = class extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon || null;
      this.ownerID = data.owner_user_id || null;
      this.members = new Collection2();
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerID) || null;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL({format, size} = {}) {
      if (!this.icon)
        return null;
      return this.client.rest.cdn.TeamIcon(this.id, this.icon, {format, size});
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({createdTimestamp: true});
    }
  };
  module2.exports = Team;
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports2, module2) => {
  "use strict";
  var {ClientApplicationAssetTypes, Endpoints} = require_Constants();
  var Snowflake = require_Snowflake();
  var Base = require_Base();
  var AssetTypes = Object.keys(ClientApplicationAssetTypes);
  var Application = class extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.name = data.name;
      this.description = data.description;
      this.icon = data.icon;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL({format, size} = {}) {
      if (!this.icon)
        return null;
      return this.client.rest.cdn.AppIcon(this.id, this.icon, {format, size});
    }
    coverImage({format, size} = {}) {
      if (!this.cover)
        return null;
      return Endpoints.CDN(this.client.options.http.cdn).AppIcon(this.id, this.cover, {format, size});
    }
    fetchAssets() {
      return this.client.api.oauth2.applications(this.id).assets.get().then((assets) => assets.map((a) => ({
        id: a.id,
        name: a.name,
        type: AssetTypes[a.type - 1]
      })));
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({createdTimestamp: true});
    }
  };
  module2.exports = Application;
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports2, module2) => {
  "use strict";
  var Team = require_Team();
  var Application = require_Application();
  var ClientApplication2 = class extends Application {
    _patch(data) {
      super._patch(data);
      this.cover = data.cover_image || null;
      this.rpcOrigins = data.rpc_origins || [];
      this.botRequireCodeGrant = typeof data.bot_require_code_grant !== "undefined" ? data.bot_require_code_grant : null;
      this.botPublic = typeof data.bot_public !== "undefined" ? data.bot_public : null;
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users.add(data.owner) : null;
    }
  };
  module2.exports = ClientApplication2;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports2, module2) => {
  "use strict";
  var Collection2 = require_Collection();
  var {ChannelTypes} = require_Constants();
  var Util = require_Util();
  var MessageMentions = class {
    constructor(message, users, roles, everyone, crosspostedChannels) {
      Object.defineProperty(this, "client", {value: message.client});
      Object.defineProperty(this, "guild", {value: message.guild});
      Object.defineProperty(this, "_content", {value: message.content});
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection2) {
          this.users = new Collection2(users);
        } else {
          this.users = new Collection2();
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members.add(Object.assign(mention.member, {user: mention}));
            }
            const user = message.client.users.add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection2();
      }
      if (roles) {
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else {
          this.roles = new Collection2();
          for (const mention of roles) {
            const role = message.channel.guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection2();
      }
      this._members = null;
      this._channels = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection2) {
          this.crosspostedChannels = new Collection2(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection2();
          const channelTypes = Object.keys(ChannelTypes);
          for (const d of crosspostedChannels) {
            const type = channelTypes[d.type];
            this.crosspostedChannels.set(d.id, {
              channelID: d.id,
              guildID: d.guild_id,
              type: type ? type.toLowerCase() : "unknown",
              name: d.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection2();
      }
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection2();
      this.users.forEach((user) => {
        const member = this.guild.member(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection2();
      let matches;
      while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {
        const chan = this.client.channels.cache.get(matches[1]);
        if (chan)
          this._channels.set(chan.id, chan);
      }
      return this._channels;
    }
    has(data, {ignoreDirect = false, ignoreRoles = false, ignoreEveryone = false} = {}) {
      if (!ignoreEveryone && this.everyone)
        return true;
      const GuildMember = require_GuildMember();
      if (!ignoreRoles && data instanceof GuildMember) {
        for (const role of this.roles.values())
          if (data.roles.cache.has(role.id))
            return true;
      }
      if (!ignoreDirect) {
        const id = this.client.users.resolveID(data) || this.guild && this.guild.roles.resolveID(data) || this.client.channels.resolveID(data);
        return this.users.has(id) || this.channels.has(id) || this.roles.has(id);
      }
      return false;
    }
    toJSON() {
      return Util.flatten(this, {
        members: true,
        channels: true
      });
    }
  };
  MessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;
  MessageMentions.USERS_PATTERN = /<@!?(\d{17,19})>/g;
  MessageMentions.ROLES_PATTERN = /<@&(\d{17,19})>/g;
  MessageMentions.CHANNELS_PATTERN = /<#(\d{17,19})>/g;
  module2.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports2, module2) => {
  "use strict";
  var Collector = require_Collector();
  var Collection2 = require_Collection();
  var {Events: Events2} = require_Constants();
  var ReactionCollector = class extends Collector {
    constructor(message, filter, options = {}) {
      super(message.client, filter, options);
      this.message = message;
      this.users = new Collection2();
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events2.MESSAGE_REACTION_ADD, this.handleCollect);
      this.client.on(Events2.MESSAGE_REACTION_REMOVE, this.handleDispose);
      this.client.on(Events2.MESSAGE_REACTION_REMOVE_ALL, this.empty);
      this.client.on(Events2.MESSAGE_DELETE, this._handleMessageDeletion);
      this.client.on(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
      this.client.on(Events2.GUILD_DELETE, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events2.MESSAGE_REACTION_ADD, this.handleCollect);
        this.client.removeListener(Events2.MESSAGE_REACTION_REMOVE, this.handleDispose);
        this.client.removeListener(Events2.MESSAGE_REACTION_REMOVE_ALL, this.empty);
        this.client.removeListener(Events2.MESSAGE_DELETE, this._handleMessageDeletion);
        this.client.removeListener(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
        this.client.removeListener(Events2.GUILD_DELETE, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (reaction, user) => {
        this.total--;
        if (!this.collected.some((r) => r.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return null;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channel.id) {
        this.stop("channelDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (this.message.guild && guild.id === this.message.guild.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id || reaction.emoji.name;
    }
  };
  module2.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports2, module2) => {
  "use strict";
  var Emoji = require_Emoji();
  var Util = require_Util();
  var ReactionEmoji = class extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return Util.flatten(this, {identifier: true});
    }
    valueOf() {
      return this.id;
    }
  };
  module2.exports = ReactionEmoji;
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var {Error: Error2} = require_errors();
  var Collection2 = require_Collection();
  var ReactionUserManager = class extends BaseManager {
    constructor(client, iterable, reaction) {
      super(client, iterable, {name: "User"});
      this.reaction = reaction;
    }
    async fetch({limit = 100, after, before} = {}) {
      const message = this.reaction.message;
      const data = await this.client.api.channels[message.channel.id].messages[message.id].reactions[this.reaction.emoji.identifier].get({query: {limit, before, after}});
      const users = new Collection2();
      for (const rawUser of data) {
        const user = this.client.users.add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    remove(user = this.client.user) {
      const userID = this.client.users.resolveID(user);
      if (!userID)
        return Promise.reject(new Error2("REACTION_RESOLVE_USER"));
      const message = this.reaction.message;
      return this.client.api.channels[message.channel.id].messages[message.id].reactions[this.reaction.emoji.identifier][userID === this.client.user.id ? "@me" : userID].delete().then(() => this.reaction);
    }
  };
  module2.exports = ReactionUserManager;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports2, module2) => {
  "use strict";
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var Util = require_Util();
  var MessageReaction = class {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", {value: client});
      this.message = message;
      this.users = new ReactionUserManager(client, void 0, this);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this._patch(data);
    }
    _patch(data) {
      if (this.count == void 0) {
        this.count = data.count;
      }
      this.me = data.me;
    }
    async remove() {
      await this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions(this._emoji.identifier).delete();
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id || this.emoji.name);
      this._patch(existing || {count: 0});
      return this;
    }
    toJSON() {
      return Util.flatten(this, {emoji: "emojiID", message: "messageID"});
    }
    _add(user) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
        this.count++;
      if (!this.me)
        this.me = user.id === this.message.client.user.id;
    }
    _remove(user) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id)
        this.count--;
      if (user.id === this.message.client.user.id)
        this.me = false;
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id || this.emoji.name);
      }
    }
  };
  module2.exports = MessageReaction;
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var MessageReaction = require_MessageReaction();
  var ReactionManager = class extends BaseManager {
    constructor(message, iterable) {
      super(message.client, iterable, MessageReaction);
      this.message = message;
    }
    add(data, cache) {
      return super.add(data, cache, {id: data.emoji.id || data.emoji.name, extras: [this.message]});
    }
    removeAll() {
      return this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions.delete().then(() => this.message);
    }
  };
  module2.exports = ReactionManager;
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports2, module2) => {
  "use strict";
  var APIMessage = require_APIMessage();
  var Base = require_Base();
  var ClientApplication2 = require_ClientApplication();
  var MessageAttachment = require_MessageAttachment();
  var Embed = require_MessageEmbed();
  var Mentions = require_MessageMentions();
  var ReactionCollector = require_ReactionCollector();
  var {Error: Error2, TypeError: TypeError2} = require_errors();
  var ReactionManager = require_ReactionManager();
  var Collection2 = require_Collection();
  var {MessageTypes} = require_Constants();
  var MessageFlags = require_MessageFlags();
  var Permissions2 = require_Permissions();
  var SnowflakeUtil = require_Snowflake();
  var Util = require_Util();
  var Message = class extends Base {
    constructor(client, data, channel) {
      super(client);
      this.channel = channel;
      this.deleted = false;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = MessageTypes[data.type];
        this.system = data.type !== 0;
      } else if (typeof this.type !== "string") {
        this.system = null;
        this.type = null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else if (typeof this.content !== "string") {
        this.content = null;
      }
      if ("author" in data) {
        this.author = this.client.users.add(data.author, !data.webhook_id);
      } else if (!this.author) {
        this.author = null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else if (typeof this.pinned !== "boolean") {
        this.pinned = null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else if (typeof this.tts !== "boolean") {
        this.tts = null;
      }
      this.nonce = "nonce" in data ? data.nonce : null;
      this.embeds = (data.embeds || []).map((e) => new Embed(e, true));
      this.attachments = new Collection2();
      if (data.attachments) {
        for (const attachment of data.attachments) {
          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));
        }
      }
      this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;
      this.editedTimestamp = "edited_timestamp" in data ? new Date(data.edited_timestamp).getTime() : null;
      this.reactions = new ReactionManager(this);
      if (data.reactions && data.reactions.length > 0) {
        for (const reaction of data.reactions) {
          this.reactions.add(reaction);
        }
      }
      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);
      this.webhookID = data.webhook_id || null;
      this.application = data.application ? new ClientApplication2(this.client, data.application) : null;
      this.activity = data.activity ? {
        partyID: data.activity.party_id,
        type: data.activity.type
      } : null;
      this._edits = [];
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members.add(Object.assign(data.member, {user: this.author}));
      }
      this.flags = new MessageFlags(data.flags).freeze();
      this.reference = data.message_reference ? {
        channelID: data.message_reference.channel_id,
        guildID: data.message_reference.guild_id,
        messageID: data.message_reference.message_id
      } : null;
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    patch(data) {
      const clone = this._clone();
      const {messageEditHistoryMaxSize} = this.client.options;
      if (messageEditHistoryMaxSize !== 0) {
        const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;
        if (this._edits.unshift(clone) > editsLimit)
          this._edits.pop();
      }
      if ("edited_timestamp" in data)
        this.editedTimestamp = new Date(data.edited_timestamp).getTime();
      if ("content" in data)
        this.content = data.content;
      if ("pinned" in data)
        this.pinned = data.pinned;
      if ("tts" in data)
        this.tts = data.tts;
      if ("embeds" in data)
        this.embeds = data.embeds.map((e) => new Embed(e, true));
      else
        this.embeds = this.embeds.slice();
      if ("attachments" in data) {
        this.attachments = new Collection2();
        for (const attachment of data.attachments) {
          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));
        }
      } else {
        this.attachments = new Collection2(this.attachments);
      }
      this.mentions = new Mentions(this, "mentions" in data ? data.mentions : this.mentions.users, "mention_roles" in data ? data.mention_roles : this.mentions.roles, "mention_everyone" in data ? data.mention_everyone : this.mentions.everyone, "mention_channels" in data ? data.mention_channels : this.mentions.crosspostedChannels);
      this.flags = new MessageFlags("flags" in data ? data.flags : 0).freeze();
      return clone;
    }
    get member() {
      return this.guild ? this.guild.member(this.author) || null : null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
    }
    get guild() {
      return this.channel.guild || null;
    }
    get url() {
      return `https://discord.com/channels/${this.guild ? this.guild.id : "@me"}/${this.channel.id}/${this.id}`;
    }
    get cleanContent() {
      return this.content != null ? Util.cleanContent(this.content, this) : null;
    }
    createReactionCollector(filter, options = {}) {
      return new ReactionCollector(this, filter, options);
    }
    awaitReactions(filter, options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(filter, options);
        collector.once("end", (reactions, reason) => {
          if (options.errors && options.errors.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    get edits() {
      const copy = this._edits.slice();
      copy.unshift(this);
      return copy;
    }
    get editable() {
      return this.author.id === this.client.user.id;
    }
    get deletable() {
      return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_MESSAGES, false));
    }
    get pinnable() {
      return this.type === "DEFAULT" && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_MESSAGES, false));
    }
    get crosspostable() {
      return this.channel.type === "news" && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === "DEFAULT" && this.channel.viewable && this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.SEND_MESSAGES) && (this.author.id === this.client.user.id || this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_MESSAGES));
    }
    edit(content, options) {
      const {data} = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();
      return this.client.api.channels[this.channel.id].messages[this.id].patch({data}).then((d) => {
        const clone = this._clone();
        clone._patch(d);
        return clone;
      });
    }
    async crosspost() {
      await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();
      return this;
    }
    pin(options) {
      return this.client.api.channels(this.channel.id).pins(this.id).put(options).then(() => this);
    }
    unpin(options) {
      return this.client.api.channels(this.channel.id).pins(this.id).delete(options).then(() => this);
    }
    react(emoji) {
      emoji = this.client.emojis.resolveIdentifier(emoji);
      if (!emoji)
        throw new TypeError2("EMOJI_TYPE");
      return this.client.api.channels(this.channel.id).messages(this.id).reactions(emoji, "@me").put().then(() => this.client.actions.MessageReactionAdd.handle({
        user: this.client.user,
        channel: this.channel,
        message: this,
        emoji: Util.parseEmoji(emoji)
      }).reaction);
    }
    delete(options = {}) {
      if (typeof options !== "object")
        return Promise.reject(new TypeError2("INVALID_TYPE", "options", "object", true));
      const {timeout = 0, reason} = options;
      if (timeout <= 0) {
        return this.channel.messages.delete(this.id, reason).then(() => this);
      } else {
        return new Promise((resolve) => {
          this.client.setTimeout(() => {
            resolve(this.delete({reason}));
          }, timeout);
        });
      }
    }
    reply(content, options) {
      return this.channel.send(content instanceof APIMessage ? content : APIMessage.transformOptions(content, options, {reply: this.member || this.author}));
    }
    fetch(force = false) {
      return this.channel.messages.fetch(this.id, true, force);
    }
    fetchWebhook() {
      if (!this.webhookID)
        return Promise.reject(new Error2("WEBHOOK_MESSAGE"));
      return this.client.fetchWebhook(this.webhookID);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlags(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
      } else {
        flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
      }
      return this.edit({flags});
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();
      }
      return equal;
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelID",
        author: "authorID",
        application: "applicationID",
        guild: "guildID",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  };
  module2.exports = Message;
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports2, module2) => {
  "use strict";
  var Collection2 = require_Collection();
  var LimitedCollection = class extends Collection2 {
    constructor(maxSize = 0, iterable = null) {
      super(iterable);
      this.maxSize = maxSize;
    }
    set(key, value) {
      if (this.maxSize === 0)
        return this;
      if (this.size >= this.maxSize && !this.has(key))
        this.delete(this.firstKey());
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection2;
    }
  };
  module2.exports = LimitedCollection;
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var {TypeError: TypeError2} = require_errors();
  var Message = require_Message();
  var Collection2 = require_Collection();
  var LimitedCollection = require_LimitedCollection();
  var MessageManager = class extends BaseManager {
    constructor(channel, iterable) {
      super(channel.client, iterable, Message, LimitedCollection, channel.client.options.messageCacheMaxSize);
      this.channel = channel;
    }
    add(data, cache) {
      return super.add(data, cache, {extras: [this.channel]});
    }
    fetch(message, cache = true, force = false) {
      return typeof message === "string" ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);
    }
    fetchPinned(cache = true) {
      return this.client.api.channels[this.channel.id].pins.get().then((data) => {
        const messages = new Collection2();
        for (const message of data)
          messages.set(message.id, this.add(message, cache));
        return messages;
      });
    }
    async delete(message, reason) {
      message = this.resolveID(message);
      if (!message)
        throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
      await this.client.api.channels(this.channel.id).messages(message).delete({reason});
    }
    async _fetchId(messageID, cache, force) {
      if (!force) {
        const existing = this.cache.get(messageID);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.api.channels[this.channel.id].messages[messageID].get();
      return this.add(data, cache);
    }
    async _fetchMany(options = {}, cache) {
      const data = await this.client.api.channels[this.channel.id].messages.get({query: options});
      const messages = new Collection2();
      for (const message of data)
        messages.set(message.id, this.add(message, cache));
      return messages;
    }
  };
  module2.exports = MessageManager;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports2, module2) => {
  "use strict";
  var MessageCollector = require_MessageCollector();
  var APIMessage = require_APIMessage();
  var Snowflake = require_Snowflake();
  var Collection2 = require_Collection();
  var {RangeError: RangeError2, TypeError: TypeError2} = require_errors();
  var TextBasedChannel = class {
    constructor() {
      this.messages = new MessageManager(this);
      this.lastMessageID = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.cache.get(this.lastMessageID) || null;
    }
    get lastPinAt() {
      return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;
    }
    async send(content, options) {
      const User = require_User();
      const GuildMember = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        return this.createDM().then((dm) => dm.send(content, options));
      }
      let apiMessage;
      if (content instanceof APIMessage) {
        apiMessage = content.resolveData();
      } else {
        apiMessage = APIMessage.create(this, content, options).resolveData();
        if (Array.isArray(apiMessage.data.content)) {
          return Promise.all(apiMessage.split().map(this.send.bind(this)));
        }
      }
      const {data, files} = await apiMessage.resolveFiles();
      return this.client.api.channels[this.id].messages.post({data, files}).then((d) => this.client.actions.MessageCreate.handle(d).message);
    }
    startTyping(count) {
      if (typeof count !== "undefined" && count < 1)
        throw new RangeError2("TYPING_COUNT");
      if (this.client.user._typing.has(this.id)) {
        const entry2 = this.client.user._typing.get(this.id);
        entry2.count = count || entry2.count + 1;
        return entry2.promise;
      }
      const entry = {};
      entry.promise = new Promise((resolve, reject) => {
        const endpoint = this.client.api.channels[this.id].typing;
        Object.assign(entry, {
          count: count || 1,
          interval: this.client.setInterval(() => {
            endpoint.post().catch((error) => {
              this.client.clearInterval(entry.interval);
              this.client.user._typing.delete(this.id);
              reject(error);
            });
          }, 9e3),
          resolve
        });
        endpoint.post().catch((error) => {
          this.client.clearInterval(entry.interval);
          this.client.user._typing.delete(this.id);
          reject(error);
        });
        this.client.user._typing.set(this.id, entry);
      });
      return entry.promise;
    }
    stopTyping(force = false) {
      if (this.client.user._typing.has(this.id)) {
        const entry = this.client.user._typing.get(this.id);
        entry.count--;
        if (entry.count <= 0 || force) {
          this.client.clearInterval(entry.interval);
          this.client.user._typing.delete(this.id);
          entry.resolve();
        }
      }
    }
    get typing() {
      return this.client.user._typing.has(this.id);
    }
    get typingCount() {
      if (this.client.user._typing.has(this.id))
        return this.client.user._typing.get(this.id).count;
      return 0;
    }
    createMessageCollector(filter, options = {}) {
      return new MessageCollector(this, filter, options);
    }
    awaitMessages(filter, options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(filter, options);
        collector.once("end", (collection, reason) => {
          if (options.errors && options.errors.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection2) {
        let messageIDs = messages instanceof Collection2 ? messages.keyArray() : messages.map((m) => m.id || m);
        if (filterOld) {
          messageIDs = messageIDs.filter((id) => Date.now() - Snowflake.deconstruct(id).date.getTime() < 12096e5);
        }
        if (messageIDs.length === 0)
          return new Collection2();
        if (messageIDs.length === 1) {
          await this.client.api.channels(this.id).messages(messageIDs[0]).delete();
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIDs[0]
          }, this);
          return message ? new Collection2([[message.id, message]]) : new Collection2();
        }
        await this.client.api.channels[this.id].messages["bulk-delete"].post({data: {messages: messageIDs}});
        return messageIDs.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection2());
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({limit: messages});
        return this.bulkDelete(msgs, filterOld);
      }
      throw new TypeError2("MESSAGE_BULK_DELETE_TYPE");
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "startTyping", "stopTyping", "typing", "typingCount", "createMessageCollector", "awaitMessages");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  };
  module2.exports = TextBasedChannel;
  var MessageManager = require_MessageManager();
});

// node_modules/discord.js/src/util/UserFlags.js
var require_UserFlags = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var UserFlags = class extends BitField {
  };
  UserFlags.FLAGS = {
    DISCORD_EMPLOYEE: 1 << 0,
    PARTNERED_SERVER_OWNER: 1 << 1,
    DISCORD_PARTNER: 1 << 1,
    HYPESQUAD_EVENTS: 1 << 2,
    BUGHUNTER_LEVEL_1: 1 << 3,
    HOUSE_BRAVERY: 1 << 6,
    HOUSE_BRILLIANCE: 1 << 7,
    HOUSE_BALANCE: 1 << 8,
    EARLY_SUPPORTER: 1 << 9,
    TEAM_USER: 1 << 10,
    SYSTEM: 1 << 12,
    BUGHUNTER_LEVEL_2: 1 << 14,
    VERIFIED_BOT: 1 << 16,
    EARLY_VERIFIED_DEVELOPER: 1 << 17,
    VERIFIED_DEVELOPER: 1 << 17
  };
  module2.exports = UserFlags;
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var {Error: Error2} = require_errors();
  var Snowflake = require_Snowflake();
  var UserFlags = require_UserFlags();
  var Structures2;
  var User = class extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.system = null;
      this.locale = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else if (typeof this.username !== "string") {
        this.username = null;
      }
      if ("bot" in data || typeof this.bot !== "boolean") {
        this.bot = Boolean(data.bot);
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else if (typeof this.discriminator !== "string") {
        this.discriminator = null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      }
      if ("locale" in data) {
        this.locale = data.locale;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlags(data.public_flags);
      }
      this.lastMessageID = null;
      this.lastMessageChannelID = null;
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get lastMessage() {
      const channel = this.client.channels.cache.get(this.lastMessageChannelID);
      return channel && channel.messages.cache.get(this.lastMessageID) || null;
    }
    get presence() {
      for (const guild of this.client.guilds.cache.values()) {
        if (guild.presences.cache.has(this.id))
          return guild.presences.cache.get(this.id);
      }
      if (!Structures2)
        Structures2 = require_Structures();
      const Presence = Structures2.get("Presence");
      return new Presence(this.client, {user: {id: this.id}});
    }
    avatarURL({format, size, dynamic} = {}) {
      if (!this.avatar)
        return null;
      return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);
    }
    get defaultAvatarURL() {
      return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) || this.defaultAvatarURL;
    }
    get tag() {
      return typeof this.username === "string" ? `${this.username}#${this.discriminator}` : null;
    }
    typingIn(channel) {
      channel = this.client.channels.resolve(channel);
      return channel._typing.has(this.id);
    }
    typingSinceIn(channel) {
      channel = this.client.channels.resolve(channel);
      return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;
    }
    typingDurationIn(channel) {
      channel = this.client.channels.resolve(channel);
      return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;
    }
    get dmChannel() {
      return this.client.channels.cache.find((c) => c.type === "dm" && c.recipient.id === this.id) || null;
    }
    async createDM(force = false) {
      if (!force) {
        const {dmChannel} = this;
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.api.users(this.client.user.id).channels.post({
        data: {
          recipient_id: this.id
        }
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async deleteDM() {
      const {dmChannel} = this;
      if (!dmChannel)
        throw new Error2("USER_NO_DMCHANNEL");
      const data = await this.client.api.channels(dmChannel.id).delete();
      return this.client.actions.ChannelDelete.handle(data).channel;
    }
    equals(user) {
      let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar;
      return equal;
    }
    async fetchFlags(force = false) {
      if (this.flags && !force)
        return this.flags;
      const data = await this.client.api.users(this.id).get();
      this._patch(data);
      return this.flags;
    }
    fetch(force = false) {
      return this.client.users.fetch(this.id, true, force);
    }
    toString() {
      return `<@${this.id}>`;
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        tag: true,
        lastMessage: false,
        lastMessageID: false
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      return json;
    }
    send() {
    }
  };
  TextBasedChannel.applyToClass(User);
  module2.exports = User;
});

// node_modules/discord.js/src/structures/APIMessage.js
var require_APIMessage = __commonJS((exports2, module2) => {
  "use strict";
  var MessageAttachment = require_MessageAttachment();
  var MessageEmbed = require_MessageEmbed();
  var {RangeError: RangeError2} = require_errors();
  var {browser: browser2} = require_Constants();
  var DataResolver2 = require_DataResolver();
  var MessageFlags = require_MessageFlags();
  var Util = require_Util();
  var APIMessage = class {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.data = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook2 = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook2 || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const GuildMember = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const Message = require_Message();
      return this.target instanceof Message;
    }
    makeContent() {
      const GuildMember = require_GuildMember();
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (typeof this.options.content !== "undefined") {
        content = Util.resolveString(this.options.content);
      }
      if (typeof content !== "string")
        return content;
      const disableMentions = typeof this.options.disableMentions === "undefined" ? this.target.client.options.disableMentions : this.options.disableMentions;
      if (disableMentions === "all") {
        content = Util.removeMentions(content);
      } else if (disableMentions === "everyone") {
        content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {
          if (target.match(/^[&!]?\d+$/)) {
            return `@${target}`;
          } else {
            return `@\u200B${target}`;
          }
        });
      }
      const isSplit = typeof this.options.split !== "undefined" && this.options.split !== false;
      const isCode = typeof this.options.code !== "undefined" && this.options.code !== false;
      const splitOptions = isSplit ? {...this.options.split} : void 0;
      let mentionPart = "";
      if (this.options.reply && !this.isUser && this.target.type !== "dm") {
        const id = this.target.client.users.resolveID(this.options.reply);
        mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? "!" : ""}${id}>, `;
        if (isSplit) {
          splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ""}`;
        }
      }
      if (content || mentionPart) {
        if (isCode) {
          const codeName = typeof this.options.code === "string" ? this.options.code : "";
          content = `${mentionPart}\`\`\`${codeName}
${Util.cleanCodeBlockContent(content)}
\`\`\``;
          if (isSplit) {
            splitOptions.prepend = `${splitOptions.prepend || ""}\`\`\`${codeName}
`;
            splitOptions.append = `
\`\`\`${splitOptions.append || ""}`;
          }
        } else if (mentionPart) {
          content = `${mentionPart}${content}`;
        }
        if (isSplit) {
          content = Util.splitMessage(content, splitOptions);
        }
      }
      return content;
    }
    resolveData() {
      if (this.data)
        return this;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (typeof this.options.nonce !== "undefined") {
        nonce = parseInt(this.options.nonce);
        if (isNaN(nonce) || nonce < 0)
          throw new RangeError2("MESSAGE_NONCE_TYPE");
      }
      const embedLikes = [];
      if (this.isWebhook) {
        if (this.options.embeds) {
          embedLikes.push(...this.options.embeds);
        }
      } else if (this.options.embed) {
        embedLikes.push(this.options.embed);
      }
      const embeds = embedLikes.map((e) => new MessageEmbed(e).toJSON());
      let username;
      let avatarURL;
      if (this.isWebhook) {
        username = this.options.username || this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
      }
      let flags;
      if (this.isMessage) {
        flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;
      }
      let allowedMentions = typeof this.options.allowedMentions === "undefined" ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (this.options.reply) {
        const id = this.target.client.users.resolveID(this.options.reply);
        if (allowedMentions) {
          allowedMentions = Util.cloneObject(allowedMentions);
          const parsed = allowedMentions.parse && allowedMentions.parse.includes("users");
          if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {
            if (!allowedMentions.users)
              allowedMentions.users = [];
            allowedMentions.users.push(id);
          }
        } else {
          allowedMentions = {users: [id]};
        }
      }
      this.data = {
        content,
        tts,
        nonce,
        embed: this.options.embed === null ? null : embeds[0],
        embeds,
        username,
        avatar_url: avatarURL,
        allowed_mentions: typeof content === "undefined" ? void 0 : allowedMentions,
        flags
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      const embedLikes = [];
      if (this.isWebhook) {
        if (this.options.embeds) {
          embedLikes.push(...this.options.embeds);
        }
      } else if (this.options.embed) {
        embedLikes.push(this.options.embed);
      }
      const fileLikes = [];
      if (this.options.files) {
        fileLikes.push(...this.options.files);
      }
      for (const embed of embedLikes) {
        if (embed.files) {
          fileLikes.push(...embed.files);
        }
      }
      this.files = await Promise.all(fileLikes.map((f) => this.constructor.resolveFile(f)));
      return this;
    }
    split() {
      if (!this.data)
        this.resolveData();
      if (!Array.isArray(this.data.content))
        return [this];
      const apiMessages = [];
      for (let i = 0; i < this.data.content.length; i++) {
        let data;
        let opt;
        if (i === this.data.content.length - 1) {
          data = {...this.data, content: this.data.content[i]};
          opt = {...this.options, content: this.data.content[i]};
        } else {
          data = {content: this.data.content[i], tts: this.data.tts, allowed_mentions: this.options.allowedMentions};
          opt = {content: this.data.content[i], tts: this.data.tts, allowedMentions: this.options.allowedMentions};
        }
        const apiMessage = new APIMessage(this.target, opt);
        apiMessage.data = data;
        apiMessages.push(apiMessage);
      }
      return apiMessages;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return Util.basename(thing);
        }
        if (thing.path) {
          return Util.basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof (browser2 ? ArrayBuffer : Buffer) || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name || findName(attachment);
      }
      const resource = await DataResolver2.resolveFile(attachment);
      return {attachment, name, file: resource};
    }
    static partitionMessageAdditions(items) {
      const embeds = [];
      const files = [];
      for (const item of items) {
        if (item instanceof MessageEmbed) {
          embeds.push(item);
        } else if (item instanceof MessageAttachment) {
          files.push(item);
        }
      }
      return [embeds, files];
    }
    static transformOptions(content, options, extra = {}, isWebhook = false) {
      if (!options && typeof content === "object" && !Array.isArray(content)) {
        options = content;
        content = void 0;
      }
      if (!options) {
        options = {};
      } else if (options instanceof MessageEmbed) {
        return isWebhook ? {content, embeds: [options], ...extra} : {content, embed: options, ...extra};
      } else if (options instanceof MessageAttachment) {
        return {content, files: [options], ...extra};
      }
      if (Array.isArray(options)) {
        const [embeds, files] = this.partitionMessageAdditions(options);
        return isWebhook ? {content, embeds, files, ...extra} : {content, embed: embeds[0], files, ...extra};
      } else if (Array.isArray(content)) {
        const [embeds, files] = this.partitionMessageAdditions(content);
        if (embeds.length || files.length) {
          return isWebhook ? {embeds, files, ...extra} : {embed: embeds[0], files, ...extra};
        }
      }
      return {content, ...options, ...extra};
    }
    static create(target, content, options, extra = {}) {
      const Webhook2 = require_Webhook();
      const WebhookClient = require_WebhookClient();
      const isWebhook = target instanceof Webhook2 || target instanceof WebhookClient;
      const transformed = this.transformOptions(content, options, extra, isWebhook);
      return new this(target, transformed);
    }
  };
  module2.exports = APIMessage;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports2, module2) => {
  "use strict";
  var APIMessage = require_APIMessage();
  var Channel = require_Channel();
  var {WebhookTypes} = require_Constants();
  var DataResolver2 = require_DataResolver();
  var Snowflake = require_Snowflake();
  var Webhook2 = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.name = data.name;
      Object.defineProperty(this, "token", {value: data.token || null, writable: true, configurable: true});
      this.avatar = data.avatar;
      this.id = data.id;
      this.type = WebhookTypes[data.type];
      this.guildID = data.guild_id;
      this.channelID = data.channel_id;
      if (data.user) {
        this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;
      } else {
        this.owner = null;
      }
    }
    async send(content, options) {
      let apiMessage;
      if (content instanceof APIMessage) {
        apiMessage = content.resolveData();
      } else {
        apiMessage = APIMessage.create(this, content, options).resolveData();
        if (Array.isArray(apiMessage.data.content)) {
          return Promise.all(apiMessage.split().map(this.send.bind(this)));
        }
      }
      const {data, files} = await apiMessage.resolveFiles();
      return this.client.api.webhooks(this.id, this.token).post({
        data,
        files,
        query: {wait: true},
        auth: false
      }).then((d) => {
        const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : void 0;
        if (!channel)
          return d;
        return channel.messages.add(d, false);
      });
    }
    sendSlackMessage(body) {
      return this.client.api.webhooks(this.id, this.token).slack.post({
        query: {wait: true},
        auth: false,
        data: body
      }).then((data) => data.toString() === "ok");
    }
    async edit({name = this.name, avatar, channel}, reason) {
      if (avatar && typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await DataResolver2.resolveImage(avatar);
      }
      if (channel)
        channel = channel instanceof Channel ? channel.id : channel;
      const data = await this.client.api.webhooks(this.id, channel ? void 0 : this.token).patch({
        data: {name, avatar, channel_id: channel},
        reason
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelID = data.channel_id;
      return this;
    }
    delete(reason) {
      return this.client.api.webhooks(this.id, this.token).delete({reason});
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);
    }
    avatarURL({format, size} = {}) {
      if (!this.avatar)
        return null;
      return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);
    }
    static applyToClass(structure) {
      for (const prop of ["send", "sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt", "url"]) {
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook2.prototype, prop));
      }
    }
  };
  module2.exports = Webhook2;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports2, module2) => {
  "use strict";
  var GuildChannel = require_GuildChannel();
  var Webhook2 = require_Webhook();
  var TextBasedChannel = require_TextBasedChannel();
  var MessageManager = require_MessageManager();
  var Collection2 = require_Collection();
  var DataResolver2 = require_DataResolver();
  var TextChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.messages = new MessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._typing = new Map();
    }
    _patch(data) {
      super._patch(data);
      this.topic = data.topic;
      if (typeof data.nsfw !== "undefined")
        this.nsfw = Boolean(data.nsfw);
      this.lastMessageID = data.last_message_id;
      this.rateLimitPerUser = data.rate_limit_per_user || 0;
      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
      if (data.messages)
        for (const message of data.messages)
          this.messages.add(message);
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({rateLimitPerUser}, reason);
    }
    setNSFW(nsfw, reason) {
      return this.edit({nsfw}, reason);
    }
    fetchWebhooks() {
      return this.client.api.channels[this.id].webhooks.get().then((data) => {
        const hooks = new Collection2();
        for (const hook of data)
          hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      });
    }
    async createWebhook(name, {avatar, reason} = {}) {
      if (typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await DataResolver2.resolveImage(avatar);
      }
      return this.client.api.channels[this.id].webhooks.post({
        data: {
          name,
          avatar
        },
        reason
      }).then((data) => new Webhook2(this.client, data));
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    startTyping() {
    }
    stopTyping() {
    }
    get typing() {
    }
    get typingCount() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    bulkDelete() {
    }
  };
  TextBasedChannel.applyToClass(TextChannel, true);
  module2.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports2, module2) => {
  "use strict";
  var GuildChannel = require_GuildChannel();
  var {Error: Error2} = require_errors();
  var Collection2 = require_Collection();
  var {browser: browser2} = require_Constants();
  var Permissions2 = require_Permissions();
  var VoiceChannel = class extends GuildChannel {
    _patch(data) {
      super._patch(data);
      this.bitrate = data.bitrate;
      this.userLimit = data.user_limit;
    }
    get members() {
      const coll = new Collection2();
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelID === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get deletable() {
      return super.deletable && this.permissionsFor(this.client.user).has(Permissions2.FLAGS.CONNECT, false);
    }
    get editable() {
      return this.manageable && this.permissionsFor(this.client.user).has(Permissions2.FLAGS.CONNECT, false);
    }
    get joinable() {
      if (browser2)
        return false;
      if (!this.viewable)
        return false;
      if (!this.permissionsFor(this.client.user).has(Permissions2.FLAGS.CONNECT, false))
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(Permissions2.FLAGS.MOVE_MEMBERS, false))
        return false;
      return true;
    }
    get speakable() {
      return this.permissionsFor(this.client.user).has(Permissions2.FLAGS.SPEAK, false);
    }
    setBitrate(bitrate, reason) {
      return this.edit({bitrate}, reason);
    }
    setUserLimit(userLimit, reason) {
      return this.edit({userLimit}, reason);
    }
    join() {
      if (browser2)
        return Promise.reject(new Error2("VOICE_NO_BROWSER"));
      return this.client.voice.joinChannel(this);
    }
    leave() {
      if (browser2)
        return;
      const connection = this.client.voice.connections.get(this.guild.id);
      if (connection && connection.channel.id === this.id)
        connection.disconnect();
    }
  };
  module2.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports2, module2) => {
  "use strict";
  var GuildChannel = require_GuildChannel();
  var CategoryChannel = class extends GuildChannel {
    get children() {
      return this.guild.channels.cache.filter((c) => c.parentID === this.id);
    }
  };
  module2.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports2, module2) => {
  "use strict";
  var TextChannel = require_TextChannel();
  var {Error: Error2} = require_errors();
  var NewsChannel = class extends TextChannel {
    _patch(data) {
      super._patch(data);
      this.rateLimitPerUser = void 0;
    }
    async addFollower(channel, reason) {
      const channelID = this.guild.channels.resolveID(channel);
      if (!channelID)
        throw new Error2("GUILD_CHANNEL_RESOLVE");
      await this.client.api.channels(this.id).followers.post({data: {webhook_channel_id: channelID}, reason});
      return this;
    }
  };
  module2.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/StoreChannel.js
var require_StoreChannel = __commonJS((exports2, module2) => {
  "use strict";
  var GuildChannel = require_GuildChannel();
  var StoreChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.nsfw = Boolean(data.nsfw);
    }
    _patch(data) {
      super._patch(data);
      if (typeof data.nsfw !== "undefined")
        this.nsfw = Boolean(data.nsfw);
    }
  };
  module2.exports = StoreChannel;
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports2, module2) => {
  "use strict";
  var Application = require_Application();
  var IntegrationApplication = class extends Application {
    _patch(data) {
      super._patch(data);
      if (typeof data.bot !== "undefined") {
        this.bot = this.client.users.add(data.bot);
      } else if (!this.bot) {
        this.bot = null;
      }
    }
  };
  module2.exports = IntegrationApplication;
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();
  var Integration = class extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled;
      this.syncing = data.syncing;
      this.role = this.guild.roles.cache.get(data.role_id);
      if (data.user) {
        this.user = this.client.users.add(data.user);
      } else {
        this.user = null;
      }
      this.account = data.account;
      this.syncedAt = data.synced_at;
      this._patch(data);
    }
    _patch(data) {
      this.expireBehavior = data.expire_behavior;
      this.expireGracePeriod = data.expire_grace_period;
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else if (!this.application) {
        this.application = null;
      }
    }
    sync() {
      this.syncing = true;
      return this.client.api.guilds(this.guild.id).integrations(this.id).post().then(() => {
        this.syncing = false;
        this.syncedAt = Date.now();
        return this;
      });
    }
    edit(data, reason) {
      if ("expireBehavior" in data) {
        data.expire_behavior = data.expireBehavior;
        data.expireBehavior = null;
      }
      if ("expireGracePeriod" in data) {
        data.expire_grace_period = data.expireGracePeriod;
        data.expireGracePeriod = null;
      }
      return this.client.api.guilds(this.guild.id).integrations(this.id).patch({data, reason}).then(() => {
        this._patch(data);
        return this;
      });
    }
    delete(reason) {
      return this.client.api.guilds(this.guild.id).integrations(this.id).delete({reason}).then(() => this);
    }
    toJSON() {
      return super.toJSON({
        role: "roleID",
        guild: "guildID",
        user: "userID"
      });
    }
  };
  module2.exports = Integration;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports2, module2) => {
  "use strict";
  var Integration = require_Integration();
  var Webhook2 = require_Webhook();
  var Collection2 = require_Collection();
  var {PartialTypes} = require_Constants();
  var Snowflake = require_Snowflake();
  var Util = require_Util();
  var Targets = {
    ALL: "ALL",
    GUILD: "GUILD",
    CHANNEL: "CHANNEL",
    USER: "USER",
    ROLE: "ROLE",
    INVITE: "INVITE",
    WEBHOOK: "WEBHOOK",
    EMOJI: "EMOJI",
    MESSAGE: "MESSAGE",
    INTEGRATION: "INTEGRATION",
    UNKNOWN: "UNKNOWN"
  };
  var Actions = {
    ALL: null,
    GUILD_UPDATE: 1,
    CHANNEL_CREATE: 10,
    CHANNEL_UPDATE: 11,
    CHANNEL_DELETE: 12,
    CHANNEL_OVERWRITE_CREATE: 13,
    CHANNEL_OVERWRITE_UPDATE: 14,
    CHANNEL_OVERWRITE_DELETE: 15,
    MEMBER_KICK: 20,
    MEMBER_PRUNE: 21,
    MEMBER_BAN_ADD: 22,
    MEMBER_BAN_REMOVE: 23,
    MEMBER_UPDATE: 24,
    MEMBER_ROLE_UPDATE: 25,
    MEMBER_MOVE: 26,
    MEMBER_DISCONNECT: 27,
    BOT_ADD: 28,
    ROLE_CREATE: 30,
    ROLE_UPDATE: 31,
    ROLE_DELETE: 32,
    INVITE_CREATE: 40,
    INVITE_UPDATE: 41,
    INVITE_DELETE: 42,
    WEBHOOK_CREATE: 50,
    WEBHOOK_UPDATE: 51,
    WEBHOOK_DELETE: 52,
    EMOJI_CREATE: 60,
    EMOJI_UPDATE: 61,
    EMOJI_DELETE: 62,
    MESSAGE_DELETE: 72,
    MESSAGE_BULK_DELETE: 73,
    MESSAGE_PIN: 74,
    MESSAGE_UNPIN: 75,
    INTEGRATION_CREATE: 80,
    INTEGRATION_UPDATE: 81,
    INTEGRATION_DELETE: 82
  };
  var GuildAuditLogs = class {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users.add(user);
      this.webhooks = new Collection2();
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook2(guild.client, hook));
        }
      }
      this.integrations = new Collection2();
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.entries = new Collection2();
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(this, guild, item);
        this.entries.set(entry.id, entry);
      }
    }
    static build(...args) {
      const logs = new GuildAuditLogs(...args);
      return Promise.all(logs.entries.map((e) => e.target)).then(() => logs);
    }
    static targetType(target) {
      if (target < 10)
        return Targets.GUILD;
      if (target < 20)
        return Targets.CHANNEL;
      if (target < 30)
        return Targets.USER;
      if (target < 40)
        return Targets.ROLE;
      if (target < 50)
        return Targets.INVITE;
      if (target < 60)
        return Targets.WEBHOOK;
      if (target < 70)
        return Targets.EMOJI;
      if (target < 80)
        return Targets.MESSAGE;
      if (target < 90)
        return Targets.INTEGRATION;
      return Targets.UNKNOWN;
    }
    static actionType(action) {
      if ([
        Actions.CHANNEL_CREATE,
        Actions.CHANNEL_OVERWRITE_CREATE,
        Actions.MEMBER_BAN_REMOVE,
        Actions.BOT_ADD,
        Actions.ROLE_CREATE,
        Actions.INVITE_CREATE,
        Actions.WEBHOOK_CREATE,
        Actions.EMOJI_CREATE,
        Actions.MESSAGE_PIN,
        Actions.INTEGRATION_CREATE
      ].includes(action)) {
        return "CREATE";
      }
      if ([
        Actions.CHANNEL_DELETE,
        Actions.CHANNEL_OVERWRITE_DELETE,
        Actions.MEMBER_KICK,
        Actions.MEMBER_PRUNE,
        Actions.MEMBER_BAN_ADD,
        Actions.MEMBER_DISCONNECT,
        Actions.ROLE_DELETE,
        Actions.INVITE_DELETE,
        Actions.WEBHOOK_DELETE,
        Actions.EMOJI_DELETE,
        Actions.MESSAGE_DELETE,
        Actions.MESSAGE_BULK_DELETE,
        Actions.MESSAGE_UNPIN,
        Actions.INTEGRATION_DELETE
      ].includes(action)) {
        return "DELETE";
      }
      if ([
        Actions.GUILD_UPDATE,
        Actions.CHANNEL_UPDATE,
        Actions.CHANNEL_OVERWRITE_UPDATE,
        Actions.MEMBER_UPDATE,
        Actions.MEMBER_ROLE_UPDATE,
        Actions.MEMBER_MOVE,
        Actions.ROLE_UPDATE,
        Actions.INVITE_UPDATE,
        Actions.WEBHOOK_UPDATE,
        Actions.EMOJI_UPDATE,
        Actions.INTEGRATION_UPDATE
      ].includes(action)) {
        return "UPDATE";
      }
      return "ALL";
    }
    toJSON() {
      return Util.flatten(this);
    }
  };
  var GuildAuditLogsEntry = class {
    constructor(logs, guild, data) {
      const targetType = GuildAuditLogs.targetType(data.action_type);
      this.targetType = targetType;
      this.actionType = GuildAuditLogs.actionType(data.action_type);
      this.action = Object.keys(Actions).find((k) => Actions[k] === data.action_type);
      this.reason = data.reason || null;
      this.executor = guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users.add({id: data.user_id}) : guild.client.users.cache.get(data.user_id);
      this.changes = data.changes ? data.changes.map((c) => ({key: c.key, old: c.old_value, new: c.new_value})) : null;
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case Actions.MEMBER_PRUNE:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case Actions.MEMBER_MOVE:
        case Actions.MESSAGE_DELETE:
        case Actions.MESSAGE_BULK_DELETE:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) || {id: data.options.channel_id},
            count: Number(data.options.count)
          };
          break;
        case Actions.MESSAGE_PIN:
        case Actions.MESSAGE_UNPIN:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) || {id: data.options.channel_id},
            messageID: data.options.message_id
          };
          break;
        case Actions.MEMBER_DISCONNECT:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case Actions.CHANNEL_OVERWRITE_CREATE:
        case Actions.CHANNEL_OVERWRITE_UPDATE:
        case Actions.CHANNEL_OVERWRITE_DELETE:
          switch (data.options.type) {
            case "member":
              this.extra = guild.members.cache.get(data.options.id) || {id: data.options.id, type: "member"};
              break;
            case "role":
              this.extra = guild.roles.cache.get(data.options.id) || {
                id: data.options.id,
                name: data.options.role_name,
                type: "role"
              };
              break;
            default:
              break;
          }
          break;
        default:
          break;
      }
      this.target = null;
      if (targetType === Targets.UNKNOWN) {
        this.target = this.changes.reduce((o, c) => {
          o[c.key] = c.new || c.old;
          return o;
        }, {});
        this.target.id = data.target_id;
      } else if (targetType === Targets.USER && data.target_id) {
        this.target = guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users.add({id: data.target_id}) : guild.client.users.cache.get(data.target_id);
      } else if (targetType === Targets.GUILD) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.WEBHOOK) {
        this.target = logs.webhooks.get(data.target_id) || new Webhook2(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new || c.old;
          return o;
        }, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.INVITE) {
        this.target = guild.members.fetch(guild.client.user.id).then((me) => {
          if (me.permissions.has("MANAGE_GUILD")) {
            const change = this.changes.find((c) => c.key === "code");
            return guild.fetchInvites().then((invites) => {
              this.target = invites.find((i) => i.code === (change.new || change.old));
            });
          } else {
            this.target = this.changes.reduce((o, c) => {
              o[c.key] = c.new || c.old;
              return o;
            }, {});
            return this.target;
          }
        });
      } else if (targetType === Targets.MESSAGE) {
        this.target = data.action_type === Actions.MESSAGE_BULK_DELETE ? guild.channels.cache.get(data.target_id) || {id: data.target_id} : guild.client.users.cache.get(data.target_id);
      } else if (targetType === Targets.INTEGRATION) {
        this.target = logs.integrations.get(data.target_id) || new Integration(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new || c.old;
          return o;
        }, {id: data.target_id}), guild);
      } else if (data.target_id) {
        this.target = guild[`${targetType.toLowerCase()}s`].cache.get(data.target_id) || {id: data.target_id};
      }
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return Util.flatten(this, {createdTimestamp: true});
    }
  };
  GuildAuditLogs.Actions = Actions;
  GuildAuditLogs.Targets = Targets;
  GuildAuditLogs.Entry = GuildAuditLogsEntry;
  module2.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports2, module2) => {
  "use strict";
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var GuildPreviewEmoji = class extends BaseGuildEmoji {
    get roles() {
      return new Set(this._roles);
    }
  };
  module2.exports = GuildPreviewEmoji;
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var Collection2 = require_Collection();
  var GuildPreview2 = class extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.splash = data.splash;
      this.discoverySplash = data.discovery_splash;
      this.features = data.features;
      this.approximateMemberCount = data.approximate_member_count;
      this.approximatePresenceCount = data.approximate_presence_count;
      this.description = data.description || null;
      if (!this.emojis) {
        this.emojis = new Collection2();
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
    }
    splashURL({format, size} = {}) {
      if (!this.splash)
        return null;
      return this.client.rest.cdn.Splash(this.id, this.splash, format, size);
    }
    discoverySplashURL({format, size} = {}) {
      if (!this.discoverySplash)
        return null;
      return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
    }
    iconURL({format, size, dynamic} = {}) {
      if (!this.icon)
        return null;
      return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
    }
    fetch() {
      return this.client.api.guilds(this.id).preview.get().then((data) => {
        this._patch(data);
        return this;
      });
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  };
  module2.exports = GuildPreview2;
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {Events: Events2} = require_Constants();
  var DataResolver2 = require_DataResolver();
  var GuildTemplate2 = class extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.code = data.code;
      this.name = data.name;
      this.description = data.description;
      this.usageCount = data.usage_count;
      this.creatorID = data.creator_id;
      this.creator = this.client.users.add(data.creator);
      this.createdAt = new Date(data.created_at);
      this.updatedAt = new Date(data.updated_at);
      this.guildID = data.source_guild_id;
      this.serializedGuild = data.serialized_source_guild;
      this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const {client} = this;
      const data = await client.api.guilds.templates(this.code).post({
        data: {
          name,
          icon: await DataResolver2.resolveImage(icon)
        }
      });
      return new Promise((resolve) => {
        const createdGuild = client.guilds.cache.get(data.id);
        if (createdGuild)
          return resolve(createdGuild);
        const resolveGuild = (guild) => {
          client.off(Events2.GUILD_CREATE, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            client.clearTimeout(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events2.GUILD_CREATE, handleGuild);
        const timeout = client.setTimeout(() => resolveGuild(client.guilds.add(data)), 1e4);
      });
    }
    edit({name, description} = {}) {
      return this.client.api.guilds(this.guildID).templates(this.code).patch({data: {name, description}}).then((data) => this._patch(data));
    }
    delete() {
      return this.client.api.guilds(this.guildID).templates(this.code).delete().then(() => this);
    }
    sync() {
      return this.client.api.guilds(this.guildID).templates(this.code).put().then((data) => this._patch(data));
    }
    get createdTimestamp() {
      return this.createdAt.getTime();
    }
    get updatedTimestamp() {
      return this.updatedAt.getTime();
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildID) || null;
    }
    get url() {
      return `${this.client.options.http.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  };
  module2.exports = GuildTemplate2;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports2, module2) => {
  "use strict";
  var Util = require_Util();
  var VoiceRegion2 = class {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.vip = data.vip;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return Util.flatten(this);
    }
  };
  module2.exports = VoiceRegion2;
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var {ChannelTypes} = require_Constants();
  var GuildChannelManager = class extends BaseManager {
    constructor(guild, iterable) {
      super(guild.client, iterable, GuildChannel);
      this.guild = guild;
    }
    add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    async create(name, options = {}) {
      let {
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        reason
      } = options;
      if (parent)
        parent = this.client.channels.resolveID(parent);
      if (permissionOverwrites) {
        permissionOverwrites = permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
      }
      const data = await this.client.api.guilds(this.guild.id).channels.post({
        data: {
          name,
          topic,
          type: type ? ChannelTypes[type.toUpperCase()] : ChannelTypes.TEXT,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
  };
  module2.exports = GuildChannelManager;
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var {TypeError: TypeError2} = require_errors();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var Collection2 = require_Collection();
  var DataResolver2 = require_DataResolver();
  var {parseEmoji} = require_Util();
  var GuildEmojiManager2 = class extends BaseManager {
    constructor(guild, iterable) {
      super(guild.client, iterable, GuildEmoji);
      this.guild = guild;
    }
    add(data, cache) {
      return super.add(data, cache, {extras: [this.guild]});
    }
    async create(attachment, name, {roles, reason} = {}) {
      attachment = await DataResolver2.resolveImage(attachment);
      if (!attachment)
        throw new TypeError2("REQ_RESOURCE_TYPE");
      const data = {image: attachment, name};
      if (roles) {
        data.roles = [];
        for (let role of roles instanceof Collection2 ? roles.values() : roles) {
          role = this.guild.roles.resolve(role);
          if (!role) {
            return Promise.reject(new TypeError2("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", true));
          }
          data.roles.push(role.id);
        }
      }
      return this.client.api.guilds(this.guild.id).emojis.post({data, reason}).then((emoji) => this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return super.resolve(emoji.id);
      return super.resolve(emoji);
    }
    resolveID(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      return super.resolveID(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res && res.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        else
          return emoji;
      }
      return null;
    }
  };
  module2.exports = GuildEmojiManager2;
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var {Error: Error2, TypeError: TypeError2, RangeError: RangeError2} = require_errors();
  var GuildMember = require_GuildMember();
  var Collection2 = require_Collection();
  var {Events: Events2, OPCodes} = require_Constants();
  var SnowflakeUtil = require_Snowflake();
  var GuildMemberManager = class extends BaseManager {
    constructor(guild, iterable) {
      super(guild.client, iterable, GuildMember);
      this.guild = guild;
    }
    add(data, cache = true) {
      return super.add(data, cache, {id: data.user.id, extras: [this.guild]});
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveID(member);
      if (userResolvable)
        return super.resolve(userResolvable);
      return null;
    }
    resolveID(member) {
      const memberResolvable = super.resolveID(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveID(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const user = this.client.users.resolveID(options);
      if (user)
        return this._fetchSingle({user, cache: true});
      if (options.user) {
        if (Array.isArray(options.user)) {
          options.user = options.user.map((u) => this.client.users.resolveID(u));
          return this._fetchMany(options);
        } else {
          options.user = this.client.users.resolveID(options.user);
        }
        if (!options.limit && !options.withPresences)
          return this._fetchSingle(options);
      }
      return this._fetchMany(options);
    }
    prune({days = 7, dry = false, count: compute_prune_count = true, roles = [], reason} = {}) {
      if (typeof days !== "number")
        throw new TypeError2("PRUNE_DAYS_TYPE");
      const query = {days};
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveID(role);
        if (!resolvedRole) {
          return Promise.reject(new TypeError2("INVALID_TYPE", "roles", "Array of Roles or Snowflakes", true));
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = this.client.api.guilds(this.guild.id).prune;
      if (dry) {
        return endpoint.get({query, reason}).then((data) => data.pruned);
      }
      return endpoint.post({
        data: {...query, compute_prune_count},
        reason
      }).then((data) => data.pruned);
    }
    ban(user, options = {days: 0}) {
      if (options.days)
        options.delete_message_days = options.days;
      const id = this.client.users.resolveID(user);
      if (!id)
        return Promise.reject(new Error2("BAN_RESOLVE_ID", true));
      return this.client.api.guilds(this.guild.id).bans[id].put({data: options}).then(() => {
        if (user instanceof GuildMember)
          return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          const member = this.resolve(_user);
          return member || _user;
        }
        return id;
      });
    }
    unban(user, reason) {
      const id = this.client.users.resolveID(user);
      if (!id)
        return Promise.reject(new Error2("BAN_RESOLVE_ID"));
      return this.client.api.guilds(this.guild.id).bans[id].delete({reason}).then(() => this.client.users.resolve(user));
    }
    _fetchSingle({user, cache, force = false}) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return Promise.resolve(existing);
      }
      return this.client.api.guilds(this.guild.id).members(user).get().then((data) => this.add(data, cache));
    }
    _fetchMany({
      limit = 0,
      withPresences: presences = false,
      user: user_ids,
      query,
      time = 12e4,
      nonce = SnowflakeUtil.generate(),
      force = false
    } = {}) {
      return new Promise((resolve, reject) => {
        if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {
          resolve(this.cache);
          return;
        }
        if (!query && !user_ids)
          query = "";
        if (nonce.length > 32)
          throw new RangeError2("MEMBER_FETCH_NONCE_LENGTH");
        this.guild.shard.send({
          op: OPCodes.REQUEST_GUILD_MEMBERS,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection2();
        const option = query || limit || presences || user_ids;
        let i = 0;
        const handler = (members, _, chunk) => {
          timeout.refresh();
          if (chunk.nonce !== nonce)
            return;
          i++;
          for (const member of members.values()) {
            if (option)
              fetchedMembers.set(member.id, member);
          }
          if (this.guild.memberCount <= this.cache.size || option && members.size < 1e3 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            this.client.clearTimeout(timeout);
            this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
            this.client.decrementMaxListeners();
            let fetched = option ? fetchedMembers : this.cache;
            if (user_ids && !Array.isArray(user_ids) && fetched.size)
              fetched = fetched.first();
            resolve(fetched);
          }
        };
        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
          this.client.decrementMaxListeners();
          reject(new Error2("GUILD_MEMBERS_TIMEOUT"));
        }, time);
        this.client.incrementMaxListeners();
        this.client.on(Events2.GUILD_MEMBERS_CHUNK, handler);
      });
    }
  };
  module2.exports = GuildMemberManager;
});

// node_modules/discord.js/src/util/ActivityFlags.js
var require_ActivityFlags = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var ActivityFlags = class extends BitField {
  };
  ActivityFlags.FLAGS = {
    INSTANCE: 1 << 0,
    JOIN: 1 << 1,
    SPECTATE: 1 << 2,
    JOIN_REQUEST: 1 << 3,
    SYNC: 1 << 4,
    PLAY: 1 << 5
  };
  module2.exports = ActivityFlags;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports2) => {
  "use strict";
  var Emoji = require_Emoji();
  var ActivityFlags = require_ActivityFlags();
  var {ActivityTypes} = require_Constants();
  var Util = require_Util();
  var Presence = class {
    constructor(client, data = {}) {
      Object.defineProperty(this, "client", {value: client});
      this.userID = data.user.id;
      this.guild = data.guild || null;
      this.patch(data);
    }
    get user() {
      return this.client.users.cache.get(this.userID) || null;
    }
    get member() {
      return this.guild.members.cache.get(this.userID) || null;
    }
    patch(data) {
      this.status = data.status || this.status || "offline";
      if (data.activities) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else if (data.activity || data.game) {
        this.activities = [new Activity(this, data.game || data.activity)];
      } else {
        this.activities = [];
      }
      this.clientStatus = data.client_status || null;
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      if (this.activities)
        clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && this.clientStatus.web === presence.clientStatus.web && this.clientStatus.mobile === presence.clientStatus.mobile && this.clientStatus.desktop === presence.clientStatus.desktop;
    }
    toJSON() {
      return Util.flatten(this);
    }
  };
  var Activity = class {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", {value: presence});
      this.name = data.name;
      this.type = ActivityTypes[data.type];
      this.url = data.url || null;
      this.details = data.details || null;
      this.state = data.state || null;
      this.applicationID = data.application_id || null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party || null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.syncID = data.sync_id;
      this.flags = new ActivityFlags(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.createdTimestamp = new Date(data.created_at).getTime();
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  };
  var RichPresenceAssets = class {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", {value: activity});
      this.largeText = assets.large_text || null;
      this.smallText = assets.small_text || null;
      this.largeImage = assets.large_image || null;
      this.smallImage = assets.small_image || null;
    }
    smallImageURL({format, size} = {}) {
      if (!this.smallImage)
        return null;
      return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.smallImage, {
        format,
        size
      });
    }
    largeImageURL({format, size} = {}) {
      if (!this.largeImage)
        return null;
      if (/^spotify:/.test(this.largeImage)) {
        return `https://i.scdn.co/image/${this.largeImage.slice(8)}`;
      } else if (/^twitch:/.test(this.largeImage)) {
        return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${this.largeImage.slice(7)}.png`;
      }
      return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationID, this.largeImage, {
        format,
        size
      });
    }
  };
  exports2.Presence = Presence;
  exports2.Activity = Activity;
  exports2.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var {Presence} = require_Presence();
  var PresenceManager = class extends BaseManager {
    constructor(client, iterable) {
      super(client, iterable, Presence);
    }
    add(data, cache) {
      const existing = this.cache.get(data.user.id);
      return existing ? existing.patch(data) : super.add(data, cache, {id: data.user.id});
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const UserResolvable = this.client.users.resolveID(presence);
      return super.resolve(UserResolvable) || null;
    }
    resolveID(presence) {
      const presenceResolvable = super.resolveID(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userResolvable = this.client.users.resolveID(presence);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
  };
  module2.exports = PresenceManager;
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var Role = require_Role();
  var Permissions2 = require_Permissions();
  var {resolveColor} = require_Util();
  var RoleManager = class extends BaseManager {
    constructor(guild, iterable) {
      super(guild.client, iterable, Role);
      this.guild = guild;
    }
    add(data, cache) {
      return super.add(data, cache, {extras: [this.guild]});
    }
    async fetch(id, cache = true, force = false) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      const roles = await this.client.api.guilds(this.guild.id).roles.get();
      for (const role of roles)
        this.add(role, cache);
      return id ? this.cache.get(id) || null : this;
    }
    create({data = {}, reason} = {}) {
      if (data.color)
        data.color = resolveColor(data.color);
      if (data.permissions)
        data.permissions = Permissions2.resolve(data.permissions);
      return this.guild.client.api.guilds(this.guild.id).roles.post({data, reason}).then((r) => {
        const {role} = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: r
        });
        if (data.position)
          return role.setPosition(data.position, reason);
        return role;
      });
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  };
  module2.exports = RoleManager;
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var VoiceStateManager = class extends BaseManager {
    constructor(guild, iterable) {
      super(guild.client, iterable, {name: "VoiceState"});
      this.guild = guild;
    }
    add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
  };
  module2.exports = VoiceStateManager;
});

// node_modules/discord.js/src/util/SystemChannelFlags.js
var require_SystemChannelFlags = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var SystemChannelFlags = class extends BitField {
  };
  SystemChannelFlags.FLAGS = {
    WELCOME_MESSAGE_DISABLED: 1 << 0,
    BOOST_MESSAGE_DISABLED: 1 << 1
  };
  module2.exports = SystemChannelFlags;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports2, module2) => {
  "use strict";
  var {deprecate} = require("util");
  var Base = require_Base();
  var GuildAuditLogs = require_GuildAuditLogs();
  var GuildPreview2 = require_GuildPreview();
  var GuildTemplate2 = require_GuildTemplate();
  var Integration = require_Integration();
  var Invite2 = require_Invite();
  var VoiceRegion2 = require_VoiceRegion();
  var Webhook2 = require_Webhook();
  var {Error: Error2, TypeError: TypeError2} = require_errors();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager2 = require_GuildEmojiManager();
  var GuildMemberManager = require_GuildMemberManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var VoiceStateManager = require_VoiceStateManager();
  var Collection2 = require_Collection();
  var {
    browser: browser2,
    ChannelTypes,
    DefaultMessageNotifications,
    PartialTypes,
    VerificationLevels,
    ExplicitContentFilterLevels
  } = require_Constants();
  var DataResolver2 = require_DataResolver();
  var Snowflake = require_Snowflake();
  var SystemChannelFlags = require_SystemChannelFlags();
  var Util = require_Util();
  var Guild = class extends Base {
    constructor(client, data) {
      super(client);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.deleted = false;
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
        this.id = data.id;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardID = data.shardID;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardID);
    }
    _patch(data) {
      this.name = data.name;
      this.icon = data.icon;
      this.splash = data.splash;
      this.discoverySplash = data.discovery_splash;
      this.region = data.region;
      this.memberCount = data.member_count || this.memberCount;
      this.large = Boolean("large" in data ? data.large : this.large);
      this.features = data.features;
      this.applicationID = data.application_id;
      this.afkTimeout = data.afk_timeout;
      this.afkChannelID = data.afk_channel_id;
      this.systemChannelID = data.system_channel_id;
      this.embedEnabled = data.embed_enabled;
      this.premiumTier = data.premium_tier;
      if (typeof data.premium_subscription_count !== "undefined") {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      }
      if (typeof data.widget_enabled !== "undefined") {
        this.widgetEnabled = data.widget_enabled;
      }
      if (typeof data.widget_channel_id !== "undefined") {
        this.widgetChannelID = data.widget_channel_id;
      }
      if (typeof data.embed_channel_id !== "undefined") {
        this.embedChannelID = data.embed_channel_id;
      }
      this.verificationLevel = VerificationLevels[data.verification_level];
      this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];
      this.mfaLevel = data.mfa_level;
      this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;
      this.defaultMessageNotifications = DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;
      this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();
      if (typeof data.max_members !== "undefined") {
        this.maximumMembers = data.max_members;
      } else if (typeof this.maximumMembers === "undefined") {
        this.maximumMembers = null;
      }
      if (typeof data.max_presences !== "undefined") {
        this.maximumPresences = data.max_presences || 25e3;
      } else if (typeof this.maximumPresences === "undefined") {
        this.maximumPresences = null;
      }
      if (typeof data.approximate_member_count !== "undefined") {
        this.approximateMemberCount = data.approximate_member_count;
      } else if (typeof this.approximateMemberCount === "undefined") {
        this.approximateMemberCount = null;
      }
      if (typeof data.approximate_presence_count !== "undefined") {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else if (typeof this.approximatePresenceCount === "undefined") {
        this.approximatePresenceCount = null;
      }
      this.vanityURLCode = data.vanity_url_code;
      this.vanityURLUses = null;
      this.description = data.description;
      this.banner = data.banner;
      this.id = data.id;
      this.available = !data.unavailable;
      this.features = data.features || this.features || [];
      this.rulesChannelID = data.rules_channel_id;
      this.publicUpdatesChannelID = data.public_updates_channel_id;
      this.preferredLocale = data.preferred_locale;
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels.add(rawChannel, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles.add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members.add(guildUser);
      }
      if (data.owner_id) {
        this.ownerID = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences.add(Object.assign(presence, {guild: this}));
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates.add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager2(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis.add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
    }
    bannerURL({format, size} = {}) {
      if (!this.banner)
        return null;
      return this.client.rest.cdn.Banner(this.id, this.banner, format, size);
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    get partnered() {
      return this.features.includes("PARTNERED");
    }
    get verified() {
      return this.features.includes("VERIFIED");
    }
    iconURL({format, size, dynamic} = {}) {
      if (!this.icon)
        return null;
      return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    splashURL({format, size} = {}) {
      if (!this.splash)
        return null;
      return this.client.rest.cdn.Splash(this.id, this.splash, format, size);
    }
    discoverySplashURL({format, size} = {}) {
      if (!this.discoverySplash)
        return null;
      return this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
    }
    get owner() {
      return this.members.cache.get(this.ownerID) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({user: {id: this.ownerID}}, true) : null);
    }
    get afkChannel() {
      return this.client.channels.cache.get(this.afkChannelID) || null;
    }
    get systemChannel() {
      return this.client.channels.cache.get(this.systemChannelID) || null;
    }
    get widgetChannel() {
      return this.client.channels.cache.get(this.widgetChannelID) || null;
    }
    get embedChannel() {
      return this.client.channels.cache.get(this.embedChannelID) || null;
    }
    get rulesChannel() {
      return this.client.channels.cache.get(this.rulesChannelID) || null;
    }
    get publicUpdatesChannel() {
      return this.client.channels.cache.get(this.publicUpdatesChannelID) || null;
    }
    get me() {
      return this.members.cache.get(this.client.user.id) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({user: {id: this.client.user.id}}, true) : null);
    }
    get voice() {
      return this.voiceStates.cache.get(this.client.user.id);
    }
    member(user) {
      return this.members.resolve(user);
    }
    fetch() {
      return this.client.api.guilds(this.id).get({query: {with_counts: true}}).then((data) => {
        this._patch(data);
        return this;
      });
    }
    fetchBan(user) {
      const id = this.client.users.resolveID(user);
      if (!id)
        throw new Error2("FETCH_BAN_RESOLVE_ID");
      return this.client.api.guilds(this.id).bans(id).get().then((ban) => ({
        reason: ban.reason,
        user: this.client.users.add(ban.user)
      }));
    }
    fetchBans() {
      return this.client.api.guilds(this.id).bans.get().then((bans) => bans.reduce((collection, ban) => {
        collection.set(ban.user.id, {
          reason: ban.reason,
          user: this.client.users.add(ban.user)
        });
        return collection;
      }, new Collection2()));
    }
    fetchIntegrations({includeApplications = false} = {}) {
      return this.client.api.guilds(this.id).integrations.get({
        query: {
          include_applications: includeApplications
        }
      }).then((data) => data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection2()));
    }
    fetchTemplates() {
      return this.client.api.guilds(this.id).templates.get().then((templates) => templates.reduce((col, data) => col.set(data.code, new GuildTemplate2(this.client, data)), new Collection2()));
    }
    createIntegration(data, reason) {
      return this.client.api.guilds(this.id).integrations.post({data, reason}).then(() => this);
    }
    createTemplate(name, description) {
      return this.client.api.guilds(this.id).templates.post({data: {name, description}}).then((data) => new GuildTemplate2(this.client, data));
    }
    fetchInvites() {
      return this.client.api.guilds(this.id).invites.get().then((inviteItems) => {
        const invites = new Collection2();
        for (const inviteItem of inviteItems) {
          const invite = new Invite2(this.client, inviteItem);
          invites.set(invite.code, invite);
        }
        return invites;
      });
    }
    fetchPreview() {
      return this.client.api.guilds(this.id).preview.get().then((data) => new GuildPreview2(this.client, data));
    }
    fetchVanityCode() {
      return this.fetchVanityData().then((vanity) => vanity.code);
    }
    async fetchVanityData() {
      if (!this.features.includes("VANITY_URL")) {
        throw new Error2("VANITY_URL");
      }
      const data = await this.client.api.guilds(this.id, "vanity-url").get();
      this.vanityURLUses = data.uses;
      return data;
    }
    fetchWebhooks() {
      return this.client.api.guilds(this.id).webhooks.get().then((data) => {
        const hooks = new Collection2();
        for (const hook of data)
          hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      });
    }
    fetchVoiceRegions() {
      return this.client.api.guilds(this.id).regions.get().then((res) => {
        const regions = new Collection2();
        for (const region of res)
          regions.set(region.id, new VoiceRegion2(region));
        return regions;
      });
    }
    fetchEmbed() {
      return this.fetchWidget();
    }
    async fetchWidget() {
      const data = await this.client.api.guilds(this.id).widget.get();
      this.widgetEnabled = this.embedEnabled = data.enabled;
      this.widgetChannelID = this.embedChannelID = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    fetchAuditLogs(options = {}) {
      if (options.before && options.before instanceof GuildAuditLogs.Entry)
        options.before = options.before.id;
      if (typeof options.type === "string")
        options.type = GuildAuditLogs.Actions[options.type];
      return this.client.api.guilds(this.id)["audit-logs"].get({
        query: {
          before: options.before,
          limit: options.limit,
          user_id: this.client.users.resolveID(options.user),
          action_type: options.type
        }
      }).then((data) => GuildAuditLogs.build(this, data));
    }
    async addMember(user, options) {
      user = this.client.users.resolveID(user);
      if (!user)
        throw new TypeError2("INVALID_TYPE", "user", "UserResolvable");
      if (this.members.cache.has(user))
        return this.members.cache.get(user);
      options.access_token = options.accessToken;
      if (options.roles) {
        const roles = [];
        for (let role of options.roles instanceof Collection2 ? options.roles.values() : options.roles) {
          role = this.roles.resolve(role);
          if (!role) {
            throw new TypeError2("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", true);
          }
          roles.push(role.id);
        }
        options.roles = roles;
      }
      const data = await this.client.api.guilds(this.id).members(user).put({data: options});
      return data instanceof (browser2 ? ArrayBuffer : Buffer) ? this.members.fetch(user) : this.members.add(data);
    }
    edit(data, reason) {
      const _data = {};
      if (data.name)
        _data.name = data.name;
      if (data.region)
        _data.region = data.region;
      if (typeof data.verificationLevel !== "undefined") {
        _data.verification_level = typeof data.verificationLevel === "number" ? Number(data.verificationLevel) : VerificationLevels.indexOf(data.verificationLevel);
      }
      if (typeof data.afkChannel !== "undefined") {
        _data.afk_channel_id = this.client.channels.resolveID(data.afkChannel);
      }
      if (typeof data.systemChannel !== "undefined") {
        _data.system_channel_id = this.client.channels.resolveID(data.systemChannel);
      }
      if (data.afkTimeout)
        _data.afk_timeout = Number(data.afkTimeout);
      if (typeof data.icon !== "undefined")
        _data.icon = data.icon;
      if (data.owner)
        _data.owner_id = this.client.users.resolveID(data.owner);
      if (data.splash)
        _data.splash = data.splash;
      if (data.discoverySplash)
        _data.discovery_splash = data.discoverySplash;
      if (data.banner)
        _data.banner = data.banner;
      if (typeof data.explicitContentFilter !== "undefined") {
        _data.explicit_content_filter = typeof data.explicitContentFilter === "number" ? data.explicitContentFilter : ExplicitContentFilterLevels.indexOf(data.explicitContentFilter);
      }
      if (typeof data.defaultMessageNotifications !== "undefined") {
        _data.default_message_notifications = typeof data.defaultMessageNotifications === "string" ? DefaultMessageNotifications.indexOf(data.defaultMessageNotifications) : data.defaultMessageNotifications;
      }
      if (typeof data.systemChannelFlags !== "undefined") {
        _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);
      }
      if (typeof data.rulesChannel !== "undefined") {
        _data.rules_channel_id = this.client.channels.resolveID(data.rulesChannel);
      }
      if (typeof data.publicUpdatesChannel !== "undefined") {
        _data.public_updates_channel_id = this.client.channels.resolveID(data.publicUpdatesChannel);
      }
      if (data.preferredLocale)
        _data.preferred_locale = data.preferredLocale;
      return this.client.api.guilds(this.id).patch({data: _data, reason}).then((newData) => this.client.actions.GuildUpdate.handle(newData).updated);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({explicitContentFilter}, reason);
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({defaultMessageNotifications}, reason);
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({systemChannelFlags}, reason);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setRegion(region, reason) {
      return this.edit({region}, reason);
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({verificationLevel}, reason);
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({afkChannel}, reason);
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({systemChannel}, reason);
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({afkTimeout}, reason);
    }
    async setIcon(icon, reason) {
      return this.edit({icon: await DataResolver2.resolveImage(icon), reason});
    }
    setOwner(owner, reason) {
      return this.edit({owner}, reason);
    }
    async setSplash(splash, reason) {
      return this.edit({splash: await DataResolver2.resolveImage(splash), reason});
    }
    async setDiscoverySplash(discoverySplash, reason) {
      return this.edit({discoverySplash: await DataResolver2.resolveImage(discoverySplash), reason});
    }
    async setBanner(banner, reason) {
      return this.edit({banner: await DataResolver2.resolveImage(banner), reason});
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({rulesChannel}, reason);
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({publicUpdatesChannel}, reason);
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({preferredLocale}, reason);
    }
    setChannelPositions(channelPositions) {
      const updatedChannels = channelPositions.map((r) => ({
        id: this.client.channels.resolveID(r.channel),
        position: r.position
      }));
      return this.client.api.guilds(this.id).channels.patch({data: updatedChannels}).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.id,
        channels: updatedChannels
      }).guild);
    }
    setRolePositions(rolePositions) {
      rolePositions = rolePositions.map((o) => ({
        id: this.roles.resolveID(o.role),
        position: o.position
      }));
      return this.client.api.guilds(this.id).roles.patch({
        data: rolePositions
      }).then(() => this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.id,
        roles: rolePositions
      }).guild);
    }
    setEmbed(embed, reason) {
      return this.setWidget(embed, reason);
    }
    setWidget(widget, reason) {
      return this.client.api.guilds(this.id).widget.patch({
        data: {
          enabled: widget.enabled,
          channel_id: this.channels.resolveID(widget.channel)
        },
        reason
      }).then(() => this);
    }
    leave() {
      if (this.ownerID === this.client.user.id)
        return Promise.reject(new Error2("GUILD_OWNED"));
      return this.client.api.users("@me").guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({id: this.id}).guild);
    }
    delete() {
      return this.client.api.guilds(this.id).delete().then(() => this.client.actions.GuildDelete.handle({id: this.id}).guild);
    }
    equals(guild) {
      let equal = guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.region === guild.region && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerID === guild.ownerID && this.verificationLevel === guild.verificationLevel && this.embedEnabled === guild.embedEnabled && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
      if (equal) {
        if (this.embedChannel) {
          if (!guild.embedChannel || this.embedChannel.id !== guild.embedChannel.id)
            equal = false;
        } else if (guild.embedChannel) {
          equal = false;
        }
      }
      return equal;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    _sortedRoles() {
      return Util.discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const category = channel.type === ChannelTypes.CATEGORY;
      return Util.discordSort(this.channels.cache.filter((c) => (["text", "news", "store"].includes(channel.type) ? ["text", "news", "store"].includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent)));
    }
  };
  Guild.prototype.setEmbed = deprecate(Guild.prototype.setEmbed, "Guild#setEmbed: Use setWidget instead");
  Guild.prototype.fetchEmbed = deprecate(Guild.prototype.fetchEmbed, "Guild#fetchEmbed: Use fetchWidget instead");
  Guild.prototype.fetchVanityCode = deprecate(Guild.prototype.fetchVanityCode, "Guild#fetchVanityCode: Use fetchVanityData() instead");
  module2.exports = Guild;
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports2, module2) => {
  "use strict";
  var {Presence} = require_Presence();
  var {TypeError: TypeError2} = require_errors();
  var Collection2 = require_Collection();
  var {ActivityTypes, OPCodes} = require_Constants();
  var ClientPresence = class extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, {status: "online", user: {id: null}}));
    }
    async set(presence) {
      const packet = await this._parse(presence);
      this.patch(packet);
      if (typeof presence.shardID === "undefined") {
        this.client.ws.broadcast({op: OPCodes.STATUS_UPDATE, d: packet});
      } else if (Array.isArray(presence.shardID)) {
        for (const shardID of presence.shardID) {
          this.client.ws.shards.get(shardID).send({op: OPCodes.STATUS_UPDATE, d: packet});
        }
      } else {
        this.client.ws.shards.get(presence.shardID).send({op: OPCodes.STATUS_UPDATE, d: packet});
      }
      return this;
    }
    async _parse({status, since, afk, activity}) {
      const applicationID = activity && (activity.application ? activity.application.id || activity.application : null);
      let assets = new Collection2();
      if (activity) {
        if (typeof activity.name !== "string")
          throw new TypeError2("INVALID_TYPE", "name", "string");
        if (!activity.type)
          activity.type = 0;
        if (activity.assets && applicationID) {
          try {
            const a = await this.client.api.oauth2.applications(applicationID).assets.get();
            for (const asset of a)
              assets.set(asset.name, asset.id);
          } catch {
          }
        }
      }
      const packet = {
        afk: afk != null ? afk : false,
        since: since != null ? since : null,
        status: status || this.status,
        game: activity ? {
          type: activity.type,
          name: activity.name,
          url: activity.url,
          details: activity.details || void 0,
          state: activity.state || void 0,
          assets: activity.assets ? {
            large_text: activity.assets.largeText || void 0,
            small_text: activity.assets.smallText || void 0,
            large_image: assets.get(activity.assets.largeImage) || activity.assets.largeImage,
            small_image: assets.get(activity.assets.smallImage) || activity.assets.smallImage
          } : void 0,
          timestamps: activity.timestamps || void 0,
          party: activity.party || void 0,
          application_id: applicationID || void 0,
          secrets: activity.secrets || void 0,
          instance: activity.instance || void 0
        } : null
      };
      if ((status || afk || since) && !activity) {
        packet.game = this.activities[0] || null;
      }
      if (packet.game) {
        packet.game.type = typeof packet.game.type === "number" ? packet.game.type : ActivityTypes.indexOf(packet.game.type);
      }
      return packet;
    }
  };
  module2.exports = ClientPresence;
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {Error: Error2, TypeError: TypeError2} = require_errors();
  var {browser: browser2} = require_Constants();
  var VoiceState = class extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      this.serverDeaf = "deaf" in data ? data.deaf : null;
      this.serverMute = "mute" in data ? data.mute : null;
      this.selfDeaf = "self_deaf" in data ? data.self_deaf : null;
      this.selfMute = "self_mute" in data ? data.self_mute : null;
      this.selfVideo = "self_video" in data ? data.self_video : null;
      this.sessionID = "session_id" in data ? data.session_id : null;
      this.streaming = data.self_stream || false;
      this.channelID = data.channel_id || null;
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) || null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelID) || null;
    }
    get connection() {
      if (browser2 || this.id !== this.client.user.id)
        return null;
      return this.client.voice.connections.get(this.guild.id) || null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    get speaking() {
      return this.channel && this.channel.connection ? Boolean(this.channel.connection._speaking.get(this.id)) : null;
    }
    setMute(mute, reason) {
      return this.member ? this.member.edit({mute}, reason) : Promise.reject(new Error2("VOICE_STATE_UNCACHED_MEMBER"));
    }
    setDeaf(deaf, reason) {
      return this.member ? this.member.edit({deaf}, reason) : Promise.reject(new Error2("VOICE_STATE_UNCACHED_MEMBER"));
    }
    kick(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.member ? this.member.edit({channel}, reason) : Promise.reject(new Error2("VOICE_STATE_UNCACHED_MEMBER"));
    }
    async setSelfMute(mute) {
      if (this.id !== this.client.user.id)
        throw new Error2("VOICE_STATE_NOT_OWN");
      if (typeof mute !== "boolean")
        throw new TypeError2("VOICE_STATE_INVALID_TYPE", "mute");
      if (!this.connection)
        return false;
      this.selfMute = mute;
      await this.connection.sendVoiceStateUpdate();
      return true;
    }
    async setSelfDeaf(deaf) {
      if (this.id !== this.client.user.id)
        return new Error2("VOICE_STATE_NOT_OWN");
      if (typeof deaf !== "boolean")
        return new TypeError2("VOICE_STATE_INVALID_TYPE", "deaf");
      if (!this.connection)
        return false;
      this.selfDeaf = deaf;
      await this.connection.sendVoiceStateUpdate();
      return true;
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionID: true,
        channelID: "channel"
      });
    }
  };
  module2.exports = VoiceState;
});

// node_modules/discord.js/src/util/Structures.js
var require_Structures = __commonJS((exports2, module2) => {
  "use strict";
  var Structures2 = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static get(structure) {
      if (typeof structure === "string")
        return structures[structure];
      throw new TypeError(`"structure" argument must be a string (received ${typeof structure})`);
    }
    static extend(structure, extender) {
      if (!structures[structure])
        throw new RangeError(`"${structure}" is not a valid extensible structure.`);
      if (typeof extender !== "function") {
        const received = `(received ${typeof extender})`;
        throw new TypeError(`"extender" argument must be a function that returns the extended structure class/prototype ${received}.`);
      }
      const extended = extender(structures[structure]);
      if (typeof extended !== "function") {
        const received = `(received ${typeof extended})`;
        throw new TypeError(`The extender function must return the extended structure class/prototype ${received}.`);
      }
      if (!(extended.prototype instanceof structures[structure])) {
        const prototype = Object.getPrototypeOf(extended);
        const received = `${extended.name || "unnamed"}${prototype.name ? ` extends ${prototype.name}` : ""}`;
        throw new Error(`The class/prototype returned from the extender function must extend the existing structure class/prototype (received function ${received}; expected extension of ${structures[structure].name}).`);
      }
      structures[structure] = extended;
      return extended;
    }
  };
  var structures = {
    GuildEmoji: require_GuildEmoji(),
    DMChannel: require_DMChannel(),
    TextChannel: require_TextChannel(),
    VoiceChannel: require_VoiceChannel(),
    CategoryChannel: require_CategoryChannel(),
    NewsChannel: require_NewsChannel(),
    StoreChannel: require_StoreChannel(),
    GuildMember: require_GuildMember(),
    Guild: require_Guild(),
    Message: require_Message(),
    MessageReaction: require_MessageReaction(),
    Presence: require_Presence().Presence,
    ClientPresence: require_ClientPresence(),
    VoiceState: require_VoiceState(),
    Role: require_Role(),
    User: require_User()
  };
  module2.exports = Structures2;
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports2, module2) => {
  "use strict";
  var Channel = require_Channel();
  var {Error: Error2} = require_errors();
  var PartialGroupDMChannel = class extends Channel {
    constructor(client, data) {
      super(client, data);
      this.name = data.name;
      this.icon = data.icon;
    }
    iconURL({format, size} = {}) {
      if (!this.icon)
        return null;
      return this.client.rest.cdn.GDMIcon(this.id, this.icon, format, size);
    }
    delete() {
      return Promise.reject(new Error2("DELETE_GROUP_DM_CHANNEL"));
    }
    fetch() {
      return Promise.reject(new Error2("FETCH_GROUP_DM_CHANNEL"));
    }
  };
  module2.exports = PartialGroupDMChannel;
});

// node_modules/discord.js/src/structures/Channel.js
var require_Channel = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_Base();
  var {ChannelTypes} = require_Constants();
  var Snowflake = require_Snowflake();
  var Channel = class extends Base {
    constructor(client, data) {
      super(client);
      const type = Object.keys(ChannelTypes)[data.type];
      this.type = type ? type.toLowerCase() : "unknown";
      this.deleted = false;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return `<#${this.id}>`;
    }
    delete() {
      return this.client.api.channels(this.id).delete().then(() => this);
    }
    fetch(force = false) {
      return this.client.channels.fetch(this.id, true, force);
    }
    isText() {
      return "messages" in this;
    }
    static create(client, data, guild) {
      const Structures2 = require_Structures();
      let channel;
      if (!data.guild_id && !guild) {
        if (data.recipients && data.type !== ChannelTypes.GROUP || data.type === ChannelTypes.DM) {
          const DMChannel = Structures2.get("DMChannel");
          channel = new DMChannel(client, data);
        } else if (data.type === ChannelTypes.GROUP) {
          const PartialGroupDMChannel = require_PartialGroupDMChannel();
          channel = new PartialGroupDMChannel(client, data);
        }
      } else {
        guild = guild || client.guilds.cache.get(data.guild_id);
        if (guild) {
          switch (data.type) {
            case ChannelTypes.TEXT: {
              const TextChannel = Structures2.get("TextChannel");
              channel = new TextChannel(guild, data);
              break;
            }
            case ChannelTypes.VOICE: {
              const VoiceChannel = Structures2.get("VoiceChannel");
              channel = new VoiceChannel(guild, data);
              break;
            }
            case ChannelTypes.CATEGORY: {
              const CategoryChannel = Structures2.get("CategoryChannel");
              channel = new CategoryChannel(guild, data);
              break;
            }
            case ChannelTypes.NEWS: {
              const NewsChannel = Structures2.get("NewsChannel");
              channel = new NewsChannel(guild, data);
              break;
            }
            case ChannelTypes.STORE: {
              const StoreChannel = Structures2.get("StoreChannel");
              channel = new StoreChannel(guild, data);
              break;
            }
          }
          if (channel)
            guild.channels.cache.set(channel.id, channel);
        }
      }
      return channel;
    }
    toJSON(...props) {
      return super.toJSON({createdTimestamp: true}, ...props);
    }
  };
  module2.exports = Channel;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports2, module2) => {
  "use strict";
  var Channel = require_Channel();
  var TextBasedChannel = require_TextBasedChannel();
  var MessageManager = require_MessageManager();
  var DMChannel = class extends Channel {
    constructor(client, data) {
      super(client, data);
      this.type = "dm";
      this.messages = new MessageManager(this);
      this._typing = new Map();
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        this.recipient = this.client.users.add(data.recipients[0]);
      }
      this.lastMessageID = data.last_message_id;
      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
    }
    get partial() {
      return typeof this.lastMessageID === "undefined";
    }
    fetch(force = false) {
      return this.recipient.createDM(force);
    }
    toString() {
      return this.recipient.toString();
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    startTyping() {
    }
    stopTyping() {
    }
    get typing() {
    }
    get typingCount() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
  };
  TextBasedChannel.applyToClass(DMChannel, true, ["bulkDelete"]);
  module2.exports = DMChannel;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var DMChannel = require_DMChannel();
  var {Events: Events2} = require_Constants();
  var ChannelDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels.remove(channel.id);
        channel.deleted = true;
        if (channel.messages && !(channel instanceof DMChannel)) {
          for (const message of channel.messages.cache.values()) {
            message.deleted = true;
          }
        }
        client.emit(Events2.CHANNEL_DELETE, channel);
      }
      return {channel};
    }
  };
  module2.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var Channel = require_Channel();
  var {ChannelTypes} = require_Constants();
  var ChannelUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (ChannelTypes[channel.type.toUpperCase()] !== data.type) {
          const newChannel = Channel.create(this.client, data, channel.guild);
          for (const [id, message] of channel.messages.cache)
            newChannel.messages.cache.set(id, message);
          newChannel._typing = new Map(channel._typing);
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      }
      return {};
    }
  };
  module2.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        for (const channel of guild.channels.cache.values()) {
          if (channel.type === "text")
            channel.stopTyping(true);
        }
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events2.GUILD_UNAVAILABLE, guild);
          return {
            guild: null
          };
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels.remove(channel.id);
        if (guild.voice && guild.voice.connection)
          guild.voice.connection.disconnect();
        client.guilds.cache.delete(guild.id);
        guild.deleted = true;
        client.emit(Events2.GUILD_DELETE, guild);
        this.deleted.set(guild.id, guild);
        this.scheduleForDeletion(guild.id);
      } else {
        guild = this.deleted.get(data.id) || null;
      }
      return {guild};
    }
    scheduleForDeletion(id) {
      this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events2.GUILD_UPDATE, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var Invite2 = require_Invite();
  var {Events: Events2} = require_Constants();
  var InviteCreateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, {channel, guild});
      const invite = new Invite2(client, inviteData);
      client.emit(Events2.INVITE_CREATE, invite);
      return {invite};
    }
  };
  module2.exports = InviteCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var Invite2 = require_Invite();
  var {Events: Events2} = require_Constants();
  var InviteDeleteAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel && !guild)
        return false;
      const inviteData = Object.assign(data, {channel, guild});
      const invite = new Invite2(client, inviteData);
      client.emit(Events2.INVITE_DELETE, invite);
      return {invite};
    }
  };
  module2.exports = InviteDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2, Status: Status2} = require_Constants();
  var GuildMemberRemoveAction = class extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({user: data.user}, guild);
        guild.memberCount--;
        if (member) {
          member.deleted = true;
          guild.members.cache.delete(member.id);
          if (shard.status === Status2.READY)
            client.emit(Events2.GUILD_MEMBER_REMOVE, member);
        }
        guild.voiceStates.cache.delete(data.user.id);
      }
      return {guild, member};
    }
  };
  module2.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Status: Status2, Events: Events2} = require_Constants();
  var GuildMemberUpdateAction = class extends Action {
    handle(data, shard) {
      const {client} = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users.add(data.user);
        } else if (!user.equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({user: data.user}, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status2.READY)
            client.emit(Events2.GUILD_MEMBER_UPDATE, old, member);
        } else {
          const newMember = guild.members.add(data);
          this.client.emit(Events2.GUILD_MEMBER_AVAILABLE, newMember);
        }
      }
    }
  };
  module2.exports = GuildMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildBanRemove = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      const user = client.users.add(data.user);
      if (guild && user)
        client.emit(Events2.GUILD_BAN_REMOVE, guild, user);
    }
  };
  module2.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildRoleCreate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles.add(data.role);
        if (!already)
          client.emit(Events2.GUILD_ROLE_CREATE, role);
      }
      return {role};
    }
  };
  module2.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildRoleDeleteAction = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          role.deleted = true;
          client.emit(Events2.GUILD_ROLE_DELETE, role);
        }
      }
      return {role};
    }
  };
  module2.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildRoleUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events2.GUILD_ROLE_UPDATE, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var PresenceUpdateAction = class extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && data.user.username)
        user = this.client.users.add(data.user);
      if (!user)
        return;
      if (data.user && data.user.username) {
        if (!user.equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      let oldPresence = guild.presences.cache.get(user.id);
      if (oldPresence)
        oldPresence = oldPresence._clone();
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members.add({
          user,
          roles: data.roles,
          deaf: false,
          mute: false
        });
        this.client.emit(Events2.GUILD_MEMBER_AVAILABLE, member);
      }
      guild.presences.add(Object.assign(data, {guild}));
      if (member && this.client.listenerCount(Events2.PRESENCE_UPDATE)) {
        this.client.emit(Events2.PRESENCE_UPDATE, oldPresence, member.presence);
      }
    }
  };
  module2.exports = PresenceUpdateAction;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var UserUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const newUser = client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events2.USER_UPDATE, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var Structures2 = require_Structures();
  var VoiceStateUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const VoiceState = Structures2.get("VoiceState");
        const oldState = guild.voiceStates.cache.has(data.user_id) ? guild.voiceStates.cache.get(data.user_id)._clone() : new VoiceState(guild, {user_id: data.user_id});
        const newState = guild.voiceStates.add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member && data.member.user && data.member.joined_at) {
          member = guild.members.add(data.member);
        }
        if (member && member.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events2.VOICE_STATE_UPDATE, oldState, newState);
      }
    }
  };
  module2.exports = VoiceStateUpdate;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildEmojiCreateAction = class extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis.add(createdEmoji);
      if (!already)
        this.client.emit(Events2.GUILD_EMOJI_CREATE, emoji);
      return {emoji};
    }
  };
  module2.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildEmojiDeleteAction = class extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      emoji.deleted = true;
      this.client.emit(Events2.GUILD_EMOJI_DELETE, emoji);
      return {emoji};
    }
  };
  module2.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildEmojiUpdateAction = class extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events2.GUILD_EMOJI_UPDATE, old, current);
      return {emoji: current};
    }
  };
  module2.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var GuildEmojisUpdateAction = class extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild || !guild.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  };
  module2.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var GuildRolesPositionUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return {guild};
    }
  };
  module2.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var GuildChannelsPositionUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return {guild};
    }
  };
  module2.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var GuildIntegrationsUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events2.GUILD_INTEGRATIONS_UPDATE, guild);
    }
  };
  module2.exports = GuildIntegrationsUpdate;
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var WebhooksUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel)
        client.emit(Events2.WEBHOOKS_UPDATE, channel);
    }
  };
  module2.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports2, module2) => {
  "use strict";
  var Action = require_Action();
  var {Events: Events2} = require_Constants();
  var textBasedChannelTypes = ["dm", "text", "news"];
  var TypingStart = class extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel) {
        return;
      }
      if (!textBasedChannelTypes.includes(channel.type)) {
        this.client.emit(Events2.WARN, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      const timestamp = new Date(data.timestamp * 1e3);
      if (channel && user) {
        if (channel._typing.has(user.id)) {
          const typing = channel._typing.get(user.id);
          typing.lastTimestamp = timestamp;
          typing.elapsedTime = Date.now() - typing.since;
          this.client.clearTimeout(typing.timeout);
          typing.timeout = this.tooLate(channel, user);
        } else {
          const since = new Date();
          const lastTimestamp = new Date();
          channel._typing.set(user.id, {
            user,
            since,
            lastTimestamp,
            elapsedTime: Date.now() - since,
            timeout: this.tooLate(channel, user)
          });
          this.client.emit(Events2.TYPING_START, channel, user);
        }
      }
    }
    tooLate(channel, user) {
      return channel.client.setTimeout(() => {
        channel._typing.delete(user.id);
      }, 1e4);
    }
  };
  module2.exports = TypingStart;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports2, module2) => {
  "use strict";
  var ActionsManager2 = class {
    constructor(client) {
      this.client = client;
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessageUpdate());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildUpdate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildBanRemove());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_WebhooksUpdate());
      this.register(require_TypingStart());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  };
  module2.exports = ActionsManager2;
});

// node_modules/prism-media/src/util/loader.js
var require_loader = __commonJS((exports2) => {
  exports2.require = function loader(list) {
    const errorLog = [];
    for (const [name, fn] of list) {
      try {
        const data = fn(require(name));
        data.name = name;
        return data;
      } catch (e) {
        errorLog.push(e);
      }
    }
    throw new Error(errorLog.join("\n"));
  };
});

// node_modules/prism-media/src/opus/Opus.js
var require_Opus = __commonJS((exports2, module2) => {
  var {Transform} = require("stream");
  var loader = require_loader();
  var CTL = {
    BITRATE: 4002,
    FEC: 4012,
    PLP: 4014
  };
  var Opus = {};
  function loadOpus(refresh = false) {
    if (Opus.Encoder && !refresh)
      return Opus;
    Opus = loader.require([
      ["@discordjs/opus", (opus) => ({Encoder: opus.OpusEncoder})],
      ["node-opus", (opus) => ({Encoder: opus.OpusEncoder})],
      ["opusscript", (opus) => ({Encoder: opus})]
    ]);
    return Opus;
  }
  var charCode = (x) => x.charCodeAt(0);
  var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
  var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
  var OpusStream = class extends Transform {
    constructor(options = {}) {
      if (!loadOpus().Encoder) {
        throw Error("Could not find an Opus module! Please install @discordjs/opus, node-opus, or opusscript.");
      }
      super(Object.assign({readableObjectMode: true}, options));
      if (Opus.name === "opusscript") {
        options.application = Opus.Encoder.Application[options.application];
      }
      this.encoder = new Opus.Encoder(options.rate, options.channels, options.application);
      this._options = options;
      this._required = this._options.frameSize * this._options.channels * 2;
    }
    _encode(buffer) {
      return this.encoder.encode(buffer, this._options.frameSize);
    }
    _decode(buffer) {
      return this.encoder.decode(buffer, Opus.name === "opusscript" ? null : this._options.frameSize);
    }
    static get type() {
      return Opus.name;
    }
    setBitrate(bitrate) {
      (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.BITRATE, Math.min(128e3, Math.max(16e3, bitrate))]);
    }
    setFEC(enabled) {
      (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.FEC, enabled ? 1 : 0]);
    }
    setPLP(percentage) {
      (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.PLP, Math.min(100, Math.max(0, percentage * 100))]);
    }
    _final(cb) {
      this._cleanup();
      cb();
    }
    _destroy(err, cb) {
      this._cleanup();
      return cb ? cb(err) : void 0;
    }
    _cleanup() {
      if (Opus.name === "opusscript" && this.encoder)
        this.encoder.delete();
      this.encoder = null;
    }
  };
  var Encoder = class extends OpusStream {
    constructor(options) {
      super(options);
      this._buffer = Buffer.alloc(0);
    }
    async _transform(chunk, encoding, done) {
      this._buffer = Buffer.concat([this._buffer, chunk]);
      let n = 0;
      while (this._buffer.length >= this._required * (n + 1)) {
        const buf = await this._encode(this._buffer.slice(n * this._required, (n + 1) * this._required));
        this.push(buf);
        n++;
      }
      if (n > 0)
        this._buffer = this._buffer.slice(n * this._required);
      return done();
    }
    _destroy(err, cb) {
      super._destroy(err, cb);
      this._buffer = null;
    }
  };
  var Decoder = class extends OpusStream {
    _transform(chunk, encoding, done) {
      const signature = chunk.slice(0, 8);
      if (signature.equals(OPUS_HEAD)) {
        this.emit("format", {
          channels: this._options.channels,
          sampleRate: this._options.rate,
          bitDepth: 16,
          float: false,
          signed: true,
          version: chunk.readUInt8(8),
          preSkip: chunk.readUInt16LE(10),
          gain: chunk.readUInt16LE(16)
        });
        return done();
      }
      if (signature.equals(OPUS_TAGS)) {
        this.emit("tags", chunk);
        return done();
      }
      try {
        this.push(this._decode(chunk));
      } catch (e) {
        return done(e);
      }
      return done();
    }
  };
  module2.exports = {Decoder, Encoder};
});

// node_modules/prism-media/src/opus/OggDemuxer.js
var require_OggDemuxer = __commonJS((exports2, module2) => {
  var {Transform} = require("stream");
  var OGG_PAGE_HEADER_SIZE = 26;
  var STREAM_STRUCTURE_VERSION = 0;
  var charCode = (x) => x.charCodeAt(0);
  var OGGS_HEADER = Buffer.from([..."OggS"].map(charCode));
  var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
  var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
  var OggDemuxer = class extends Transform {
    constructor(options = {}) {
      super(Object.assign({readableObjectMode: true}, options));
      this._remainder = null;
      this._head = null;
      this._bitstream = null;
    }
    _transform(chunk, encoding, done) {
      if (this._remainder) {
        chunk = Buffer.concat([this._remainder, chunk]);
        this._remainder = null;
      }
      while (chunk) {
        const result = this._readPage(chunk);
        if (result)
          chunk = result;
        else
          break;
      }
      this._remainder = chunk;
      done();
    }
    _readPage(chunk) {
      if (chunk.length < OGG_PAGE_HEADER_SIZE) {
        return false;
      }
      if (!chunk.slice(0, 4).equals(OGGS_HEADER)) {
        throw Error(`capture_pattern is not ${OGGS_HEADER}`);
      }
      if (chunk.readUInt8(4) !== STREAM_STRUCTURE_VERSION) {
        throw Error(`stream_structure_version is not ${STREAM_STRUCTURE_VERSION}`);
      }
      if (chunk.length < 27)
        return false;
      const pageSegments = chunk.readUInt8(26);
      if (chunk.length < 27 + pageSegments)
        return false;
      const table = chunk.slice(27, 27 + pageSegments);
      const bitstream = chunk.readUInt32BE(14);
      let sizes = [], totalSize = 0;
      for (let i = 0; i < pageSegments; ) {
        let size = 0, x = 255;
        while (x === 255) {
          if (i >= table.length)
            return false;
          x = table.readUInt8(i);
          i++;
          size += x;
        }
        sizes.push(size);
        totalSize += size;
      }
      if (chunk.length < 27 + pageSegments + totalSize)
        return false;
      let start = 27 + pageSegments;
      for (const size of sizes) {
        const segment = chunk.slice(start, start + size);
        const header = segment.slice(0, 8);
        if (this._head) {
          if (header.equals(OPUS_TAGS))
            this.emit("tags", segment);
          else if (this._bitstream === bitstream)
            this.push(segment);
        } else if (header.equals(OPUS_HEAD)) {
          this.emit("head", segment);
          this._head = segment;
          this._bitstream = bitstream;
        } else {
          this.emit("unknownSegment", segment);
        }
        start += size;
      }
      return chunk.slice(start);
    }
    _destroy(err, cb) {
      this._cleanup();
      return cb ? cb(err) : void 0;
    }
    _final(cb) {
      this._cleanup();
      cb();
    }
    _cleanup() {
      this._remainder = null;
      this._head = null;
      this._bitstream = null;
    }
  };
  module2.exports = OggDemuxer;
});

// node_modules/prism-media/src/core/WebmBase.js
var require_WebmBase = __commonJS((exports2, module2) => {
  var {Transform} = require("stream");
  var WebmBaseDemuxer = class extends Transform {
    constructor(options = {}) {
      super(Object.assign({readableObjectMode: true}, options));
      this._remainder = null;
      this._length = 0;
      this._count = 0;
      this._skipUntil = null;
      this._track = null;
      this._incompleteTrack = {};
      this._ebmlFound = false;
    }
    _transform(chunk, encoding, done) {
      this._length += chunk.length;
      if (this._remainder) {
        chunk = Buffer.concat([this._remainder, chunk]);
        this._remainder = null;
      }
      let offset = 0;
      if (this._skipUntil && this._length > this._skipUntil) {
        offset = this._skipUntil - this._count;
        this._skipUntil = null;
      } else if (this._skipUntil) {
        this._count += chunk.length;
        return done();
      }
      let result;
      while (result !== TOO_SHORT) {
        result = this._readTag(chunk, offset);
        if (result === TOO_SHORT)
          break;
        if (result._skipUntil) {
          this._skipUntil = result._skipUntil;
          break;
        }
        if (result.offset)
          offset = result.offset;
        else
          break;
      }
      this._count += offset;
      this._remainder = chunk.slice(offset);
      return done();
    }
    _readEBMLId(chunk, offset) {
      const idLength = vintLength(chunk, offset);
      if (idLength === TOO_SHORT)
        return TOO_SHORT;
      return {
        id: chunk.slice(offset, offset + idLength),
        offset: offset + idLength
      };
    }
    _readTagDataSize(chunk, offset) {
      const sizeLength = vintLength(chunk, offset);
      if (sizeLength === TOO_SHORT)
        return TOO_SHORT;
      const dataLength = expandVint(chunk, offset, offset + sizeLength);
      return {offset: offset + sizeLength, dataLength, sizeLength};
    }
    _readTag(chunk, offset) {
      const idData = this._readEBMLId(chunk, offset);
      if (idData === TOO_SHORT)
        return TOO_SHORT;
      const ebmlID = idData.id.toString("hex");
      if (!this._ebmlFound) {
        if (ebmlID === "1a45dfa3")
          this._ebmlFound = true;
        else
          throw Error("Did not find the EBML tag at the start of the stream");
      }
      offset = idData.offset;
      const sizeData = this._readTagDataSize(chunk, offset);
      if (sizeData === TOO_SHORT)
        return TOO_SHORT;
      const {dataLength} = sizeData;
      offset = sizeData.offset;
      if (typeof TAGS[ebmlID] === "undefined") {
        if (chunk.length > offset + dataLength) {
          return {offset: offset + dataLength};
        }
        return {offset, _skipUntil: this._count + offset + dataLength};
      }
      const tagHasChildren = TAGS[ebmlID];
      if (tagHasChildren) {
        return {offset};
      }
      if (offset + dataLength > chunk.length)
        return TOO_SHORT;
      const data = chunk.slice(offset, offset + dataLength);
      if (!this._track) {
        if (ebmlID === "ae")
          this._incompleteTrack = {};
        if (ebmlID === "d7")
          this._incompleteTrack.number = data[0];
        if (ebmlID === "83")
          this._incompleteTrack.type = data[0];
        if (this._incompleteTrack.type === 2 && typeof this._incompleteTrack.number !== "undefined") {
          this._track = this._incompleteTrack;
        }
      }
      if (ebmlID === "63a2") {
        this._checkHead(data);
      } else if (ebmlID === "a3") {
        if (!this._track)
          throw Error("No audio track in this webm!");
        if ((data[0] & 15) === this._track.number) {
          this.push(data.slice(4));
        }
      }
      return {offset: offset + dataLength};
    }
    _destroy(err, cb) {
      this._cleanup();
      return cb ? cb(err) : void 0;
    }
    _final(cb) {
      this._cleanup();
      cb();
    }
    _cleanup() {
      this._remainder = null;
      this._incompleteTrack = {};
    }
  };
  var TOO_SHORT = WebmBaseDemuxer.TOO_SHORT = Symbol("TOO_SHORT");
  var TAGS = WebmBaseDemuxer.TAGS = {
    "1a45dfa3": true,
    "18538067": true,
    "1f43b675": true,
    "1654ae6b": true,
    ae: true,
    d7: false,
    "83": false,
    a3: false,
    "63a2": false
  };
  module2.exports = WebmBaseDemuxer;
  function vintLength(buffer, index) {
    let i = 0;
    for (; i < 8; i++)
      if (1 << 7 - i & buffer[index])
        break;
    i++;
    if (index + i > buffer.length) {
      return TOO_SHORT;
    }
    return i;
  }
  function expandVint(buffer, start, end) {
    const length = vintLength(buffer, start);
    if (end > buffer.length || length === TOO_SHORT)
      return TOO_SHORT;
    let mask = (1 << 8 - length) - 1;
    let value = buffer[start] & mask;
    for (let i = start + 1; i < end; i++) {
      value = (value << 8) + buffer[i];
    }
    return value;
  }
});

// node_modules/prism-media/src/opus/WebmDemuxer.js
var require_WebmDemuxer = __commonJS((exports2, module2) => {
  var WebmBaseDemuxer = require_WebmBase();
  var OPUS_HEAD = Buffer.from([..."OpusHead"].map((x) => x.charCodeAt(0)));
  var WebmDemuxer = class extends WebmBaseDemuxer {
    _checkHead(data) {
      if (!data.slice(0, 8).equals(OPUS_HEAD)) {
        throw Error("Audio codec is not Opus!");
      }
    }
  };
  module2.exports = WebmDemuxer;
});

// node_modules/prism-media/src/opus/index.js
var require_opus = __commonJS((exports2, module2) => {
  module2.exports = {
    ...require_Opus(),
    OggDemuxer: require_OggDemuxer(),
    WebmDemuxer: require_WebmDemuxer()
  };
});

// node_modules/prism-media/src/vorbis/WebmDemuxer.js
var require_WebmDemuxer2 = __commonJS((exports2, module2) => {
  var WebmBaseDemuxer = require_WebmBase();
  var VORBIS_HEAD = Buffer.from([..."vorbis"].map((x) => x.charCodeAt(0)));
  var WebmDemuxer = class extends WebmBaseDemuxer {
    _checkHead(data) {
      if (data.readUInt8(0) !== 2 || !data.slice(4, 10).equals(VORBIS_HEAD)) {
        throw Error("Audio codec is not Vorbis!");
      }
      this.push(data.slice(3, 3 + data.readUInt8(1)));
      this.push(data.slice(3 + data.readUInt8(1), 3 + data.readUInt8(1) + data.readUInt8(2)));
      this.push(data.slice(3 + data.readUInt8(1) + data.readUInt8(2)));
    }
  };
  module2.exports = WebmDemuxer;
});

// node_modules/prism-media/src/vorbis/index.js
var require_vorbis = __commonJS((exports2, module2) => {
  module2.exports = {
    WebmDemuxer: require_WebmDemuxer2()
  };
});

// node_modules/prism-media/src/core/FFmpeg.js
var require_FFmpeg = __commonJS((exports2, module2) => {
  var ChildProcess = require("child_process");
  var {Duplex} = require("stream");
  var FFMPEG = {
    command: null,
    output: null
  };
  var VERSION_REGEX = /version (.+) Copyright/mi;
  Object.defineProperty(FFMPEG, "version", {
    get() {
      return VERSION_REGEX.exec(FFMPEG.output)[1];
    },
    enumerable: true
  });
  var FFmpeg = class extends Duplex {
    constructor(options = {}) {
      super();
      this.process = FFmpeg.create(options);
      const EVENTS = {
        readable: this._reader,
        data: this._reader,
        end: this._reader,
        unpipe: this._reader,
        finish: this._writer,
        drain: this._writer
      };
      this._readableState = this._reader._readableState;
      this._writableState = this._writer._writableState;
      this._copy(["write", "end"], this._writer);
      this._copy(["read", "setEncoding", "pipe", "unpipe"], this._reader);
      for (const method of ["on", "once", "removeListener", "removeListeners", "listeners"]) {
        this[method] = (ev, fn) => EVENTS[ev] ? EVENTS[ev][method](ev, fn) : Duplex.prototype[method].call(this, ev, fn);
      }
      const processError = (error) => this.emit("error", error);
      this._reader.on("error", processError);
      this._writer.on("error", processError);
    }
    get _reader() {
      return this.process.stdout;
    }
    get _writer() {
      return this.process.stdin;
    }
    _copy(methods, target) {
      for (const method of methods) {
        this[method] = target[method].bind(target);
      }
    }
    _destroy(err, cb) {
      this._cleanup();
      return cb ? cb(err) : void 0;
    }
    _final(cb) {
      this._cleanup();
      cb();
    }
    _cleanup() {
      if (this.process) {
        this.once("error", () => {
        });
        this.process.kill("SIGKILL");
        this.process = null;
      }
    }
    static getInfo(force = false) {
      if (FFMPEG.command && !force)
        return FFMPEG;
      const sources = [() => {
        const ffmpegStatic = require("ffmpeg-static");
        return ffmpegStatic.path || ffmpegStatic;
      }, "ffmpeg", "avconv", "./ffmpeg", "./avconv"];
      for (let source of sources) {
        try {
          if (typeof source === "function")
            source = source();
          const result = ChildProcess.spawnSync(source, ["-h"], {windowsHide: true});
          if (result.error)
            throw result.error;
          Object.assign(FFMPEG, {
            command: source,
            output: Buffer.concat(result.output.filter(Boolean)).toString()
          });
          return FFMPEG;
        } catch (error) {
        }
      }
      throw new Error("FFmpeg/avconv not found!");
    }
    static create({args = []} = {}) {
      if (!args.includes("-i"))
        args.unshift("-i", "-");
      return ChildProcess.spawn(FFmpeg.getInfo().command, args.concat(["pipe:1"]), {windowsHide: true});
    }
  };
  module2.exports = FFmpeg;
});

// node_modules/prism-media/src/core/VolumeTransformer.js
var require_VolumeTransformer = __commonJS((exports2, module2) => {
  var {Transform} = require("stream");
  var VolumeTransformer = class extends Transform {
    constructor(options = {}) {
      super(options);
      switch (options.type) {
        case "s16le":
          this._readInt = (buffer, index) => buffer.readInt16LE(index);
          this._writeInt = (buffer, int, index) => buffer.writeInt16LE(int, index);
          this._bits = 16;
          break;
        case "s16be":
          this._readInt = (buffer, index) => buffer.readInt16BE(index);
          this._writeInt = (buffer, int, index) => buffer.writeInt16BE(int, index);
          this._bits = 16;
          break;
        case "s32le":
          this._readInt = (buffer, index) => buffer.readInt32LE(index);
          this._writeInt = (buffer, int, index) => buffer.writeInt32LE(int, index);
          this._bits = 32;
          break;
        case "s32be":
          this._readInt = (buffer, index) => buffer.readInt32BE(index);
          this._writeInt = (buffer, int, index) => buffer.writeInt32BE(int, index);
          this._bits = 32;
          break;
        default:
          throw new Error("VolumeTransformer type should be one of s16le, s16be, s32le, s32be");
      }
      this._bytes = this._bits / 8;
      this._extremum = Math.pow(2, this._bits - 1);
      this.volume = typeof options.volume === "undefined" ? 1 : options.volume;
      this._chunk = Buffer.alloc(0);
    }
    _readInt(buffer, index) {
      return index;
    }
    _writeInt(buffer, int, index) {
      return index;
    }
    _transform(chunk, encoding, done) {
      if (this.volume === 1) {
        this.push(chunk);
        return done();
      }
      const {_bytes, _extremum} = this;
      chunk = this._chunk = Buffer.concat([this._chunk, chunk]);
      if (chunk.length < _bytes)
        return done();
      const transformed = Buffer.allocUnsafe(chunk.length);
      const complete = Math.floor(chunk.length / _bytes) * _bytes;
      for (let i = 0; i < complete; i += _bytes) {
        const int = Math.min(_extremum - 1, Math.max(-_extremum, Math.floor(this.volume * this._readInt(chunk, i))));
        this._writeInt(transformed, int, i);
      }
      this._chunk = chunk.slice(complete);
      this.push(transformed);
      return done();
    }
    _destroy(err, cb) {
      super._destroy(err, cb);
      this._chunk = null;
    }
    setVolume(volume) {
      this.volume = volume;
    }
    setVolumeDecibels(db) {
      this.setVolume(Math.pow(10, db / 20));
    }
    setVolumeLogarithmic(value) {
      this.setVolume(Math.pow(value, 1.660964));
    }
    get volumeDecibels() {
      return Math.log10(this._volume) * 20;
    }
    get volumeLogarithmic() {
      return Math.pow(this._volume, 1 / 1.660964);
    }
  };
  module2.exports = VolumeTransformer;
});

// node_modules/prism-media/src/core/index.js
var require_core = __commonJS((exports2, module2) => {
  module2.exports = {
    FFmpeg: require_FFmpeg(),
    VolumeTransformer: require_VolumeTransformer()
  };
});

// node_modules/prism-media/src/index.js
var require_src = __commonJS((exports2, module2) => {
  module2.exports = {
    opus: require_opus(),
    vorbis: require_vorbis(),
    ...require_core()
  };
});

// node_modules/discord.js/src/client/voice/util/Secretbox.js
var require_Secretbox = __commonJS((exports2) => {
  "use strict";
  var libs = {
    sodium: (sodium) => ({
      open: sodium.api.crypto_secretbox_open_easy,
      close: sodium.api.crypto_secretbox_easy,
      random: (n) => sodium.randombytes_buf(n)
    }),
    "libsodium-wrappers": (sodium) => ({
      open: sodium.crypto_secretbox_open_easy,
      close: sodium.crypto_secretbox_easy,
      random: (n) => sodium.randombytes_buf(n)
    }),
    tweetnacl: (tweetnacl) => ({
      open: tweetnacl.secretbox.open,
      close: tweetnacl.secretbox,
      random: (n) => tweetnacl.randomBytes(n)
    })
  };
  exports2.methods = {};
  (async () => {
    for (const libName of Object.keys(libs)) {
      try {
        const lib = require(libName);
        if (libName === "libsodium-wrappers" && lib.ready)
          await lib.ready;
        exports2.methods = libs[libName](lib);
        break;
      } catch {
      }
    }
  })();
});

// node_modules/discord.js/src/client/voice/util/Silence.js
var require_Silence = __commonJS((exports2, module2) => {
  "use strict";
  var {Readable} = require("stream");
  var SILENCE_FRAME = Buffer.from([248, 255, 254]);
  var Silence = class extends Readable {
    _read() {
      this.push(SILENCE_FRAME);
    }
  };
  Silence.SILENCE_FRAME = SILENCE_FRAME;
  module2.exports = Silence;
});

// node_modules/discord.js/src/client/voice/util/VolumeInterface.js
var require_VolumeInterface = __commonJS((exports2) => {
  "use strict";
  var EventEmitter = require("events");
  var VolumeInterface = class extends EventEmitter {
    constructor({volume = 1} = {}) {
      super();
      this.setVolume(volume);
    }
    get volumeEditable() {
      return true;
    }
    get volume() {
      return this._volume;
    }
    get volumeDecibels() {
      return Math.log10(this.volume) * 20;
    }
    get volumeLogarithmic() {
      return Math.pow(this.volume, 1 / 1.660964);
    }
    applyVolume(buffer, volume) {
      volume = volume || this._volume;
      if (volume === 1)
        return buffer;
      const out = Buffer.alloc(buffer.length);
      for (let i = 0; i < buffer.length; i += 2) {
        if (i >= buffer.length - 1)
          break;
        const uint = Math.min(32767, Math.max(-32767, Math.floor(volume * buffer.readInt16LE(i))));
        out.writeInt16LE(uint, i);
      }
      return out;
    }
    setVolume(volume) {
      this.emit("volumeChange", this._volume, volume);
      this._volume = volume;
    }
    setVolumeDecibels(db) {
      this.setVolume(Math.pow(10, db / 20));
    }
    setVolumeLogarithmic(value) {
      this.setVolume(Math.pow(value, 1.660964));
    }
  };
  var props = ["volumeDecibels", "volumeLogarithmic", "setVolumeDecibels", "setVolumeLogarithmic"];
  exports2.applyToClass = function applyToClass(structure) {
    for (const prop of props) {
      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(VolumeInterface.prototype, prop));
    }
  };
});

// node_modules/discord.js/src/client/voice/dispatcher/StreamDispatcher.js
var require_StreamDispatcher = __commonJS((exports2, module2) => {
  "use strict";
  var {Writable} = require("stream");
  var secretbox = require_Secretbox();
  var Silence = require_Silence();
  var VolumeInterface = require_VolumeInterface();
  var FRAME_LENGTH = 20;
  var CHANNELS = 2;
  var TIMESTAMP_INC = 48e3 / 100 * CHANNELS;
  var MAX_NONCE_SIZE = 2 ** 32 - 1;
  var nonce = Buffer.alloc(24);
  var StreamDispatcher = class extends Writable {
    constructor(player, {seek = 0, volume = 1, fec, plp, bitrate = 96, highWaterMark = 12} = {}, streams) {
      const streamOptions = {seek, volume, fec, plp, bitrate, highWaterMark};
      super(streamOptions);
      this.player = player;
      this.streamOptions = streamOptions;
      this.streams = streams;
      this.streams.silence = new Silence();
      this._nonce = 0;
      this._nonceBuffer = Buffer.alloc(24);
      this.pausedSince = null;
      this._writeCallback = null;
      this.broadcast = this.streams.broadcast || null;
      this._pausedTime = 0;
      this._silentPausedTime = 0;
      this.count = 0;
      this.on("finish", () => {
        this._cleanup();
        this._setSpeaking(0);
      });
      this.setVolume(volume);
      this.setBitrate(bitrate);
      if (typeof fec !== "undefined")
        this.setFEC(fec);
      if (typeof plp !== "undefined")
        this.setPLP(plp);
      const streamError = (type, err) => {
        if (type && err) {
          err.message = `${type} stream: ${err.message}`;
          this.emit(this.player.dispatcher === this ? "error" : "debug", err);
        }
        this.destroy();
      };
      this.on("error", () => streamError());
      if (this.streams.input)
        this.streams.input.on("error", (err) => streamError("input", err));
      if (this.streams.ffmpeg)
        this.streams.ffmpeg.on("error", (err) => streamError("ffmpeg", err));
      if (this.streams.opus)
        this.streams.opus.on("error", (err) => streamError("opus", err));
      if (this.streams.volume)
        this.streams.volume.on("error", (err) => streamError("volume", err));
    }
    get _sdata() {
      return this.player.streamingData;
    }
    _write(chunk, enc, done) {
      if (!this.startTime) {
        this.emit("start");
        this.startTime = Date.now();
      }
      this._playChunk(chunk);
      this._step(done);
    }
    _destroy(err, cb) {
      this._cleanup();
      super._destroy(err, cb);
    }
    _cleanup() {
      if (this.player.dispatcher === this)
        this.player.dispatcher = null;
      const {streams} = this;
      if (streams.broadcast)
        streams.broadcast.delete(this);
      if (streams.opus)
        streams.opus.destroy();
      if (streams.ffmpeg)
        streams.ffmpeg.destroy();
    }
    pause(silence = false) {
      if (this.paused)
        return;
      if (this.streams.opus)
        this.streams.opus.unpipe(this);
      if (silence) {
        this.streams.silence.pipe(this);
        this._silence = true;
      } else {
        this._setSpeaking(0);
      }
      this.pausedSince = Date.now();
    }
    get paused() {
      return Boolean(this.pausedSince);
    }
    get pausedTime() {
      return this._silentPausedTime + this._pausedTime + (this.paused ? Date.now() - this.pausedSince : 0);
    }
    resume() {
      if (!this.pausedSince)
        return;
      this.streams.silence.unpipe(this);
      if (this.streams.opus)
        this.streams.opus.pipe(this);
      if (this._silence) {
        this._silentPausedTime += Date.now() - this.pausedSince;
        this._silence = false;
      } else {
        this._pausedTime += Date.now() - this.pausedSince;
      }
      this.pausedSince = null;
      if (typeof this._writeCallback === "function")
        this._writeCallback();
    }
    get streamTime() {
      return this.count * FRAME_LENGTH;
    }
    get totalStreamTime() {
      return Date.now() - this.startTime;
    }
    setBitrate(value) {
      if (!value || !this.bitrateEditable)
        return false;
      const bitrate = value === "auto" ? this.player.voiceConnection.channel.bitrate : value;
      this.streams.opus.setBitrate(bitrate * 1e3);
      return true;
    }
    setPLP(value) {
      if (!this.bitrateEditable)
        return false;
      this.streams.opus.setPLP(value);
      return true;
    }
    setFEC(enabled) {
      if (!this.bitrateEditable)
        return false;
      this.streams.opus.setFEC(enabled);
      return true;
    }
    _step(done) {
      this._writeCallback = () => {
        this._writeCallback = null;
        done();
      };
      if (!this.streams.broadcast) {
        const next = FRAME_LENGTH + this.count * FRAME_LENGTH - (Date.now() - this.startTime - this._pausedTime);
        setTimeout(() => {
          if ((!this.pausedSince || this._silence) && this._writeCallback)
            this._writeCallback();
        }, next);
      }
      this._sdata.sequence++;
      this._sdata.timestamp += TIMESTAMP_INC;
      if (this._sdata.sequence >= 2 ** 16)
        this._sdata.sequence = 0;
      if (this._sdata.timestamp >= 2 ** 32)
        this._sdata.timestamp = 0;
      this.count++;
    }
    _final(callback) {
      this._writeCallback = null;
      callback();
    }
    _playChunk(chunk) {
      if (this.player.dispatcher !== this || !this.player.voiceConnection.authentication.secret_key)
        return;
      this._sendPacket(this._createPacket(this._sdata.sequence, this._sdata.timestamp, chunk));
    }
    _encrypt(buffer) {
      const {secret_key, mode} = this.player.voiceConnection.authentication;
      if (mode === "xsalsa20_poly1305_lite") {
        this._nonce++;
        if (this._nonce > MAX_NONCE_SIZE)
          this._nonce = 0;
        this._nonceBuffer.writeUInt32BE(this._nonce, 0);
        return [secretbox.methods.close(buffer, this._nonceBuffer, secret_key), this._nonceBuffer.slice(0, 4)];
      } else if (mode === "xsalsa20_poly1305_suffix") {
        const random = secretbox.methods.random(24);
        return [secretbox.methods.close(buffer, random, secret_key), random];
      } else {
        return [secretbox.methods.close(buffer, nonce, secret_key)];
      }
    }
    _createPacket(sequence, timestamp, buffer) {
      const packetBuffer = Buffer.alloc(12);
      packetBuffer[0] = 128;
      packetBuffer[1] = 120;
      packetBuffer.writeUIntBE(sequence, 2, 2);
      packetBuffer.writeUIntBE(timestamp, 4, 4);
      packetBuffer.writeUIntBE(this.player.voiceConnection.authentication.ssrc, 8, 4);
      packetBuffer.copy(nonce, 0, 0, 12);
      return Buffer.concat([packetBuffer, ...this._encrypt(buffer)]);
    }
    _sendPacket(packet) {
      this._setSpeaking(1);
      if (!this.player.voiceConnection.sockets.udp) {
        this.emit("debug", "Failed to send a packet - no UDP socket");
        return;
      }
      this.player.voiceConnection.sockets.udp.send(packet).catch((e) => {
        this._setSpeaking(0);
        this.emit("debug", `Failed to send a packet - ${e}`);
      });
    }
    _setSpeaking(value) {
      if (typeof this.player.voiceConnection !== "undefined") {
        this.player.voiceConnection.setSpeaking(value);
      }
      this.emit("speaking", value);
    }
    get volumeEditable() {
      return Boolean(this.streams.volume);
    }
    get bitrateEditable() {
      return this.streams.opus && this.streams.opus.setBitrate;
    }
    get volume() {
      return this.streams.volume ? this.streams.volume.volume : 1;
    }
    setVolume(value) {
      if (!this.streams.volume)
        return false;
      this.emit("volumeChange", this.volume, value);
      this.streams.volume.setVolume(value);
      return true;
    }
    get volumeDecibels() {
    }
    get volumeLogarithmic() {
    }
    setVolumeDecibels() {
    }
    setVolumeLogarithmic() {
    }
  };
  VolumeInterface.applyToClass(StreamDispatcher);
  module2.exports = StreamDispatcher;
});

// node_modules/discord.js/src/client/voice/player/BasePlayer.js
var require_BasePlayer = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var {Readable: ReadableStream} = require("stream");
  var prism = require_src();
  var StreamDispatcher = require_StreamDispatcher();
  var FFMPEG_ARGUMENTS = ["-analyzeduration", "0", "-loglevel", "0", "-f", "s16le", "-ar", "48000", "-ac", "2"];
  var BasePlayer = class extends EventEmitter {
    constructor() {
      super();
      this.dispatcher = null;
      this.streamingData = {
        channels: 2,
        sequence: 0,
        timestamp: 0
      };
    }
    destroy() {
      this.destroyDispatcher();
    }
    destroyDispatcher() {
      if (this.dispatcher) {
        this.dispatcher.destroy();
        this.dispatcher = null;
      }
    }
    playUnknown(input, options) {
      this.destroyDispatcher();
      const isStream = input instanceof ReadableStream;
      const args = isStream ? FFMPEG_ARGUMENTS.slice() : ["-i", input, ...FFMPEG_ARGUMENTS];
      if (options.seek)
        args.unshift("-ss", String(options.seek));
      const ffmpeg = new prism.FFmpeg({args});
      const streams = {ffmpeg};
      if (isStream) {
        streams.input = input;
        input.pipe(ffmpeg);
      }
      return this.playPCMStream(ffmpeg, options, streams);
    }
    playPCMStream(stream, options, streams = {}) {
      this.destroyDispatcher();
      const opus = streams.opus = new prism.opus.Encoder({channels: 2, rate: 48e3, frameSize: 960});
      if (options && options.volume === false) {
        stream.pipe(opus);
        return this.playOpusStream(opus, options, streams);
      }
      streams.volume = new prism.VolumeTransformer({type: "s16le", volume: options ? options.volume : 1});
      stream.pipe(streams.volume).pipe(opus);
      return this.playOpusStream(opus, options, streams);
    }
    playOpusStream(stream, options, streams = {}) {
      this.destroyDispatcher();
      streams.opus = stream;
      if (options.volume !== false && !streams.input) {
        streams.input = stream;
        const decoder = new prism.opus.Decoder({channels: 2, rate: 48e3, frameSize: 960});
        streams.volume = new prism.VolumeTransformer({type: "s16le", volume: options ? options.volume : 1});
        streams.opus = stream.pipe(decoder).pipe(streams.volume).pipe(new prism.opus.Encoder({channels: 2, rate: 48e3, frameSize: 960}));
      }
      const dispatcher = this.createDispatcher(options, streams);
      streams.opus.pipe(dispatcher);
      return dispatcher;
    }
    createDispatcher(options, streams, broadcast) {
      this.destroyDispatcher();
      const dispatcher = this.dispatcher = new StreamDispatcher(this, options, streams, broadcast);
      return dispatcher;
    }
  };
  module2.exports = BasePlayer;
});

// node_modules/discord.js/src/client/voice/dispatcher/BroadcastDispatcher.js
var require_BroadcastDispatcher = __commonJS((exports2, module2) => {
  "use strict";
  var StreamDispatcher = require_StreamDispatcher();
  var BroadcastDispatcher = class extends StreamDispatcher {
    constructor(player, options, streams) {
      super(player, options, streams);
      this.broadcast = player.broadcast;
    }
    _write(chunk, enc, done) {
      if (!this.startTime)
        this.startTime = Date.now();
      for (const dispatcher of this.broadcast.subscribers) {
        dispatcher._write(chunk, enc);
      }
      this._step(done);
    }
    _destroy(err, cb) {
      if (this.player.dispatcher === this)
        this.player.dispatcher = null;
      const {streams} = this;
      if (streams.opus)
        streams.opus.unpipe(this);
      if (streams.ffmpeg)
        streams.ffmpeg.destroy();
      super._destroy(err, cb);
    }
    setBitrate(value) {
      if (!value || !this.streams.opus || !this.streams.opus.setBitrate)
        return false;
      const bitrate = value === "auto" ? 48 : value;
      this.streams.opus.setBitrate(bitrate * 1e3);
      return true;
    }
  };
  module2.exports = BroadcastDispatcher;
});

// node_modules/discord.js/src/client/voice/player/BroadcastAudioPlayer.js
var require_BroadcastAudioPlayer = __commonJS((exports2, module2) => {
  "use strict";
  var BasePlayer = require_BasePlayer();
  var BroadcastDispatcher = require_BroadcastDispatcher();
  var AudioPlayer = class extends BasePlayer {
    constructor(broadcast) {
      super();
      this.broadcast = broadcast;
    }
    createDispatcher(options, streams) {
      this.destroyDispatcher();
      const dispatcher = this.dispatcher = new BroadcastDispatcher(this, options, streams);
      return dispatcher;
    }
  };
  module2.exports = AudioPlayer;
});

// node_modules/discord.js/src/client/voice/util/PlayInterface.js
var require_PlayInterface = __commonJS((exports2, module2) => {
  "use strict";
  var {Readable} = require("stream");
  var prism = require_src();
  var {Error: Error2} = require_errors();
  var PlayInterface = class {
    constructor(player) {
      this.player = player;
    }
    play(resource, options = {}) {
      const VoiceBroadcast = require_VoiceBroadcast();
      if (resource instanceof VoiceBroadcast) {
        if (!this.player.playBroadcast)
          throw new Error2("VOICE_PLAY_INTERFACE_NO_BROADCAST");
        return this.player.playBroadcast(resource, options);
      }
      if (resource instanceof Readable || typeof resource === "string") {
        const type = options.type || "unknown";
        if (type === "unknown") {
          return this.player.playUnknown(resource, options);
        } else if (type === "converted") {
          return this.player.playPCMStream(resource, options);
        } else if (type === "opus") {
          return this.player.playOpusStream(resource, options);
        } else if (type === "ogg/opus") {
          if (!(resource instanceof Readable))
            throw new Error2("VOICE_PRISM_DEMUXERS_NEED_STREAM");
          return this.player.playOpusStream(resource.pipe(new prism.opus.OggDemuxer()), options);
        } else if (type === "webm/opus") {
          if (!(resource instanceof Readable))
            throw new Error2("VOICE_PRISM_DEMUXERS_NEED_STREAM");
          return this.player.playOpusStream(resource.pipe(new prism.opus.WebmDemuxer()), options);
        }
      }
      throw new Error2("VOICE_PLAY_INTERFACE_BAD_TYPE");
    }
    static applyToClass(structure) {
      for (const prop of ["play"]) {
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(PlayInterface.prototype, prop));
      }
    }
  };
  module2.exports = PlayInterface;
});

// node_modules/discord.js/src/client/voice/VoiceBroadcast.js
var require_VoiceBroadcast = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var BroadcastAudioPlayer = require_BroadcastAudioPlayer();
  var PlayInterface = require_PlayInterface();
  var {Events: Events2} = require_Constants();
  var VoiceBroadcast = class extends EventEmitter {
    constructor(client) {
      super();
      this.client = client;
      this.subscribers = [];
      this.player = new BroadcastAudioPlayer(this);
    }
    get dispatcher() {
      return this.player.dispatcher;
    }
    play() {
      return null;
    }
    end() {
      for (const dispatcher of this.subscribers)
        this.delete(dispatcher);
      const index = this.client.voice.broadcasts.indexOf(this);
      if (index !== -1)
        this.client.voice.broadcasts.splice(index, 1);
    }
    add(dispatcher) {
      const index = this.subscribers.indexOf(dispatcher);
      if (index === -1) {
        this.subscribers.push(dispatcher);
        this.emit(Events2.VOICE_BROADCAST_SUBSCRIBE, dispatcher);
        return true;
      } else {
        return false;
      }
    }
    delete(dispatcher) {
      const index = this.subscribers.indexOf(dispatcher);
      if (index !== -1) {
        this.subscribers.splice(index, 1);
        dispatcher.destroy();
        this.emit(Events2.VOICE_BROADCAST_UNSUBSCRIBE, dispatcher);
        return true;
      }
      return false;
    }
  };
  PlayInterface.applyToClass(VoiceBroadcast);
  module2.exports = VoiceBroadcast;
});

// node_modules/discord.js/src/client/voice/networking/VoiceUDPClient.js
var require_VoiceUDPClient = __commonJS((exports2, module2) => {
  "use strict";
  var udp = require("dgram");
  var EventEmitter = require("events");
  var {Error: Error2} = require_errors();
  var {VoiceOPCodes} = require_Constants();
  var VoiceConnectionUDPClient = class extends EventEmitter {
    constructor(voiceConnection) {
      super();
      this.voiceConnection = voiceConnection;
      this.socket = null;
      this.discordAddress = null;
      this.localAddress = null;
      this.localPort = null;
      this.voiceConnection.on("closing", this.shutdown.bind(this));
    }
    shutdown() {
      this.emit("debug", `[UDP] shutdown requested`);
      if (this.socket) {
        this.socket.removeAllListeners("message");
        try {
          this.socket.close();
        } finally {
          this.socket = null;
        }
      }
    }
    get discordPort() {
      return this.voiceConnection.authentication.port;
    }
    send(packet) {
      return new Promise((resolve, reject) => {
        if (!this.socket)
          throw new Error2("UDP_SEND_FAIL");
        if (!this.discordAddress || !this.discordPort)
          throw new Error2("UDP_ADDRESS_MALFORMED");
        this.socket.send(packet, 0, packet.length, this.discordPort, this.discordAddress, (error) => {
          if (error) {
            this.emit("debug", `[UDP] >> ERROR: ${error}`);
            reject(error);
          } else {
            resolve(packet);
          }
        });
      });
    }
    async createUDPSocket(address) {
      this.discordAddress = address;
      const socket = this.socket = udp.createSocket("udp4");
      socket.on("error", (e) => {
        this.emit("debug", `[UDP] Error: ${e}`);
        this.emit("error", e);
      });
      socket.on("close", () => {
        this.emit("debug", "[UDP] socket closed");
      });
      this.emit("debug", `[UDP] created socket`);
      socket.once("message", (message) => {
        this.emit("debug", `[UDP] message: [${[...message]}] (${message})`);
        if (!this.voiceConnection.sockets.ws)
          return;
        const packet = parseLocalPacket(message);
        if (packet.error) {
          this.emit("debug", `[UDP] ERROR: ${packet.error}`);
          this.emit("error", packet.error);
          return;
        }
        this.localAddress = packet.address;
        this.localPort = packet.port;
        this.voiceConnection.sockets.ws.sendPacket({
          op: VoiceOPCodes.SELECT_PROTOCOL,
          d: {
            protocol: "udp",
            data: {
              address: packet.address,
              port: packet.port,
              mode: this.voiceConnection.authentication.mode
            }
          }
        });
        this.emit("debug", `[UDP] << ${JSON.stringify(packet)}`);
        socket.on("message", (buffer) => this.voiceConnection.receiver.packets.push(buffer));
      });
      const blankMessage = Buffer.alloc(70);
      blankMessage.writeUIntBE(this.voiceConnection.authentication.ssrc, 0, 4);
      this.emit("debug", `Sending IP discovery packet: [${[...blankMessage]}]`);
      await this.send(blankMessage);
      this.emit("debug", `Successfully sent IP discovery packet`);
    }
  };
  function parseLocalPacket(message) {
    try {
      const packet = Buffer.from(message);
      let address = "";
      for (let i = 4; i < packet.indexOf(0, i); i++)
        address += String.fromCharCode(packet[i]);
      const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
      return {address, port};
    } catch (error) {
      return {error};
    }
  }
  module2.exports = VoiceConnectionUDPClient;
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports2, module2) => {
  var sep = require("path").sep || "/";
  module2.exports = fileUriToPath;
  function fileUriToPath(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  function bindings(opts) {
    if (typeof opts == "string") {
      opts = {bindings: opts};
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports2.getRoot(exports2.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (; i < l; i++) {
      n = join.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
      return opts.arrow + a;
    }).join("\n"));
    err.tries = tries;
    throw err;
  }
  module2.exports = exports2 = bindings;
  exports2.getFileName = function getFileName(calling_file) {
    var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length; i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports2.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join(dir, "..");
    }
  };
});

// node_modules/erlpack/js/index.js
var require_js = __commonJS((exports2, module2) => {
  module2.exports = require_bindings()("erlpack");
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    EMPTY_BUFFER: Buffer.alloc(0),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports2, module2) => {
  "use strict";
  var {EMPTY_BUFFER} = require_constants();
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0; i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength)
      return target.slice(0, offset);
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    const length = buffer.length;
    for (let i = 0; i < length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  try {
    const bufferUtil = require("bufferutil");
    const bu = bufferUtil.BufferUtil || bufferUtil;
    module2.exports = {
      concat,
      mask(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bu.mask(source, mask, output, offset, length);
      },
      toArrayBuffer,
      toBuffer,
      unmask(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bu.unmask(buffer, mask);
      }
    };
  } catch (e) {
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports2, module2) => {
  "use strict";
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");
  var Limiter = class {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  };
  module2.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports2, module2) => {
  "use strict";
  var zlib = require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var {kStatusCode, NOOP} = require_constants();
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;
  var PerMessageDeflate = class {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("error", NOOP);
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin)
          data2 = data2.slice(0, data2.length - 4);
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  };
  module2.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports2) => {
  "use strict";
  try {
    const isValidUTF8 = require("utf-8-validate");
    exports2.isValidUTF8 = typeof isValidUTF8 === "object" ? isValidUTF8.Validation.isValidUTF8 : isValidUTF8;
  } catch (e) {
    exports2.isValidUTF8 = () => true;
  }
  exports2.isValidStatusCode = (code) => {
    return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
  };
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports2, module2) => {
  "use strict";
  var {Writable} = require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var {concat, toArrayBuffer, unmask} = require_buffer_util();
  var {isValidStatusCode, isValidUTF8} = require_validation();
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var Receiver = class extends Writable {
    constructor(binaryType, extensions, isServer, maxPayload) {
      super();
      this._binaryType = binaryType || BINARY_TYPES[0];
      this[kWebSocket] = void 0;
      this._extensions = extensions || {};
      this._isServer = !!isServer;
      this._maxPayload = maxPayload | 0;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = void 0;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = buf.slice(n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          default:
            this._loop = false;
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002);
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002);
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002);
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        if (this._payloadLength > 125) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002);
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002);
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002);
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009);
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009);
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked)
          unmask(data, this._mask);
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data);
        } else {
          const buf = concat(fragments, messageLength);
          if (!isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007);
          }
          this.emit("message", buf.toString());
        }
      }
      this._state = GET_INFO;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, "");
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, "invalid payload length 1", true, 1002);
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002);
          }
          const buf = data.slice(2);
          if (!isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007);
          }
          this.emit("conclude", code, buf.toString());
          this.end();
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
      } else {
        this.emit("pong", data);
      }
      this._state = GET_INFO;
    }
  };
  module2.exports = Receiver;
  function error(ErrorCtor, message, prefix, statusCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err[kStatusCode] = statusCode;
    return err;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports2, module2) => {
  "use strict";
  var {randomFillSync} = require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var {EMPTY_BUFFER} = require_constants();
  var {isValidStatusCode} = require_validation();
  var {mask: applyMask, toBuffer} = require_buffer_util();
  var mask = Buffer.alloc(4);
  var Sender = class {
    constructor(socket, extensions) {
      this._extensions = extensions || {};
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      const merge = options.mask && options.readOnly;
      let offset = options.mask ? 6 : 2;
      let payloadLength = data.length;
      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }
      if (!options.mask)
        return [target, data];
      randomFillSync(mask, 0, 4);
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (merge) {
        applyMask(data, mask, target, offset, data.length);
        return [target];
      }
      applyMask(data, mask, data, 0, data.length);
      return [target, data];
    }
    close(code, data, mask2, cb) {
      let buf;
      if (code === void 0) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === void 0 || data === "") {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        buf.write(data, 2);
      }
      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask2, cb]);
      } else {
        this.doClose(buf, mask2, cb);
      }
    }
    doClose(data, mask2, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 8,
        mask: mask2,
        readOnly: false
      }), cb);
    }
    ping(data, mask2, cb) {
      const buf = toBuffer(data);
      if (buf.length > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
      } else {
        this.doPing(buf, mask2, toBuffer.readOnly, cb);
      }
    }
    doPing(data, mask2, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 9,
        mask: mask2,
        readOnly
      }), cb);
    }
    pong(data, mask2, cb) {
      const buf = toBuffer(data);
      if (buf.length > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
      } else {
        this.doPong(buf, mask2, toBuffer.readOnly, cb);
      }
    }
    doPong(data, mask2, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 10,
        mask: mask2,
        readOnly
      }), cb);
    }
    send(data, options, cb) {
      const buf = toBuffer(data);
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          fin: options.fin,
          rsv1,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += data.length;
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0; i < this._queue.length; i++) {
            const callback = this._queue[i][4];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= data.length;
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[1].length;
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[1].length;
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  };
  module2.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports2, module2) => {
  "use strict";
  var Event = class {
    constructor(type, target) {
      this.target = target;
      this.type = type;
    }
  };
  var MessageEvent = class extends Event {
    constructor(data, target) {
      super("message", target);
      this.data = data;
    }
  };
  var CloseEvent = class extends Event {
    constructor(code, reason, target) {
      super("close", target);
      this.wasClean = target._closeFrameReceived && target._closeFrameSent;
      this.reason = reason;
      this.code = code;
    }
  };
  var OpenEvent = class extends Event {
    constructor(target) {
      super("open", target);
    }
  };
  var ErrorEvent = class extends Event {
    constructor(error, target) {
      super("error", target);
      this.message = error.message;
      this.error = error;
    }
  };
  var EventTarget = {
    addEventListener(type, listener, options) {
      if (typeof listener !== "function")
        return;
      function onMessage(data) {
        listener.call(this, new MessageEvent(data, this));
      }
      function onClose(code, message) {
        listener.call(this, new CloseEvent(code, message, this));
      }
      function onError(error) {
        listener.call(this, new ErrorEvent(error, this));
      }
      function onOpen() {
        listener.call(this, new OpenEvent(this));
      }
      const method = options && options.once ? "once" : "on";
      if (type === "message") {
        onMessage._listener = listener;
        this[method](type, onMessage);
      } else if (type === "close") {
        onClose._listener = listener;
        this[method](type, onClose);
      } else if (type === "error") {
        onError._listener = listener;
        this[method](type, onError);
      } else if (type === "open") {
        onOpen._listener = listener;
        this[method](type, onOpen);
      } else {
        this[method](type, listener);
      }
    },
    removeEventListener(type, listener) {
      const listeners = this.listeners(type);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener || listeners[i]._listener === listener) {
          this.removeListener(type, listeners[i]);
        }
      }
    }
  };
  module2.exports = EventTarget;
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports2, module2) => {
  "use strict";
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function push(dest, name, elem) {
    if (dest[name] === void 0)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    if (header === void 0 || header === "")
      return offers;
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let end = -1;
    let i = 0;
    for (; i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (extensionName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = void 0;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = void 0;
          }
          paramName = void 0;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === void 0) {
      push(offers, token, params);
    } else {
      if (paramName === void 0) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module2.exports = {format, parse};
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var https = require("https");
  var http = require("http");
  var net = require("net");
  var tls = require("tls");
  var {randomBytes, createHash} = require("crypto");
  var {URL} = require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {addEventListener, removeEventListener} = require_event_target();
  var {format, parse} = require_extension();
  var {toBuffer} = require_buffer_util();
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var protocolVersions = [8, 13];
  var closeTimeout = 30 * 1e3;
  var WebSocket = class extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = "";
      this._closeTimer = null;
      this._extensions = {};
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (Array.isArray(protocols)) {
          protocols = protocols.join(", ");
        } else if (typeof protocols === "object" && protocols !== null) {
          options = protocols;
          protocols = void 0;
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, maxPayload) {
      const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
      this._sender = new Sender(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && this._closeFrameReceived)
          this._socket.end();
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived)
          this._socket.end();
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === void 0)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === void 0)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  };
  readyStates.forEach((readyState, i) => {
    const descriptor = {enumerable: true, value: i};
    Object.defineProperty(WebSocket.prototype, readyState, descriptor);
    Object.defineProperty(WebSocket, readyState, descriptor);
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, {enumerable: true});
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      configurable: true,
      enumerable: true,
      get() {
        const listeners = this.listeners(method);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener)
            return listeners[i]._listener;
        }
        return void 0;
      },
      set(listener) {
        const listeners = this.listeners(method);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener)
            this.removeListener(method, listeners[i]);
        }
        this.addEventListener(method, listener);
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module2.exports = WebSocket;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: void 0,
      socketPath: void 0,
      hostname: void 0,
      protocol: void 0,
      timeout: void 0,
      method: void 0,
      host: void 0,
      path: void 0,
      port: void 0
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      parsedUrl = new URL(address);
      websocket._url = address;
    }
    const isUnixSocket = parsedUrl.protocol === "ws+unix:";
    if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
      throw new Error(`Invalid URL: ${websocket.url}`);
    }
    const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const get = isSecure ? https.get : http.get;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket",
      ...opts.headers
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols) {
      opts.headers["Sec-WebSocket-Protocol"] = protocols;
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isUnixSocket) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req = websocket._req = get(opts);
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req.aborted)
        return;
      req = websocket._req = null;
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        const addr = new URL(location, address);
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      const protList = (protocols || "").split(/, */);
      let protError;
      if (!protocols && serverProt) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (protocols && !serverProt) {
        protError = "Server sent no subprotocol";
      } else if (serverProt && !protList.includes(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      if (perMessageDeflate) {
        try {
          const extensions = parse(res.headers["sec-websocket-extensions"]);
          if (extensions[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
          return;
        }
      }
      websocket.setSocket(socket, head, opts.maxPayload);
    });
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = void 0;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream.abort();
      stream.once("abort", websocket.emitClose.bind(websocket));
      websocket.emit("error", err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
      cb(err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._socket.removeListener("data", socketOnData);
    websocket._socket.resume();
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    this[kWebSocket]._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    websocket._socket.removeListener("data", socketOnData);
    websocket._readyState = WebSocket.CLOSING;
    websocket._closeCode = err[kStatusCode];
    websocket.emit("error", err);
    websocket._socket.destroy();
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data) {
    this[kWebSocket].emit("message", data);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    websocket._socket.read();
    websocket._receiver.end();
    this.removeListener("data", socketOnData);
    this[kWebSocket] = void 0;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {Duplex} = require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let resumeOnReceiverDrain = true;
    function receiverOnDrain() {
      if (resumeOnReceiverDrain)
        ws._socket.resume();
    }
    if (ws.readyState === ws.CONNECTING) {
      ws.once("open", function open() {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      });
    } else {
      ws._receiver.removeAllListeners("drain");
      ws._receiver.on("drain", receiverOnDrain);
    }
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg) {
      if (!duplex.push(msg)) {
        resumeOnReceiverDrain = false;
        ws._socket.pause();
      }
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
        resumeOnReceiverDrain = true;
        if (!ws._receiver._writableState.needDrain)
          ws._socket.resume();
      }
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module2.exports = createWebSocketStream;
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var {createHash} = require("crypto");
  var {createServer, STATUS_CODES} = require("http");
  var PerMessageDeflate = require_permessage_deflate();
  var WebSocket = require_websocket();
  var {format, parse} = require_extension();
  var {GUID, kWebSocket} = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var WebSocketServer = class extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer) {
        throw new TypeError('One of the "port", "server", or "noServer" options must be specified');
      }
      if (options.port != null) {
        this._server = createServer((req, res) => {
          const body = STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking)
        this.clients = new Set();
      this.options = options;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (cb)
        this.once("close", cb);
      if (this.clients) {
        for (const client of this.clients)
          client.terminate();
      }
      const server = this._server;
      if (server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
        if (this.options.port != null) {
          server.close(() => this.emit("close"));
          return;
        }
      }
      process.nextTick(emitClose, this);
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
      const version = +req.headers["sec-websocket-version"];
      const extensions = {};
      if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake(socket, 400);
      }
      if (this.options.perMessageDeflate) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = parse(req.headers["sec-websocket-extensions"]);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(key, extensions, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(key, extensions, req, socket, head, cb);
    }
    completeUpgrade(key, extensions, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new WebSocket(null);
      let protocol = req.headers["sec-websocket-protocol"];
      if (protocol) {
        protocol = protocol.trim().split(/ *, */);
        if (this.options.handleProtocols) {
          protocol = this.options.handleProtocols(protocol, req);
        } else {
          protocol = protocol[0];
        }
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, this.options.maxPayload);
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => this.clients.delete(ws));
      }
      cb(ws, req);
    }
  };
  module2.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    if (socket.writable) {
      message = message || STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.write(`HTTP/1.1 ${code} ${STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    socket.removeListener("error", socketOnError);
    socket.destroy();
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports2, module2) => {
  "use strict";
  var WebSocket = require_websocket();
  WebSocket.createWebSocketStream = require_stream();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver();
  WebSocket.Sender = require_sender();
  module2.exports = WebSocket;
});

// node_modules/discord.js/src/WebSocket.js
var require_WebSocket = __commonJS((exports2) => {
  "use strict";
  var {browser: browser2} = require_Constants();
  var erlpack;
  try {
    erlpack = require_js();
    if (!erlpack.pack)
      erlpack = null;
  } catch {
  }
  var TextDecoder;
  if (browser2) {
    TextDecoder = window.TextDecoder;
    exports2.WebSocket = window.WebSocket;
  } else {
    TextDecoder = require("util").TextDecoder;
    exports2.WebSocket = require_ws();
  }
  var ab = new TextDecoder();
  exports2.encoding = erlpack ? "etf" : "json";
  exports2.pack = erlpack ? erlpack.pack : JSON.stringify;
  exports2.unpack = (data, type) => {
    if (exports2.encoding === "json" || type === "json") {
      if (typeof data !== "string") {
        data = ab.decode(data);
      }
      return JSON.parse(data);
    }
    if (!Buffer.isBuffer(data))
      data = Buffer.from(new Uint8Array(data));
    return erlpack.unpack(data);
  };
  exports2.create = (gateway, query = {}, ...args) => {
    const [g, q] = gateway.split("?");
    query.encoding = exports2.encoding;
    query = new URLSearchParams(query);
    if (q)
      new URLSearchParams(q).forEach((v, k) => query.set(k, v));
    const ws = new exports2.WebSocket(`${g}?${query}`, ...args);
    if (browser2)
      ws.binaryType = "arraybuffer";
    return ws;
  };
  for (const state of ["CONNECTING", "OPEN", "CLOSING", "CLOSED"])
    exports2[state] = exports2.WebSocket[state];
});

// node_modules/discord.js/src/client/voice/networking/VoiceWebSocket.js
var require_VoiceWebSocket = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var WebSocket = require_WebSocket();
  var {Error: Error2} = require_errors();
  var {OPCodes, VoiceOPCodes} = require_Constants();
  var VoiceWebSocket = class extends EventEmitter {
    constructor(connection) {
      super();
      this.connection = connection;
      this.attempts = 0;
      this.dead = false;
      this.connection.on("closing", this.shutdown.bind(this));
    }
    get client() {
      return this.connection.client;
    }
    shutdown() {
      this.emit("debug", `[WS] shutdown requested`);
      this.dead = true;
      this.reset();
    }
    reset() {
      this.emit("debug", `[WS] reset requested`);
      if (this.ws) {
        if (this.ws.readyState !== WebSocket.CLOSED)
          this.ws.close();
        this.ws = null;
      }
      this.clearHeartbeat();
    }
    connect() {
      this.emit("debug", `[WS] connect requested`);
      if (this.dead)
        return;
      if (this.ws)
        this.reset();
      if (this.attempts >= 5) {
        this.emit("debug", new Error2("VOICE_CONNECTION_ATTEMPTS_EXCEEDED", this.attempts));
        return;
      }
      this.attempts++;
      this.ws = WebSocket.create(`wss://${this.connection.authentication.endpoint}/`, {v: 4});
      this.emit("debug", `[WS] connecting, ${this.attempts} attempts, ${this.ws.url}`);
      this.ws.onopen = this.onOpen.bind(this);
      this.ws.onmessage = this.onMessage.bind(this);
      this.ws.onclose = this.onClose.bind(this);
      this.ws.onerror = this.onError.bind(this);
    }
    send(data) {
      this.emit("debug", `[WS] >> ${data}`);
      return new Promise((resolve, reject) => {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN)
          throw new Error2("WS_NOT_OPEN", data);
        this.ws.send(data, null, (error) => {
          if (error)
            reject(error);
          else
            resolve(data);
        });
      });
    }
    sendPacket(packet) {
      try {
        packet = JSON.stringify(packet);
      } catch (error) {
        return Promise.reject(error);
      }
      return this.send(packet);
    }
    onOpen() {
      this.emit("debug", `[WS] opened at gateway ${this.connection.authentication.endpoint}`);
      this.sendPacket({
        op: OPCodes.DISPATCH,
        d: {
          server_id: this.connection.channel.guild.id,
          user_id: this.client.user.id,
          token: this.connection.authentication.token,
          session_id: this.connection.authentication.sessionID
        }
      }).catch(() => {
        this.emit("error", new Error2("VOICE_JOIN_SOCKET_CLOSED"));
      });
    }
    onMessage(event) {
      try {
        return this.onPacket(WebSocket.unpack(event.data, "json"));
      } catch (error) {
        return this.onError(error);
      }
    }
    onClose() {
      this.emit("debug", `[WS] closed`);
      if (!this.dead)
        this.client.setTimeout(this.connect.bind(this), this.attempts * 1e3);
    }
    onError(error) {
      this.emit("debug", `[WS] Error: ${error}`);
      this.emit("error", error);
    }
    onPacket(packet) {
      this.emit("debug", `[WS] << ${JSON.stringify(packet)}`);
      switch (packet.op) {
        case VoiceOPCodes.HELLO:
          this.setHeartbeat(packet.d.heartbeat_interval);
          break;
        case VoiceOPCodes.READY:
          this.emit("ready", packet.d);
          break;
        case VoiceOPCodes.SESSION_DESCRIPTION:
          packet.d.secret_key = new Uint8Array(packet.d.secret_key);
          this.emit("sessionDescription", packet.d);
          break;
        case VoiceOPCodes.CLIENT_CONNECT:
          this.connection.ssrcMap.set(+packet.d.audio_ssrc, {
            userID: packet.d.user_id,
            speaking: 0,
            hasVideo: Boolean(packet.d.video_ssrc)
          });
          break;
        case VoiceOPCodes.CLIENT_DISCONNECT:
          const streamInfo = this.connection.receiver && this.connection.receiver.packets.streams.get(packet.d.user_id);
          if (streamInfo) {
            this.connection.receiver.packets.streams.delete(packet.d.user_id);
            streamInfo.stream.push(null);
          }
          break;
        case VoiceOPCodes.SPEAKING:
          this.emit("startSpeaking", packet.d);
          break;
        default:
          this.emit("unknownPacket", packet);
          break;
      }
    }
    setHeartbeat(interval) {
      if (!interval || isNaN(interval)) {
        this.onError(new Error2("VOICE_INVALID_HEARTBEAT"));
        return;
      }
      if (this.heartbeatInterval) {
        this.emit("warn", "A voice heartbeat interval is being overwritten");
        this.client.clearInterval(this.heartbeatInterval);
      }
      this.heartbeatInterval = this.client.setInterval(this.sendHeartbeat.bind(this), interval);
    }
    clearHeartbeat() {
      if (!this.heartbeatInterval) {
        this.emit("warn", "Tried to clear a heartbeat interval that does not exist");
        return;
      }
      this.client.clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    sendHeartbeat() {
      this.sendPacket({op: VoiceOPCodes.HEARTBEAT, d: Math.floor(Math.random() * 1e11)}).catch(() => {
        this.emit("warn", "Tried to send heartbeat, but connection is not open");
        this.clearHeartbeat();
      });
    }
  };
  module2.exports = VoiceWebSocket;
});

// node_modules/discord.js/src/client/voice/player/AudioPlayer.js
var require_AudioPlayer = __commonJS((exports2, module2) => {
  "use strict";
  var BasePlayer = require_BasePlayer();
  var AudioPlayer = class extends BasePlayer {
    constructor(voiceConnection) {
      super();
      this.voiceConnection = voiceConnection;
    }
    playBroadcast(broadcast, options) {
      const dispatcher = this.createDispatcher(options, {broadcast});
      broadcast.add(dispatcher);
      return dispatcher;
    }
  };
  module2.exports = AudioPlayer;
});

// node_modules/discord.js/src/util/Speaking.js
var require_Speaking = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var Speaking = class extends BitField {
  };
  Speaking.FLAGS = {
    SPEAKING: 1 << 0,
    SOUNDSHARE: 1 << 1,
    PRIORITY_SPEAKING: 1 << 2
  };
  module2.exports = Speaking;
});

// node_modules/discord.js/src/client/voice/receiver/PacketHandler.js
var require_PacketHandler = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var Speaking = require_Speaking();
  var secretbox = require_Secretbox();
  var {SILENCE_FRAME} = require_Silence();
  var DISCORD_SPEAKING_DELAY = 250;
  var Readable = class extends require("stream").Readable {
    _read() {
    }
  };
  var PacketHandler = class extends EventEmitter {
    constructor(receiver) {
      super();
      this.nonce = Buffer.alloc(24);
      this.receiver = receiver;
      this.streams = new Map();
      this.speakingTimeouts = new Map();
    }
    get connection() {
      return this.receiver.connection;
    }
    _stoppedSpeaking(userID) {
      const streamInfo = this.streams.get(userID);
      if (streamInfo && streamInfo.end === "silence") {
        this.streams.delete(userID);
        streamInfo.stream.push(null);
      }
    }
    makeStream(user, end) {
      if (this.streams.has(user))
        return this.streams.get(user).stream;
      const stream = new Readable();
      stream.on("end", () => this.streams.delete(user));
      this.streams.set(user, {stream, end});
      return stream;
    }
    parseBuffer(buffer) {
      const {secret_key, mode} = this.receiver.connection.authentication;
      let end;
      if (mode === "xsalsa20_poly1305_lite") {
        buffer.copy(this.nonce, 0, buffer.length - 4);
        end = buffer.length - 4;
      } else if (mode === "xsalsa20_poly1305_suffix") {
        buffer.copy(this.nonce, 0, buffer.length - 24);
        end = buffer.length - 24;
      } else {
        buffer.copy(this.nonce, 0, 0, 12);
      }
      let packet = secretbox.methods.open(buffer.slice(12, end), this.nonce, secret_key);
      if (!packet)
        return new Error("Failed to decrypt voice packet");
      packet = Buffer.from(packet);
      if (packet[0] === 190 && packet[1] === 222 && packet.length > 4) {
        const headerExtensionLength = packet.readUInt16BE(2);
        let offset = 4;
        for (let i = 0; i < headerExtensionLength; i++) {
          const byte = packet[offset];
          offset++;
          if (byte === 0)
            continue;
          offset += 1 + (15 & byte >> 4);
        }
        offset++;
        packet = packet.slice(offset);
      }
      return packet;
    }
    push(buffer) {
      const ssrc = buffer.readUInt32BE(8);
      const userStat = this.connection.ssrcMap.get(ssrc);
      if (!userStat)
        return;
      let opusPacket;
      const streamInfo = this.streams.get(userStat.userID);
      if (userStat.hasVideo) {
        opusPacket = this.parseBuffer(buffer);
        if (opusPacket instanceof Error) {
          if (streamInfo) {
            this.emit("error", opusPacket);
            return;
          }
        }
        if (SILENCE_FRAME.equals(opusPacket)) {
          return;
        }
      }
      let speakingTimeout = this.speakingTimeouts.get(ssrc);
      if (typeof speakingTimeout === "undefined") {
        if (userStat.speaking === 0) {
          userStat.speaking = Speaking.FLAGS.SPEAKING;
        }
        this.connection.onSpeaking({user_id: userStat.userID, ssrc, speaking: userStat.speaking});
        speakingTimeout = this.receiver.connection.client.setTimeout(() => {
          try {
            this.connection.onSpeaking({user_id: userStat.userID, ssrc, speaking: 0});
            this.receiver.connection.client.clearTimeout(speakingTimeout);
            this.speakingTimeouts.delete(ssrc);
          } catch {
          }
        }, DISCORD_SPEAKING_DELAY);
        this.speakingTimeouts.set(ssrc, speakingTimeout);
      } else {
        speakingTimeout.refresh();
      }
      if (streamInfo) {
        const {stream} = streamInfo;
        if (!opusPacket) {
          opusPacket = this.parseBuffer(buffer);
          if (opusPacket instanceof Error) {
            this.emit("error", opusPacket);
            return;
          }
        }
        stream.push(opusPacket);
      }
    }
  };
  module2.exports = PacketHandler;
});

// node_modules/discord.js/src/client/voice/receiver/Receiver.js
var require_Receiver = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var prism = require_src();
  var PacketHandler = require_PacketHandler();
  var {Error: Error2} = require_errors();
  var VoiceReceiver = class extends EventEmitter {
    constructor(connection) {
      super();
      this.connection = connection;
      this.packets = new PacketHandler(this);
      this.packets.on("error", (err) => this.emit("debug", err));
    }
    createStream(user, {mode = "opus", end = "silence"} = {}) {
      user = this.connection.client.users.resolve(user);
      if (!user)
        throw new Error2("VOICE_USER_MISSING");
      const stream = this.packets.makeStream(user.id, end);
      if (mode === "pcm") {
        const decoder = new prism.opus.Decoder({channels: 2, rate: 48e3, frameSize: 960});
        stream.pipe(decoder);
        return decoder;
      }
      return stream;
    }
  };
  module2.exports = VoiceReceiver;
});

// node_modules/discord.js/src/client/voice/VoiceConnection.js
var require_VoiceConnection = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var VoiceUDP = require_VoiceUDPClient();
  var VoiceWebSocket = require_VoiceWebSocket();
  var AudioPlayer = require_AudioPlayer();
  var VoiceReceiver = require_Receiver();
  var PlayInterface = require_PlayInterface();
  var Silence = require_Silence();
  var {Error: Error2} = require_errors();
  var {OPCodes, VoiceOPCodes, VoiceStatus, Events: Events2} = require_Constants();
  var Speaking = require_Speaking();
  var Util = require_Util();
  var SingleSilence = class extends Silence {
    _read() {
      super._read();
      this.push(null);
    }
  };
  var SUPPORTED_MODES = ["xsalsa20_poly1305_lite", "xsalsa20_poly1305_suffix", "xsalsa20_poly1305"];
  var VoiceConnection = class extends EventEmitter {
    constructor(voiceManager, channel) {
      super();
      this.voiceManager = voiceManager;
      this.channel = channel;
      this.status = VoiceStatus.AUTHENTICATING;
      this.speaking = new Speaking().freeze();
      this.authentication = {};
      this.player = new AudioPlayer(this);
      this.player.on("debug", (m) => {
        this.emit("debug", `audio player - ${m}`);
      });
      this.player.on("error", (e) => {
        this.emit("warn", e);
      });
      this.once("closing", () => this.player.destroy());
      this.ssrcMap = new Map();
      this._speaking = new Map();
      this.sockets = {};
      this.receiver = new VoiceReceiver(this);
    }
    get client() {
      return this.voiceManager.client;
    }
    get dispatcher() {
      return this.player.dispatcher;
    }
    setSpeaking(value) {
      if (this.speaking.equals(value))
        return;
      if (this.status !== VoiceStatus.CONNECTED)
        return;
      this.speaking = new Speaking(value).freeze();
      this.sockets.ws.sendPacket({
        op: VoiceOPCodes.SPEAKING,
        d: {
          speaking: this.speaking.bitfield,
          delay: 0,
          ssrc: this.authentication.ssrc
        }
      }).catch((e) => {
        this.emit("debug", e);
      });
    }
    get voice() {
      return this.channel.guild.voice;
    }
    sendVoiceStateUpdate(options = {}) {
      options = Util.mergeDefault({
        guild_id: this.channel.guild.id,
        channel_id: this.channel.id,
        self_mute: this.voice ? this.voice.selfMute : false,
        self_deaf: this.voice ? this.voice.selfDeaf : false
      }, options);
      this.emit("debug", `Sending voice state update: ${JSON.stringify(options)}`);
      return this.channel.guild.shard.send({
        op: OPCodes.VOICE_STATE_UPDATE,
        d: options
      }, true);
    }
    setTokenAndEndpoint(token, endpoint) {
      this.emit("debug", `Token "${token}" and endpoint "${endpoint}"`);
      if (!endpoint) {
        return;
      }
      if (!token) {
        this.authenticateFailed("VOICE_TOKEN_ABSENT");
        return;
      }
      endpoint = endpoint.match(/([^:]*)/)[0];
      this.emit("debug", `Endpoint resolved as ${endpoint}`);
      if (!endpoint) {
        this.authenticateFailed("VOICE_INVALID_ENDPOINT");
        return;
      }
      if (this.status === VoiceStatus.AUTHENTICATING) {
        this.authentication.token = token;
        this.authentication.endpoint = endpoint;
        this.checkAuthenticated();
      } else if (token !== this.authentication.token || endpoint !== this.authentication.endpoint) {
        this.reconnect(token, endpoint);
      }
    }
    setSessionID(sessionID) {
      this.emit("debug", `Setting sessionID ${sessionID} (stored as "${this.authentication.sessionID}")`);
      if (!sessionID) {
        this.authenticateFailed("VOICE_SESSION_ABSENT");
        return;
      }
      if (this.status === VoiceStatus.AUTHENTICATING) {
        this.authentication.sessionID = sessionID;
        this.checkAuthenticated();
      } else if (sessionID !== this.authentication.sessionID) {
        this.authentication.sessionID = sessionID;
        this.emit("newSession", sessionID);
      }
    }
    checkAuthenticated() {
      const {token, endpoint, sessionID} = this.authentication;
      this.emit("debug", `Authenticated with sessionID ${sessionID}`);
      if (token && endpoint && sessionID) {
        this.status = VoiceStatus.CONNECTING;
        this.emit("authenticated");
        this.connect();
      }
    }
    authenticateFailed(reason) {
      this.client.clearTimeout(this.connectTimeout);
      this.emit("debug", `Authenticate failed - ${reason}`);
      if (this.status === VoiceStatus.AUTHENTICATING) {
        this.emit("failed", new Error2(reason));
      } else {
        this.emit("error", new Error2(reason));
      }
      this.status = VoiceStatus.DISCONNECTED;
    }
    updateChannel(channel) {
      this.channel = channel;
      this.sendVoiceStateUpdate();
    }
    authenticate() {
      this.sendVoiceStateUpdate();
      this.connectTimeout = this.client.setTimeout(() => this.authenticateFailed("VOICE_CONNECTION_TIMEOUT"), 15e3);
    }
    reconnect(token, endpoint) {
      this.authentication.token = token;
      this.authentication.endpoint = endpoint;
      this.speaking = new Speaking().freeze();
      this.status = VoiceStatus.RECONNECTING;
      this.emit("debug", `Reconnecting to ${endpoint}`);
      this.emit("reconnecting");
      this.connect();
    }
    disconnect() {
      this.emit("closing");
      this.emit("debug", "disconnect() triggered");
      this.client.clearTimeout(this.connectTimeout);
      const conn = this.voiceManager.connections.get(this.channel.guild.id);
      if (conn === this)
        this.voiceManager.connections.delete(this.channel.guild.id);
      this.sendVoiceStateUpdate({
        channel_id: null
      });
      this._disconnect();
    }
    _disconnect() {
      this.cleanup();
      this.status = VoiceStatus.DISCONNECTED;
      this.emit("disconnect");
    }
    cleanup() {
      this.player.destroy();
      this.speaking = new Speaking().freeze();
      const {ws, udp} = this.sockets;
      this.emit("debug", "Connection clean up");
      if (ws) {
        ws.removeAllListeners("error");
        ws.removeAllListeners("ready");
        ws.removeAllListeners("sessionDescription");
        ws.removeAllListeners("speaking");
        ws.shutdown();
      }
      if (udp)
        udp.removeAllListeners("error");
      this.sockets.ws = null;
      this.sockets.udp = null;
    }
    connect() {
      this.emit("debug", `Connect triggered`);
      if (this.status !== VoiceStatus.RECONNECTING) {
        if (this.sockets.ws)
          throw new Error2("WS_CONNECTION_EXISTS");
        if (this.sockets.udp)
          throw new Error2("UDP_CONNECTION_EXISTS");
      }
      if (this.sockets.ws)
        this.sockets.ws.shutdown();
      if (this.sockets.udp)
        this.sockets.udp.shutdown();
      this.sockets.ws = new VoiceWebSocket(this);
      this.sockets.udp = new VoiceUDP(this);
      const {ws, udp} = this.sockets;
      ws.on("debug", (msg) => this.emit("debug", msg));
      udp.on("debug", (msg) => this.emit("debug", msg));
      ws.on("error", (err) => this.emit("error", err));
      udp.on("error", (err) => this.emit("error", err));
      ws.on("ready", this.onReady.bind(this));
      ws.on("sessionDescription", this.onSessionDescription.bind(this));
      ws.on("startSpeaking", this.onStartSpeaking.bind(this));
      this.sockets.ws.connect();
    }
    onReady(data) {
      Object.assign(this.authentication, data);
      for (let mode of data.modes) {
        if (SUPPORTED_MODES.includes(mode)) {
          this.authentication.mode = mode;
          this.emit("debug", `Selecting the ${mode} mode`);
          break;
        }
      }
      this.sockets.udp.createUDPSocket(data.ip);
    }
    onSessionDescription(data) {
      Object.assign(this.authentication, data);
      this.status = VoiceStatus.CONNECTED;
      const ready = () => {
        this.client.clearTimeout(this.connectTimeout);
        this.emit("debug", `Ready with authentication details: ${JSON.stringify(this.authentication)}`);
        this.emit("ready");
      };
      if (this.dispatcher) {
        ready();
      } else {
        const dispatcher = this.play(new SingleSilence(), {type: "opus", volume: false});
        dispatcher.once("finish", ready);
      }
    }
    onStartSpeaking({user_id, ssrc, speaking}) {
      this.ssrcMap.set(+ssrc, {
        ...this.ssrcMap.get(+ssrc) || {},
        userID: user_id,
        speaking
      });
    }
    onSpeaking({user_id, speaking}) {
      speaking = new Speaking(speaking).freeze();
      const guild = this.channel.guild;
      const user = this.client.users.cache.get(user_id);
      const old = this._speaking.get(user_id);
      this._speaking.set(user_id, speaking);
      if (this.status === VoiceStatus.CONNECTED) {
        this.emit("speaking", user, speaking);
        if (!speaking.has(Speaking.FLAGS.SPEAKING)) {
          this.receiver.packets._stoppedSpeaking(user_id);
        }
      }
      if (guild && user && !speaking.equals(old)) {
        const member = guild.member(user);
        if (member) {
          this.client.emit(Events2.GUILD_MEMBER_SPEAKING, member, speaking);
        }
      }
    }
    play() {
    }
  };
  PlayInterface.applyToClass(VoiceConnection);
  module2.exports = VoiceConnection;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports2, module2) => {
  "use strict";
  var VoiceBroadcast = require_VoiceBroadcast();
  var VoiceConnection = require_VoiceConnection();
  var {Error: Error2} = require_errors();
  var Collection2 = require_Collection();
  var ClientVoiceManager2 = class {
    constructor(client) {
      Object.defineProperty(this, "client", {value: client});
      this.connections = new Collection2();
      this.broadcasts = [];
    }
    createBroadcast() {
      const broadcast = new VoiceBroadcast(this.client);
      this.broadcasts.push(broadcast);
      return broadcast;
    }
    onVoiceServer({guild_id, token, endpoint}) {
      this.client.emit("debug", `[VOICE] voiceServer guild: ${guild_id} token: ${token} endpoint: ${endpoint}`);
      const connection = this.connections.get(guild_id);
      if (connection)
        connection.setTokenAndEndpoint(token, endpoint);
    }
    onVoiceStateUpdate({guild_id, session_id, channel_id}) {
      const connection = this.connections.get(guild_id);
      this.client.emit("debug", `[VOICE] connection? ${!!connection}, ${guild_id} ${session_id} ${channel_id}`);
      if (!connection)
        return;
      if (!channel_id) {
        connection._disconnect();
        this.connections.delete(guild_id);
        return;
      }
      connection.channel = this.client.channels.cache.get(channel_id);
      connection.setSessionID(session_id);
    }
    joinChannel(channel) {
      return new Promise((resolve, reject) => {
        if (!channel.joinable) {
          throw new Error2("VOICE_JOIN_CHANNEL", channel.full);
        }
        let connection = this.connections.get(channel.guild.id);
        if (connection) {
          if (connection.channel.id !== channel.id) {
            this.connections.get(channel.guild.id).updateChannel(channel);
          }
          resolve(connection);
          return;
        } else {
          connection = new VoiceConnection(this, channel);
          connection.on("debug", (msg) => this.client.emit("debug", `[VOICE (${channel.guild.id}:${connection.status})]: ${msg}`));
          connection.authenticate();
          this.connections.set(channel.guild.id, connection);
        }
        connection.once("failed", (reason) => {
          this.connections.delete(channel.guild.id);
          reject(reason);
        });
        connection.on("error", reject);
        connection.once("authenticated", () => {
          connection.once("ready", () => {
            resolve(connection);
            connection.removeListener("error", reject);
          });
          connection.once("disconnect", () => this.connections.delete(channel.guild.id));
        });
      });
    }
  };
  module2.exports = ClientVoiceManager2;
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var WebSocket = require_WebSocket();
  var {browser: browser2, Status: Status2, Events: Events2, ShardEvents, OPCodes, WSEvents} = require_Constants();
  var STATUS_KEYS = Object.keys(Status2);
  var CONNECTION_STATE = Object.keys(WebSocket.WebSocket);
  var zlib;
  if (!browser2) {
    try {
      zlib = require("zlib-sync");
    } catch {
    }
  }
  var WebSocketShard = class extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status2.IDLE;
      this.sequence = -1;
      this.closeSequence = 0;
      this.sessionID = null;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      this.lastHeartbeatAcked = true;
      Object.defineProperty(this, "ratelimit", {
        value: {
          queue: [],
          total: 120,
          remaining: 120,
          time: 6e4,
          timer: null
        }
      });
      Object.defineProperty(this, "connection", {value: null, writable: true});
      Object.defineProperty(this, "inflate", {value: null, writable: true});
      Object.defineProperty(this, "helloTimeout", {value: null, writable: true});
      Object.defineProperty(this, "eventsAttached", {value: false, writable: true});
      Object.defineProperty(this, "expectedGuilds", {value: null, writable: true});
      Object.defineProperty(this, "readyTimeout", {value: null, writable: true});
      Object.defineProperty(this, "connectedAt", {value: 0, writable: true});
    }
    debug(message) {
      this.manager.debug(message, this);
    }
    connect() {
      const {gateway, client} = this.manager;
      if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status2.READY) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          this.removeListener(ShardEvents.CLOSE, onClose);
          this.removeListener(ShardEvents.READY, onReady);
          this.removeListener(ShardEvents.RESUMED, onResumed);
          this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
          this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);
        };
        const onReady = () => {
          cleanup();
          resolve();
        };
        const onResumed = () => {
          cleanup();
          resolve();
        };
        const onClose = (event) => {
          cleanup();
          reject(event);
        };
        const onInvalidOrDestroyed = () => {
          cleanup();
          reject();
        };
        this.once(ShardEvents.READY, onReady);
        this.once(ShardEvents.RESUMED, onResumed);
        this.once(ShardEvents.CLOSE, onClose);
        this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
        this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);
        if (this.connection && this.connection.readyState === WebSocket.OPEN) {
          this.debug("An open connection was found, attempting an immediate identify.");
          this.identify();
          return;
        }
        if (this.connection) {
          this.debug(`A connection object was found. Cleaning up before continuing.
    State: ${CONNECTION_STATE[this.connection.readyState]}`);
          this.destroy({emit: false});
        }
        const wsQuery = {v: client.options.ws.version};
        if (zlib) {
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            flush: zlib.Z_SYNC_FLUSH,
            to: WebSocket.encoding === "json" ? "string" : ""
          });
          wsQuery.compress = "zlib-stream";
        }
        this.debug(`[CONNECT]
    Gateway    : ${gateway}
    Version    : ${client.options.ws.version}
    Encoding   : ${WebSocket.encoding}
    Compression: ${zlib ? "zlib-stream" : "none"}`);
        this.status = this.status === Status2.DISCONNECTED ? Status2.RECONNECTING : Status2.CONNECTING;
        this.setHelloTimeout();
        this.connectedAt = Date.now();
        const ws = this.connection = WebSocket.create(gateway, wsQuery);
        ws.onopen = this.onOpen.bind(this);
        ws.onmessage = this.onMessage.bind(this);
        ws.onerror = this.onError.bind(this);
        ws.onclose = this.onClose.bind(this);
      });
    }
    onOpen() {
      this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);
      this.status = Status2.NEARLY;
    }
    onMessage({data}) {
      let raw;
      if (data instanceof ArrayBuffer)
        data = new Uint8Array(data);
      if (zlib) {
        const l = data.length;
        const flush = l >= 4 && data[l - 4] === 0 && data[l - 3] === 0 && data[l - 2] === 255 && data[l - 1] === 255;
        this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);
        if (!flush)
          return;
        raw = this.inflate.result;
      } else {
        raw = data;
      }
      let packet;
      try {
        packet = WebSocket.unpack(raw);
        this.manager.client.emit(Events2.RAW, packet, this.id);
        if (packet.op === OPCodes.DISPATCH)
          this.manager.emit(packet.t, packet.d, this.id);
      } catch (err) {
        this.manager.client.emit(Events2.SHARD_ERROR, err, this.id);
        return;
      }
      this.onPacket(packet);
    }
    onError(event) {
      const error = event && event.error ? event.error : event;
      if (!error)
        return;
      this.manager.client.emit(Events2.SHARD_ERROR, error, this.id);
    }
    onClose(event) {
      if (this.sequence !== -1)
        this.closeSequence = this.sequence;
      this.sequence = -1;
      this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason || "No reason received"}`);
      this.setHeartbeatTimer(-1);
      this.setHelloTimeout(-1);
      if (this.connection)
        this._cleanupConnection();
      this.status = Status2.DISCONNECTED;
      this.emit(ShardEvents.CLOSE, event);
    }
    onPacket(packet) {
      if (!packet) {
        this.debug(`Received broken packet: '${packet}'.`);
        return;
      }
      switch (packet.t) {
        case WSEvents.READY:
          this.emit(ShardEvents.READY);
          this.sessionID = packet.d.session_id;
          this.expectedGuilds = new Set(packet.d.guilds.map((d) => d.id));
          this.status = Status2.WAITING_FOR_GUILDS;
          this.debug(`[READY] Session ${this.sessionID}.`);
          this.lastHeartbeatAcked = true;
          this.sendHeartbeat("ReadyHeartbeat");
          break;
        case WSEvents.RESUMED: {
          this.emit(ShardEvents.RESUMED);
          this.status = Status2.READY;
          const replayed = packet.s - this.closeSequence;
          this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);
          this.lastHeartbeatAcked = true;
          this.sendHeartbeat("ResumeHeartbeat");
          break;
        }
      }
      if (packet.s > this.sequence)
        this.sequence = packet.s;
      switch (packet.op) {
        case OPCodes.HELLO:
          this.setHelloTimeout(-1);
          this.setHeartbeatTimer(packet.d.heartbeat_interval);
          this.identify();
          break;
        case OPCodes.RECONNECT:
          this.debug("[RECONNECT] Discord asked us to reconnect");
          this.destroy({closeCode: 4e3});
          break;
        case OPCodes.INVALID_SESSION:
          this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
          if (packet.d) {
            this.identifyResume();
            return;
          }
          this.sequence = -1;
          this.sessionID = null;
          this.status = Status2.RECONNECTING;
          this.emit(ShardEvents.INVALID_SESSION);
          break;
        case OPCodes.HEARTBEAT_ACK:
          this.ackHeartbeat();
          break;
        case OPCodes.HEARTBEAT:
          this.sendHeartbeat("HeartbeatRequest", true);
          break;
        default:
          this.manager.handlePacket(packet, this);
          if (this.status === Status2.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {
            this.expectedGuilds.delete(packet.d.id);
            this.checkReady();
          }
      }
    }
    checkReady() {
      if (this.readyTimeout) {
        this.manager.client.clearTimeout(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug("Shard received all its guilds. Marking as fully ready.");
        this.status = Status2.READY;
        this.emit(ShardEvents.ALL_READY);
        return;
      }
      this.readyTimeout = this.manager.client.setTimeout(() => {
        this.debug(`Shard did not receive any more guild packets in 15 seconds.
  Unavailable guild count: ${this.expectedGuilds.size}`);
        this.readyTimeout = null;
        this.status = Status2.READY;
        this.emit(ShardEvents.ALL_READY, this.expectedGuilds);
      }, 15e3);
    }
    setHelloTimeout(time) {
      if (time === -1) {
        if (this.helloTimeout) {
          this.debug("Clearing the HELLO timeout.");
          this.manager.client.clearTimeout(this.helloTimeout);
          this.helloTimeout = null;
        }
        return;
      }
      this.debug("Setting a HELLO timeout for 20s.");
      this.helloTimeout = this.manager.client.setTimeout(() => {
        this.debug("Did not receive HELLO in time. Destroying and connecting again.");
        this.destroy({reset: true, closeCode: 4009});
      }, 2e4);
    }
    setHeartbeatTimer(time) {
      if (time === -1) {
        if (this.heartbeatInterval) {
          this.debug("Clearing the heartbeat interval.");
          this.manager.client.clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
        return;
      }
      this.debug(`Setting a heartbeat interval for ${time}ms.`);
      if (this.heartbeatInterval)
        this.manager.client.clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);
    }
    sendHeartbeat(tag = "HeartbeatTimer", ignoreHeartbeatAck = [Status2.WAITING_FOR_GUILDS, Status2.IDENTIFYING, Status2.RESUMING].includes(this.status)) {
      if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
        this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
      } else if (!this.lastHeartbeatAcked) {
        this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
    Status          : ${STATUS_KEYS[this.status]}
    Sequence        : ${this.sequence}
    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : "No Connection??"}`);
        this.destroy({closeCode: 4009, reset: true});
        return;
      }
      this.debug(`[${tag}] Sending a heartbeat.`);
      this.lastHeartbeatAcked = false;
      this.lastPingTimestamp = Date.now();
      this.send({op: OPCodes.HEARTBEAT, d: this.sequence}, true);
    }
    ackHeartbeat() {
      this.lastHeartbeatAcked = true;
      const latency = Date.now() - this.lastPingTimestamp;
      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
      this.ping = latency;
    }
    identify() {
      return this.sessionID ? this.identifyResume() : this.identifyNew();
    }
    identifyNew() {
      const {client} = this.manager;
      if (!client.token) {
        this.debug("[IDENTIFY] No token available to identify a new session.");
        return;
      }
      this.status = Status2.IDENTIFYING;
      const d = {
        ...client.options.ws,
        token: client.token,
        shard: [this.id, Number(client.options.shardCount)]
      };
      this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);
      this.send({op: OPCodes.IDENTIFY, d}, true);
    }
    identifyResume() {
      if (!this.sessionID) {
        this.debug("[RESUME] No session ID was present; identifying as a new session.");
        this.identifyNew();
        return;
      }
      this.status = Status2.RESUMING;
      this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);
      const d = {
        token: this.manager.client.token,
        session_id: this.sessionID,
        seq: this.closeSequence
      };
      this.send({op: OPCodes.RESUME, d}, true);
    }
    send(data, important = false) {
      this.ratelimit.queue[important ? "unshift" : "push"](data);
      this.processQueue();
    }
    _send(data) {
      if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {
        this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);
        this.destroy({close: 4e3});
        return;
      }
      this.connection.send(WebSocket.pack(data), (err) => {
        if (err)
          this.manager.client.emit(Events2.SHARD_ERROR, err, this.id);
      });
    }
    processQueue() {
      if (this.ratelimit.remaining === 0)
        return;
      if (this.ratelimit.queue.length === 0)
        return;
      if (this.ratelimit.remaining === this.ratelimit.total) {
        this.ratelimit.timer = this.manager.client.setTimeout(() => {
          this.ratelimit.remaining = this.ratelimit.total;
          this.processQueue();
        }, this.ratelimit.time);
      }
      while (this.ratelimit.remaining > 0) {
        const item = this.ratelimit.queue.shift();
        if (!item)
          return;
        this._send(item);
        this.ratelimit.remaining--;
      }
    }
    destroy({closeCode = 1e3, reset = false, emit = true, log = true} = {}) {
      if (log) {
        this.debug(`[DESTROY]
    Close Code    : ${closeCode}
    Reset         : ${reset}
    Emit DESTROYED: ${emit}`);
      }
      this.setHeartbeatTimer(-1);
      this.setHelloTimeout(-1);
      if (this.connection) {
        if (this.connection.readyState === WebSocket.OPEN) {
          this.connection.close(closeCode);
        } else {
          this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
          this._cleanupConnection();
          try {
            this.connection.close(closeCode);
          } catch {
          }
          if (emit)
            this._emitDestroyed();
        }
      } else if (emit) {
        this._emitDestroyed();
      }
      this.connection = null;
      this.status = Status2.DISCONNECTED;
      if (this.sequence !== -1)
        this.closeSequence = this.sequence;
      if (reset) {
        this.sequence = -1;
        this.sessionID = null;
      }
      this.ratelimit.remaining = this.ratelimit.total;
      this.ratelimit.queue.length = 0;
      if (this.ratelimit.timer) {
        this.manager.client.clearTimeout(this.ratelimit.timer);
        this.ratelimit.timer = null;
      }
    }
    _cleanupConnection() {
      this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;
    }
    _emitDestroyed() {
      this.emit(ShardEvents.DESTROYED);
    }
  };
  module2.exports = WebSocketShard;
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports2, module2) => {
  "use strict";
  var {WSEvents} = require_Constants();
  var handlers = {};
  for (const name of Object.keys(WSEvents)) {
    try {
      handlers[name] = require(`./${name}.js`);
    } catch {
    }
  }
  module2.exports = handlers;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var {Error: DJSError} = require_errors();
  var Collection2 = require_Collection();
  var {Events: Events2, ShardEvents, Status: Status2, WSCodes, WSEvents} = require_Constants();
  var Util = require_Util();
  var BeforeReadyWhitelist = [
    WSEvents.READY,
    WSEvents.RESUMED,
    WSEvents.GUILD_CREATE,
    WSEvents.GUILD_DELETE,
    WSEvents.GUILD_MEMBERS_CHUNK,
    WSEvents.GUILD_MEMBER_ADD,
    WSEvents.GUILD_MEMBER_REMOVE
  ];
  var UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);
  var UNRESUMABLE_CLOSE_CODES = [1e3, 4006, 4007];
  var WebSocketManager2 = class extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", {value: client});
      this.gateway = null;
      this.totalShards = this.client.options.shards.length;
      this.shards = new Collection2();
      Object.defineProperty(this, "shardQueue", {value: new Set(), writable: true});
      Object.defineProperty(this, "packetQueue", {value: []});
      this.status = Status2.IDLE;
      this.destroyed = false;
      this.reconnecting = false;
      this.sessionStartLimit = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(message, shard) {
      this.client.emit(Events2.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : "Manager"}] ${message}`);
    }
    async connect() {
      const invalidToken = new DJSError(WSCodes[4004]);
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this.client.api.gateway.bot.get().catch((error) => {
        throw error.httpStatus === 401 ? invalidToken : error;
      });
      this.sessionStartLimit = sessionStartLimit;
      const {total, remaining, reset_after} = sessionStartLimit;
      this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
      this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
      this.gateway = `${gatewayURL}/`;
      let {shards} = this.client.options;
      if (shards === "auto") {
        this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
        this.totalShards = this.client.options.shardCount = recommendedShards;
        shards = this.client.options.shards = Array.from({length: recommendedShards}, (_, i) => i);
      }
      this.totalShards = shards.length;
      this.debug(`Spawning shards: ${shards.join(", ")}`);
      this.shardQueue = new Set(shards.map((id) => new WebSocketShard(this, id)));
      await this._handleSessionLimit(remaining, reset_after);
      return this.createShards();
    }
    async createShards() {
      if (!this.shardQueue.size)
        return false;
      const [shard] = this.shardQueue;
      this.shardQueue.delete(shard);
      if (!shard.eventsAttached) {
        shard.on(ShardEvents.ALL_READY, (unavailableGuilds) => {
          this.client.emit(Events2.SHARD_READY, shard.id, unavailableGuilds);
          if (!this.shardQueue.size)
            this.reconnecting = false;
          this.checkShardsReady();
        });
        shard.on(ShardEvents.CLOSE, (event) => {
          if (event.code === 1e3 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {
            this.client.emit(Events2.SHARD_DISCONNECT, event, shard.id);
            this.debug(WSCodes[event.code], shard);
            return;
          }
          if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {
            shard.sessionID = null;
          }
          this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
          this.shardQueue.add(shard);
          if (shard.sessionID) {
            this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);
            this.reconnect(true);
          } else {
            shard.destroy({reset: true, emit: false, log: false});
            this.reconnect();
          }
        });
        shard.on(ShardEvents.INVALID_SESSION, () => {
          this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
        });
        shard.on(ShardEvents.DESTROYED, () => {
          this.debug("Shard was destroyed but no WebSocket connection was present! Reconnecting...", shard);
          this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
          this.shardQueue.add(shard);
          this.reconnect();
        });
        shard.eventsAttached = true;
      }
      this.shards.set(shard.id, shard);
      try {
        await shard.connect();
      } catch (error) {
        if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {
          throw new DJSError(WSCodes[error.code]);
        } else if (!error || error.code) {
          this.debug("Failed to connect to the gateway, requeueing...", shard);
          this.shardQueue.add(shard);
        } else {
          throw error;
        }
      }
      if (this.shardQueue.size) {
        this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
        await Util.delayFor(5e3);
        await this._handleSessionLimit();
        return this.createShards();
      }
      return true;
    }
    async reconnect(skipLimit = false) {
      if (this.reconnecting || this.status !== Status2.READY)
        return false;
      this.reconnecting = true;
      try {
        if (!skipLimit)
          await this._handleSessionLimit();
        await this.createShards();
      } catch (error) {
        this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);
        if (error.httpStatus !== 401) {
          this.debug(`Possible network error occurred. Retrying in 5s...`);
          await Util.delayFor(5e3);
          this.reconnecting = false;
          return this.reconnect();
        }
        if (this.client.listenerCount(Events2.INVALIDATED)) {
          this.client.emit(Events2.INVALIDATED);
          this.destroy();
        } else {
          this.client.destroy();
        }
      } finally {
        this.reconnecting = false;
      }
      return true;
    }
    broadcast(packet) {
      for (const shard of this.shards.values())
        shard.send(packet);
    }
    destroy() {
      if (this.destroyed)
        return;
      this.debug(`Manager was destroyed. Called by:
${new Error("MANAGER_DESTROYED").stack}`);
      this.destroyed = true;
      this.shardQueue.clear();
      for (const shard of this.shards.values())
        shard.destroy({closeCode: 1e3, reset: true, emit: false, log: false});
    }
    async _handleSessionLimit(remaining, resetAfter) {
      if (typeof remaining === "undefined" && typeof resetAfter === "undefined") {
        const {session_start_limit} = await this.client.api.gateway.bot.get();
        this.sessionStartLimit = session_start_limit;
        remaining = session_start_limit.remaining;
        resetAfter = session_start_limit.reset_after;
        this.debug(`Session Limit Information
    Total: ${session_start_limit.total}
    Remaining: ${remaining}`);
      }
      if (!remaining) {
        this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);
        await Util.delayFor(resetAfter);
      }
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status2.READY) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({packet, shard});
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        this.client.setImmediate(() => {
          this.handlePacket(item.packet, item.shard);
        });
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    async checkShardsReady() {
      if (this.status === Status2.READY)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((s) => s.status !== Status2.READY)) {
        return;
      }
      this.status = Status2.NEARLY;
      if (this.client.options.fetchAllMembers) {
        try {
          const promises = this.client.guilds.cache.map((guild) => {
            if (guild.available)
              return guild.members.fetch();
            return Promise.resolve();
          });
          await Promise.all(promises);
        } catch (err) {
          this.debug(`Failed to fetch all members before ready! ${err}
${err.stack}`);
        }
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status2.READY;
      this.client.readyAt = new Date();
      this.client.emit(Events2.CLIENT_READY);
      this.handlePacket();
    }
  };
  module2.exports = WebSocketManager2;
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var Channel = require_Channel();
  var {Events: Events2} = require_Constants();
  var ChannelManager2 = class extends BaseManager {
    constructor(client, iterable) {
      super(client, iterable, Channel);
    }
    add(data, guild, cache = true) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (existing._patch && cache)
          existing._patch(data);
        if (guild)
          guild.channels.add(existing);
        return existing;
      }
      const channel = Channel.create(this.client, data, guild);
      if (!channel) {
        this.client.emit(Events2.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache)
        this.cache.set(channel.id, channel);
      return channel;
    }
    remove(id) {
      const channel = this.cache.get(id);
      if (channel.guild)
        channel.guild.channels.cache.delete(id);
      this.cache.delete(id);
    }
    async fetch(id, cache = true, force = false) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.api.channels(id).get();
      return this.add(data, null, cache);
    }
  };
  module2.exports = ChannelManager2;
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var Guild = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var GuildMember = require_GuildMember();
  var Invite2 = require_Invite();
  var Role = require_Role();
  var {
    ChannelTypes,
    Events: Events2,
    VerificationLevels,
    DefaultMessageNotifications,
    ExplicitContentFilterLevels
  } = require_Constants();
  var DataResolver2 = require_DataResolver();
  var Permissions2 = require_Permissions();
  var {resolveColor} = require_Util();
  var GuildManager2 = class extends BaseManager {
    constructor(client, iterable) {
      super(client, iterable, Guild);
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveID(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
        return super.resolveID(guild.guild.id);
      }
      return super.resolveID(guild);
    }
    async create(name, {
      afkChannelID,
      afkTimeout,
      channels = [],
      defaultMessageNotifications,
      explicitContentFilter,
      icon = null,
      region,
      roles = [],
      systemChannelID,
      verificationLevel
    } = {}) {
      icon = await DataResolver2.resolveImage(icon);
      if (typeof verificationLevel !== "undefined" && typeof verificationLevel !== "number") {
        verificationLevel = VerificationLevels.indexOf(verificationLevel);
      }
      if (typeof defaultMessageNotifications !== "undefined" && typeof defaultMessageNotifications !== "number") {
        defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);
      }
      if (typeof explicitContentFilter !== "undefined" && typeof explicitContentFilter !== "number") {
        explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);
      }
      for (const channel of channels) {
        if (channel.type)
          channel.type = ChannelTypes[channel.type.toUpperCase()];
        channel.parent_id = channel.parentID;
        delete channel.parentID;
        if (!channel.permissionOverwrites)
          continue;
        for (const overwrite of channel.permissionOverwrites) {
          if (overwrite.allow)
            overwrite.allow = Permissions2.resolve(overwrite.allow);
          if (overwrite.deny)
            overwrite.deny = Permissions2.resolve(overwrite.deny);
        }
        channel.permission_overwrites = channel.permissionOverwrites;
        delete channel.permissionOverwrites;
      }
      for (const role of roles) {
        if (role.color)
          role.color = resolveColor(role.color);
        if (role.permissions)
          role.permissions = Permissions2.resolve(role.permissions);
      }
      return new Promise((resolve, reject) => this.client.api.guilds.post({
        data: {
          name,
          region,
          icon,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles,
          channels,
          afk_channel_id: afkChannelID,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelID
        }
      }).then((data) => {
        if (this.client.guilds.cache.has(data.id))
          return resolve(this.client.guilds.cache.get(data.id));
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            this.client.clearTimeout(timeout);
            this.client.removeListener(Events2.GUILD_CREATE, handleGuild);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.on(Events2.GUILD_CREATE, handleGuild);
        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Events2.GUILD_CREATE, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds.add(data));
        }, 1e4);
        return void 0;
      }, reject));
    }
    async fetch(id, cache = true, force = false) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      const data = await this.client.api.guilds(id).get({query: {with_counts: true}});
      return this.add(data, cache);
    }
  };
  module2.exports = GuildManager2;
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports2, module2) => {
  "use strict";
  var BaseManager = require_BaseManager();
  var GuildMember = require_GuildMember();
  var Message = require_Message();
  var User = require_User();
  var UserManager2 = class extends BaseManager {
    constructor(client, iterable) {
      super(client, iterable, User);
    }
    resolve(user) {
      if (user instanceof GuildMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveID(user) {
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveID(user);
    }
    async fetch(id, cache = true, force = false) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.api.users(id).get();
      return this.add(data, cache);
    }
  };
  module2.exports = UserManager2;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports2, module2) => {
  "use strict";
  var {Events: Events2} = require_Constants();
  var Util = require_Util();
  var ShardClientUtil2 = class {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      if (mode === "process") {
        process.on("message", this._handleMessage.bind(this));
        client.on("ready", () => {
          process.send({_ready: true});
        });
        client.on("disconnect", () => {
          process.send({_disconnect: true});
        });
        client.on("reconnecting", () => {
          process.send({_reconnecting: true});
        });
      } else if (mode === "worker") {
        this.parentPort = require("worker_threads").parentPort;
        this.parentPort.on("message", this._handleMessage.bind(this));
        client.on("ready", () => {
          this.parentPort.postMessage({_ready: true});
        });
        client.on("disconnect", () => {
          this.parentPort.postMessage({_disconnect: true});
        });
        client.on("reconnecting", () => {
          this.parentPort.postMessage({_reconnecting: true});
        });
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.mode === "process") {
          process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve();
          });
        } else if (this.mode === "worker") {
          this.parentPort.postMessage(message);
          resolve();
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort || process;
        const listener = (message) => {
          if (!message || message._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util.makeError(message._error));
        };
        parent.on("message", listener);
        this.send({_sFetchProp: prop, _sFetchPropShard: shard}).catch((err) => {
          parent.removeListener("message", listener);
          reject(err);
        });
      });
    }
    broadcastEval(script, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort || process;
        script = typeof script === "function" ? `(${script})(this)` : script;
        const listener = (message) => {
          if (!message || message._sEval !== script || message._sEvalShard !== shard)
            return;
          parent.removeListener("message", listener);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util.makeError(message._error));
        };
        parent.on("message", listener);
        this.send({_sEval: script, _sEvalShard: shard}).catch((err) => {
          parent.removeListener("message", listener);
          reject(err);
        });
      });
    }
    respawnAll(shardDelay = 5e3, respawnDelay = 500, spawnTimeout = 3e4) {
      return this.send({_sRespawnAll: {shardDelay, respawnDelay, spawnTimeout}});
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        const props = message._fetchProp.split(".");
        let value = this.client;
        for (const prop of props)
          value = value[prop];
        this._respond("fetchProp", {_fetchProp: message._fetchProp, _result: value});
      } else if (message._eval) {
        try {
          this._respond("eval", {_eval: message._eval, _result: await this.client._eval(message._eval)});
        } catch (err) {
          this._respond("eval", {_eval: message._eval, _error: Util.makePlainError(err)});
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        err.message = `Error when sending ${type} response to master process: ${err.message}`;
        this.client.emit(Events2.ERROR, err);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events2.WARN, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIDForGuildID(guildID, shardCount) {
      const shard = Number(BigInt(guildID) >> 22n) % shardCount;
      if (shard < 0)
        throw new Error("SHARDING_SHARD_MISCALCULATION", shard, guildID, shardCount);
      return shard;
    }
  };
  module2.exports = ShardClientUtil2;
});

// node_modules/discord.js/src/util/Intents.js
var require_Intents = __commonJS((exports2, module2) => {
  "use strict";
  var BitField = require_BitField();
  var Intents2 = class extends BitField {
  };
  Intents2.FLAGS = {
    GUILDS: 1 << 0,
    GUILD_MEMBERS: 1 << 1,
    GUILD_BANS: 1 << 2,
    GUILD_EMOJIS: 1 << 3,
    GUILD_INTEGRATIONS: 1 << 4,
    GUILD_WEBHOOKS: 1 << 5,
    GUILD_INVITES: 1 << 6,
    GUILD_VOICE_STATES: 1 << 7,
    GUILD_PRESENCES: 1 << 8,
    GUILD_MESSAGES: 1 << 9,
    GUILD_MESSAGE_REACTIONS: 1 << 10,
    GUILD_MESSAGE_TYPING: 1 << 11,
    DIRECT_MESSAGES: 1 << 12,
    DIRECT_MESSAGE_REACTIONS: 1 << 13,
    DIRECT_MESSAGE_TYPING: 1 << 14
  };
  Intents2.PRIVILEGED = Intents2.FLAGS.GUILD_MEMBERS | Intents2.FLAGS.GUILD_PRESENCES;
  Intents2.ALL = Object.values(Intents2.FLAGS).reduce((acc, p) => acc | p, 0);
  Intents2.NON_PRIVILEGED = Intents2.ALL & ~Intents2.PRIVILEGED;
  module2.exports = Intents2;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  "use strict";
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var {Error, TypeError, RangeError} = require_errors();
  var ChannelManager = require_ChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientApplication = require_ClientApplication();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Collection = require_Collection();
  var {Events, browser, DefaultOptions} = require_Constants();
  var DataResolver = require_DataResolver();
  var Intents = require_Intents();
  var Permissions = require_Permissions();
  var Structures = require_Structures();
  var Client = class extends BaseClient {
    constructor(options = {}) {
      super(Object.assign({_tokenType: "Bot"}, options));
      let data = process.env;
      try {
        data = require("worker_threads").workerData || data;
      } catch {
      }
      if (this.options.shards === DefaultOptions.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === DefaultOptions.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({length: this.options.shardCount}, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = !browser ? new ClientVoiceManager(this) : null;
      this.shard = !browser && process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      const ClientPresence = Structures.get("ClientPresence");
      this.presence = new ClientPresence(this);
      Object.defineProperty(this, "token", {writable: true});
      if (!browser && !this.token && "DISCORD_TOKEN" in process.env) {
        this.token = process.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.readyAt = null;
      if (this.options.messageSweepInterval > 0) {
        this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1e3);
      }
    }
    get emojis() {
      const emojis = new GuildEmojiManager({client: this});
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyTimestamp() {
      return this.readyAt ? this.readyAt.getTime() : null;
    }
    get uptime() {
      return this.readyAt ? Date.now() - this.readyAt : null;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new Error("TOKEN_INVALID");
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.emit(Events.DEBUG, `Provided token: ${token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".")}`);
      if (this.options.presence) {
        this.options.ws.presence = await this.presence._parse(this.options.presence);
      }
      this.emit(Events.DEBUG, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        this.destroy();
        throw error;
      }
    }
    destroy() {
      super.destroy();
      this.ws.destroy();
      this.token = null;
    }
    fetchInvite(invite) {
      const code = DataResolver.resolveInviteCode(invite);
      return this.api.invites(code).get({query: {with_counts: true}}).then((data) => new Invite(this, data));
    }
    fetchGuildTemplate(template) {
      const code = DataResolver.resolveGuildTemplateCode(template);
      return this.api.guilds.templates(code).get().then((data) => new GuildTemplate(this, data));
    }
    fetchWebhook(id, token) {
      return this.api.webhooks(id, token).get().then((data) => new Webhook(this, data));
    }
    fetchVoiceRegions() {
      return this.api.voice.regions.get().then((res) => {
        const regions = new Collection();
        for (const region of res)
          regions.set(region.id, new VoiceRegion(region));
        return regions;
      });
    }
    sweepMessages(lifetime = this.options.messageCacheLifetime) {
      if (typeof lifetime !== "number" || isNaN(lifetime)) {
        throw new TypeError("INVALID_TYPE", "lifetime", "number");
      }
      if (lifetime <= 0) {
        this.emit(Events.DEBUG, "Didn't sweep messages - lifetime is unlimited");
        return -1;
      }
      const lifetimeMs = lifetime * 1e3;
      const now = Date.now();
      let channels = 0;
      let messages = 0;
      for (const channel of this.channels.cache.values()) {
        if (!channel.messages)
          continue;
        channels++;
        messages += channel.messages.cache.sweep((message) => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);
      }
      this.emit(Events.DEBUG, `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);
      return messages;
    }
    fetchApplication() {
      return this.api.oauth2.applications("@me").get().then((app) => new ClientApplication(this, app));
    }
    fetchGuildPreview(guild) {
      const id = this.guilds.resolveID(guild);
      if (!id)
        throw new TypeError("INVALID_TYPE", "guild", "GuildResolvable");
      return this.api.guilds(id).preview.get().then((data) => new GuildPreview(this, data));
    }
    async generateInvite(options = {}) {
      if (Array.isArray(options) || ["string", "number"].includes(typeof options) || options instanceof Permissions) {
        process.emitWarning("Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable", "DeprecationWarning");
        options = {permissions: options};
      }
      const application = await this.fetchApplication();
      const query = new URLSearchParams({
        client_id: application.id,
        permissions: Permissions.resolve(options.permissions),
        scope: "bot"
      });
      if (typeof options.disableGuildSelect === "boolean") {
        query.set("disable_guild_select", options.disableGuildSelect.toString());
      }
      if (typeof options.guild !== "undefined") {
        const guildID = this.guilds.resolveID(options.guild);
        if (!guildID)
          throw new TypeError("INVALID_TYPE", "options.guild", "GuildResolvable");
        query.set("guild_id", guildID);
      }
      return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        readyAt: false
      });
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (typeof options.ws.intents !== "undefined") {
        options.ws.intents = Intents.resolve(options.ws.intents);
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new TypeError("CLIENT_INVALID_OPTION", "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new TypeError("CLIENT_INVALID_OPTION", "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new RangeError("CLIENT_INVALID_PROVIDED_SHARDS");
      if (typeof options.messageCacheMaxSize !== "number" || isNaN(options.messageCacheMaxSize)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "messageCacheMaxSize", "a number");
      }
      if (typeof options.messageCacheLifetime !== "number" || isNaN(options.messageCacheLifetime)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "The messageCacheLifetime", "a number");
      }
      if (typeof options.messageSweepInterval !== "number" || isNaN(options.messageSweepInterval)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "messageSweepInterval", "a number");
      }
      if (typeof options.messageEditHistoryMaxSize !== "number" || isNaN(options.messageEditHistoryMaxSize) || options.messageEditHistoryMaxSize < -1) {
        throw new TypeError("CLIENT_INVALID_OPTION", "messageEditHistoryMaxSize", "a number greater than or equal to -1");
      }
      if (typeof options.fetchAllMembers !== "boolean") {
        throw new TypeError("CLIENT_INVALID_OPTION", "fetchAllMembers", "a boolean");
      }
      if (typeof options.disableMentions !== "string") {
        throw new TypeError("CLIENT_INVALID_OPTION", "disableMentions", "a string");
      }
      if (!Array.isArray(options.partials)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "partials", "an Array");
      }
      if (typeof options.restWsBridgeTimeout !== "number" || isNaN(options.restWsBridgeTimeout)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "restWsBridgeTimeout", "a number");
      }
      if (typeof options.restRequestTimeout !== "number" || isNaN(options.restRequestTimeout)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "restRequestTimeout", "a number");
      }
      if (typeof options.restSweepInterval !== "number" || isNaN(options.restSweepInterval)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "restSweepInterval", "a number");
      }
      if (typeof options.retryLimit !== "number" || isNaN(options.retryLimit)) {
        throw new TypeError("CLIENT_INVALID_OPTION", "retryLimit", "a number");
      }
    }
  };
  module.exports = Client;
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var path = require("path");
  var {Error: Error2} = require_errors();
  var Util = require_Util();
  var childProcess = null;
  var Worker = null;
  var Shard = class extends EventEmitter {
    constructor(manager, id) {
      super();
      if (manager.mode === "process")
        childProcess = require("child_process");
      else if (manager.mode === "worker")
        Worker = require("worker_threads").Worker;
      this.manager = manager;
      this.id = id;
      this.args = manager.shardArgs || [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map();
      this._fetches = new Map();
      this._exitListener = this._handleExit.bind(this, void 0);
    }
    async spawn(spawnTimeout = 3e4) {
      if (this.process)
        throw new Error2("SHARDING_PROCESS_EXISTS", this.id);
      if (this.worker)
        throw new Error2("SHARDING_WORKER_EXISTS", this.id);
      if (this.manager.mode === "process") {
        this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
          env: this.env,
          execArgv: this.execArgv
        }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
      } else if (this.manager.mode === "worker") {
        this.worker = new Worker(path.resolve(this.manager.file), {workerData: this.env}).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
      }
      this._evals.clear();
      this._fetches.clear();
      this.emit("spawn", this.process || this.worker);
      if (spawnTimeout === -1 || spawnTimeout === Infinity)
        return this.process || this.worker;
      await new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve();
        };
        const onDisconnect = () => {
          cleanup();
          reject(new Error2("SHARDING_READY_DISCONNECTED", this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new Error2("SHARDING_READY_DIED", this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new Error2("SHARDING_READY_TIMEOUT", this.id));
        };
        const spawnTimeoutTimer = setTimeout(onTimeout, spawnTimeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
      return this.process || this.worker;
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn(delay = 500, spawnTimeout) {
      this.kill();
      if (delay > 0)
        await Util.delayFor(delay);
      return this.spawn(spawnTimeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    fetchClientValue(prop) {
      if (!this.process && !this.worker)
        return Promise.reject(new Error2("SHARDING_NO_CHILD_EXISTS", this.id));
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process || this.worker;
        const listener = (message) => {
          if (!message || message._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this._fetches.delete(prop);
          resolve(message._result);
        };
        child.on("message", listener);
        this.send({_fetchProp: prop}).catch((err) => {
          child.removeListener("message", listener);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    eval(script) {
      if (!this.process && !this.worker)
        return Promise.reject(new Error2("SHARDING_NO_CHILD_EXISTS", this.id));
      if (this._evals.has(script))
        return this._evals.get(script);
      const promise = new Promise((resolve, reject) => {
        const child = this.process || this.worker;
        const listener = (message) => {
          if (!message || message._eval !== script)
            return;
          child.removeListener("message", listener);
          this._evals.delete(script);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util.makeError(message._error));
        };
        child.on("message", listener);
        const _eval = typeof script === "function" ? `(${script})(this)` : script;
        this.send({_eval}).catch((err) => {
          child.removeListener("message", listener);
          this._evals.delete(script);
          reject(err);
        });
      });
      this._evals.set(script, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit("ready");
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit("disconnect");
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit("reconnecting");
          return;
        }
        if (message._sFetchProp) {
          const resp = {_sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard};
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({...resp, _result: results}), (err) => this.send({...resp, _error: Util.makePlainError(err)}));
          return;
        }
        if (message._sEval) {
          const resp = {_sEval: message._sEval, _sEvalShard: message._sEvalShard};
          this.manager.broadcastEval(message._sEval, message._sEvalShard).then((results) => this.send({...resp, _result: results}), (err) => this.send({...resp, _error: Util.makePlainError(err)}));
          return;
        }
        if (message._sRespawnAll) {
          const {shardDelay, respawnDelay, spawnTimeout} = message._sRespawnAll;
          this.manager.respawnAll(shardDelay, respawnDelay, spawnTimeout).catch(() => {
          });
          return;
        }
      }
      this.emit("message", message);
    }
    _handleExit(respawn = this.manager.respawn) {
      this.emit("death", this.process || this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn().catch((err) => this.emit("error", err));
    }
  };
  module2.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var fs = require("fs");
  var path = require("path");
  var Shard = require_Shard();
  var {Error: Error2, TypeError: TypeError2, RangeError: RangeError2} = require_errors();
  var Collection2 = require_Collection();
  var Util = require_Util();
  var ShardingManager = class extends EventEmitter {
    constructor(file, options = {}) {
      super();
      options = Util.mergeDefault({
        totalShards: "auto",
        mode: "process",
        respawn: true,
        shardArgs: [],
        execArgv: [],
        token: process.env.DISCORD_TOKEN
      }, options);
      this.file = file;
      if (!file)
        throw new Error2("CLIENT_INVALID_OPTION", "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new Error2("CLIENT_INVALID_OPTION", "File", "a file");
      this.shardList = options.shardList || "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new TypeError2("CLIENT_INVALID_OPTION", "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1)
          throw new RangeError2("CLIENT_INVALID_OPTION", "shardList", "at least 1 ID.");
        if (this.shardList.some((shardID) => typeof shardID !== "number" || isNaN(shardID) || !Number.isInteger(shardID) || shardID < 0)) {
          throw new TypeError2("CLIENT_INVALID_OPTION", "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "a number.");
        }
        if (this.totalShards < 1)
          throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "at least 1.");
        if (!Number.isInteger(this.totalShards)) {
          throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "an integer.");
        }
      }
      this.mode = options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new RangeError2("CLIENT_INVALID_OPTION", "Sharding mode", '"process" or "worker"');
      }
      this.respawn = options.respawn;
      this.shardArgs = options.shardArgs;
      this.execArgv = options.execArgv;
      this.token = options.token ? options.token.replace(/^Bot\s*/i, "") : null;
      this.shards = new Collection2();
      process.env.SHARDING_MANAGER = true;
      process.env.SHARDING_MANAGER_MODE = this.mode;
      process.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn(amount = this.totalShards, delay = 5500, spawnTimeout) {
      if (amount === "auto") {
        amount = await Util.fetchRecommendedShards(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new Error2("SHARDING_ALREADY_SPAWNED", this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardID) => shardID >= amount)) {
        throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "bigger than the highest shardID in the shardList option.");
      }
      for (const shardID of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardID);
        promises.push(shard.spawn(spawnTimeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(Util.delayFor(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    broadcastEval(script, shard) {
      return this._performOnShards("eval", [script], shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        return Promise.reject(new Error2("SHARDING_NO_SHARDS"));
      if (this.shards.size !== this.shardList.length)
        return Promise.reject(new Error2("SHARDING_IN_PROCESS"));
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        return Promise.reject(new Error2("SHARDING_SHARD_NOT_FOUND", shard));
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll(shardDelay = 5e3, respawnDelay = 500, spawnTimeout) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn(respawnDelay, spawnTimeout)];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(Util.delayFor(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  };
  module2.exports = ShardingManager;
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports2, module2) => {
  "use strict";
  var DataResolver2 = require_DataResolver();
  var Structures2 = require_Structures();
  var ClientUser = class extends Structures2.get("User") {
    constructor(client, data) {
      super(client, data);
      this._typing = new Map();
    }
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else if (typeof this.mfaEnabled === "undefined") {
        this.mfaEnabled = null;
      }
      if (data.token)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    edit(data) {
      return this.client.api.users("@me").patch({data}).then((newData) => {
        this.client.token = newData.token;
        const {updated} = this.client.actions.UserUpdate.handle(newData);
        if (updated)
          return updated;
        return this;
      });
    }
    setUsername(username) {
      return this.edit({username});
    }
    async setAvatar(avatar) {
      return this.edit({avatar: await DataResolver2.resolveImage(avatar)});
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardID) {
      return this.setPresence({status, shardID});
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({activity: null, shardID: options.shardID});
      const activity = Object.assign({}, options, typeof name === "object" ? name : {name});
      return this.setPresence({activity, shardID: activity.shardID});
    }
    setAFK(afk) {
      return this.setPresence({afk});
    }
  };
  module2.exports = ClientUser;
});

// node_modules/discord.js/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var Util = require_Util();
  module2.exports = {
    BaseClient: require_BaseClient(),
    Client: require_Client(),
    Shard: require_Shard(),
    ShardClientUtil: require_ShardClientUtil(),
    ShardingManager: require_ShardingManager(),
    WebhookClient: require_WebhookClient(),
    ActivityFlags: require_ActivityFlags(),
    BitField: require_BitField(),
    Collection: require_Collection(),
    Constants: require_Constants(),
    DataResolver: require_DataResolver(),
    BaseManager: require_BaseManager(),
    DiscordAPIError: require_DiscordAPIError(),
    HTTPError: require_HTTPError(),
    MessageFlags: require_MessageFlags(),
    Intents: require_Intents(),
    Permissions: require_Permissions(),
    Speaking: require_Speaking(),
    Snowflake: require_Snowflake(),
    SnowflakeUtil: require_Snowflake(),
    Structures: require_Structures(),
    SystemChannelFlags: require_SystemChannelFlags(),
    UserFlags: require_UserFlags(),
    Util,
    version: require_package().version,
    ChannelManager: require_ChannelManager(),
    GuildChannelManager: require_GuildChannelManager(),
    GuildEmojiManager: require_GuildEmojiManager(),
    GuildEmojiRoleManager: require_GuildEmojiRoleManager(),
    GuildMemberManager: require_GuildMemberManager(),
    GuildMemberRoleManager: require_GuildMemberRoleManager(),
    GuildManager: require_GuildManager(),
    ReactionManager: require_ReactionManager(),
    ReactionUserManager: require_ReactionUserManager(),
    MessageManager: require_MessageManager(),
    PresenceManager: require_PresenceManager(),
    RoleManager: require_RoleManager(),
    UserManager: require_UserManager(),
    discordSort: Util.discordSort,
    escapeMarkdown: Util.escapeMarkdown,
    fetchRecommendedShards: Util.fetchRecommendedShards,
    resolveColor: Util.resolveColor,
    resolveString: Util.resolveString,
    splitMessage: Util.splitMessage,
    Application: require_Application(),
    Base: require_Base(),
    Activity: require_Presence().Activity,
    APIMessage: require_APIMessage(),
    BaseGuildEmoji: require_BaseGuildEmoji(),
    CategoryChannel: require_CategoryChannel(),
    Channel: require_Channel(),
    ClientApplication: require_ClientApplication(),
    get ClientUser() {
      return require_ClientUser();
    },
    Collector: require_Collector(),
    DMChannel: require_DMChannel(),
    Emoji: require_Emoji(),
    Guild: require_Guild(),
    GuildAuditLogs: require_GuildAuditLogs(),
    GuildChannel: require_GuildChannel(),
    GuildEmoji: require_GuildEmoji(),
    GuildMember: require_GuildMember(),
    GuildPreview: require_GuildPreview(),
    GuildTemplate: require_GuildTemplate(),
    Integration: require_Integration(),
    Invite: require_Invite(),
    Message: require_Message(),
    MessageAttachment: require_MessageAttachment(),
    MessageCollector: require_MessageCollector(),
    MessageEmbed: require_MessageEmbed(),
    MessageMentions: require_MessageMentions(),
    MessageReaction: require_MessageReaction(),
    NewsChannel: require_NewsChannel(),
    PermissionOverwrites: require_PermissionOverwrites(),
    Presence: require_Presence().Presence,
    ClientPresence: require_ClientPresence(),
    ReactionCollector: require_ReactionCollector(),
    ReactionEmoji: require_ReactionEmoji(),
    RichPresenceAssets: require_Presence().RichPresenceAssets,
    Role: require_Role(),
    StoreChannel: require_StoreChannel(),
    Team: require_Team(),
    TeamMember: require_TeamMember(),
    TextChannel: require_TextChannel(),
    User: require_User(),
    VoiceChannel: require_VoiceChannel(),
    VoiceRegion: require_VoiceRegion(),
    VoiceState: require_VoiceState(),
    Webhook: require_Webhook(),
    WebSocket: require_WebSocket()
  };
});

// node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug6(...args) {
        if (!debug6.enabled) {
          return;
        }
        const self2 = debug6;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug6.namespace = namespace;
      debug6.useColors = createDebug.useColors();
      debug6.color = createDebug.selectColor(namespace);
      debug6.extend = extend;
      debug6.destroy = createDebug.destroy;
      Object.defineProperty(debug6, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug6);
      }
      return debug6;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug6) {
    debug6.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug6.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof global.Map !== "undefined") {
    module2.exports = global.Map;
    module2.exports.Map = global.Map;
  } else {
    Map2 = function(array) {
      this._keys = [];
      this._values = {};
      for (var i = 0; i < array.length; i++) {
        if (array[i] == null)
          continue;
        var entry = array[i];
        var key = entry[0];
        var value = entry[1];
        this._keys.push(key);
        this._values[key] = {v: value, i: this._keys.length - 1};
      }
    };
    Map2.prototype.clear = function() {
      this._keys = [];
      this._values = {};
    };
    Map2.prototype.delete = function(key) {
      var value = this._values[key];
      if (value == null)
        return false;
      delete this._values[key];
      this._keys.splice(value.i, 1);
      return true;
    };
    Map2.prototype.entries = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? [key, self2._values[key].v] : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.forEach = function(callback, self2) {
      self2 = self2 || this;
      for (var i = 0; i < this._keys.length; i++) {
        var key = this._keys[i];
        callback.call(self2, this._values[key].v, key, self2);
      }
    };
    Map2.prototype.get = function(key) {
      return this._values[key] ? this._values[key].v : void 0;
    };
    Map2.prototype.has = function(key) {
      return this._values[key] != null;
    };
    Map2.prototype.keys = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? key : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.set = function(key, value) {
      if (this._values[key]) {
        this._values[key].v = value;
        return this;
      }
      this._keys.push(key);
      this._values[key] = {v: value, i: this._keys.length - 1};
      return this;
    };
    Map2.prototype.values = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? self2._values[key].v : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Object.defineProperty(Map2.prototype, "size", {
      enumerable: true,
      get: function() {
        return this._keys.length;
      }
    });
    module2.exports = Map2;
    module2.exports.Map = Map2;
  }
  var Map2;
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS((exports2, module2) => {
  function Long2(low, high) {
    if (!(this instanceof Long2))
      return new Long2(low, high);
    this._bsontype = "Long";
    this.low_ = low | 0;
    this.high_ = high | 0;
  }
  Long2.prototype.toInt = function() {
    return this.low_;
  };
  Long2.prototype.toNumber = function() {
    return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  Long2.prototype.toJSON = function() {
    return this.toString();
  };
  Long2.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.equals(Long2.MIN_VALUE)) {
        var radixLong = Long2.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return "-" + this.negate().toString(radix);
      }
    }
    var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
    rem = this;
    var result = "";
    while (!rem.isZero()) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = "0" + digits;
        }
        result = "" + digits + result;
      }
    }
  };
  Long2.prototype.getHighBits = function() {
    return this.high_;
  };
  Long2.prototype.getLowBits = function() {
    return this.low_;
  };
  Long2.prototype.getLowBitsUnsigned = function() {
    return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
  };
  Long2.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(Long2.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ !== 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }
      return this.high_ !== 0 ? bit + 33 : bit + 1;
    }
  };
  Long2.prototype.isZero = function() {
    return this.high_ === 0 && this.low_ === 0;
  };
  Long2.prototype.isNegative = function() {
    return this.high_ < 0;
  };
  Long2.prototype.isOdd = function() {
    return (this.low_ & 1) === 1;
  };
  Long2.prototype.equals = function(other) {
    return this.high_ === other.high_ && this.low_ === other.low_;
  };
  Long2.prototype.notEquals = function(other) {
    return this.high_ !== other.high_ || this.low_ !== other.low_;
  };
  Long2.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };
  Long2.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };
  Long2.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };
  Long2.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };
  Long2.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }
    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  Long2.prototype.negate = function() {
    if (this.equals(Long2.MIN_VALUE)) {
      return Long2.MIN_VALUE;
    } else {
      return this.not().add(Long2.ONE);
    }
  };
  Long2.prototype.add = function(other) {
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Long2.prototype.subtract = function(other) {
    return this.add(other.negate());
  };
  Long2.prototype.multiply = function(other) {
    if (this.isZero()) {
      return Long2.ZERO;
    } else if (other.isZero()) {
      return Long2.ZERO;
    }
    if (this.equals(Long2.MIN_VALUE)) {
      return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
    } else if (other.equals(Long2.MIN_VALUE)) {
      return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }
    if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
      return Long2.fromNumber(this.toNumber() * other.toNumber());
    }
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Long2.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error("division by zero");
    } else if (this.isZero()) {
      return Long2.ZERO;
    }
    if (this.equals(Long2.MIN_VALUE)) {
      if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
        return Long2.MIN_VALUE;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ONE;
      } else {
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(Long2.ZERO)) {
          return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(Long2.MIN_VALUE)) {
      return Long2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }
    var res = Long2.ZERO;
    rem = this;
    while (rem.greaterThanOrEqual(other)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
      var approxRes = Long2.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = Long2.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }
      if (approxRes.isZero()) {
        approxRes = Long2.ONE;
      }
      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };
  Long2.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };
  Long2.prototype.not = function() {
    return Long2.fromBits(~this.low_, ~this.high_);
  };
  Long2.prototype.and = function(other) {
    return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
  };
  Long2.prototype.or = function(other) {
    return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
  };
  Long2.prototype.xor = function(other) {
    return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
  };
  Long2.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
      } else {
        return Long2.fromBits(0, low << numBits - 32);
      }
    }
  };
  Long2.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
      } else {
        return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
      }
    }
  };
  Long2.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
      } else if (numBits === 32) {
        return Long2.fromBits(high, 0);
      } else {
        return Long2.fromBits(high >>> numBits - 32, 0);
      }
    }
  };
  Long2.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = Long2.INT_CACHE_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }
    var obj = new Long2(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      Long2.INT_CACHE_[value] = obj;
    }
    return obj;
  };
  Long2.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return Long2.ZERO;
    } else if (value <= -Long2.TWO_PWR_63_DBL_) {
      return Long2.MIN_VALUE;
    } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
      return Long2.MAX_VALUE;
    } else if (value < 0) {
      return Long2.fromNumber(-value).negate();
    } else {
      return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
    }
  };
  Long2.fromBits = function(lowBits, highBits) {
    return new Long2(lowBits, highBits);
  };
  Long2.fromString = function(str, opt_radix) {
    if (str.length === 0) {
      throw Error("number format error: empty string");
    }
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (str.charAt(0) === "-") {
      return Long2.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf("-") >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }
    var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
    var result = Long2.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = Long2.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(Long2.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(Long2.fromNumber(value));
      }
    }
    return result;
  };
  Long2.INT_CACHE_ = {};
  Long2.TWO_PWR_16_DBL_ = 1 << 16;
  Long2.TWO_PWR_24_DBL_ = 1 << 24;
  Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
  Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
  Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
  Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
  Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
  Long2.ZERO = Long2.fromInt(0);
  Long2.ONE = Long2.fromInt(1);
  Long2.NEG_ONE = Long2.fromInt(-1);
  Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
  Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
  Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
  module2.exports = Long2;
  module2.exports.Long = Long2;
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS((exports2, module2) => {
  function Double2(value) {
    if (!(this instanceof Double2))
      return new Double2(value);
    this._bsontype = "Double";
    this.value = value;
  }
  Double2.prototype.valueOf = function() {
    return this.value;
  };
  Double2.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Double2;
  module2.exports.Double = Double2;
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  function Timestamp2(low, high) {
    if (!(this instanceof Timestamp2))
      return new Timestamp2(low, high);
    this._bsontype = "Timestamp";
    this.low_ = low | 0;
    this.high_ = high | 0;
  }
  Timestamp2.prototype.toInt = function() {
    return this.low_;
  };
  Timestamp2.prototype.toNumber = function() {
    return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  Timestamp2.prototype.toJSON = function() {
    return this.toString();
  };
  Timestamp2.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        var radixTimestamp = Timestamp2.fromNumber(radix);
        var div = this.div(radixTimestamp);
        var rem = div.multiply(radixTimestamp).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return "-" + this.negate().toString(radix);
      }
    }
    var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
    rem = this;
    var result = "";
    while (!rem.isZero()) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = "0" + digits;
        }
        result = "" + digits + result;
      }
    }
  };
  Timestamp2.prototype.getHighBits = function() {
    return this.high_;
  };
  Timestamp2.prototype.getLowBits = function() {
    return this.low_;
  };
  Timestamp2.prototype.getLowBitsUnsigned = function() {
    return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
  };
  Timestamp2.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ !== 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }
      return this.high_ !== 0 ? bit + 33 : bit + 1;
    }
  };
  Timestamp2.prototype.isZero = function() {
    return this.high_ === 0 && this.low_ === 0;
  };
  Timestamp2.prototype.isNegative = function() {
    return this.high_ < 0;
  };
  Timestamp2.prototype.isOdd = function() {
    return (this.low_ & 1) === 1;
  };
  Timestamp2.prototype.equals = function(other) {
    return this.high_ === other.high_ && this.low_ === other.low_;
  };
  Timestamp2.prototype.notEquals = function(other) {
    return this.high_ !== other.high_ || this.low_ !== other.low_;
  };
  Timestamp2.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };
  Timestamp2.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };
  Timestamp2.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };
  Timestamp2.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };
  Timestamp2.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }
    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  Timestamp2.prototype.negate = function() {
    if (this.equals(Timestamp2.MIN_VALUE)) {
      return Timestamp2.MIN_VALUE;
    } else {
      return this.not().add(Timestamp2.ONE);
    }
  };
  Timestamp2.prototype.add = function(other) {
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Timestamp2.prototype.subtract = function(other) {
    return this.add(other.negate());
  };
  Timestamp2.prototype.multiply = function(other) {
    if (this.isZero()) {
      return Timestamp2.ZERO;
    } else if (other.isZero()) {
      return Timestamp2.ZERO;
    }
    if (this.equals(Timestamp2.MIN_VALUE)) {
      return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
    } else if (other.equals(Timestamp2.MIN_VALUE)) {
      return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }
    if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
      return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
    }
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Timestamp2.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error("division by zero");
    } else if (this.isZero()) {
      return Timestamp2.ZERO;
    }
    if (this.equals(Timestamp2.MIN_VALUE)) {
      if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
        return Timestamp2.MIN_VALUE;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ONE;
      } else {
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(Timestamp2.ZERO)) {
          return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(Timestamp2.MIN_VALUE)) {
      return Timestamp2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }
    var res = Timestamp2.ZERO;
    rem = this;
    while (rem.greaterThanOrEqual(other)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
      var approxRes = Timestamp2.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = Timestamp2.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }
      if (approxRes.isZero()) {
        approxRes = Timestamp2.ONE;
      }
      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };
  Timestamp2.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };
  Timestamp2.prototype.not = function() {
    return Timestamp2.fromBits(~this.low_, ~this.high_);
  };
  Timestamp2.prototype.and = function(other) {
    return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
  };
  Timestamp2.prototype.or = function(other) {
    return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
  };
  Timestamp2.prototype.xor = function(other) {
    return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
  };
  Timestamp2.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
      } else {
        return Timestamp2.fromBits(0, low << numBits - 32);
      }
    }
  };
  Timestamp2.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
      } else {
        return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
      }
    }
  };
  Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
      } else if (numBits === 32) {
        return Timestamp2.fromBits(high, 0);
      } else {
        return Timestamp2.fromBits(high >>> numBits - 32, 0);
      }
    }
  };
  Timestamp2.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = Timestamp2.INT_CACHE_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }
    var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      Timestamp2.INT_CACHE_[value] = obj;
    }
    return obj;
  };
  Timestamp2.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return Timestamp2.ZERO;
    } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
      return Timestamp2.MIN_VALUE;
    } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
      return Timestamp2.MAX_VALUE;
    } else if (value < 0) {
      return Timestamp2.fromNumber(-value).negate();
    } else {
      return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
    }
  };
  Timestamp2.fromBits = function(lowBits, highBits) {
    return new Timestamp2(lowBits, highBits);
  };
  Timestamp2.fromString = function(str, opt_radix) {
    if (str.length === 0) {
      throw Error("number format error: empty string");
    }
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (str.charAt(0) === "-") {
      return Timestamp2.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf("-") >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }
    var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
    var result = Timestamp2.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = Timestamp2.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(Timestamp2.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(Timestamp2.fromNumber(value));
      }
    }
    return result;
  };
  Timestamp2.INT_CACHE_ = {};
  Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
  Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
  Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
  Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
  Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
  Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
  Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
  Timestamp2.ZERO = Timestamp2.fromInt(0);
  Timestamp2.ONE = Timestamp2.fromInt(1);
  Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
  Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
  Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
  Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
  module2.exports = Timestamp2;
  module2.exports.Timestamp = Timestamp2;
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS((exports2, module2) => {
  "use strict";
  function normalizedFunctionString(fn) {
    return fn.toString().replace(/function *\(/, "function (");
  }
  function newBuffer(item, encoding) {
    return new Buffer(item, encoding);
  }
  function allocBuffer() {
    return Buffer.alloc.apply(Buffer, arguments);
  }
  function toBuffer() {
    return Buffer.from.apply(Buffer, arguments);
  }
  module2.exports = {
    normalizedFunctionString,
    allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
    toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
  };
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS((exports2, module2) => {
  var inspect = "inspect";
  var utils2 = require_utils();
  var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
  var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
  try {
    if (Buffer && Buffer.from) {
      hasBufferType = true;
      inspect = require("util").inspect.custom || "inspect";
    }
  } catch (err) {
    hasBufferType = false;
  }
  var hasBufferType;
  var ObjectID2 = function ObjectID3(id) {
    if (id instanceof ObjectID3)
      return id;
    if (!(this instanceof ObjectID3))
      return new ObjectID3(id);
    this._bsontype = "ObjectID";
    if (id == null || typeof id === "number") {
      this.id = this.generate(id);
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
      return;
    }
    var valid = ObjectID3.isValid(id);
    if (!valid && id != null) {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
      return new ObjectID3(utils2.toBuffer(id, "hex"));
    } else if (valid && typeof id === "string" && id.length === 24) {
      return ObjectID3.createFromHexString(id);
    } else if (id != null && id.length === 12) {
      this.id = id;
    } else if (id != null && typeof id.toHexString === "function") {
      return id;
    } else {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    }
    if (ObjectID3.cacheHexString)
      this.__id = this.toString("hex");
  };
  var hexTable = [];
  for (var i = 0; i < 256; i++) {
    hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
  }
  ObjectID2.prototype.toHexString = function() {
    if (ObjectID2.cacheHexString && this.__id)
      return this.__id;
    var hexString = "";
    if (!this.id || !this.id.length) {
      throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
    }
    if (this.id instanceof _Buffer) {
      hexString = convertToHex(this.id);
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    }
    for (var i2 = 0; i2 < this.id.length; i2++) {
      hexString += hexTable[this.id.charCodeAt(i2)];
    }
    if (ObjectID2.cacheHexString)
      this.__id = hexString;
    return hexString;
  };
  ObjectID2.prototype.get_inc = function() {
    return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
  };
  ObjectID2.prototype.getInc = function() {
    return this.get_inc();
  };
  ObjectID2.prototype.generate = function(time) {
    if (typeof time !== "number") {
      time = ~~(Date.now() / 1e3);
    }
    var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
    var inc = this.get_inc();
    var buffer = utils2.allocBuffer(12);
    buffer[3] = time & 255;
    buffer[2] = time >> 8 & 255;
    buffer[1] = time >> 16 & 255;
    buffer[0] = time >> 24 & 255;
    buffer[6] = MACHINE_ID & 255;
    buffer[5] = MACHINE_ID >> 8 & 255;
    buffer[4] = MACHINE_ID >> 16 & 255;
    buffer[8] = pid & 255;
    buffer[7] = pid >> 8 & 255;
    buffer[11] = inc & 255;
    buffer[10] = inc >> 8 & 255;
    buffer[9] = inc >> 16 & 255;
    return buffer;
  };
  ObjectID2.prototype.toString = function(format) {
    if (this.id && this.id.copy) {
      return this.id.toString(typeof format === "string" ? format : "hex");
    }
    return this.toHexString();
  };
  ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
  ObjectID2.prototype.toJSON = function() {
    return this.toHexString();
  };
  ObjectID2.prototype.equals = function equals(otherId) {
    if (otherId instanceof ObjectID2) {
      return this.toString() === otherId.toString();
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
      return otherId === this.id.toString("binary");
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
      return otherId.toLowerCase() === this.toHexString();
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
      return otherId === this.id;
    } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
      return otherId.toHexString() === this.toHexString();
    } else {
      return false;
    }
  };
  ObjectID2.prototype.getTimestamp = function() {
    var timestamp = new Date();
    var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
    timestamp.setTime(Math.floor(time) * 1e3);
    return timestamp;
  };
  ObjectID2.index = ~~(Math.random() * 16777215);
  ObjectID2.createPk = function createPk() {
    return new ObjectID2();
  };
  ObjectID2.createFromTime = function createFromTime(time) {
    var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    buffer[3] = time & 255;
    buffer[2] = time >> 8 & 255;
    buffer[1] = time >> 16 & 255;
    buffer[0] = time >> 24 & 255;
    return new ObjectID2(buffer);
  };
  var decodeLookup = [];
  i = 0;
  while (i < 10)
    decodeLookup[48 + i] = i++;
  while (i < 16)
    decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
  var _Buffer = Buffer;
  var convertToHex = function(bytes) {
    return bytes.toString("hex");
  };
  ObjectID2.createFromHexString = function createFromHexString(string) {
    if (typeof string === "undefined" || string != null && string.length !== 24) {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    }
    if (hasBufferType)
      return new ObjectID2(utils2.toBuffer(string, "hex"));
    var array = new _Buffer(12);
    var n = 0;
    var i2 = 0;
    while (i2 < 24) {
      array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
    }
    return new ObjectID2(array);
  };
  ObjectID2.isValid = function isValid(id) {
    if (id == null)
      return false;
    if (typeof id === "number") {
      return true;
    }
    if (typeof id === "string") {
      return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
    }
    if (id instanceof ObjectID2) {
      return true;
    }
    if (id instanceof _Buffer) {
      return true;
    }
    if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
      return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
    }
    return false;
  };
  Object.defineProperty(ObjectID2.prototype, "generationTime", {
    enumerable: true,
    get: function() {
      return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
    },
    set: function(value) {
      this.id[3] = value & 255;
      this.id[2] = value >> 8 & 255;
      this.id[1] = value >> 16 & 255;
      this.id[0] = value >> 24 & 255;
    }
  });
  module2.exports = ObjectID2;
  module2.exports.ObjectID = ObjectID2;
  module2.exports.ObjectId = ObjectID2;
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS((exports2, module2) => {
  function BSONRegExp2(pattern, options) {
    if (!(this instanceof BSONRegExp2))
      return new BSONRegExp2();
    this._bsontype = "BSONRegExp";
    this.pattern = pattern || "";
    this.options = options || "";
    for (var i = 0; i < this.options.length; i++) {
      if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
        throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
      }
    }
  }
  module2.exports = BSONRegExp2;
  module2.exports.BSONRegExp = BSONRegExp2;
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS((exports2, module2) => {
  var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
  function Symbol2(value) {
    if (!(this instanceof Symbol2))
      return new Symbol2(value);
    this._bsontype = "Symbol";
    this.value = value;
  }
  Symbol2.prototype.valueOf = function() {
    return this.value;
  };
  Symbol2.prototype.toString = function() {
    return this.value;
  };
  Symbol2.prototype[inspect] = function() {
    return this.value;
  };
  Symbol2.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Symbol2;
  module2.exports.Symbol = Symbol2;
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS((exports2, module2) => {
  var Int322 = function(value) {
    if (!(this instanceof Int322))
      return new Int322(value);
    this._bsontype = "Int32";
    this.value = value;
  };
  Int322.prototype.valueOf = function() {
    return this.value;
  };
  Int322.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Int322;
  module2.exports.Int32 = Int322;
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS((exports2, module2) => {
  var Code2 = function Code3(code, scope) {
    if (!(this instanceof Code3))
      return new Code3(code, scope);
    this._bsontype = "Code";
    this.code = code;
    this.scope = scope;
  };
  Code2.prototype.toJSON = function() {
    return {scope: this.scope, code: this.code};
  };
  module2.exports = Code2;
  module2.exports.Code = Code2;
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_long();
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = [
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var INF_NEGATIVE_BUFFER = [
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var INF_POSITIVE_BUFFER = [
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var utils2 = require_utils();
  var isDigit = function(value) {
    return !isNaN(parseInt(value, 10));
  };
  var divideu128 = function(value) {
    var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
    var _rem = Long2.fromNumber(0);
    var i = 0;
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return {quotient: value, rem: _rem};
    }
    for (i = 0; i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long2(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low_;
      _rem = _rem.modulo(DIVISOR);
    }
    return {quotient: value, rem: _rem};
  };
  var multiply64x2 = function(left, right) {
    if (!left && !right) {
      return {high: Long2.fromNumber(0), low: Long2.fromNumber(0)};
    }
    var leftHigh = left.shiftRightUnsigned(32);
    var leftLow = new Long2(left.getLowBits(), 0);
    var rightHigh = right.shiftRightUnsigned(32);
    var rightLow = new Long2(right.getLowBits(), 0);
    var productHigh = leftHigh.multiply(rightHigh);
    var productMid = leftHigh.multiply(rightLow);
    var productMid2 = leftLow.multiply(rightHigh);
    var productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
    return {high: productHigh, low: productLow};
  };
  var lessThan = function(left, right) {
    var uhleft = left.high_ >>> 0;
    var uhright = right.high_ >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      var ulleft = left.low_ >>> 0;
      var ulright = right.low_ >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  };
  var Decimal1282 = function(bytes) {
    this._bsontype = "Decimal128";
    this.bytes = bytes;
  };
  Decimal1282.fromString = function(string) {
    var isNegative = false;
    var sawRadix = false;
    var foundNonZero = false;
    var significantDigits = 0;
    var nDigitsRead = 0;
    var nDigits = 0;
    var radixPosition = 0;
    var firstNonZero = 0;
    var digits = [0];
    var nDigitsStored = 0;
    var digitsInsert = 0;
    var firstDigit = 0;
    var lastDigit = 0;
    var exponent = 0;
    var i = 0;
    var significandHigh = [0, 0];
    var significandLow = [0, 0];
    var biasedExponent = 0;
    var index = 0;
    string = string.trim();
    if (string.length >= 7e3) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    var stringMatch = string.match(PARSE_STRING_REGEXP);
    var infMatch = string.match(PARSE_INF_REGEXP);
    var nanMatch = string.match(PARSE_NAN_REGEXP);
    if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (string[index] === "+" || string[index] === "-") {
      isNegative = string[index++] === "-";
    }
    if (!isDigit(string[index]) && string[index] !== ".") {
      if (string[index] === "i" || string[index] === "I") {
        return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
      } else if (string[index] === "N") {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
    }
    while (isDigit(string[index]) || string[index] === ".") {
      if (string[index] === ".") {
        if (sawRadix) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        sawRadix = true;
        index = index + 1;
        continue;
      }
      if (nDigitsStored < 34) {
        if (string[index] !== "0" || foundNonZero) {
          if (!foundNonZero) {
            firstNonZero = nDigitsRead;
          }
          foundNonZero = true;
          digits[digitsInsert++] = parseInt(string[index], 10);
          nDigitsStored = nDigitsStored + 1;
        }
      }
      if (foundNonZero) {
        nDigits = nDigits + 1;
      }
      if (sawRadix) {
        radixPosition = radixPosition + 1;
      }
      nDigitsRead = nDigitsRead + 1;
      index = index + 1;
    }
    if (sawRadix && !nDigitsRead) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (string[index] === "e" || string[index] === "E") {
      var match = string.substr(++index).match(EXPONENT_REGEX);
      if (!match || !match[2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      exponent = parseInt(match[0], 10);
      index = index + match[0].length;
    }
    if (string[index]) {
      return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
    }
    firstDigit = 0;
    if (!nDigitsStored) {
      firstDigit = 0;
      lastDigit = 0;
      digits[0] = 0;
      nDigits = 1;
      nDigitsStored = 1;
      significantDigits = 0;
    } else {
      lastDigit = nDigitsStored - 1;
      significantDigits = nDigits;
      if (exponent !== 0 && significantDigits !== 1) {
        while (string[firstNonZero + significantDigits - 1] === "0") {
          significantDigits = significantDigits - 1;
        }
      }
    }
    if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
      exponent = EXPONENT_MIN;
    } else {
      exponent = exponent - radixPosition;
    }
    while (exponent > EXPONENT_MAX) {
      lastDigit = lastDigit + 1;
      if (lastDigit - firstDigit > MAX_DIGITS) {
        var digitsString = digits.join("");
        if (digitsString.match(/^0+$/)) {
          exponent = EXPONENT_MAX;
          break;
        } else {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        }
      }
      exponent = exponent - 1;
    }
    while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
      if (lastDigit === 0) {
        exponent = EXPONENT_MIN;
        significantDigits = 0;
        break;
      }
      if (nDigitsStored < nDigits) {
        nDigits = nDigits - 1;
      } else {
        lastDigit = lastDigit - 1;
      }
      if (exponent < EXPONENT_MAX) {
        exponent = exponent + 1;
      } else {
        digitsString = digits.join("");
        if (digitsString.match(/^0+$/)) {
          exponent = EXPONENT_MAX;
          break;
        } else {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        }
      }
    }
    if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
      var endOfString = nDigitsRead;
      if (sawRadix && exponent === EXPONENT_MIN) {
        firstNonZero = firstNonZero + 1;
        endOfString = endOfString + 1;
      }
      var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
      var roundBit = 0;
      if (roundDigit >= 5) {
        roundBit = 1;
        if (roundDigit === 5) {
          roundBit = digits[lastDigit] % 2 === 1;
          for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
            if (parseInt(string[i], 10)) {
              roundBit = 1;
              break;
            }
          }
        }
      }
      if (roundBit) {
        var dIdx = lastDigit;
        for (; dIdx >= 0; dIdx--) {
          if (++digits[dIdx] > 9) {
            digits[dIdx] = 0;
            if (dIdx === 0) {
              if (exponent < EXPONENT_MAX) {
                exponent = exponent + 1;
                digits[dIdx] = 1;
              } else {
                return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
              }
            }
          } else {
            break;
          }
        }
      }
    }
    significandHigh = Long2.fromNumber(0);
    significandLow = Long2.fromNumber(0);
    if (significantDigits === 0) {
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
    } else if (lastDigit - firstDigit < 17) {
      dIdx = firstDigit;
      significandLow = Long2.fromNumber(digits[dIdx++]);
      significandHigh = new Long2(0, 0);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long2.fromNumber(10));
        significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
      }
    } else {
      dIdx = firstDigit;
      significandHigh = Long2.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit - 17; dIdx++) {
        significandHigh = significandHigh.multiply(Long2.fromNumber(10));
        significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
      }
      significandLow = Long2.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long2.fromNumber(10));
        significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
      }
    }
    var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
    significand.low = significand.low.add(significandLow);
    if (lessThan(significand.low, significandLow)) {
      significand.high = significand.high.add(Long2.fromNumber(1));
    }
    biasedExponent = exponent + EXPONENT_BIAS;
    var dec = {low: Long2.fromNumber(0), high: Long2.fromNumber(0)};
    if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
      dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
      dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
      dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
    } else {
      dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
      dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
    }
    dec.low = significand.low;
    if (isNegative) {
      dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
    }
    var buffer = utils2.allocBuffer(16);
    index = 0;
    buffer[index++] = dec.low.low_ & 255;
    buffer[index++] = dec.low.low_ >> 8 & 255;
    buffer[index++] = dec.low.low_ >> 16 & 255;
    buffer[index++] = dec.low.low_ >> 24 & 255;
    buffer[index++] = dec.low.high_ & 255;
    buffer[index++] = dec.low.high_ >> 8 & 255;
    buffer[index++] = dec.low.high_ >> 16 & 255;
    buffer[index++] = dec.low.high_ >> 24 & 255;
    buffer[index++] = dec.high.low_ & 255;
    buffer[index++] = dec.high.low_ >> 8 & 255;
    buffer[index++] = dec.high.low_ >> 16 & 255;
    buffer[index++] = dec.high.low_ >> 24 & 255;
    buffer[index++] = dec.high.high_ & 255;
    buffer[index++] = dec.high.high_ >> 8 & 255;
    buffer[index++] = dec.high.high_ >> 16 & 255;
    buffer[index++] = dec.high.high_ >> 24 & 255;
    return new Decimal1282(buffer);
  };
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;
  EXPONENT_BIAS = 6176;
  Decimal1282.prototype.toString = function() {
    var high;
    var midh;
    var midl;
    var low;
    var combination;
    var biased_exponent;
    var significand_digits = 0;
    var significand = new Array(36);
    for (var i = 0; i < significand.length; i++)
      significand[i] = 0;
    var index = 0;
    var exponent;
    var scientific_exponent;
    var is_zero = false;
    var significand_msb;
    var significand128 = {parts: new Array(4)};
    i;
    var j, k;
    var string = [];
    index = 0;
    var buffer = this.bytes;
    low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    index = 0;
    var dec = {
      low: new Long2(low, midl),
      high: new Long2(midh, high)
    };
    if (dec.high.lessThan(Long2.ZERO)) {
      string.push("-");
    }
    combination = high >> 26 & COMBINATION_MASK;
    if (combination >> 3 === 3) {
      if (combination === COMBINATION_INFINITY) {
        return string.join("") + "Infinity";
      } else if (combination === COMBINATION_NAN) {
        return "NaN";
      } else {
        biased_exponent = high >> 15 & EXPONENT_MASK;
        significand_msb = 8 + (high >> 14 & 1);
      }
    } else {
      significand_msb = high >> 14 & 7;
      biased_exponent = high >> 17 & EXPONENT_MASK;
    }
    exponent = biased_exponent - EXPONENT_BIAS;
    significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
    significand128.parts[1] = midh;
    significand128.parts[2] = midl;
    significand128.parts[3] = low;
    if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
      is_zero = true;
    } else {
      for (k = 3; k >= 0; k--) {
        var least_digits = 0;
        var result = divideu128(significand128);
        significand128 = result.quotient;
        least_digits = result.rem.low_;
        if (!least_digits)
          continue;
        for (j = 8; j >= 0; j--) {
          significand[k * 9 + j] = least_digits % 10;
          least_digits = Math.floor(least_digits / 10);
        }
      }
    }
    if (is_zero) {
      significand_digits = 1;
      significand[index] = 0;
    } else {
      significand_digits = 36;
      i = 0;
      while (!significand[index]) {
        i++;
        significand_digits = significand_digits - 1;
        index = index + 1;
      }
    }
    scientific_exponent = significand_digits - 1 + exponent;
    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
      string.push(significand[index++]);
      significand_digits = significand_digits - 1;
      if (significand_digits) {
        string.push(".");
      }
      for (i = 0; i < significand_digits; i++) {
        string.push(significand[index++]);
      }
      string.push("E");
      if (scientific_exponent > 0) {
        string.push("+" + scientific_exponent);
      } else {
        string.push(scientific_exponent);
      }
    } else {
      if (exponent >= 0) {
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index++]);
        }
      } else {
        var radix_position = significand_digits + exponent;
        if (radix_position > 0) {
          for (i = 0; i < radix_position; i++) {
            string.push(significand[index++]);
          }
        } else {
          string.push("0");
        }
        string.push(".");
        while (radix_position++ < 0) {
          string.push("0");
        }
        for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
          string.push(significand[index++]);
        }
      }
    }
    return string.join("");
  };
  Decimal1282.prototype.toJSON = function() {
    return {$numberDecimal: this.toString()};
  };
  module2.exports = Decimal1282;
  module2.exports.Decimal128 = Decimal1282;
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS((exports2, module2) => {
  function MinKey2() {
    if (!(this instanceof MinKey2))
      return new MinKey2();
    this._bsontype = "MinKey";
  }
  module2.exports = MinKey2;
  module2.exports.MinKey = MinKey2;
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS((exports2, module2) => {
  function MaxKey2() {
    if (!(this instanceof MaxKey2))
      return new MaxKey2();
    this._bsontype = "MaxKey";
  }
  module2.exports = MaxKey2;
  module2.exports.MaxKey = MaxKey2;
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS((exports2, module2) => {
  function DBRef2(namespace, oid, db) {
    if (!(this instanceof DBRef2))
      return new DBRef2(namespace, oid, db);
    this._bsontype = "DBRef";
    this.namespace = namespace;
    this.oid = oid;
    this.db = db;
  }
  DBRef2.prototype.toJSON = function() {
    return {
      $ref: this.namespace,
      $id: this.oid,
      $db: this.db == null ? "" : this.db
    };
  };
  module2.exports = DBRef2;
  module2.exports.DBRef = DBRef2;
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS((exports2, module2) => {
  if (typeof global !== "undefined") {
    Buffer2 = require("buffer").Buffer;
  }
  var Buffer2;
  var utils2 = require_utils();
  function Binary2(buffer, subType) {
    if (!(this instanceof Binary2))
      return new Binary2(buffer, subType);
    if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
      throw new Error("only String, Buffer, Uint8Array or Array accepted");
    }
    this._bsontype = "Binary";
    if (buffer instanceof Number) {
      this.sub_type = buffer;
      this.position = 0;
    } else {
      this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
      this.position = 0;
    }
    if (buffer != null && !(buffer instanceof Number)) {
      if (typeof buffer === "string") {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.toBuffer(buffer);
        } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
          this.buffer = writeStringToArray(buffer);
        } else {
          throw new Error("only String, Buffer, Uint8Array or Array accepted");
        }
      } else {
        this.buffer = buffer;
      }
      this.position = buffer.length;
    } else {
      if (typeof Buffer2 !== "undefined") {
        this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
      } else if (typeof Uint8Array !== "undefined") {
        this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
      } else {
        this.buffer = new Array(Binary2.BUFFER_SIZE);
      }
      this.position = 0;
    }
  }
  Binary2.prototype.put = function put(byte_value) {
    if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
      throw new Error("only accepts single character String, Uint8Array or Array");
    if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
      throw new Error("only accepts number in a valid unsigned byte range 0-255");
    var decoded_byte = null;
    if (typeof byte_value === "string") {
      decoded_byte = byte_value.charCodeAt(0);
    } else if (byte_value["length"] != null) {
      decoded_byte = byte_value[0];
    } else {
      decoded_byte = byte_value;
    }
    if (this.buffer.length > this.position) {
      this.buffer[this.position++] = decoded_byte;
    } else {
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
        this.buffer = buffer;
        this.buffer[this.position++] = decoded_byte;
      } else {
        buffer = null;
        if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
        } else {
          buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
        }
        for (var i = 0; i < this.buffer.length; i++) {
          buffer[i] = this.buffer[i];
        }
        this.buffer = buffer;
        this.buffer[this.position++] = decoded_byte;
      }
    }
  };
  Binary2.prototype.write = function write(string, offset) {
    offset = typeof offset === "number" ? offset : this.position;
    if (this.buffer.length < offset + string.length) {
      var buffer = null;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        buffer = utils2.allocBuffer(this.buffer.length + string.length);
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
      } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
        buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
        for (var i = 0; i < this.position; i++) {
          buffer[i] = this.buffer[i];
        }
      }
      this.buffer = buffer;
    }
    if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
      string.copy(this.buffer, offset, 0, string.length);
      this.position = offset + string.length > this.position ? offset + string.length : this.position;
    } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
      this.buffer.write(string, offset, "binary");
      this.position = offset + string.length > this.position ? offset + string.length : this.position;
    } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
      for (i = 0; i < string.length; i++) {
        this.buffer[offset++] = string[i];
      }
      this.position = offset > this.position ? offset : this.position;
    } else if (typeof string === "string") {
      for (i = 0; i < string.length; i++) {
        this.buffer[offset++] = string.charCodeAt(i);
      }
      this.position = offset > this.position ? offset : this.position;
    }
  };
  Binary2.prototype.read = function read(position, length) {
    length = length && length > 0 ? length : this.position;
    if (this.buffer["slice"]) {
      return this.buffer.slice(position, position + length);
    } else {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
      for (var i = 0; i < length; i++) {
        buffer[i] = this.buffer[position++];
      }
    }
    return buffer;
  };
  Binary2.prototype.value = function value(asRaw) {
    asRaw = asRaw == null ? false : asRaw;
    if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
      return this.buffer;
    if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
      return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
    } else {
      if (asRaw) {
        if (this.buffer["slice"] != null) {
          return this.buffer.slice(0, this.position);
        } else {
          var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
          for (var i = 0; i < this.position; i++) {
            newBuffer[i] = this.buffer[i];
          }
          return newBuffer;
        }
      } else {
        return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
      }
    }
  };
  Binary2.prototype.length = function length() {
    return this.position;
  };
  Binary2.prototype.toJSON = function() {
    return this.buffer != null ? this.buffer.toString("base64") : "";
  };
  Binary2.prototype.toString = function(format) {
    return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : "";
  };
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var writeStringToArray = function(data) {
    var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      buffer[i] = data.charCodeAt(i);
    }
    return buffer;
  };
  var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
    var result = "";
    for (var i = startIndex; i < endIndex; i++) {
      result = result + String.fromCharCode(byteArray[i]);
    }
    return result;
  };
  Binary2.BUFFER_SIZE = 256;
  Binary2.SUBTYPE_DEFAULT = 0;
  Binary2.SUBTYPE_FUNCTION = 1;
  Binary2.SUBTYPE_BYTE_ARRAY = 2;
  Binary2.SUBTYPE_UUID_OLD = 3;
  Binary2.SUBTYPE_UUID = 4;
  Binary2.SUBTYPE_MD5 = 5;
  Binary2.SUBTYPE_USER_DEFINED = 128;
  module2.exports = Binary2;
  module2.exports.Binary = Binary2;
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS((exports, module) => {
  "use strict";
  var Long = require_long().Long;
  var Double = require_double().Double;
  var Timestamp = require_timestamp().Timestamp;
  var ObjectID = require_objectid().ObjectID;
  var Symbol = require_symbol().Symbol;
  var Code = require_code().Code;
  var MinKey = require_min_key().MinKey;
  var MaxKey = require_max_key().MaxKey;
  var Decimal128 = require_decimal128();
  var Int32 = require_int_32();
  var DBRef = require_db_ref().DBRef;
  var BSONRegExp = require_regexp().BSONRegExp;
  var Binary = require_binary().Binary;
  var utils = require_utils();
  var deserialize = function(buffer, options, isArray) {
    options = options == null ? {} : options;
    var index = options && options.index ? options.index : 0;
    var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
    if (size < 5 || buffer.length < size || size + index > buffer.length) {
      throw new Error("corrupt bson message");
    }
    if (buffer[index + size - 1] !== 0) {
      throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer, index, options, isArray);
  };
  var deserializeObject = function(buffer, index, options, isArray) {
    var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
    var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
    var cacheFunctionsCrc32 = options["cacheFunctionsCrc32"] == null ? false : options["cacheFunctionsCrc32"];
    if (!cacheFunctionsCrc32)
      var crc32 = null;
    var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    var raw = options["raw"] == null ? false : options["raw"];
    var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
    var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
    var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
    var startIndex = index;
    if (buffer.length < 5)
      throw new Error("corrupt bson message < 5 bytes long");
    var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    if (size < 5 || size > buffer.length)
      throw new Error("corrupt bson message");
    var object = isArray ? [] : {};
    var arrayIndex = 0;
    var done = false;
    while (!done) {
      var elementType = buffer[index++];
      if (elementType === 0)
        break;
      var i = index;
      while (buffer[i] !== 0 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length)
        throw new Error("Bad BSON Document: illegal CString");
      var name = isArray ? arrayIndex++ : buffer.toString("utf8", index, i);
      index = i + 1;
      if (elementType === BSON.BSON_DATA_STRING) {
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        object[name] = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_OID) {
        var oid = utils.allocBuffer(12);
        buffer.copy(oid, 0, index, index + 12);
        object[name] = new ObjectID(oid);
        index = index + 12;
      } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
        object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
      } else if (elementType === BSON.BSON_DATA_INT) {
        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
        object[name] = new Double(buffer.readDoubleLE(index));
        index = index + 8;
      } else if (elementType === BSON.BSON_DATA_NUMBER) {
        object[name] = buffer.readDoubleLE(index);
        index = index + 8;
      } else if (elementType === BSON.BSON_DATA_DATE) {
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        object[name] = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
        if (buffer[index] !== 0 && buffer[index] !== 1)
          throw new Error("illegal boolean type value");
        object[name] = buffer[index++] === 1;
      } else if (elementType === BSON.BSON_DATA_OBJECT) {
        var _index = index;
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        if (objectSize <= 0 || objectSize > buffer.length - index)
          throw new Error("bad embedded document length in bson");
        if (raw) {
          object[name] = buffer.slice(index, index + objectSize);
        } else {
          object[name] = deserializeObject(buffer, _index, options, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON.BSON_DATA_ARRAY) {
        _index = index;
        objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        var arrayOptions = options;
        var stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = {};
          for (var n in options)
            arrayOptions[n] = options[n];
          arrayOptions["raw"] = true;
        }
        object[name] = deserializeObject(buffer, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer[index - 1] !== 0)
          throw new Error("invalid array terminator byte");
        if (index !== stopIndex)
          throw new Error("corrupted array bson");
      } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
        object[name] = void 0;
      } else if (elementType === BSON.BSON_DATA_NULL) {
        object[name] = null;
      } else if (elementType === BSON.BSON_DATA_LONG) {
        lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var long = new Long(lowBits, highBits);
        if (promoteLongs && promoteValues === true) {
          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          object[name] = long;
        }
      } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
        var bytes = utils.allocBuffer(16);
        buffer.copy(bytes, 0, index, index + 16);
        index = index + 16;
        var decimal128 = new Decimal128(bytes);
        object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
      } else if (elementType === BSON.BSON_DATA_BINARY) {
        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var totalBinarySize = binarySize;
        var subType = buffer[index++];
        if (binarySize < 0)
          throw new Error("Negative binary type element size found");
        if (binarySize > buffer.length)
          throw new Error("Binary type size larger than document size");
        if (buffer["slice"] != null) {
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
            if (binarySize < 0)
              throw new Error("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to short binary size");
          }
          if (promoteBuffers && promoteValues) {
            object[name] = buffer.slice(index, index + binarySize);
          } else {
            object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
          }
        } else {
          var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
            if (binarySize < 0)
              throw new Error("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to short binary size");
          }
          for (i = 0; i < binarySize; i++) {
            _buffer[i] = buffer[index + i];
          }
          if (promoteBuffers && promoteValues) {
            object[name] = _buffer;
          } else {
            object[name] = new Binary(_buffer, subType);
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var source = buffer.toString("utf8", index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var regExpOptions = buffer.toString("utf8", index, i);
        index = i + 1;
        var optionsArray = new Array(regExpOptions.length);
        for (i = 0; i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        object[name] = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        source = buffer.toString("utf8", index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        regExpOptions = buffer.toString("utf8", index, i);
        index = i + 1;
        object[name] = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON.BSON_DATA_SYMBOL) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        object[name] = new Symbol(buffer.toString("utf8", index, index + stringSize - 1));
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
        lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        object[name] = new Timestamp(lowBits, highBits);
      } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
        object[name] = new MinKey();
      } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
        object[name] = new MaxKey();
      } else if (elementType === BSON.BSON_DATA_CODE) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        var functionString = buffer.toString("utf8", index, index + stringSize - 1);
        if (evalFunctions) {
          if (cacheFunctions) {
            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            object[name] = isolateEval(functionString);
          }
        } else {
          object[name] = new Code(functionString);
        }
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new Error("code_w_scope total size shorter minimum expected length");
        }
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        functionString = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
        _index = index;
        objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        var scopeObject = deserializeObject(buffer, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new Error("code_w_scope total size is to short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new Error("code_w_scope total size is to long, clips outer document");
        }
        if (evalFunctions) {
          if (cacheFunctions) {
            hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            object[name] = isolateEval(functionString);
          }
          object[name].scope = scopeObject;
        } else {
          object[name] = new Code(functionString, scopeObject);
        }
      } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        var namespace = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
        var oidBuffer = utils.allocBuffer(12);
        buffer.copy(oidBuffer, 0, index, index + 12);
        oid = new ObjectID(oidBuffer);
        index = index + 12;
        var parts = namespace.split(".");
        var db = parts.shift();
        var collection = parts.join(".");
        object[name] = new DBRef(collection, oid, db);
      } else {
        throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser');
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new Error("corrupt array bson");
      throw new Error("corrupt object bson");
    }
    if (object["$id"] != null)
      object = new DBRef(object["$ref"], object["$id"], object["$db"]);
    return object;
  };
  var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
    var value = null;
    if (functionCache[hash] == null) {
      eval("value = " + functionString);
      functionCache[hash] = value;
    }
    return functionCache[hash].bind(object);
  };
  var isolateEval = function(functionString) {
    var value = null;
    eval("value = " + functionString);
    return value;
  };
  var BSON = {};
  var functionCache = BSON.functionCache = {};
  BSON.BSON_DATA_NUMBER = 1;
  BSON.BSON_DATA_STRING = 2;
  BSON.BSON_DATA_OBJECT = 3;
  BSON.BSON_DATA_ARRAY = 4;
  BSON.BSON_DATA_BINARY = 5;
  BSON.BSON_DATA_UNDEFINED = 6;
  BSON.BSON_DATA_OID = 7;
  BSON.BSON_DATA_BOOLEAN = 8;
  BSON.BSON_DATA_DATE = 9;
  BSON.BSON_DATA_NULL = 10;
  BSON.BSON_DATA_REGEXP = 11;
  BSON.BSON_DATA_DBPOINTER = 12;
  BSON.BSON_DATA_CODE = 13;
  BSON.BSON_DATA_SYMBOL = 14;
  BSON.BSON_DATA_CODE_W_SCOPE = 15;
  BSON.BSON_DATA_INT = 16;
  BSON.BSON_DATA_TIMESTAMP = 17;
  BSON.BSON_DATA_LONG = 18;
  BSON.BSON_DATA_DECIMAL128 = 19;
  BSON.BSON_DATA_MIN_KEY = 255;
  BSON.BSON_DATA_MAX_KEY = 127;
  BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  BSON.BSON_INT32_MAX = 2147483647;
  BSON.BSON_INT32_MIN = -2147483648;
  BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON.JS_INT_MAX = 9007199254740992;
  BSON.JS_INT_MIN = -9007199254740992;
  var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
  var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
  module.exports = deserialize;
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS((exports2) => {
  var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
    var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
    var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
      ;
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
      ;
    buffer[offset + i - d] |= s * 128;
  };
  exports2.readIEEE754 = readIEEE754;
  exports2.writeIEEE754 = writeIEEE754;
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS((exports2, module2) => {
  "use strict";
  var writeIEEE754 = require_float_parser().writeIEEE754;
  var Long2 = require_long().Long;
  var Map2 = require_map();
  var Binary2 = require_binary().Binary;
  var normalizedFunctionString = require_utils().normalizedFunctionString;
  var regexp = /\x00/;
  var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
  var isDate = function isDate2(d) {
    return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
  };
  var isRegExp = function isRegExp2(d) {
    return Object.prototype.toString.call(d) === "[object RegExp]";
  };
  var serializeString = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_STRING;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes + 1;
    buffer[index - 1] = 0;
    var size = buffer.write(value, index + 4, "utf8");
    buffer[index + 3] = size + 1 >> 24 & 255;
    buffer[index + 2] = size + 1 >> 16 & 255;
    buffer[index + 1] = size + 1 >> 8 & 255;
    buffer[index] = size + 1 & 255;
    index = index + 4 + size;
    buffer[index++] = 0;
    return index;
  };
  var serializeNumber = function(buffer, key, value, index, isArray) {
    if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
      if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
        buffer[index++] = BSON2.BSON_DATA_INT;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        buffer[index++] = value & 255;
        buffer[index++] = value >> 8 & 255;
        buffer[index++] = value >> 16 & 255;
        buffer[index++] = value >> 24 & 255;
      } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        buffer[index++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        writeIEEE754(buffer, value, index, "little", 52, 8);
        index = index + 8;
      } else {
        buffer[index++] = BSON2.BSON_DATA_LONG;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var longVal = Long2.fromNumber(value);
        var lowBits = longVal.getLowBits();
        var highBits = longVal.getHighBits();
        buffer[index++] = lowBits & 255;
        buffer[index++] = lowBits >> 8 & 255;
        buffer[index++] = lowBits >> 16 & 255;
        buffer[index++] = lowBits >> 24 & 255;
        buffer[index++] = highBits & 255;
        buffer[index++] = highBits >> 8 & 255;
        buffer[index++] = highBits >> 16 & 255;
        buffer[index++] = highBits >> 24 & 255;
      }
    } else {
      buffer[index++] = BSON2.BSON_DATA_NUMBER;
      numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value, index, "little", 52, 8);
      index = index + 8;
    }
    return index;
  };
  var serializeNull = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_NULL;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  };
  var serializeBoolean = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BOOLEAN;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value ? 1 : 0;
    return index;
  };
  var serializeDate = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_DATE;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var dateInMilis = Long2.fromNumber(value.getTime());
    var lowBits = dateInMilis.getLowBits();
    var highBits = dateInMilis.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = lowBits >> 8 & 255;
    buffer[index++] = lowBits >> 16 & 255;
    buffer[index++] = lowBits >> 24 & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = highBits >> 8 & 255;
    buffer[index++] = highBits >> 16 & 255;
    buffer[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeRegExp = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw Error("value " + value.source + " must not contain null bytes");
    }
    index = index + buffer.write(value.source, index, "utf8");
    buffer[index++] = 0;
    if (value.global)
      buffer[index++] = 115;
    if (value.ignoreCase)
      buffer[index++] = 105;
    if (value.multiline)
      buffer[index++] = 109;
    buffer[index++] = 0;
    return index;
  };
  var serializeBSONRegExp = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw Error("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + buffer.write(value.pattern, index, "utf8");
    buffer[index++] = 0;
    index = index + buffer.write(value.options.split("").sort().join(""), index, "utf8");
    buffer[index++] = 0;
    return index;
  };
  var serializeMinMax = function(buffer, key, value, index, isArray) {
    if (value === null) {
      buffer[index++] = BSON2.BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer[index++] = BSON2.BSON_DATA_MIN_KEY;
    } else {
      buffer[index++] = BSON2.BSON_DATA_MAX_KEY;
    }
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  };
  var serializeObjectId = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_OID;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (typeof value.id === "string") {
      buffer.write(value.id, index, "binary");
    } else if (value.id && value.id.copy) {
      value.id.copy(buffer, index, 0, 12);
    } else {
      throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
    }
    return index + 12;
  };
  var serializeBuffer = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = value.length;
    buffer[index++] = size & 255;
    buffer[index++] = size >> 8 & 255;
    buffer[index++] = size >> 16 & 255;
    buffer[index++] = size >> 24 & 255;
    buffer[index++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
    value.copy(buffer, index, 0, size);
    index = index + size;
    return index;
  };
  var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
    for (var i = 0; i < path.length; i++) {
      if (path[i] === value)
        throw new Error("cyclic dependency detected");
    }
    path.push(value);
    buffer[index++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.pop();
    return endIndex;
  };
  var serializeDecimal128 = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_DECIMAL128;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    value.bytes.copy(buffer, index, 0, 16);
    return index + 16;
  };
  var serializeLong = function(buffer, key, value, index, isArray) {
    buffer[index++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var lowBits = value.getLowBits();
    var highBits = value.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = lowBits >> 8 & 255;
    buffer[index++] = lowBits >> 16 & 255;
    buffer[index++] = lowBits >> 24 & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = highBits >> 8 & 255;
    buffer[index++] = highBits >> 16 & 255;
    buffer[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeInt32 = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_INT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value & 255;
    buffer[index++] = value >> 8 & 255;
    buffer[index++] = value >> 16 & 255;
    buffer[index++] = value >> 24 & 255;
    return index;
  };
  var serializeDouble = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_NUMBER;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    writeIEEE754(buffer, value, index, "little", 52, 8);
    index = index + 8;
    return index;
  };
  var serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {
    buffer[index++] = BSON2.BSON_DATA_CODE;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var functionString = normalizedFunctionString(value);
    var size = buffer.write(functionString, index + 4, "utf8") + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = size >> 8 & 255;
    buffer[index + 2] = size >> 16 & 255;
    buffer[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  };
  var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
    if (value.scope && typeof value.scope === "object") {
      buffer[index++] = BSON2.BSON_DATA_CODE_W_SCOPE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var functionString = typeof value.code === "string" ? value.code : value.code.toString();
      index = index + 4;
      var codeSize = buffer.write(functionString, index + 4, "utf8") + 1;
      buffer[index] = codeSize & 255;
      buffer[index + 1] = codeSize >> 8 & 255;
      buffer[index + 2] = codeSize >> 16 & 255;
      buffer[index + 3] = codeSize >> 24 & 255;
      buffer[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
      index = endIndex - 1;
      var totalSize = endIndex - startIndex;
      buffer[startIndex++] = totalSize & 255;
      buffer[startIndex++] = totalSize >> 8 & 255;
      buffer[startIndex++] = totalSize >> 16 & 255;
      buffer[startIndex++] = totalSize >> 24 & 255;
      buffer[index++] = 0;
    } else {
      buffer[index++] = BSON2.BSON_DATA_CODE;
      numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      functionString = value.code.toString();
      var size = buffer.write(functionString, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
    }
    return index;
  };
  var serializeBinary = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var data = value.value(true);
    var size = value.position;
    if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    buffer[index++] = size & 255;
    buffer[index++] = size >> 8 & 255;
    buffer[index++] = size >> 16 & 255;
    buffer[index++] = size >> 24 & 255;
    buffer[index++] = value.sub_type;
    if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
    }
    data.copy(buffer, index, 0, value.position);
    index = index + value.position;
    return index;
  };
  var serializeSymbol = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_SYMBOL;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = buffer.write(value.value, index + 4, "utf8") + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = size >> 8 & 255;
    buffer[index + 2] = size >> 16 & 255;
    buffer[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  };
  var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {
    buffer[index++] = BSON2.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var endIndex;
    if (value.db != null) {
      endIndex = serializeInto(buffer, {
        $ref: value.namespace,
        $id: value.oid,
        $db: value.db
      }, false, index, depth + 1, serializeFunctions);
    } else {
      endIndex = serializeInto(buffer, {
        $ref: value.namespace,
        $id: value.oid
      }, false, index, depth + 1, serializeFunctions);
    }
    var size = endIndex - startIndex;
    buffer[startIndex++] = size & 255;
    buffer[startIndex++] = size >> 8 & 255;
    buffer[startIndex++] = size >> 16 & 255;
    buffer[startIndex++] = size >> 24 & 255;
    return endIndex;
  };
  var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    startingIndex = startingIndex || 0;
    path = path || [];
    path.push(object);
    var index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        var key = "" + i;
        var value = object[i];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== "function")
            throw new Error("toBSON is not a function");
          value = value.toBSON();
        }
        var type = typeof value;
        if (type === "string") {
          index = serializeString(buffer, key, value, index, true);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index, true);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index, true);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index, true);
        } else if (value === void 0) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index, true);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index, true);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index, true);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index, true);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index, true);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    } else if (object instanceof Map2) {
      var iterator = object.entries();
      var done = false;
      while (!done) {
        var entry = iterator.next();
        done = entry.done;
        if (done)
          continue;
        key = entry.value[0];
        value = entry.value[1];
        type = typeof value;
        if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
          if (key.match(regexp) != null) {
            throw Error("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw Error("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw Error("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (value === null || value === void 0 && ignoreUndefined === false) {
          index = serializeNull(buffer, key, value, index);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    } else {
      if (object.toBSON) {
        if (typeof object.toBSON !== "function")
          throw new Error("toBSON is not a function");
        object = object.toBSON();
        if (object != null && typeof object !== "object")
          throw new Error("toBSON function did not return an object");
      }
      for (key in object) {
        value = object[key];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== "function")
            throw new Error("toBSON is not a function");
          value = value.toBSON();
        }
        type = typeof value;
        if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
          if (key.match(regexp) != null) {
            throw Error("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw Error("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw Error("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (value === void 0) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    }
    path.pop();
    buffer[index++] = 0;
    var size = index - startingIndex;
    buffer[startingIndex++] = size & 255;
    buffer[startingIndex++] = size >> 8 & 255;
    buffer[startingIndex++] = size >> 16 & 255;
    buffer[startingIndex++] = size >> 24 & 255;
    return index;
  };
  var BSON2 = {};
  BSON2.BSON_DATA_NUMBER = 1;
  BSON2.BSON_DATA_STRING = 2;
  BSON2.BSON_DATA_OBJECT = 3;
  BSON2.BSON_DATA_ARRAY = 4;
  BSON2.BSON_DATA_BINARY = 5;
  BSON2.BSON_DATA_UNDEFINED = 6;
  BSON2.BSON_DATA_OID = 7;
  BSON2.BSON_DATA_BOOLEAN = 8;
  BSON2.BSON_DATA_DATE = 9;
  BSON2.BSON_DATA_NULL = 10;
  BSON2.BSON_DATA_REGEXP = 11;
  BSON2.BSON_DATA_CODE = 13;
  BSON2.BSON_DATA_SYMBOL = 14;
  BSON2.BSON_DATA_CODE_W_SCOPE = 15;
  BSON2.BSON_DATA_INT = 16;
  BSON2.BSON_DATA_TIMESTAMP = 17;
  BSON2.BSON_DATA_LONG = 18;
  BSON2.BSON_DATA_DECIMAL128 = 19;
  BSON2.BSON_DATA_MIN_KEY = 255;
  BSON2.BSON_DATA_MAX_KEY = 127;
  BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  module2.exports = serializeInto;
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_long().Long;
  var Double2 = require_double().Double;
  var Timestamp2 = require_timestamp().Timestamp;
  var ObjectID2 = require_objectid().ObjectID;
  var Symbol2 = require_symbol().Symbol;
  var BSONRegExp2 = require_regexp().BSONRegExp;
  var Code2 = require_code().Code;
  var Decimal1282 = require_decimal128();
  var MinKey2 = require_min_key().MinKey;
  var MaxKey2 = require_max_key().MaxKey;
  var DBRef2 = require_db_ref().DBRef;
  var Binary2 = require_binary().Binary;
  var normalizedFunctionString = require_utils().normalizedFunctionString;
  var isDate = function isDate2(d) {
    return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
  };
  var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
    var totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (object.toBSON) {
        object = object.toBSON();
      }
      for (var key in object) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  };
  function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
    if (value && value.toBSON) {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
      case "number":
        if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
      case "object":
        if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
        } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
        } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
        } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
          }
        } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
          if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
          }
        } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
        } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
          var ordered_values = {
            $ref: value.namespace,
            $id: value.oid
          };
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
        } else {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else {
          if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else if (serializeFunctions) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
          }
        }
    }
    return 0;
  }
  var BSON2 = {};
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  module2.exports = calculateObjectSize;
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS((exports2, module2) => {
  "use strict";
  var Map2 = require_map();
  var Long2 = require_long();
  var Double2 = require_double();
  var Timestamp2 = require_timestamp();
  var ObjectID2 = require_objectid();
  var BSONRegExp2 = require_regexp();
  var Symbol2 = require_symbol();
  var Int322 = require_int_32();
  var Code2 = require_code();
  var Decimal1282 = require_decimal128();
  var MinKey2 = require_min_key();
  var MaxKey2 = require_max_key();
  var DBRef2 = require_db_ref();
  var Binary2 = require_binary();
  var deserialize2 = require_deserializer();
  var serializer = require_serializer();
  var calculateObjectSize = require_calculate_size();
  var utils2 = require_utils();
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = utils2.allocBuffer(MAXSIZE);
  var BSON2 = function() {
  };
  BSON2.prototype.serialize = function serialize(object, options) {
    options = options || {};
    var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = utils2.allocBuffer(minInternalBufferSize);
    }
    var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
    var finishedBuffer = utils2.allocBuffer(serializationIndex);
    buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
    return finishedBuffer;
  };
  BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options) {
    options = options || {};
    var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    var startIndex = typeof options.index === "number" ? options.index : 0;
    var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
    return serializationIndex - 1;
  };
  BSON2.prototype.deserialize = function(buffer2, options) {
    return deserialize2(buffer2, options);
  };
  BSON2.prototype.calculateObjectSize = function(object, options) {
    options = options || {};
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
  };
  BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    options = options != null ? options : {};
    var index = startIndex;
    for (var i = 0; i < numberOfDocuments; i++) {
      var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
      options["index"] = index;
      documents[docStartIndex + i] = this.deserialize(data, options);
      index = index + size;
    }
    return index;
  };
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  BSON2.BSON_DATA_NUMBER = 1;
  BSON2.BSON_DATA_STRING = 2;
  BSON2.BSON_DATA_OBJECT = 3;
  BSON2.BSON_DATA_ARRAY = 4;
  BSON2.BSON_DATA_BINARY = 5;
  BSON2.BSON_DATA_OID = 7;
  BSON2.BSON_DATA_BOOLEAN = 8;
  BSON2.BSON_DATA_DATE = 9;
  BSON2.BSON_DATA_NULL = 10;
  BSON2.BSON_DATA_REGEXP = 11;
  BSON2.BSON_DATA_CODE = 13;
  BSON2.BSON_DATA_SYMBOL = 14;
  BSON2.BSON_DATA_CODE_W_SCOPE = 15;
  BSON2.BSON_DATA_INT = 16;
  BSON2.BSON_DATA_TIMESTAMP = 17;
  BSON2.BSON_DATA_LONG = 18;
  BSON2.BSON_DATA_MIN_KEY = 255;
  BSON2.BSON_DATA_MAX_KEY = 127;
  BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  module2.exports = BSON2;
  module2.exports.Code = Code2;
  module2.exports.Map = Map2;
  module2.exports.Symbol = Symbol2;
  module2.exports.BSON = BSON2;
  module2.exports.DBRef = DBRef2;
  module2.exports.Binary = Binary2;
  module2.exports.ObjectID = ObjectID2;
  module2.exports.Long = Long2;
  module2.exports.Timestamp = Timestamp2;
  module2.exports.Double = Double2;
  module2.exports.Int32 = Int322;
  module2.exports.MinKey = MinKey2;
  module2.exports.MaxKey = MaxKey2;
  module2.exports.BSONRegExp = BSONRegExp2;
  module2.exports.Decimal128 = Decimal1282;
});

// node_modules/bson/index.js
var require_bson2 = __commonJS((exports2, module2) => {
  var BSON2 = require_bson();
  var Binary2 = require_binary();
  var Code2 = require_code();
  var DBRef2 = require_db_ref();
  var Decimal1282 = require_decimal128();
  var Double2 = require_double();
  var Int322 = require_int_32();
  var Long2 = require_long();
  var Map2 = require_map();
  var MaxKey2 = require_max_key();
  var MinKey2 = require_min_key();
  var ObjectId = require_objectid();
  var BSONRegExp2 = require_regexp();
  var Symbol2 = require_symbol();
  var Timestamp2 = require_timestamp();
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  BSON2.Binary = Binary2;
  BSON2.Code = Code2;
  BSON2.DBRef = DBRef2;
  BSON2.Decimal128 = Decimal1282;
  BSON2.Double = Double2;
  BSON2.Int32 = Int322;
  BSON2.Long = Long2;
  BSON2.Map = Map2;
  BSON2.MaxKey = MaxKey2;
  BSON2.MinKey = MinKey2;
  BSON2.ObjectId = ObjectId;
  BSON2.ObjectID = ObjectId;
  BSON2.BSONRegExp = BSONRegExp2;
  BSON2.Symbol = Symbol2;
  BSON2.Timestamp = Timestamp2;
  module2.exports = BSON2;
});

// node_modules/require_optional/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var Module = require("module");
  module2.exports = function(fromDir, moduleId) {
    if (typeof fromDir !== "string" || typeof moduleId !== "string") {
      throw new TypeError("Expected `fromDir` and `moduleId` to be a string");
    }
    fromDir = path.resolve(fromDir);
    var fromFile = path.join(fromDir, "noop.js");
    try {
      return Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
    } catch (err) {
      return null;
    }
  };
});

// node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug6;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug6 = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug6 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug6(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug6("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug6("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug6("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug6("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug6("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug6("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug6("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug6("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug6("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug6("caret", comp);
    comp = replaceTildes(comp, options);
    debug6("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug6("xrange", comp);
    comp = replaceStars(comp, options);
    debug6("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug6("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug6("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug6("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug6("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug6("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug6("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug6("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug6("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug6("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug6("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug6("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug6("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug6(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/require_optional/index.js
var require_require_optional = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  var f = require("util").format;
  var resolveFrom = require_resolve_from();
  var semver = require_semver();
  var exists = fs.existsSync || path.existsSync;
  var find_package_json = function(location) {
    var found = false;
    while (!found) {
      if (exists(location + "/package.json")) {
        found = location;
      } else if (location !== "/") {
        location = path.dirname(location);
      } else {
        return false;
      }
    }
    return location;
  };
  var find_package_json_with_name = function(name) {
    var currentModule = module2;
    var found = false;
    while (currentModule) {
      location = currentModule.filename;
      var location = find_package_json(location);
      if (!location) {
        currentModule = currentModule.parent;
        continue;
      }
      var object = JSON.parse(fs.readFileSync(f("%s/package.json", location)));
      var parts = name.split(/\//);
      if (!object.peerOptionalDependencies || object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {
        currentModule = currentModule.parent;
        continue;
      }
      found = true;
      break;
    }
    if (!found) {
      throw new Error(f("no optional dependency [%s] defined in peerOptionalDependencies in any package.json", parts[0]));
    }
    return {
      object,
      parts
    };
  };
  var require_optional = function(name, options) {
    options = options || {};
    options.strict = typeof options.strict == "boolean" ? options.strict : true;
    var res = find_package_json_with_name(name);
    var object = res.object;
    var parts = res.parts;
    var expectedVersions = object.peerOptionalDependencies[parts[0]];
    var moduleEntry = void 0;
    var moduleEntryFile = name;
    try {
      moduleEntry = require(moduleEntryFile);
    } catch (err) {
      try {
        moduleEntryFile = resolveFrom(process.cwd(), name);
        if (moduleEntryFile == null)
          return void 0;
        moduleEntry = require(moduleEntryFile);
      } catch (err2) {
        if (err2.code === "MODULE_NOT_FOUND")
          return void 0;
      }
    }
    var location = find_package_json(require.resolve(moduleEntryFile));
    if (!location) {
      throw new Error("package.json can not be located");
    }
    var dependentOnModule = JSON.parse(fs.readFileSync(f("%s/package.json", location)));
    var version = dependentOnModule.version;
    if (semver.satisfies(version, expectedVersions) == false && options.strict) {
      var error = new Error(f("optional dependency [%s] found but version [%s] did not satisfy constraint [%s]", parts[0], version, expectedVersions));
      error.code = "OPTIONAL_MODULE_NOT_FOUND";
      throw error;
    }
    return moduleEntry;
  };
  require_optional.exists = function(name) {
    try {
      var m = require_optional(name);
      if (m === void 0)
        return false;
      return true;
    } catch (err) {
      return false;
    }
  };
  module2.exports = require_optional;
});

// node_modules/mongodb/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    _from: "mongodb@^3.6.3",
    _id: "mongodb@3.6.4",
    _inBundle: false,
    _integrity: "sha512-Y+Ki9iXE9jI+n9bVtbTOOdK0B95d6wVGSucwtBkvQ+HIvVdTCfpVRp01FDC24uhC/Q2WXQ8Lpq3/zwtB5Op9Qw==",
    _location: "/mongodb",
    _phantomChildren: {},
    _requested: {
      type: "range",
      registry: true,
      raw: "mongodb@^3.6.3",
      name: "mongodb",
      escapedName: "mongodb",
      rawSpec: "^3.6.3",
      saveSpec: null,
      fetchSpec: "^3.6.3"
    },
    _requiredBy: [
      "#DEV:/"
    ],
    _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.4.tgz",
    _shasum: "ca59fd65b06831308262372ef9df6b78f9da97be",
    _spec: "mongodb@^3.6.3",
    _where: "D:\\Programming-School\\scrummy-bot",
    bugs: {
      url: "https://github.com/mongodb/node-mongodb-native/issues"
    },
    bundleDependencies: false,
    dependencies: {
      bl: "^2.2.1",
      bson: "^1.1.4",
      denque: "^1.4.1",
      require_optional: "^1.0.1",
      "safe-buffer": "^5.1.2",
      saslprep: "^1.0.0"
    },
    deprecated: false,
    description: "The official MongoDB driver for Node.js",
    devDependencies: {
      chai: "^4.1.1",
      "chai-subset": "^1.6.0",
      chalk: "^2.4.2",
      co: "4.6.0",
      coveralls: "^2.11.6",
      eslint: "^7.10.0",
      "eslint-config-prettier": "^6.11.0",
      "eslint-plugin-es": "^3.0.1",
      "eslint-plugin-prettier": "^3.1.3",
      istanbul: "^0.4.5",
      jsdoc: "3.5.5",
      "lodash.camelcase": "^4.3.0",
      mocha: "5.2.0",
      "mocha-sinon": "^2.1.0",
      "mongodb-extjson": "^2.1.1",
      "mongodb-mock-server": "^1.0.1",
      prettier: "^1.19.1",
      semver: "^5.5.0",
      sinon: "^4.3.0",
      "sinon-chai": "^3.2.0",
      snappy: "^6.3.4",
      "spec-xunit-file": "0.0.1-3",
      "standard-version": "^8.0.2",
      "util.promisify": "^1.0.1",
      "worker-farm": "^1.5.0",
      wtfnode: "^0.8.0",
      yargs: "^14.2.0"
    },
    engines: {
      node: ">=4"
    },
    files: [
      "index.js",
      "lib"
    ],
    homepage: "https://github.com/mongodb/node-mongodb-native",
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    license: "Apache-2.0",
    main: "index.js",
    name: "mongodb",
    optionalDependencies: {
      saslprep: "^1.0.0"
    },
    peerDependenciesMeta: {
      kerberos: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      },
      "mongodb-extjson": {
        optional: true
      },
      snappy: {
        optional: true
      },
      "bson-ext": {
        optional: true
      },
      aws4: {
        optional: true
      }
    },
    peerOptionalDependencies: {
      kerberos: "^1.1.0",
      "mongodb-client-encryption": "^1.0.0",
      "mongodb-extjson": "^2.1.2",
      snappy: "^6.3.4",
      "bson-ext": "^2.0.0"
    },
    repository: {
      type: "git",
      url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
    },
    scripts: {
      atlas: "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
      bench: "node test/benchmarks/driverBench/",
      "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
      "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
      "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
      coverage: "istanbul cover mongodb-test-runner -- -t 60000 test/unit test/functional",
      format: "npm run lint -- --fix",
      "generate-evergreen": "node .evergreen/generate_evergreen_tasks.js",
      lint: "eslint -v && eslint lib test",
      release: "standard-version -i HISTORY.md",
      test: "npm run lint && mocha --recursive test/functional test/unit",
      "test-nolint": "mocha --recursive test/functional test/unit"
    },
    version: "3.6.4"
  };
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var crypto = require("crypto");
  var requireOptional = require_require_optional();
  var uuidV4 = () => {
    const result = crypto.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  };
  function relayEvents(listener, emitter, events) {
    events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
  }
  function retrieveKerberos() {
    let kerberos;
    try {
      kerberos = requireOptional("kerberos");
    } catch (err) {
      if (err.code === "MODULE_NOT_FOUND") {
        throw new Error("The `kerberos` module was not found. Please install it and try again.");
      }
      throw err;
    }
    return kerberos;
  }
  var noEJSONError = function() {
    throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
  };
  function retrieveEJSON() {
    let EJSON = null;
    try {
      EJSON = requireOptional("mongodb-extjson");
    } catch (error) {
    }
    if (!EJSON) {
      EJSON = {
        parse: noEJSONError,
        deserialize: noEJSONError,
        serialize: noEJSONError,
        stringify: noEJSONError,
        setBSONModule: noEJSONError,
        BSON: noEJSONError
      };
    }
    return EJSON;
  }
  function maxWireVersion(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.ismaster) {
        return topologyOrServer.ismaster.maxWireVersion;
      }
      if (typeof topologyOrServer.lastIsMaster === "function") {
        const lastIsMaster = topologyOrServer.lastIsMaster();
        if (lastIsMaster) {
          return lastIsMaster.maxWireVersion;
        }
      }
      if (topologyOrServer.description) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  }
  function collationNotSupported(server, cmd) {
    return cmd && cmd.collation && maxWireVersion(server) < 5;
  }
  function isPromiseLike(maybePromise) {
    return maybePromise && typeof maybePromise.then === "function";
  }
  function eachAsync(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = 0;
    for (idx = 0; idx < arr.length; ++idx) {
      awaiting++;
      eachFn(arr[idx], eachCallback);
    }
    if (awaiting === 0) {
      callback();
      return;
    }
    function eachCallback(err) {
      awaiting--;
      if (err) {
        callback(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback();
      }
    }
  }
  function eachAsyncSeries(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = arr.length;
    if (awaiting === 0) {
      callback();
      return;
    }
    function eachCallback(err) {
      idx++;
      awaiting--;
      if (err) {
        callback(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback();
        return;
      }
      eachFn(arr[idx], eachCallback);
    }
    eachFn(arr[idx], eachCallback);
  }
  function isUnifiedTopology(topology) {
    return topology.description != null;
  }
  function arrayStrictEqual(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  }
  function tagsStrictEqual(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  }
  function errorStrictEqual(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  }
  function makeStateMachine(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  }
  function makeClientMetadata(options) {
    options = options || {};
    const metadata = {
      driver: {
        name: "nodejs",
        version: require_package2().version
      },
      os: {
        type: os.type(),
        name: process.platform,
        architecture: process.arch,
        version: os.release()
      },
      platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? "unified" : "legacy"})`
    };
    if (options.driverInfo) {
      if (options.driverInfo.name) {
        metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;
      }
      if (options.driverInfo.version) {
        metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;
      }
      if (options.driverInfo.platform) {
        metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;
      }
    }
    if (options.appname) {
      const buffer = Buffer.from(options.appname);
      metadata.application = {
        name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options.appname
      };
    }
    return metadata;
  }
  var noop = () => {
  };
  module2.exports = {
    uuidV4,
    relayEvents,
    collationNotSupported,
    retrieveEJSON,
    retrieveKerberos,
    maxWireVersion,
    isPromiseLike,
    eachAsync,
    eachAsyncSeries,
    isUnifiedTopology,
    arrayStrictEqual,
    tagsStrictEqual,
    errorStrictEqual,
    makeStateMachine,
    makeClientMetadata,
    noop
  };
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS((exports2, module2) => {
  "use strict";
  var kErrorLabels = Symbol("errorLabels");
  var MongoError = class extends Error {
    constructor(message) {
      if (message instanceof Error) {
        super(message.message);
        this.stack = message.stack;
      } else {
        if (typeof message === "string") {
          super(message);
        } else {
          super(message.message || message.errmsg || message.$err || "n/a");
          if (message.errorLabels) {
            this[kErrorLabels] = new Set(message.errorLabels);
          }
          for (var name in message) {
            if (name === "errorLabels" || name === "errmsg") {
              continue;
            }
            this[name] = message[name];
          }
        }
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    static create(options) {
      return new MongoError(options);
    }
    hasErrorLabel(label) {
      if (this[kErrorLabels] == null) {
        return false;
      }
      return this[kErrorLabels].has(label);
    }
    addErrorLabel(label) {
      if (this[kErrorLabels] == null) {
        this[kErrorLabels] = new Set();
      }
      this[kErrorLabels].add(label);
    }
    get errorLabels() {
      return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
    }
  };
  var kBeforeHandshake = Symbol("beforeHandshake");
  function isNetworkErrorBeforeHandshake(err) {
    return err[kBeforeHandshake] === true;
  }
  var MongoNetworkError = class extends MongoError {
    constructor(message, options) {
      super(message);
      this.name = "MongoNetworkError";
      if (options && options.beforeHandshake === true) {
        this[kBeforeHandshake] = true;
      }
    }
  };
  var MongoNetworkTimeoutError = class extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
      this.name = "MongoNetworkTimeoutError";
    }
  };
  var MongoParseError = class extends MongoError {
    constructor(message) {
      super(message);
      this.name = "MongoParseError";
    }
  };
  var MongoTimeoutError = class extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(reason.error.message || reason.error);
      } else {
        super(message);
      }
      this.name = "MongoTimeoutError";
      if (reason) {
        this.reason = reason;
      }
    }
  };
  var MongoServerSelectionError = class extends MongoTimeoutError {
    constructor(message, reason) {
      super(message, reason);
      this.name = "MongoServerSelectionError";
    }
  };
  function makeWriteConcernResultObject(input) {
    const output = Object.assign({}, input);
    if (output.ok === 0) {
      output.ok = 1;
      delete output.errmsg;
      delete output.code;
      delete output.codeName;
    }
    return output;
  }
  var MongoWriteConcernError = class extends MongoError {
    constructor(message, result) {
      super(message);
      this.name = "MongoWriteConcernError";
      if (result && Array.isArray(result.errorLabels)) {
        this[kErrorLabels] = new Set(result.errorLabels);
      }
      if (result != null) {
        this.result = makeWriteConcernResultObject(result);
      }
    }
  };
  var RETRYABLE_ERROR_CODES = new Set([
    6,
    7,
    89,
    91,
    189,
    9001,
    10107,
    11600,
    11602,
    13435,
    13436
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = new Set([
    11600,
    11602,
    10107,
    13435,
    13436,
    189,
    91,
    7,
    6,
    89,
    9001,
    262
  ]);
  function isRetryableWriteError(error) {
    if (error instanceof MongoWriteConcernError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(error.code) || RETRYABLE_WRITE_ERROR_CODES.has(error.result.code);
    }
    return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
  }
  function isRetryableError(error) {
    return RETRYABLE_ERROR_CODES.has(error.code) || error instanceof MongoNetworkError || error.message.match(/not master/) || error.message.match(/node is recovering/);
  }
  var SDAM_RECOVERING_CODES = new Set([
    91,
    189,
    11600,
    11602,
    13436
  ]);
  var SDAM_NOTMASTER_CODES = new Set([
    10107,
    13435
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    11600,
    91
  ]);
  function isRecoveringError(err) {
    if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
      return true;
    }
    return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
  }
  function isNotMasterError(err) {
    if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
      return true;
    }
    if (isRecoveringError(err)) {
      return false;
    }
    return err.message.match(/not master/);
  }
  function isNodeShuttingDownError(err) {
    return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
  }
  function isSDAMUnrecoverableError(error) {
    if (error instanceof MongoParseError || error == null) {
      return true;
    }
    if (isRecoveringError(error) || isNotMasterError(error)) {
      return true;
    }
    return false;
  }
  module2.exports = {
    MongoError,
    MongoNetworkError,
    MongoNetworkTimeoutError,
    MongoParseError,
    MongoTimeoutError,
    MongoServerSelectionError,
    MongoWriteConcernError,
    isRetryableError,
    isSDAMUnrecoverableError,
    isNodeShuttingDownError,
    isRetryableWriteError,
    isNetworkErrorBeforeHandshake
  };
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS((exports2, module2) => {
  "use strict";
  var require_optional = require_require_optional();
  function debugOptions(debugFields, options) {
    var finaloptions = {};
    debugFields.forEach(function(n) {
      finaloptions[n] = options[n];
    });
    return finaloptions;
  }
  function retrieveBSON() {
    var BSON2 = require_bson2();
    BSON2.native = false;
    try {
      var optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
    } catch (err) {
    }
    return BSON2;
  }
  function noSnappyWarning() {
    throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
  }
  function retrieveSnappy() {
    var snappy = null;
    try {
      snappy = require_optional("snappy");
    } catch (error) {
    }
    if (!snappy) {
      snappy = {
        compress: noSnappyWarning,
        uncompress: noSnappyWarning,
        compressSync: noSnappyWarning,
        uncompressSync: noSnappyWarning
      };
    }
    return snappy;
  }
  module2.exports = {
    debugOptions,
    retrieveBSON,
    retrieveSnappy
  };
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = function(mode, tags, options) {
    if (!ReadPreference.isValid(mode)) {
      throw new TypeError(`Invalid read preference mode ${mode}`);
    }
    if (tags && !Array.isArray(tags)) {
      console.warn("ReadPreference tags must be an array, this will change in the next major version");
      const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
      const tagsHasHedge = typeof tags.hedge !== "undefined";
      const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
      if (tagsHasOptions) {
        options = tags;
        tags = void 0;
      } else {
        tags = [tags];
      }
    }
    this.mode = mode;
    this.tags = tags;
    this.hedge = options && options.hedge;
    options = options || {};
    if (options.maxStalenessSeconds != null) {
      if (options.maxStalenessSeconds <= 0) {
        throw new TypeError("maxStalenessSeconds must be a positive integer");
      }
      this.maxStalenessSeconds = options.maxStalenessSeconds;
      this.minWireVersion = 5;
    }
    if (this.mode === ReadPreference.PRIMARY) {
      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
        throw new TypeError("Primary read preference cannot be combined with tags");
      }
      if (this.maxStalenessSeconds) {
        throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
      }
      if (this.hedge) {
        throw new TypeError("Primary read preference cannot be combined with hedge");
      }
    }
  };
  Object.defineProperty(ReadPreference.prototype, "preference", {
    enumerable: true,
    get: function() {
      return this.mode;
    }
  });
  ReadPreference.PRIMARY = "primary";
  ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
  ReadPreference.SECONDARY = "secondary";
  ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
  ReadPreference.NEAREST = "nearest";
  var VALID_MODES = [
    ReadPreference.PRIMARY,
    ReadPreference.PRIMARY_PREFERRED,
    ReadPreference.SECONDARY,
    ReadPreference.SECONDARY_PREFERRED,
    ReadPreference.NEAREST,
    null
  ];
  ReadPreference.fromOptions = function(options) {
    if (!options)
      return null;
    const readPreference = options.readPreference;
    if (!readPreference)
      return null;
    const readPreferenceTags = options.readPreferenceTags;
    const maxStalenessSeconds = options.maxStalenessSeconds;
    if (typeof readPreference === "string") {
      return new ReadPreference(readPreference, readPreferenceTags);
    } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
      const mode = readPreference.mode || readPreference.preference;
      if (mode && typeof mode === "string") {
        return new ReadPreference(mode, readPreference.tags, {
          maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
          hedge: readPreference.hedge
        });
      }
    }
    return readPreference;
  };
  ReadPreference.resolve = function(parent, options) {
    options = options || {};
    const session = options.session;
    const inheritedReadPreference = parent && parent.readPreference;
    let readPreference;
    if (options.readPreference) {
      readPreference = ReadPreference.fromOptions(options);
    } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
      readPreference = session.transaction.options.readPreference;
    } else if (inheritedReadPreference != null) {
      readPreference = inheritedReadPreference;
    } else {
      readPreference = ReadPreference.primary;
    }
    return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
  };
  ReadPreference.translate = function(options) {
    if (options.readPreference == null)
      return options;
    const r = options.readPreference;
    if (typeof r === "string") {
      options.readPreference = new ReadPreference(r);
    } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
      const mode = r.mode || r.preference;
      if (mode && typeof mode === "string") {
        options.readPreference = new ReadPreference(mode, r.tags, {
          maxStalenessSeconds: r.maxStalenessSeconds
        });
      }
    } else if (!(r instanceof ReadPreference)) {
      throw new TypeError("Invalid read preference: " + r);
    }
    return options;
  };
  ReadPreference.isValid = function(mode) {
    return VALID_MODES.indexOf(mode) !== -1;
  };
  ReadPreference.prototype.isValid = function(mode) {
    return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
  };
  var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
  ReadPreference.prototype.slaveOk = function() {
    return needSlaveOk.indexOf(this.mode) !== -1;
  };
  ReadPreference.prototype.equals = function(readPreference) {
    return readPreference.mode === this.mode;
  };
  ReadPreference.prototype.toJSON = function() {
    const readPreference = {mode: this.mode};
    if (Array.isArray(this.tags))
      readPreference.tags = this.tags;
    if (this.maxStalenessSeconds)
      readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
    if (this.hedge)
      readPreference.hedge = this.hedge;
    return readPreference;
  };
  ReadPreference.primary = new ReadPreference("primary");
  ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
  ReadPreference.secondary = new ReadPreference("secondary");
  ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
  ReadPreference.nearest = new ReadPreference("nearest");
  module2.exports = ReadPreference;
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common2 = __commonJS((exports2, module2) => {
  "use strict";
  var STATE_CLOSING = "closing";
  var STATE_CLOSED = "closed";
  var STATE_CONNECTING = "connecting";
  var STATE_CONNECTED = "connected";
  var TopologyType = {
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown"
  };
  var ServerType = {
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown"
  };
  function serverType(server) {
    let description = server.s.description || server.s.serverDescription;
    if (description.topologyType === TopologyType.Single)
      return description.servers[0].type;
    return description.type;
  }
  var TOPOLOGY_DEFAULTS = {
    useUnifiedTopology: true,
    localThresholdMS: 15,
    serverSelectionTimeoutMS: 3e4,
    heartbeatFrequencyMS: 1e4,
    minHeartbeatFrequencyMS: 500
  };
  function drainTimerQueue(queue) {
    queue.forEach(clearTimeout);
    queue.clear();
  }
  function clearAndRemoveTimerFrom(timer, timers) {
    clearTimeout(timer);
    return timers.delete(timer);
  }
  module2.exports = {
    STATE_CLOSING,
    STATE_CLOSED,
    STATE_CONNECTING,
    STATE_CONNECTED,
    TOPOLOGY_DEFAULTS,
    TopologyType,
    ServerType,
    serverType,
    drainTimerQueue,
    clearAndRemoveTimerFrom
  };
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports2, module2) => {
  "use strict";
  var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
  var WriteConcern = class {
    constructor(w, wtimeout, j, fsync) {
      if (w != null) {
        this.w = w;
      }
      if (wtimeout != null) {
        this.wtimeout = wtimeout;
      }
      if (j != null) {
        this.j = j;
      }
      if (fsync != null) {
        this.fsync = fsync;
      }
    }
    static fromOptions(options) {
      if (options == null || options.writeConcern == null && options.w == null && options.wtimeout == null && options.j == null && options.journal == null && options.fsync == null) {
        return;
      }
      if (options.writeConcern) {
        if (typeof options.writeConcern === "string") {
          return new WriteConcern(options.writeConcern);
        }
        if (!Object.keys(options.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
          return;
        }
        return new WriteConcern(options.writeConcern.w, options.writeConcern.wtimeout, options.writeConcern.j || options.writeConcern.journal, options.writeConcern.fsync);
      }
      console.warn(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
      return new WriteConcern(options.w, options.wtimeout, options.j || options.journal, options.fsync);
    }
  };
  module2.exports = WriteConcern;
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS((exports2) => {
  "use strict";
  function asyncIterator() {
    const cursor = this;
    return {
      next: function() {
        return Promise.resolve().then(() => cursor.next()).then((value) => {
          if (!value) {
            return cursor.close().then(() => ({value, done: true}));
          }
          return {value, done: false};
        });
      }
    };
  }
  exports2.asyncIterator = asyncIterator;
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var WriteConcern = require_write_concern();
  var shallowClone = function(obj) {
    var copy = {};
    for (var name in obj)
      copy[name] = obj[name];
    return copy;
  };
  var getSingleProperty = function(obj, name, value) {
    Object.defineProperty(obj, name, {
      enumerable: true,
      get: function() {
        return value;
      }
    });
  };
  var formatSortValue = exports2.formatSortValue = function(sortDirection) {
    var value = ("" + sortDirection).toLowerCase();
    switch (value) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
    }
  };
  var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
    var orderBy = {};
    if (sortValue == null)
      return null;
    if (Array.isArray(sortValue)) {
      if (sortValue.length === 0) {
        return null;
      }
      for (var i = 0; i < sortValue.length; i++) {
        if (sortValue[i].constructor === String) {
          orderBy[sortValue[i]] = 1;
        } else {
          orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
        }
      }
    } else if (sortValue != null && typeof sortValue === "object") {
      orderBy = sortValue;
    } else if (typeof sortValue === "string") {
      orderBy[sortValue] = 1;
    } else {
      throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
    }
    return orderBy;
  };
  var checkCollectionName = function checkCollectionName2(collectionName) {
    if (typeof collectionName !== "string") {
      throw new MongoError("collection name must be a String");
    }
    if (!collectionName || collectionName.indexOf("..") !== -1) {
      throw new MongoError("collection names cannot be empty");
    }
    if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
      throw new MongoError("collection names must not contain '$'");
    }
    if (collectionName.match(/^\.|\.$/) != null) {
      throw new MongoError("collection names must not start or end with '.'");
    }
    if (collectionName.indexOf("\0") !== -1) {
      throw new MongoError("collection names cannot contain a null character");
    }
  };
  var handleCallback = function(callback, err, value1, value2) {
    try {
      if (callback == null)
        return;
      if (callback) {
        return value2 ? callback(err, value1, value2) : callback(err, value1);
      }
    } catch (err2) {
      process.nextTick(function() {
        throw err2;
      });
      return false;
    }
    return true;
  };
  var toError = function(error) {
    if (error instanceof Error)
      return error;
    var msg = error.err || error.errmsg || error.errMessage || error;
    var e = MongoError.create({message: msg, driver: true});
    var keys = typeof error === "object" ? Object.keys(error) : [];
    for (var i = 0; i < keys.length; i++) {
      try {
        e[keys[i]] = error[keys[i]];
      } catch (err) {
      }
    }
    return e;
  };
  var normalizeHintField = function normalizeHintField2(hint) {
    var finalHint = null;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach(function(param) {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (var name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  };
  var parseIndexOptions = function(fieldOrSpec) {
    var fieldHash = {};
    var indexes = [];
    var keys;
    if (typeof fieldOrSpec === "string") {
      indexes.push(fieldOrSpec + "_" + 1);
      fieldHash[fieldOrSpec] = 1;
    } else if (Array.isArray(fieldOrSpec)) {
      fieldOrSpec.forEach(function(f) {
        if (typeof f === "string") {
          indexes.push(f + "_" + 1);
          fieldHash[f] = 1;
        } else if (Array.isArray(f)) {
          indexes.push(f[0] + "_" + (f[1] || 1));
          fieldHash[f[0]] = f[1] || 1;
        } else if (isObject(f)) {
          keys = Object.keys(f);
          keys.forEach(function(k) {
            indexes.push(k + "_" + f[k]);
            fieldHash[k] = f[k];
          });
        } else {
        }
      });
    } else if (isObject(fieldOrSpec)) {
      keys = Object.keys(fieldOrSpec);
      keys.forEach(function(key) {
        indexes.push(key + "_" + fieldOrSpec[key]);
        fieldHash[key] = fieldOrSpec[key];
      });
    }
    return {
      name: indexes.join("_"),
      keys,
      fieldHash
    };
  };
  var isObject = exports2.isObject = function(arg) {
    return Object.prototype.toString.call(arg) === "[object Object]";
  };
  var debugOptions = function(debugFields, options) {
    var finaloptions = {};
    debugFields.forEach(function(n) {
      finaloptions[n] = options[n];
    });
    return finaloptions;
  };
  var decorateCommand = function(command, options, exclude) {
    for (var name in options) {
      if (exclude.indexOf(name) === -1)
        command[name] = options[name];
    }
    return command;
  };
  var mergeOptions = function(target, source) {
    for (var name in source) {
      target[name] = source[name];
    }
    return target;
  };
  var translateOptions = function(target, source) {
    var translations = {
      sslCA: "ca",
      sslCRL: "crl",
      sslValidate: "rejectUnauthorized",
      sslKey: "key",
      sslCert: "cert",
      sslPass: "passphrase",
      socketTimeoutMS: "socketTimeout",
      connectTimeoutMS: "connectionTimeout",
      replicaSet: "setName",
      rs_name: "setName",
      secondaryAcceptableLatencyMS: "acceptableLatency",
      connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
      acceptableLatencyMS: "localThresholdMS"
    };
    for (var name in source) {
      if (translations[name]) {
        target[translations[name]] = source[name];
      } else {
        target[name] = source[name];
      }
    }
    return target;
  };
  var filterOptions = function(options, names) {
    var filterOptions2 = {};
    for (var name in options) {
      if (names.indexOf(name) !== -1)
        filterOptions2[name] = options[name];
    }
    return filterOptions2;
  };
  var writeConcernKeys = ["w", "j", "wtimeout", "fsync"];
  var mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {
    for (var i = 0; i < keys.length; i++) {
      if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== void 0) {
        targetOptions[keys[i]] = sourceOptions[keys[i]];
      }
    }
    if (!mergeWriteConcern)
      return targetOptions;
    var found = false;
    for (i = 0; i < writeConcernKeys.length; i++) {
      if (targetOptions[writeConcernKeys[i]]) {
        found = true;
        break;
      }
    }
    if (!found) {
      for (i = 0; i < writeConcernKeys.length; i++) {
        if (sourceOptions[writeConcernKeys[i]]) {
          targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];
        }
      }
    }
    return targetOptions;
  };
  var executeLegacyOperation = (topology, operation, args, options) => {
    if (topology == null) {
      throw new TypeError("This method requires a valid topology instance");
    }
    if (!Array.isArray(args)) {
      throw new TypeError("This method requires an array of arguments to apply");
    }
    options = options || {};
    const Promise2 = topology.s.promiseLibrary;
    let callback = args[args.length - 1];
    let session, opOptions, owner;
    if (!options.skipSessions && topology.hasSessionSupport()) {
      opOptions = args[args.length - 2];
      if (opOptions == null || opOptions.session == null) {
        owner = Symbol();
        session = topology.startSession({owner});
        const optionsIndex = args.length - 2;
        args[optionsIndex] = Object.assign({}, args[optionsIndex], {session});
      } else if (opOptions.session && opOptions.session.hasEnded) {
        throw new MongoError("Use of expired sessions is not permitted");
      }
    }
    const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {
      if (session && session.owner === owner && !options.returnsCursor) {
        session.endSession(() => {
          delete opOptions.session;
          if (err)
            return reject(err);
          resolve(result);
        });
      } else {
        if (err)
          return reject(err);
        resolve(result);
      }
    };
    if (typeof callback === "function") {
      callback = args.pop();
      const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
      args.push(handler);
      try {
        return operation.apply(null, args);
      } catch (e) {
        handler(e);
        throw e;
      }
    }
    if (args[args.length - 1] != null) {
      throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
    }
    return new Promise2(function(resolve, reject) {
      const handler = makeExecuteCallback(resolve, reject);
      args[args.length - 1] = handler;
      try {
        return operation.apply(null, args);
      } catch (e) {
        handler(e);
      }
    });
  };
  function applyRetryableWrites(target, db) {
    if (db && db.s.options.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  }
  function applyWriteConcern(target, sources, options) {
    options = options || {};
    const db = sources.db;
    const coll = sources.collection;
    if (options.session && options.session.inTransaction()) {
      if (target.writeConcern) {
        delete target.writeConcern;
      }
      return target;
    }
    const writeConcern = WriteConcern.fromOptions(options);
    if (writeConcern) {
      return Object.assign(target, {writeConcern});
    }
    if (coll && coll.writeConcern) {
      return Object.assign(target, {writeConcern: Object.assign({}, coll.writeConcern)});
    }
    if (db && db.writeConcern) {
      return Object.assign(target, {writeConcern: Object.assign({}, db.writeConcern)});
    }
    return target;
  }
  function isPromiseLike(maybePromise2) {
    return maybePromise2 && typeof maybePromise2.then === "function";
  }
  function decorateWithCollation(command, target, options) {
    const topology = target.s && target.s.topology || target.topology;
    if (!topology) {
      throw new TypeError('parameter "target" is missing a topology');
    }
    const capabilities = topology.capabilities();
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new MongoError(`Current topology does not support collation`);
      }
    }
  }
  function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    let readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, {readConcern});
    }
  }
  function decorateWithExplain(command, explain) {
    if (command.explain) {
      return command;
    }
    return {explain: command, verbosity: explain.verbosity};
  }
  var emitProcessWarning = (msg) => process.emitWarning(msg, "DeprecationWarning");
  var emitConsoleWarning = (msg) => console.error(msg);
  var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
  function defaultMsgHandler(name, option) {
    return `${name} option [${option}] is deprecated and will be removed in a later version.`;
  }
  function deprecateOptions(config, fn) {
    if (process.noDeprecation === true) {
      return fn;
    }
    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
    const optionsWarned = new Set();
    function deprecated() {
      const options = arguments[config.optionsIndex];
      if (!isObject(options) || Object.keys(options).length === 0) {
        return fn.apply(this, arguments);
      }
      config.deprecatedOptions.forEach((deprecatedOption) => {
        if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
          optionsWarned.add(deprecatedOption);
          const msg = msgHandler(config.name, deprecatedOption);
          emitDeprecationWarning(msg);
          if (this && this.getLogger) {
            const logger = this.getLogger();
            if (logger) {
              logger.warn(msg);
            }
          }
        }
      });
      return fn.apply(this, arguments);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
      deprecated.prototype = fn.prototype;
    }
    return deprecated;
  }
  var SUPPORTS = {};
  try {
    require_async_iterator();
    SUPPORTS.ASYNC_ITERATOR = true;
  } catch (e) {
    SUPPORTS.ASYNC_ITERATOR = false;
  }
  var MongoDBNamespace = class {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (!namespace) {
        throw new Error(`Cannot parse namespace from "${namespace}"`);
      }
      const index = namespace.indexOf(".");
      return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));
    }
  };
  function* makeCounter(seed) {
    let count = seed || 0;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  function maybePromise(parent, callback, fn) {
    const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
    let result;
    if (typeof callback !== "function") {
      result = new PromiseLibrary((resolve, reject) => {
        callback = (err, res) => {
          if (err)
            return reject(err);
          resolve(res);
        };
      });
    }
    fn(function(err, res) {
      if (err != null) {
        try {
          callback(err);
        } catch (error) {
          return process.nextTick(() => {
            throw error;
          });
        }
        return;
      }
      callback(err, res);
    });
    return result;
  }
  function now() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
  }
  function calculateDurationInMs(started) {
    if (typeof started !== "number") {
      throw TypeError("numeric value required to calculate duration");
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  }
  function makeInterruptableAsyncInterval(fn, options) {
    let timerId;
    let lastCallTime;
    let lastWakeTime;
    let stopped = false;
    options = options || {};
    const interval = options.interval || 1e3;
    const minInterval = options.minInterval || 500;
    const immediate = typeof options.immediate === "boolean" ? options.immediate : false;
    const clock = typeof options.clock === "function" ? options.clock : now;
    function wake() {
      const currentTime = clock();
      const timeSinceLastWake = currentTime - lastWakeTime;
      const timeSinceLastCall = currentTime - lastCallTime;
      const timeUntilNextCall = interval - timeSinceLastCall;
      lastWakeTime = currentTime;
      if (timeSinceLastWake < minInterval) {
        return;
      }
      if (timeUntilNextCall > minInterval) {
        reschedule(minInterval);
      }
      if (timeUntilNextCall < 0) {
        executeAndReschedule();
      }
    }
    function stop() {
      stopped = true;
      if (timerId) {
        clearTimeout(timerId);
        timerId = null;
      }
      lastCallTime = 0;
      lastWakeTime = 0;
    }
    function reschedule(ms) {
      if (stopped)
        return;
      clearTimeout(timerId);
      timerId = setTimeout(executeAndReschedule, ms || interval);
    }
    function executeAndReschedule() {
      lastWakeTime = 0;
      lastCallTime = clock();
      fn((err) => {
        if (err)
          throw err;
        reschedule(interval);
      });
    }
    if (immediate) {
      executeAndReschedule();
    } else {
      lastCallTime = clock();
      reschedule();
    }
    return {wake, stop};
  }
  function hasAtomicOperators(doc) {
    if (Array.isArray(doc)) {
      return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
    }
    return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
  }
  module2.exports = {
    filterOptions,
    mergeOptions,
    translateOptions,
    shallowClone,
    getSingleProperty,
    checkCollectionName,
    toError,
    formattedOrderClause,
    parseIndexOptions,
    normalizeHintField,
    handleCallback,
    decorateCommand,
    isObject,
    debugOptions,
    MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
    mergeOptionsAndWriteConcern,
    executeLegacyOperation,
    applyRetryableWrites,
    applyWriteConcern,
    isPromiseLike,
    decorateWithCollation,
    decorateWithReadConcern,
    decorateWithExplain,
    deprecateOptions,
    SUPPORTS,
    MongoDBNamespace,
    emitDeprecationWarning,
    makeCounter,
    maybePromise,
    now,
    calculateDurationInMs,
    makeInterruptableAsyncInterval,
    hasAtomicOperators
  };
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS((exports2, module2) => {
  "use strict";
  var arrayStrictEqual = require_utils2().arrayStrictEqual;
  var tagsStrictEqual = require_utils2().tagsStrictEqual;
  var errorStrictEqual = require_utils2().errorStrictEqual;
  var ServerType = require_common2().ServerType;
  var now = require_utils4().now;
  var WRITABLE_SERVER_TYPES = new Set([
    ServerType.RSPrimary,
    ServerType.Standalone,
    ServerType.Mongos
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    ServerType.RSPrimary,
    ServerType.RSSecondary,
    ServerType.Mongos,
    ServerType.Standalone
  ]);
  var ISMASTER_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "compression",
    "me",
    "hosts",
    "passives",
    "arbiters",
    "tags",
    "setName",
    "setVersion",
    "electionId",
    "primary",
    "logicalSessionTimeoutMinutes",
    "saslSupportedMechs",
    "__nodejs_mock_server__",
    "$clusterTime"
  ];
  var ServerDescription = class {
    constructor(address, ismaster, options) {
      options = options || {};
      ismaster = Object.assign({
        minWireVersion: 0,
        maxWireVersion: 0,
        hosts: [],
        passives: [],
        arbiters: [],
        tags: []
      }, ismaster);
      this.address = address;
      this.error = options.error;
      this.roundTripTime = options.roundTripTime || -1;
      this.lastUpdateTime = now();
      this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
      this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
      this.type = parseServerType(ismaster);
      this.topologyVersion = options.topologyVersion || ismaster.topologyVersion;
      ISMASTER_FIELDS.forEach((field) => {
        if (typeof ismaster[field] !== "undefined")
          this[field] = ismaster[field];
      });
      if (this.me)
        this.me = this.me.toLowerCase();
      this.hosts = this.hosts.map((host) => host.toLowerCase());
      this.passives = this.passives.map((host) => host.toLowerCase());
      this.arbiters = this.arbiters.map((host) => host.toLowerCase());
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : port;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
      return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  };
  function parseServerType(ismaster) {
    if (!ismaster || !ismaster.ok) {
      return ServerType.Unknown;
    }
    if (ismaster.isreplicaset) {
      return ServerType.RSGhost;
    }
    if (ismaster.msg && ismaster.msg === "isdbgrid") {
      return ServerType.Mongos;
    }
    if (ismaster.setName) {
      if (ismaster.hidden) {
        return ServerType.RSOther;
      } else if (ismaster.ismaster) {
        return ServerType.RSPrimary;
      } else if (ismaster.secondary) {
        return ServerType.RSSecondary;
      } else if (ismaster.arbiterOnly) {
        return ServerType.RSArbiter;
      } else {
        return ServerType.RSOther;
      }
    }
    return ServerType.Standalone;
  }
  function compareTopologyVersion(lhs, rhs) {
    if (lhs == null || rhs == null) {
      return -1;
    }
    if (lhs.processId.equals(rhs.processId)) {
      if (lhs.counter === rhs.counter) {
        return 0;
      } else if (lhs.counter < rhs.counter) {
        return -1;
      }
      return 1;
    }
    return -1;
  }
  module2.exports = {
    ServerDescription,
    parseServerType,
    compareTopologyVersion
  };
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var MIN_SUPPORTED_SERVER_VERSION = "2.6";
  var MAX_SUPPORTED_SERVER_VERSION = "4.4";
  var MIN_SUPPORTED_WIRE_VERSION = 2;
  var MAX_SUPPORTED_WIRE_VERSION = 9;
  module2.exports = {
    MIN_SUPPORTED_SERVER_VERSION,
    MAX_SUPPORTED_SERVER_VERSION,
    MIN_SUPPORTED_WIRE_VERSION,
    MAX_SUPPORTED_WIRE_VERSION
  };
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var ServerDescription = require_server_description().ServerDescription;
  var WIRE_CONSTANTS = require_constants2();
  var TopologyType = require_common2().TopologyType;
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var TopologyDescription = class {
    constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {
      options = options || {};
      this.type = topologyType || TopologyType.Unknown;
      this.setName = setName || null;
      this.maxSetVersion = maxSetVersion || null;
      this.maxElectionId = maxElectionId || null;
      this.servers = serverDescriptions || new Map();
      this.stale = false;
      this.compatible = true;
      this.compatibilityError = null;
      this.logicalSessionTimeoutMinutes = null;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;
      this.localThresholdMS = options.localThresholdMS || 0;
      this.commonWireVersion = commonWireVersion || null;
      Object.defineProperty(this, "options", {value: options, enumberable: false});
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === ServerType.Unknown)
          continue;
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      const readableServers = Array.from(this.servers.values()).filter((s) => s.isReadable);
      this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {
        if (server.logicalSessionTimeoutMinutes == null)
          return null;
        if (result == null)
          return server.logicalSessionTimeoutMinutes;
        return Math.min(result, server.logicalSessionTimeoutMinutes);
      }, null);
    }
    updateFromSrvPollingEvent(ev) {
      const newAddresses = ev.addresses();
      const serverDescriptions = new Map(this.servers);
      for (const server of this.servers) {
        if (newAddresses.has(server[0])) {
          newAddresses.delete(server[0]);
        } else {
          serverDescriptions.delete(server[0]);
        }
      }
      if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
        return this;
      }
      for (const address of newAddresses) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let topologyType = this.type;
      let setName = this.setName;
      let maxSetVersion = this.maxSetVersion;
      let maxElectionId = this.maxElectionId;
      let commonWireVersion = this.commonWireVersion;
      if (serverDescription.setName && setName && serverDescription.setName !== setName) {
        serverDescription = new ServerDescription(address, null);
      }
      const serverType = serverDescription.type;
      let serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === TopologyType.Single) {
        return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      if (topologyType === TopologyType.Unknown) {
        if (serverType === ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === TopologyType.Sharded) {
        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === TopologyType.ReplicaSetNoPrimary) {
        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
          serverDescriptions.delete(address);
        }
        if (serverType === ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
          topologyType = result[0], setName = result[1];
        }
      }
      if (topologyType === TopologyType.ReplicaSetWithPrimary) {
        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return void 0;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
  };
  function topologyTypeForServerType(serverType) {
    if (serverType === ServerType.Standalone) {
      return TopologyType.Single;
    }
    if (serverType === ServerType.Mongos) {
      return TopologyType.Sharded;
    }
    if (serverType === ServerType.RSPrimary) {
      return TopologyType.ReplicaSetWithPrimary;
    }
    if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
      return TopologyType.Unknown;
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  function compareObjectId(oid1, oid2) {
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
      const oid1Buffer = oid1.id;
      const oid2Buffer = oid2.id;
      return oid1Buffer.compare(oid2Buffer);
    }
    const oid1String = oid1.toString();
    const oid2String = oid2.toString();
    return oid1String.localeCompare(oid2String);
  }
  function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    const electionId = serverDescription.electionId ? serverDescription.electionId : null;
    if (serverDescription.setVersion && electionId) {
      if (maxSetVersion && maxElectionId) {
        if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
          serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      }
      maxElectionId = serverDescription.electionId;
    }
    if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
      maxSetVersion = serverDescription.setVersion;
    }
    for (const address of serverDescriptions.keys()) {
      const server = serverDescriptions.get(address);
      if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new ServerDescription(server.address));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }
  function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
    if (setName == null) {
      throw new TypeError("setName is required");
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  }
  function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
    let topologyType = TopologyType.ReplicaSetNoPrimary;
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  }
  function checkHasPrimary(serverDescriptions) {
    for (const addr of serverDescriptions.keys()) {
      if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  module2.exports = {
    TopologyDescription
  };
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var ServerType = require_common2().ServerType;
  var TopologyDescription = require_topology_description().TopologyDescription;
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;
  var opcodes = {
    OP_REPLY: 1,
    OP_UPDATE: 2001,
    OP_INSERT: 2002,
    OP_QUERY: 2004,
    OP_GETMORE: 2005,
    OP_DELETE: 2006,
    OP_KILL_CURSORS: 2007,
    OP_COMPRESSED: 2012,
    OP_MSG: 2013
  };
  var getReadPreference = function(cmd, options) {
    var readPreference = cmd.readPreference || new ReadPreference("primary");
    if (options.readPreference) {
      readPreference = options.readPreference;
    }
    if (typeof readPreference === "string") {
      readPreference = new ReadPreference(readPreference);
    }
    if (!(readPreference instanceof ReadPreference)) {
      throw new MongoError("read preference must be a ReadPreference instance");
    }
    return readPreference;
  };
  var parseHeader = function(message) {
    return {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
  };
  function applyCommonQueryOptions(queryOptions, options) {
    Object.assign(queryOptions, {
      raw: typeof options.raw === "boolean" ? options.raw : false,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      monitoring: typeof options.monitoring === "boolean" ? options.monitoring : false,
      fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false
    });
    if (typeof options.socketTimeout === "number") {
      queryOptions.socketTimeout = options.socketTimeout;
    }
    if (options.session) {
      queryOptions.session = options.session;
    }
    if (typeof options.documentsReturnedIn === "string") {
      queryOptions.documentsReturnedIn = options.documentsReturnedIn;
    }
    return queryOptions;
  }
  function isSharded(topologyOrServer) {
    if (topologyOrServer.type === "mongos")
      return true;
    if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === ServerType.Mongos);
    }
    return false;
  }
  function databaseNamespace(ns) {
    return ns.split(".")[0];
  }
  function collectionNamespace(ns) {
    return ns.split(".").slice(1).join(".");
  }
  module2.exports = {
    getReadPreference,
    MESSAGE_HEADER_SIZE,
    COMPRESSION_DETAILS_SIZE,
    opcodes,
    parseHeader,
    applyCommonQueryOptions,
    isSharded,
    databaseNamespace,
    collectionNamespace
  };
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS((exports2, module2) => {
  "use strict";
  var Snappy = require_utils3().retrieveSnappy();
  var zlib = require("zlib");
  var compressorIDs = {
    snappy: 1,
    zlib: 2
  };
  var uncompressibleCommands = new Set([
    "ismaster",
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  function compress(self2, dataToBeCompressed, callback) {
    switch (self2.options.agreedCompressor) {
      case "snappy":
        Snappy.compress(dataToBeCompressed, callback);
        break;
      case "zlib":
        var zlibOptions = {};
        if (self2.options.zlibCompressionLevel) {
          zlibOptions.level = self2.options.zlibCompressionLevel;
        }
        zlib.deflate(dataToBeCompressed, zlibOptions, callback);
        break;
      default:
        throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
    }
  }
  function decompress(compressorID, compressedData, callback) {
    if (compressorID < 0 || compressorID > compressorIDs.length) {
      throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
    }
    switch (compressorID) {
      case compressorIDs.snappy:
        Snappy.uncompress(compressedData, callback);
        break;
      case compressorIDs.zlib:
        zlib.inflate(compressedData, callback);
        break;
      default:
        callback(null, compressedData);
    }
  }
  module2.exports = {
    compressorIDs,
    uncompressibleCommands,
    compress,
    decompress
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var Buffer2 = require_safe_buffer().Buffer;
  var _requestId = 0;
  var opcodes = require_shared().opcodes;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SLAVE = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;
  var Query = function(bson, ns, query, options) {
    var self2 = this;
    if (ns == null)
      throw new Error("ns must be specified for query");
    if (query == null)
      throw new Error("query must be specified for query");
    if (ns.indexOf("\0") !== -1) {
      throw new Error("namespace cannot contain a null character");
    }
    this.bson = bson;
    this.ns = ns;
    this.query = query;
    this.numberToSkip = options.numberToSkip || 0;
    this.numberToReturn = options.numberToReturn || 0;
    this.returnFieldSelector = options.returnFieldSelector || null;
    this.requestId = Query.getRequestId();
    this.pre32Limit = options.pre32Limit;
    this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
    this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : true;
    this.batchSize = self2.numberToReturn;
    this.tailable = false;
    this.slaveOk = typeof options.slaveOk === "boolean" ? options.slaveOk : false;
    this.oplogReplay = false;
    this.noCursorTimeout = false;
    this.awaitData = false;
    this.exhaust = false;
    this.partial = false;
  };
  Query.prototype.incRequestId = function() {
    this.requestId = _requestId++;
  };
  Query.nextRequestId = function() {
    return _requestId + 1;
  };
  Query.prototype.toBin = function() {
    var self2 = this;
    var buffers = [];
    var projection = null;
    var flags = 0;
    if (this.tailable) {
      flags |= OPTS_TAILABLE_CURSOR;
    }
    if (this.slaveOk) {
      flags |= OPTS_SLAVE;
    }
    if (this.oplogReplay) {
      flags |= OPTS_OPLOG_REPLAY;
    }
    if (this.noCursorTimeout) {
      flags |= OPTS_NO_CURSOR_TIMEOUT;
    }
    if (this.awaitData) {
      flags |= OPTS_AWAIT_DATA;
    }
    if (this.exhaust) {
      flags |= OPTS_EXHAUST;
    }
    if (this.partial) {
      flags |= OPTS_PARTIAL;
    }
    if (self2.batchSize !== self2.numberToReturn)
      self2.numberToReturn = self2.batchSize;
    var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
    buffers.push(header);
    var query = self2.bson.serialize(this.query, {
      checkKeys: this.checkKeys,
      serializeFunctions: this.serializeFunctions,
      ignoreUndefined: this.ignoreUndefined
    });
    buffers.push(query);
    if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
      projection = self2.bson.serialize(this.returnFieldSelector, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(projection);
    }
    var totalLength = header.length + query.length + (projection ? projection.length : 0);
    var index = 4;
    header[3] = totalLength >> 24 & 255;
    header[2] = totalLength >> 16 & 255;
    header[1] = totalLength >> 8 & 255;
    header[0] = totalLength & 255;
    header[index + 3] = this.requestId >> 24 & 255;
    header[index + 2] = this.requestId >> 16 & 255;
    header[index + 1] = this.requestId >> 8 & 255;
    header[index] = this.requestId & 255;
    index = index + 4;
    header[index + 3] = 0 >> 24 & 255;
    header[index + 2] = 0 >> 16 & 255;
    header[index + 1] = 0 >> 8 & 255;
    header[index] = 0 & 255;
    index = index + 4;
    header[index + 3] = opcodes.OP_QUERY >> 24 & 255;
    header[index + 2] = opcodes.OP_QUERY >> 16 & 255;
    header[index + 1] = opcodes.OP_QUERY >> 8 & 255;
    header[index] = opcodes.OP_QUERY & 255;
    index = index + 4;
    header[index + 3] = flags >> 24 & 255;
    header[index + 2] = flags >> 16 & 255;
    header[index + 1] = flags >> 8 & 255;
    header[index] = flags & 255;
    index = index + 4;
    index = index + header.write(this.ns, index, "utf8") + 1;
    header[index - 1] = 0;
    header[index + 3] = this.numberToSkip >> 24 & 255;
    header[index + 2] = this.numberToSkip >> 16 & 255;
    header[index + 1] = this.numberToSkip >> 8 & 255;
    header[index] = this.numberToSkip & 255;
    index = index + 4;
    header[index + 3] = this.numberToReturn >> 24 & 255;
    header[index + 2] = this.numberToReturn >> 16 & 255;
    header[index + 1] = this.numberToReturn >> 8 & 255;
    header[index] = this.numberToReturn & 255;
    index = index + 4;
    return buffers;
  };
  Query.getRequestId = function() {
    return ++_requestId;
  };
  var GetMore = function(bson, ns, cursorId, opts) {
    opts = opts || {};
    this.numberToReturn = opts.numberToReturn || 0;
    this.requestId = _requestId++;
    this.bson = bson;
    this.ns = ns;
    this.cursorId = cursorId;
  };
  GetMore.prototype.toBin = function() {
    var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
    var index = 0;
    var _buffer = Buffer2.alloc(length);
    _buffer[index + 3] = length >> 24 & 255;
    _buffer[index + 2] = length >> 16 & 255;
    _buffer[index + 1] = length >> 8 & 255;
    _buffer[index] = length & 255;
    index = index + 4;
    _buffer[index + 3] = this.requestId >> 24 & 255;
    _buffer[index + 2] = this.requestId >> 16 & 255;
    _buffer[index + 1] = this.requestId >> 8 & 255;
    _buffer[index] = this.requestId & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = opcodes.OP_GETMORE >> 24 & 255;
    _buffer[index + 2] = opcodes.OP_GETMORE >> 16 & 255;
    _buffer[index + 1] = opcodes.OP_GETMORE >> 8 & 255;
    _buffer[index] = opcodes.OP_GETMORE & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    index = index + _buffer.write(this.ns, index, "utf8") + 1;
    _buffer[index - 1] = 0;
    _buffer[index + 3] = this.numberToReturn >> 24 & 255;
    _buffer[index + 2] = this.numberToReturn >> 16 & 255;
    _buffer[index + 1] = this.numberToReturn >> 8 & 255;
    _buffer[index] = this.numberToReturn & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 255;
    _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 255;
    _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 255;
    _buffer[index] = this.cursorId.getLowBits() & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 255;
    _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 255;
    _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 255;
    _buffer[index] = this.cursorId.getHighBits() & 255;
    index = index + 4;
    return _buffer;
  };
  var KillCursor = function(bson, ns, cursorIds) {
    this.ns = ns;
    this.requestId = _requestId++;
    this.cursorIds = cursorIds;
  };
  KillCursor.prototype.toBin = function() {
    var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
    var index = 0;
    var _buffer = Buffer2.alloc(length);
    _buffer[index + 3] = length >> 24 & 255;
    _buffer[index + 2] = length >> 16 & 255;
    _buffer[index + 1] = length >> 8 & 255;
    _buffer[index] = length & 255;
    index = index + 4;
    _buffer[index + 3] = this.requestId >> 24 & 255;
    _buffer[index + 2] = this.requestId >> 16 & 255;
    _buffer[index + 1] = this.requestId >> 8 & 255;
    _buffer[index] = this.requestId & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
    _buffer[index + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
    _buffer[index + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
    _buffer[index] = opcodes.OP_KILL_CURSORS & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorIds.length >> 24 & 255;
    _buffer[index + 2] = this.cursorIds.length >> 16 & 255;
    _buffer[index + 1] = this.cursorIds.length >> 8 & 255;
    _buffer[index] = this.cursorIds.length & 255;
    index = index + 4;
    for (var i = 0; i < this.cursorIds.length; i++) {
      _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
      _buffer[index] = this.cursorIds[i].getLowBits() & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
      _buffer[index] = this.cursorIds[i].getHighBits() & 255;
      index = index + 4;
    }
    return _buffer;
  };
  var Response = function(bson, message, msgHeader, msgBody, opts) {
    opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.bson = bson;
    this.opts = opts;
    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed;
    this.responseFlags = msgBody.readInt32LE(0);
    this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
    this.startingFrom = msgBody.readInt32LE(12);
    this.numberReturned = msgBody.readInt32LE(16);
    this.documents = new Array(this.numberReturned);
    this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
    this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
    this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
    this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
    this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
    this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
    this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
  };
  Response.prototype.isParsed = function() {
    return this.parsed;
  };
  Response.prototype.parse = function(options) {
    if (this.parsed)
      return;
    options = options || {};
    var raw = options.raw || false;
    var documentsReturnedIn = options.documentsReturnedIn || null;
    var promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
    var promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
    var promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
    var bsonSize, _options;
    _options = {
      promoteLongs,
      promoteValues,
      promoteBuffers
    };
    this.index = 20;
    for (var i = 0; i < this.numberReturned; i++) {
      bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
      if (raw) {
        this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
      } else {
        this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
      }
      this.index = this.index + bsonSize;
    }
    if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
      const fieldsAsRaw = {};
      fieldsAsRaw[documentsReturnedIn] = true;
      _options.fieldsAsRaw = fieldsAsRaw;
      const doc = this.bson.deserialize(this.documents[0], _options);
      this.documents = [doc];
    }
    this.parsed = true;
  };
  module2.exports = {
    Query,
    GetMore,
    Response,
    KillCursor
  };
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var opcodes = require_shared().opcodes;
  var databaseNamespace = require_shared().databaseNamespace;
  var ReadPreference = require_read_preference();
  var _requestId = 0;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;
  var Msg = class {
    constructor(bson, ns, command, options) {
      if (command == null)
        throw new Error("query must be specified for query");
      this.bson = bson;
      this.ns = ns;
      this.command = command;
      this.command.$db = databaseNamespace(ns);
      if (options.readPreference && options.readPreference.mode !== ReadPreference.PRIMARY) {
        this.command.$readPreference = options.readPreference.toJSON();
      }
      this.options = options || {};
      this.requestId = options.requestId ? options.requestId : Msg.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome || false;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer2.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(opcodes.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeDocumentSegment(buffers, document2) {
      const payloadTypeBuffer = Buffer2.alloc(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document2);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
    serializeBson(document2) {
      return this.bson.serialize(document2, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
  };
  Msg.getRequestId = function() {
    _requestId = _requestId + 1 & 2147483647;
    return _requestId;
  };
  var BinMsg = class {
    constructor(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
      this.documents = [];
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options || {};
      this.index = 4;
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
      const promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
      const promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
      const _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers
      };
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 1) {
          console.error("TYPE 1");
        } else if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
          this.index += bsonSize;
        }
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    }
  };
  module2.exports = {Msg, BinMsg};
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS((exports2, module2) => {
  "use strict";
  var f = require("util").format;
  var MongoError = require_error().MongoError;
  var classFilters = {};
  var filteredClasses = {};
  var level = null;
  var pid = process.pid;
  var currentLogger = null;
  var Logger = function(className, options) {
    if (!(this instanceof Logger))
      return new Logger(className, options);
    options = options || {};
    this.className = className;
    if (options.logger) {
      currentLogger = options.logger;
    } else if (currentLogger == null) {
      currentLogger = console.log;
    }
    if (options.loggerLevel) {
      level = options.loggerLevel || "error";
    }
    if (filteredClasses[this.className] == null)
      classFilters[this.className] = true;
  };
  Logger.prototype.debug = function(message, object) {
    if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
      var state = {
        type: "debug",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  };
  Logger.prototype.warn = function(message, object) {
    if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
      var state = {
        type: "warn",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.info = function(message, object) {
    if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
      var state = {
        type: "info",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.error = function(message, object) {
    if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
      var state = {
        type: "error",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.isInfo = function() {
    return level === "info" || level === "debug";
  }, Logger.prototype.isError = function() {
    return level === "error" || level === "info" || level === "debug";
  }, Logger.prototype.isWarn = function() {
    return level === "error" || level === "warn" || level === "info" || level === "debug";
  }, Logger.prototype.isDebug = function() {
    return level === "debug";
  };
  Logger.reset = function() {
    level = "error";
    filteredClasses = {};
  };
  Logger.currentLogger = function() {
    return currentLogger;
  };
  Logger.setCurrentLogger = function(logger) {
    if (typeof logger !== "function")
      throw new MongoError("current logger must be a function");
    currentLogger = logger;
  };
  Logger.filter = function(type, values) {
    if (type === "class" && Array.isArray(values)) {
      filteredClasses = {};
      values.forEach(function(x) {
        filteredClasses[x] = true;
      });
    }
  };
  Logger.setLevel = function(_level) {
    if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
      throw new Error(f("%s is an illegal logging level", _level));
    }
    level = _level;
  };
  module2.exports = Logger;
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS((exports2, module2) => {
  "use strict";
  var CommandResult = function(result, connection, message) {
    this.result = result;
    this.connection = connection;
    this.message = message;
  };
  CommandResult.prototype.toJSON = function() {
    let result = Object.assign({}, this, this.result);
    delete result.message;
    return result;
  };
  CommandResult.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  module2.exports = CommandResult;
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events").EventEmitter;
  var crypto = require("crypto");
  var debugOptions = require_utils3().debugOptions;
  var parseHeader = require_shared().parseHeader;
  var decompress = require_compression().decompress;
  var Response = require_commands().Response;
  var BinMsg = require_msg().BinMsg;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var MongoError = require_error().MongoError;
  var Logger = require_logger();
  var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
  var OP_MSG = require_shared().opcodes.OP_MSG;
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var Buffer2 = require_safe_buffer().Buffer;
  var Query = require_commands().Query;
  var CommandResult = require_command_result();
  var _id = 0;
  var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
  var DEBUG_FIELDS = [
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "checkServerIdentity"
  ];
  var connectionAccountingSpy = void 0;
  var connectionAccounting = false;
  var connections = {};
  var Connection = class extends EventEmitter {
    constructor(socket, options) {
      super();
      options = options || {};
      if (!options.bson) {
        throw new TypeError("must pass in valid bson parser");
      }
      this.id = _id++;
      this.options = options;
      this.logger = Logger("Connection", options);
      this.bson = options.bson;
      this.tag = options.tag;
      this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
      this.port = options.port || 27017;
      this.host = options.host || "localhost";
      this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      this.keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
      this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
      this.connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : 3e4;
      if (this.keepAliveInitialDelay > this.socketTimeout) {
        this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
      }
      if (this.logger.isDebug()) {
        this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);
      }
      this.responseOptions = {
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false
      };
      this.flushing = false;
      this.queue = [];
      this.writeStream = null;
      this.destroyed = false;
      this.timedOut = false;
      const hash = crypto.createHash("sha1");
      hash.update(this.address);
      this.hashedName = hash.digest("hex");
      this.workItems = [];
      this.socket = socket;
      this.socket.once("error", errorHandler(this));
      this.socket.once("timeout", timeoutHandler(this));
      this.socket.once("close", closeHandler(this));
      this.socket.on("data", dataHandler(this));
      if (connectionAccounting) {
        addConnection(this.id, this);
      }
    }
    setSocketTimeout(value) {
      if (this.socket) {
        this.socket.setTimeout(value);
      }
    }
    resetSocketTimeout() {
      if (this.socket) {
        this.socket.setTimeout(this.socketTimeout);
      }
    }
    static enableConnectionAccounting(spy) {
      if (spy) {
        connectionAccountingSpy = spy;
      }
      connectionAccounting = true;
      connections = {};
    }
    static disableConnectionAccounting() {
      connectionAccounting = false;
      connectionAccountingSpy = void 0;
    }
    static connections() {
      return connections;
    }
    get address() {
      return `${this.host}:${this.port}`;
    }
    unref() {
      if (this.socket == null) {
        this.once("connect", () => this.socket.unref());
        return;
      }
      this.socket.unref();
    }
    flush(err) {
      while (this.workItems.length > 0) {
        const workItem = this.workItems.shift();
        if (workItem.cb) {
          workItem.cb(err);
        }
      }
    }
    destroy(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = Object.assign({force: false}, options);
      if (connectionAccounting) {
        deleteConnection(this.id);
      }
      if (this.socket == null) {
        this.destroyed = true;
        return;
      }
      if (options.force || this.timedOut) {
        this.socket.destroy();
        this.destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this.socket.end((err) => {
        this.destroyed = true;
        if (typeof callback === "function")
          callback(err, null);
      });
    }
    write(buffer) {
      if (this.logger.isDebug()) {
        if (!Array.isArray(buffer)) {
          this.logger.debug(`writing buffer [${buffer.toString("hex")}] to ${this.address}`);
        } else {
          for (let i = 0; i < buffer.length; i++)
            this.logger.debug(`writing buffer [${buffer[i].toString("hex")}] to ${this.address}`);
        }
      }
      if (this.socket.destroyed === false) {
        if (!Array.isArray(buffer)) {
          this.socket.write(buffer, "binary");
          return true;
        }
        for (let i = 0; i < buffer.length; i++) {
          this.socket.write(buffer[i], "binary");
        }
        return true;
      }
      return false;
    }
    toString() {
      return "" + this.id;
    }
    toJSON() {
      return {id: this.id, host: this.host, port: this.port};
    }
    isConnected() {
      if (this.destroyed)
        return false;
      return !this.socket.destroyed && this.socket.writable;
    }
    command(ns, command, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      const conn = this;
      const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      const bson = conn.options.bson;
      const query = new Query(bson, ns, command, {
        numberToSkip: 0,
        numberToReturn: 1
      });
      const noop = () => {
      };
      function _callback(err, result) {
        callback(err, result);
        callback = noop;
      }
      function errorHandler2(err) {
        conn.resetSocketTimeout();
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
        conn.removeListener("message", messageHandler);
        if (err == null) {
          err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
        }
        conn.on("error", noop);
        _callback(err);
      }
      function messageHandler(msg) {
        if (msg.responseTo !== query.requestId) {
          return;
        }
        conn.resetSocketTimeout();
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
        conn.removeListener("message", messageHandler);
        msg.parse({promoteValues: true});
        const response = msg.documents[0];
        if (response.ok === 0 || response.$err || response.errmsg || response.code) {
          _callback(new MongoError(response));
          return;
        }
        _callback(void 0, new CommandResult(response, this, msg));
      }
      conn.setSocketTimeout(socketTimeout);
      CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
      conn.on("message", messageHandler);
      conn.write(query.toBin());
    }
  };
  var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
  function deleteConnection(id) {
    delete connections[id];
    if (connectionAccountingSpy) {
      connectionAccountingSpy.deleteConnection(id);
    }
  }
  function addConnection(id, connection) {
    connections[id] = connection;
    if (connectionAccountingSpy) {
      connectionAccountingSpy.addConnection(id, connection);
    }
  }
  function errorHandler(conn) {
    return function(err) {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
      }
      conn.emit("error", new MongoNetworkError(err), conn);
    };
  }
  function timeoutHandler(conn) {
    return function() {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
      }
      conn.timedOut = true;
      conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
        beforeHandshake: conn.ismaster == null
      }), conn);
    };
  }
  function closeHandler(conn) {
    return function(hadError) {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
      }
      if (!hadError) {
        conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
      }
    };
  }
  function processMessage(conn, message) {
    const msgHeader = parseHeader(message);
    if (msgHeader.opCode !== OP_COMPRESSED) {
      const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
      conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
      return;
    }
    msgHeader.fromCompressed = true;
    let index = MESSAGE_HEADER_SIZE;
    msgHeader.opCode = message.readInt32LE(index);
    index += 4;
    msgHeader.length = message.readInt32LE(index);
    index += 4;
    const compressorID = message[index];
    index++;
    decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {
      if (err) {
        conn.emit("error", err);
        return;
      }
      if (decompressedMsgBody.length !== msgHeader.length) {
        conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
        return;
      }
      const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
      conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
    });
  }
  function dataHandler(conn) {
    return function(data) {
      while (data.length > 0) {
        if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
          const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
          if (remainingBytesToRead > data.length) {
            data.copy(conn.buffer, conn.bytesRead);
            conn.bytesRead = conn.bytesRead + data.length;
            data = Buffer2.alloc(0);
          } else {
            data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
            data = data.slice(remainingBytesToRead);
            const emitBuffer = conn.buffer;
            conn.buffer = null;
            conn.sizeOfMessage = 0;
            conn.bytesRead = 0;
            conn.stubBuffer = null;
            processMessage(conn, emitBuffer);
          }
        } else {
          if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
            if (conn.stubBuffer.length + data.length > 4) {
              const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
              conn.stubBuffer.copy(newData, 0);
              data.copy(newData, conn.stubBuffer.length);
              data = newData;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
            } else {
              const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
              conn.stubBuffer.copy(newStubBuffer, 0);
              data.copy(newStubBuffer, conn.stubBuffer.length);
              data = Buffer2.alloc(0);
            }
          } else {
            if (data.length > 4) {
              const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
              if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                const errorObject = {
                  err: "socketHandler",
                  trace: "",
                  bin: conn.buffer,
                  parseState: {
                    sizeOfMessage,
                    bytesRead: conn.bytesRead,
                    stubBuffer: conn.stubBuffer
                  }
                };
                conn.emit("parseError", errorObject, conn);
                return;
              }
              if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                conn.buffer = Buffer2.alloc(sizeOfMessage);
                data.copy(conn.buffer, 0);
                conn.bytesRead = data.length;
                conn.sizeOfMessage = sizeOfMessage;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
              } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                const emitBuffer = data;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
                processMessage(conn, emitBuffer);
              } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                const errorObject = {
                  err: "socketHandler",
                  trace: null,
                  bin: data,
                  parseState: {
                    sizeOfMessage,
                    bytesRead: 0,
                    buffer: null,
                    stubBuffer: null
                  }
                };
                conn.emit("parseError", errorObject, conn);
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
              } else {
                const emitBuffer = data.slice(0, sizeOfMessage);
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = data.slice(sizeOfMessage);
                processMessage(conn, emitBuffer);
              }
            } else {
              conn.stubBuffer = Buffer2.alloc(data.length);
              data.copy(conn.stubBuffer, 0);
              data = Buffer2.alloc(0);
            }
          }
        }
      }
    };
  }
  module2.exports = Connection;
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS((exports2, module2) => {
  "use strict";
  var Msg = require_msg().Msg;
  var KillCursor = require_commands().KillCursor;
  var GetMore = require_commands().GetMore;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var namespace = (command) => command.ns;
  var databaseName = (command) => command.ns.split(".")[0];
  var collectionName = (command) => command.ns.split(".")[1];
  var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
  var maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;
  var isLegacyPool = (pool) => pool.s && pool.queue;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldsSelector: "projection"
  };
  var OP_QUERY_KEYS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "partial",
    "exhaust"
  ];
  var extractCommand = (command) => {
    if (command instanceof GetMore) {
      return {
        getMore: command.cursorId,
        collection: collectionName(command),
        batchSize: command.numberToReturn
      };
    }
    if (command instanceof KillCursor) {
      return {
        killCursors: collectionName(command),
        cursors: command.cursorIds
      };
    }
    if (command instanceof Msg) {
      return command.command;
    }
    if (command.query && command.query.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = {find: collectionName(command)};
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (typeof command.query[key] !== "undefined")
            result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        if (typeof command[key] !== "undefined")
          result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];
      });
      OP_QUERY_KEYS.forEach((key) => {
        if (command[key])
          result[key] = command[key];
      });
      if (typeof command.pre32Limit !== "undefined") {
        result.limit = command.pre32Limit;
      }
      if (command.query.$explain) {
        return {explain: result};
      }
      return result;
    }
    return command.query ? command.query : command;
  };
  var extractReply = (command, reply) => {
    if (command instanceof GetMore) {
      return {
        ok: 1,
        cursor: {
          id: reply.message.cursorId,
          ns: namespace(command),
          nextBatch: reply.message.documents
        }
      };
    }
    if (command instanceof KillCursor) {
      return {
        ok: 1,
        cursorsUnknown: command.cursorIds
      };
    }
    if (command.query && typeof command.query.$query !== "undefined") {
      return {
        ok: 1,
        cursor: {
          id: reply.message.cursorId,
          ns: namespace(command),
          firstBatch: reply.message.documents
        }
      };
    }
    return reply && reply.result ? reply.result : reply;
  };
  var extractConnectionDetails = (pool) => {
    if (isLegacyPool(pool)) {
      return {
        connectionId: generateConnectionId(pool)
      };
    }
    const connection = pool;
    return {
      address: connection.address,
      connectionId: connection.id
    };
  };
  var CommandStartedEvent = class {
    constructor(pool, command) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      if (SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        databaseName: databaseName(command),
        commandName,
        command: cmd
      });
    }
  };
  var CommandSucceededEvent = class {
    constructor(pool, command, reply, started) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        commandName,
        duration: calculateDurationInMs(started),
        reply: maybeRedact(commandName, extractReply(command, reply))
      });
    }
  };
  var CommandFailedEvent = class {
    constructor(pool, command, error, started) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        commandName,
        duration: calculateDurationInMs(started),
        failure: maybeRedact(commandName, error)
      });
    }
  };
  module2.exports = {
    CommandStartedEvent,
    CommandSucceededEvent,
    CommandFailedEvent
  };
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS((exports2, module2) => {
  "use strict";
  var AuthContext = class {
    constructor(connection, credentials, options) {
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  };
  var AuthProvider = class {
    constructor(bson) {
      this.bson = bson;
    }
    prepare(handshakeDoc, context, callback) {
      callback(void 0, handshakeDoc);
    }
    auth(context, callback) {
      callback(new TypeError("`auth` method must be overridden by subclass"));
    }
  };
  module2.exports = {AuthContext, AuthProvider};
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS((exports2, module2) => {
  "use strict";
  var crypto = require("crypto");
  var AuthProvider = require_auth_provider().AuthProvider;
  var MongoCR = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const username = credentials.username;
      const password = credentials.password;
      const source = credentials.source;
      connection.command(`${source}.$cmd`, {getnonce: 1}, (err, result) => {
        let nonce = null;
        let key = null;
        if (err == null) {
          const r = result.result;
          nonce = r.nonce;
          let md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password, "utf8");
          const hash_password = md5.digest("hex");
          md5 = crypto.createHash("md5");
          md5.update(nonce + username + hash_password, "utf8");
          key = md5.digest("hex");
        }
        const authenticateCommand = {
          authenticate: 1,
          user: username,
          nonce,
          key
        };
        connection.command(`${source}.$cmd`, authenticateCommand, callback);
      });
    }
  };
  module2.exports = MongoCR;
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  "use strict";
  var AuthProvider = require_auth_provider().AuthProvider;
  var X509 = class extends AuthProvider {
    prepare(handshakeDoc, authContext, callback) {
      const credentials = authContext.credentials;
      Object.assign(handshakeDoc, {
        speculativeAuthenticate: x509AuthenticateCommand(credentials)
      });
      callback(void 0, handshakeDoc);
    }
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const response = authContext.response;
      if (response.speculativeAuthenticate) {
        return callback();
      }
      connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
    }
  };
  function x509AuthenticateCommand(credentials) {
    const command = {authenticate: 1, mechanism: "MONGODB-X509"};
    if (credentials.username) {
      Object.assign(command, {user: credentials.username});
    }
    return command;
  }
  module2.exports = X509;
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var AuthProvider = require_auth_provider().AuthProvider;
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var Plain = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const username = credentials.username;
      const password = credentials.password;
      const payload = new Binary2(`\0${username}\0${password}`);
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      connection.command("$external.$cmd", command, callback);
    }
  };
  module2.exports = Plain;
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS((exports2, module2) => {
  "use strict";
  var dns = require("dns");
  var AuthProvider = require_auth_provider().AuthProvider;
  var retrieveKerberos = require_utils2().retrieveKerberos;
  var MongoError = require_error().MongoError;
  var kerberos;
  var GSSAPI = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (credentials == null)
        return callback(new MongoError("credentials required"));
      const username = credentials.username;
      function externalCommand(command, cb) {
        return connection.command("$external.$cmd", command, cb);
      }
      makeKerberosClient(authContext, (err, client) => {
        if (err)
          return callback(err);
        if (client == null)
          return callback(new MongoError("gssapi client missing"));
        client.step("", (err2, payload) => {
          if (err2)
            return callback(err2);
          externalCommand(saslStart(payload), (err3, response) => {
            if (err3)
              return callback(err3);
            const result = response.result;
            negotiate(client, 10, result.payload, (err4, payload2) => {
              if (err4)
                return callback(err4);
              externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                if (err5)
                  return callback(err5);
                const result2 = response2.result;
                finalize(client, username, result2.payload, (err6, payload3) => {
                  if (err6)
                    return callback(err6);
                  externalCommand({
                    saslContinue: 1,
                    conversationId: result2.conversationId,
                    payload: payload3
                  }, (err7, result3) => {
                    if (err7)
                      return callback(err7);
                    callback(void 0, result3);
                  });
                });
              });
            });
          });
        });
      });
    }
  };
  module2.exports = GSSAPI;
  function makeKerberosClient(authContext, callback) {
    const host = authContext.options.host;
    const port = authContext.options.port;
    const credentials = authContext.credentials;
    if (!host || !port || !credentials) {
      return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
    }
    if (kerberos == null) {
      try {
        kerberos = retrieveKerberos();
      } catch (e) {
        return callback(e);
      }
    }
    const username = credentials.username;
    const password = credentials.password;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
    performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
      if (err)
        return callback(err);
      const initOptions = {};
      if (password != null) {
        Object.assign(initOptions, {user: username, password});
      }
      kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
        if (err2)
          return callback(new MongoError(err2));
        callback(null, client);
      });
    });
  }
  function saslStart(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  }
  function saslContinue(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  }
  function negotiate(client, retries, payload, callback) {
    client.step(payload, (err, response) => {
      if (err && retries === 0)
        return callback(err);
      if (err)
        return negotiate(client, retries - 1, payload, callback);
      callback(void 0, response || "");
    });
  }
  function finalize(client, user, payload, callback) {
    client.unwrap(payload, (err, response) => {
      if (err)
        return callback(err);
      client.wrap(response || "", {user}, (err2, wrapped) => {
        if (err2)
          return callback(err2);
        callback(void 0, wrapped);
      });
    });
  }
  function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
    const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
    if (!canonicalizeHostName)
      return callback(void 0, host);
    dns.resolveCname(host, (err, r) => {
      if (err)
        return callback(err);
      if (Array.isArray(r) && r.length > 0) {
        return callback(void 0, r[0]);
      }
      callback(void 0, host);
    });
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS((exports2, module2) => {
  "use strict";
  var crypto = require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var AuthProvider = require_auth_provider().AuthProvider;
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var saslprep;
  try {
    saslprep = require("saslprep");
  } catch (e) {
  }
  var ScramSHA = class extends AuthProvider {
    constructor(bson, cryptoMethod) {
      super(bson);
      this.cryptoMethod = cryptoMethod || "sha1";
    }
    prepare(handshakeDoc, authContext, callback) {
      const cryptoMethod = this.cryptoMethod;
      if (cryptoMethod === "sha256" && saslprep == null) {
        console.warn("Warning: no saslprep library specified. Passwords will not be sanitized");
      }
      crypto.randomBytes(24, (err, nonce) => {
        if (err) {
          return callback(err);
        }
        Object.assign(authContext, {nonce});
        const credentials = authContext.credentials;
        const request = Object.assign({}, handshakeDoc, {
          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
            db: credentials.source
          })
        });
        callback(void 0, request);
      });
    }
    auth(authContext, callback) {
      const response = authContext.response;
      if (response && response.speculativeAuthenticate) {
        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
        return;
      }
      executeScram(this.cryptoMethod, authContext, callback);
    }
  };
  function cleanUsername(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  }
  function clientFirstMessageBare(username, nonce) {
    return Buffer2.concat([
      Buffer2.from("n=", "utf8"),
      Buffer2.from(username, "utf8"),
      Buffer2.from(",r=", "utf8"),
      Buffer2.from(nonce.toString("base64"), "utf8")
    ]);
  }
  function makeFirstMessage(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
    return {
      saslStart: 1,
      mechanism,
      payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: {skipEmptyExchange: true}
    };
  }
  function executeScram(cryptoMethod, authContext, callback) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
      const err = resolveError(_err, result);
      if (err) {
        return callback(err);
      }
      continueScramConversation(cryptoMethod, result.result, authContext, callback);
    });
  }
  function continueScramConversation(cryptoMethod, response, authContext, callback) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    let processedPassword;
    if (cryptoMethod === "sha256") {
      processedPassword = saslprep ? saslprep(password) : password;
    } else {
      try {
        processedPassword = passwordDigest(username, password);
      } catch (e) {
        return callback(e);
      }
    }
    const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
    const dict = parsePayload(payload.value());
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
      return;
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
      return;
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H(cryptoMethod, clientKey);
    const authMessage = [
      clientFirstMessageBare(username, nonce),
      payload.value().toString("base64"),
      withoutProof
    ].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new Binary2(Buffer2.from(clientFinal))
    };
    connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
      const err = resolveError(_err, result);
      if (err) {
        return callback(err);
      }
      const r = result.result;
      const parsedResponse = parsePayload(r.payload.value());
      if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
        callback(new MongoError("Server returned an invalid signature"));
        return;
      }
      if (!r || r.done !== false) {
        return callback(err, r);
      }
      const retrySaslContinueCmd = {
        saslContinue: 1,
        conversationId: r.conversationId,
        payload: Buffer2.alloc(0)
      };
      connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
    });
  }
  function parsePayload(payload) {
    const dict = {};
    const parts = payload.split(",");
    for (let i = 0; i < parts.length; i++) {
      const valueParts = parts[i].split("=");
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  }
  function passwordDigest(username, password) {
    if (typeof username !== "string") {
      throw new MongoError("username must be a string");
    }
    if (typeof password !== "string") {
      throw new MongoError("password must be a string");
    }
    if (password.length === 0) {
      throw new MongoError("password cannot be empty");
    }
    const md5 = crypto.createHash("md5");
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  }
  function xor(a, b) {
    if (!Buffer2.isBuffer(a)) {
      a = Buffer2.from(a);
    }
    if (!Buffer2.isBuffer(b)) {
      b = Buffer2.from(b);
    }
    const length = Math.max(a.length, b.length);
    const res = [];
    for (let i = 0; i < length; i += 1) {
      res.push(a[i] ^ b[i]);
    }
    return Buffer2.from(res).toString("base64");
  }
  function H(method, text) {
    return crypto.createHash(method).update(text).digest();
  }
  function HMAC(method, key, text) {
    return crypto.createHmac(method, key).update(text).digest();
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  function _hiCachePurge() {
    _hiCache = {};
    _hiCacheCount = 0;
  }
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };
  function HI(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] !== void 0) {
      return _hiCache[key];
    }
    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  }
  function compareDigest(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto.timingSafeEqual === "function") {
      return crypto.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i = 0; i < lhs.length; i++) {
      result |= lhs[i] ^ rhs[i];
    }
    return result === 0;
  }
  function resolveError(err, result) {
    if (err)
      return err;
    const r = result.result;
    if (r.$err || r.errmsg)
      return new MongoError(r);
  }
  var ScramSHA1 = class extends ScramSHA {
    constructor(bson) {
      super(bson, "sha1");
    }
  };
  var ScramSHA256 = class extends ScramSHA {
    constructor(bson) {
      super(bson, "sha256");
    }
  };
  module2.exports = {ScramSHA1, ScramSHA256};
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports2, module2) => {
  "use strict";
  function getDefaultAuthMechanism(ismaster) {
    if (ismaster) {
      if (Array.isArray(ismaster.saslSupportedMechs)) {
        return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
      }
      if (ismaster.maxWireVersion >= 3) {
        return "scram-sha-1";
      }
    }
    return "mongocr";
  }
  var MongoCredentials = class {
    constructor(options) {
      options = options || {};
      this.username = options.username;
      this.password = options.password;
      this.source = options.source || options.db;
      this.mechanism = options.mechanism || "default";
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (this.username == null && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (this.password == null && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN) {
          this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
        }
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(ismaster) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(ismaster),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
  };
  module2.exports = {MongoCredentials};
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports2, module2) => {
  "use strict";
  var AuthProvider = require_auth_provider().AuthProvider;
  var MongoCredentials = require_mongo_credentials().MongoCredentials;
  var MongoError = require_error().MongoError;
  var crypto = require("crypto");
  var http = require("http");
  var maxWireVersion = require_utils2().maxWireVersion;
  var url = require("url");
  var aws4;
  try {
    aws4 = require("aws4");
  } catch (e) {
  }
  var ASCII_N = 110;
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
  var MongoDBAWS = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (maxWireVersion(connection) < 9) {
        callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
        return;
      }
      if (aws4 == null) {
        callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
        return;
      }
      if (credentials.username == null) {
        makeTempCredentials(credentials, (err, tempCredentials) => {
          if (err)
            return callback(err);
          authContext.credentials = tempCredentials;
          this.auth(authContext, callback);
        });
        return;
      }
      const username = credentials.username;
      const password = credentials.password;
      const db = credentials.source;
      const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const bson = this.bson;
      crypto.randomBytes(32, (err, nonce) => {
        if (err) {
          callback(err);
          return;
        }
        const saslStart = {
          saslStart: 1,
          mechanism: "MONGODB-AWS",
          payload: bson.serialize({r: nonce, p: ASCII_N})
        };
        connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
          if (err2)
            return callback(err2);
          const res = result.result;
          const serverResponse = bson.deserialize(res.payload.buffer);
          const host = serverResponse.h;
          const serverNonce = serverResponse.s.buffer;
          if (serverNonce.length !== 64) {
            callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
            return;
          }
          if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
            callback(new MongoError("Server nonce does not begin with client nonce"));
            return;
          }
          if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
            callback(new MongoError(`Server returned an invalid host: "${host}"`));
            return;
          }
          const body = "Action=GetCallerIdentity&Version=2011-06-15";
          const options = aws4.sign({
            method: "POST",
            host,
            region: deriveRegion(serverResponse.h),
            service: "sts",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "Content-Length": body.length,
              "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
              "X-MongoDB-GS2-CB-Flag": "n"
            },
            path: "/",
            body
          }, {
            accessKeyId: username,
            secretAccessKey: password,
            token
          });
          const authorization = options.headers.Authorization;
          const date = options.headers["X-Amz-Date"];
          const payload = {a: authorization, d: date};
          if (token) {
            payload.t = token;
          }
          const saslContinue = {
            saslContinue: 1,
            conversationId: 1,
            payload: bson.serialize(payload)
          };
          connection.command(`${db}.$cmd`, saslContinue, (err3) => {
            if (err3)
              return callback(err3);
            callback();
          });
        });
      });
    }
  };
  function makeTempCredentials(credentials, callback) {
    function done(creds) {
      if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
        callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
        return;
      }
      callback(void 0, new MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: "MONGODB-AWS",
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      }));
    }
    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
      request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
        if (err)
          return callback(err);
        done(res);
      });
      return;
    }
    request(`${AWS_EC2_URI}/latest/api/token`, {method: "PUT", json: false, headers: {"X-aws-ec2-metadata-token-ttl-seconds": 30}}, (err, token) => {
      if (err)
        return callback(err);
      request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {json: false, headers: {"X-aws-ec2-metadata-token": token}}, (err2, roleName) => {
        if (err2)
          return callback(err2);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {headers: {"X-aws-ec2-metadata-token": token}}, (err3, creds) => {
          if (err3)
            return callback(err3);
          done(creds);
        });
      });
    });
  }
  function deriveRegion(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  }
  function request(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = Object.assign({
      method: "GET",
      timeout: 1e4,
      json: true
    }, url.parse(uri), options);
    const req = http.request(options, (res) => {
      res.setEncoding("utf8");
      let data = "";
      res.on("data", (d) => data += d);
      res.on("end", () => {
        if (options.json === false) {
          callback(void 0, data);
          return;
        }
        try {
          const parsed = JSON.parse(data);
          callback(void 0, parsed);
        } catch (err) {
          callback(new MongoError(`Invalid JSON response: "${data}"`));
        }
      });
    });
    req.on("error", (err) => callback(err));
    req.end();
  }
  module2.exports = MongoDBAWS;
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS((exports2, module2) => {
  "use strict";
  var MongoCR = require_mongocr();
  var X509 = require_x509();
  var Plain = require_plain();
  var GSSAPI = require_gssapi();
  var ScramSHA1 = require_scram().ScramSHA1;
  var ScramSHA256 = require_scram().ScramSHA256;
  var MongoDBAWS = require_mongodb_aws();
  function defaultAuthProviders(bson) {
    return {
      "mongodb-aws": new MongoDBAWS(bson),
      mongocr: new MongoCR(bson),
      x509: new X509(bson),
      plain: new Plain(bson),
      gssapi: new GSSAPI(bson),
      "scram-sha-1": new ScramSHA1(bson),
      "scram-sha-256": new ScramSHA256(bson)
    };
  }
  module2.exports = {defaultAuthProviders};
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS((exports2, module2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var Connection = require_connection();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
  var AuthContext = require_auth_provider().AuthContext;
  var WIRE_CONSTANTS = require_constants2();
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var AUTH_PROVIDERS;
  function connect(options, cancellationToken, callback) {
    if (typeof cancellationToken === "function") {
      callback = cancellationToken;
      cancellationToken = void 0;
    }
    const ConnectionType = options && options.connectionType ? options.connectionType : Connection;
    if (AUTH_PROVIDERS == null) {
      AUTH_PROVIDERS = defaultAuthProviders(options.bson);
    }
    const family = options.family !== void 0 ? options.family : 0;
    makeConnection(family, options, cancellationToken, (err, socket) => {
      if (err) {
        callback(err, socket);
        return;
      }
      performInitialHandshake(new ConnectionType(socket, options), options, callback);
    });
  }
  function isModernConnectionType(conn) {
    return !(conn instanceof Connection);
  }
  function checkSupportedServer(ismaster, options) {
    const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message2);
    }
    const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
    return new MongoError(message);
  }
  function performInitialHandshake(conn, options, _callback) {
    const callback = function(err, ret) {
      if (err && conn) {
        conn.destroy();
      }
      _callback(err, ret);
    };
    const credentials = options.credentials;
    if (credentials) {
      if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
        callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
        return;
      }
    }
    const authContext = new AuthContext(conn, credentials, options);
    prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
      if (err) {
        return callback(err);
      }
      const handshakeOptions = Object.assign({}, options);
      if (options.connectTimeoutMS || options.connectionTimeout) {
        handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;
      }
      const start = new Date().getTime();
      conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
        if (err2) {
          callback(err2);
          return;
        }
        const response = result.result;
        if (response.ok === 0) {
          callback(new MongoError(response));
          return;
        }
        const supportedServerErr = checkSupportedServer(response, options);
        if (supportedServerErr) {
          callback(supportedServerErr);
          return;
        }
        if (!isModernConnectionType(conn)) {
          if (response.compression) {
            const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
            if (agreedCompressors.length) {
              conn.agreedCompressor = agreedCompressors[0];
            }
            if (options.compression && options.compression.zlibCompressionLevel) {
              conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;
            }
          }
        }
        conn.ismaster = response;
        conn.lastIsMasterMS = new Date().getTime() - start;
        if (!response.arbiterOnly && credentials) {
          Object.assign(authContext, {response});
          const resolvedCredentials = credentials.resolveAuthMechanism(response);
          const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
          authProvider.auth(authContext, (err3) => {
            if (err3)
              return callback(err3);
            callback(void 0, conn);
          });
          return;
        }
        callback(void 0, conn);
      });
    });
  }
  function prepareHandshakeDocument(authContext, callback) {
    const options = authContext.options;
    const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];
    const handshakeDoc = {
      ismaster: true,
      client: options.metadata || makeClientMetadata(options),
      compression: compressors
    };
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
        Object.assign(handshakeDoc, {
          saslSupportedMechs: `${credentials.source}.${credentials.username}`
        });
        AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
        return;
      }
      const authProvider = AUTH_PROVIDERS[credentials.mechanism];
      authProvider.prepare(handshakeDoc, authContext, callback);
      return;
    }
    callback(void 0, handshakeDoc);
  }
  var LEGAL_SSL_SOCKET_OPTIONS = [
    "pfx",
    "key",
    "passphrase",
    "cert",
    "ca",
    "ciphers",
    "NPNProtocols",
    "ALPNProtocols",
    "servername",
    "ecdhCurve",
    "secureProtocol",
    "secureContext",
    "session",
    "minDHSize",
    "crl",
    "rejectUnauthorized"
  ];
  function parseConnectOptions(family, options) {
    const host = typeof options.host === "string" ? options.host : "localhost";
    if (host.indexOf("/") !== -1) {
      return {path: host};
    }
    const result = {
      family,
      host,
      port: typeof options.port === "number" ? options.port : 27017,
      rejectUnauthorized: false
    };
    return result;
  }
  function parseSslOptions(family, options) {
    const result = parseConnectOptions(family, options);
    for (const name in options) {
      if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
        result[name] = options[name];
      }
    }
    if (options.checkServerIdentity === false) {
      result.checkServerIdentity = function() {
        return void 0;
      };
    } else if (typeof options.checkServerIdentity === "function") {
      result.checkServerIdentity = options.checkServerIdentity;
    }
    if (result.servername == null) {
      result.servername = result.host;
    }
    return result;
  }
  var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
  function makeConnection(family, options, cancellationToken, _callback) {
    const useSsl = typeof options.ssl === "boolean" ? options.ssl : false;
    const keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
    let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
    const noDelay = typeof options.noDelay === "boolean" ? options.noDelay : true;
    const connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 3e4;
    const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
    const rejectUnauthorized = typeof options.rejectUnauthorized === "boolean" ? options.rejectUnauthorized : true;
    if (keepAliveInitialDelay > socketTimeout) {
      keepAliveInitialDelay = Math.round(socketTimeout / 2);
    }
    let socket;
    const callback = function(err, ret) {
      if (err && socket) {
        socket.destroy();
      }
      _callback(err, ret);
    };
    try {
      if (useSsl) {
        socket = tls.connect(parseSslOptions(family, options));
        if (typeof socket.disableRenegotiation === "function") {
          socket.disableRenegotiation();
        }
      } else {
        socket = net.createConnection(parseConnectOptions(family, options));
      }
    } catch (err) {
      return callback(err);
    }
    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
    socket.setTimeout(connectionTimeout);
    socket.setNoDelay(noDelay);
    const connectEvent = useSsl ? "secureConnect" : "connect";
    let cancellationHandler;
    function errorHandler(eventName) {
      return (err) => {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        socket.removeListener(connectEvent, connectHandler);
        callback(connectionFailureError(eventName, err));
      };
    }
    function connectHandler() {
      SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
      if (cancellationHandler) {
        cancellationToken.removeListener("cancel", cancellationHandler);
      }
      if (socket.authorizationError && rejectUnauthorized) {
        return callback(socket.authorizationError);
      }
      socket.setTimeout(socketTimeout);
      callback(null, socket);
    }
    SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
    if (cancellationToken) {
      cancellationHandler = errorHandler("cancel");
      cancellationToken.once("cancel", cancellationHandler);
    }
    socket.once(connectEvent, connectHandler);
  }
  function connectionFailureError(type, err) {
    switch (type) {
      case "error":
        return new MongoNetworkError(err);
      case "timeout":
        return new MongoNetworkTimeoutError(`connection timed out`);
      case "close":
        return new MongoNetworkError(`connection closed`);
      case "cancel":
        return new MongoNetworkError(`connection establishment was cancelled`);
      default:
        return new MongoNetworkError(`unknown network error`);
    }
  }
  module2.exports = connect;
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports2, module2) => {
  "use strict";
  var ReadConcern = class {
    constructor(level) {
      if (level != null) {
        this.level = level;
      }
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        if (options.readConcern instanceof ReadConcern) {
          return options.readConcern;
        }
        return new ReadConcern(options.readConcern.level);
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
    }
    static get MAJORITY() {
      return "majority";
    }
    static get AVAILABLE() {
      return "available";
    }
    static get LINEARIZABLE() {
      return "linearizable";
    }
    static get SNAPSHOT() {
      return "snapshot";
    }
  };
  module2.exports = ReadConcern;
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var ReadPreference = require_read_preference();
  var ReadConcern = require_read_concern();
  var WriteConcern = require_write_concern();
  var TxnState;
  var stateMachine;
  (() => {
    const NO_TRANSACTION = "NO_TRANSACTION";
    const STARTING_TRANSACTION = "STARTING_TRANSACTION";
    const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
    const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
    const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
    const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
    TxnState = {
      NO_TRANSACTION,
      STARTING_TRANSACTION,
      TRANSACTION_IN_PROGRESS,
      TRANSACTION_COMMITTED,
      TRANSACTION_COMMITTED_EMPTY,
      TRANSACTION_ABORTED
    };
    stateMachine = {
      [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
      [STARTING_TRANSACTION]: [
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      ],
      [TRANSACTION_IN_PROGRESS]: [
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_ABORTED
      ],
      [TRANSACTION_COMMITTED]: [
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        STARTING_TRANSACTION,
        NO_TRANSACTION
      ],
      [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
      [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
    };
  })();
  var Transaction = class {
    constructor(options) {
      options = options || {};
      this.state = TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w <= 0) {
          throw new MongoError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = void 0;
      this._recoveryToken = void 0;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isActive() {
      return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.indexOf(nextState) !== -1) {
        this.state = nextState;
        if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
          this.unpinServer();
        }
        return;
      }
      throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = void 0;
    }
  };
  function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  }
  module2.exports = {TxnState, Transaction, isTransactionCommand};
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_read_preference();
  var TopologyType = require_common2().TopologyType;
  var MongoError = require_error().MongoError;
  var isRetryableWriteError = require_error().isRetryableWriteError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  function createCompressionInfo(options) {
    if (!options.compression || !options.compression.compressors) {
      return [];
    }
    options.compression.compressors.forEach(function(compressor) {
      if (compressor !== "snappy" && compressor !== "zlib") {
        throw new Error("compressors must be at least one of snappy or zlib");
      }
    });
    return options.compression.compressors;
  }
  function clone(object) {
    return JSON.parse(JSON.stringify(object));
  }
  var getPreviousDescription = function(self2) {
    if (!self2.s.serverDescription) {
      self2.s.serverDescription = {
        address: self2.name,
        arbiters: [],
        hosts: [],
        passives: [],
        type: "Unknown"
      };
    }
    return self2.s.serverDescription;
  };
  var emitServerDescriptionChanged = function(self2, description) {
    if (self2.listeners("serverDescriptionChanged").length > 0) {
      self2.emit("serverDescriptionChanged", {
        topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
        address: self2.name,
        previousDescription: getPreviousDescription(self2),
        newDescription: description
      });
      self2.s.serverDescription = description;
    }
  };
  var getPreviousTopologyDescription = function(self2) {
    if (!self2.s.topologyDescription) {
      self2.s.topologyDescription = {
        topologyType: "Unknown",
        servers: [
          {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: "Unknown"
          }
        ]
      };
    }
    return self2.s.topologyDescription;
  };
  var emitTopologyDescriptionChanged = function(self2, description) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      self2.emit("topologyDescriptionChanged", {
        topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
        address: self2.name,
        previousDescription: getPreviousTopologyDescription(self2),
        newDescription: description
      });
      self2.s.serverDescription = description;
    }
  };
  var changedIsMaster = function(self2, currentIsmaster, ismaster) {
    var currentType = getTopologyType(self2, currentIsmaster);
    var newType = getTopologyType(self2, ismaster);
    if (newType !== currentType)
      return true;
    return false;
  };
  var getTopologyType = function(self2, ismaster) {
    if (!ismaster) {
      ismaster = self2.ismaster;
    }
    if (!ismaster)
      return "Unknown";
    if (ismaster.ismaster && ismaster.msg === "isdbgrid")
      return "Mongos";
    if (ismaster.ismaster && !ismaster.hosts)
      return "Standalone";
    if (ismaster.ismaster)
      return "RSPrimary";
    if (ismaster.secondary)
      return "RSSecondary";
    if (ismaster.arbiterOnly)
      return "RSArbiter";
    return "Unknown";
  };
  var inquireServerState = function(self2) {
    return function(callback) {
      if (self2.s.state === "destroyed")
        return;
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: self2.name});
      self2.command("admin.$cmd", {ismaster: true}, {monitoring: true}, function(err, r) {
        if (!err) {
          self2.emit("ismaster", r, self2);
          var latencyMS = new Date().getTime() - start;
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: self2.name
          });
          if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
            emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
            });
          }
          self2.s.ismaster = r.result;
          self2.s.isMasterLatencyMS = latencyMS;
        } else {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: self2.name
          });
        }
        if (typeof callback === "function") {
          return callback(err, r);
        }
        self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
      });
    };
  };
  var cloneOptions = function(options) {
    var opts = {};
    for (var name in options) {
      opts[name] = options[name];
    }
    return opts;
  };
  function Interval(fn, time) {
    var timer = false;
    this.start = function() {
      if (!this.isRunning()) {
        timer = setInterval(fn, time);
      }
      return this;
    };
    this.stop = function() {
      clearInterval(timer);
      timer = false;
      return this;
    };
    this.isRunning = function() {
      return timer !== false;
    };
  }
  function Timeout(fn, time) {
    var timer = false;
    var func = () => {
      if (timer) {
        clearTimeout(timer);
        timer = false;
        fn();
      }
    };
    this.start = function() {
      if (!this.isRunning()) {
        timer = setTimeout(func, time);
      }
      return this;
    };
    this.stop = function() {
      clearTimeout(timer);
      timer = false;
      return this;
    };
    this.isRunning = function() {
      return timer !== false;
    };
  }
  function diff(previous, current) {
    var diff2 = {
      servers: []
    };
    if (!previous) {
      previous = {servers: []};
    }
    for (var i = 0; i < previous.servers.length; i++) {
      var found = false;
      for (var j = 0; j < current.servers.length; j++) {
        if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
          found = true;
          break;
        }
      }
      if (!found) {
        diff2.servers.push({
          address: previous.servers[i].address,
          from: previous.servers[i].type,
          to: "Unknown"
        });
      }
    }
    for (j = 0; j < current.servers.length; j++) {
      found = false;
      for (i = 0; i < previous.servers.length; i++) {
        if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
          found = true;
          break;
        }
      }
      if (!found) {
        diff2.servers.push({
          address: current.servers[j].address,
          from: "Unknown",
          to: current.servers[j].type
        });
      }
    }
    for (i = 0; i < previous.servers.length; i++) {
      var prevServer = previous.servers[i];
      for (j = 0; j < current.servers.length; j++) {
        var currServer = current.servers[j];
        if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
          if (prevServer.type !== currServer.type) {
            diff2.servers.push({
              address: prevServer.address,
              from: prevServer.type,
              to: currServer.type
            });
          }
        }
      }
    }
    return diff2;
  }
  function resolveClusterTime(topology, $clusterTime) {
    if (topology.clusterTime == null) {
      topology.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
        topology.clusterTime = $clusterTime;
      }
    }
  }
  var SessionMixins = {
    endSessions: function(sessions, callback) {
      if (!Array.isArray(sessions)) {
        sessions = [sessions];
      }
      this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred}, () => {
        if (typeof callback === "function")
          callback();
      });
    }
  };
  function topologyType(topology) {
    if (topology.description) {
      return topology.description.type;
    }
    if (topology.type === "mongos") {
      return TopologyType.Sharded;
    } else if (topology.type === "replset") {
      return TopologyType.ReplicaSetWithPrimary;
    }
    return TopologyType.Single;
  }
  var RETRYABLE_WIRE_VERSION = 6;
  var isRetryableWritesSupported = function(topology) {
    const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
    if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
      return false;
    }
    if (!topology.logicalSessionTimeoutMinutes) {
      return false;
    }
    if (topologyType(topology) === TopologyType.Single) {
      return false;
    }
    return true;
  };
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
  function getMMAPError(err) {
    if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
      return err;
    }
    const newErr = new MongoError({
      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
      originalError: err
    });
    return newErr;
  }
  function legacyIsRetryableWriteError(err, topology) {
    if (!(err instanceof MongoError)) {
      return false;
    }
    if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
      err.addErrorLabel("RetryableWriteError");
    }
    return err.hasErrorLabel("RetryableWriteError");
  }
  module2.exports = {
    SessionMixins,
    resolveClusterTime,
    inquireServerState,
    getTopologyType,
    emitServerDescriptionChanged,
    emitTopologyDescriptionChanged,
    cloneOptions,
    createCompressionInfo,
    clone,
    diff,
    Interval,
    Timeout,
    isRetryableWritesSupported,
    getMMAPError,
    topologyType,
    legacyIsRetryableWriteError
  };
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var EventEmitter = require("events");
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var uuidV4 = require_utils2().uuidV4;
  var MongoError = require_error().MongoError;
  var isRetryableError = require_error().isRetryableError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var Transaction = require_transactions().Transaction;
  var TxnState = require_transactions().TxnState;
  var isPromiseLike = require_utils2().isPromiseLike;
  var ReadPreference = require_read_preference();
  var maybePromise = require_utils4().maybePromise;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var isSharded = require_shared().isSharded;
  var maxWireVersion = require_utils2().maxWireVersion;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var minWireVersionForShardedTransactions = 8;
  function assertAlive(session, callback) {
    if (session.serverSession == null) {
      const error = new MongoError("Cannot use a session that has ended");
      if (typeof callback === "function") {
        callback(error, null);
        return false;
      }
      throw error;
    }
    return true;
  }
  var kServerSession = Symbol("serverSession");
  var ClientSession = class extends EventEmitter {
    constructor(topology, sessionPool, options, clientOptions) {
      super();
      if (topology == null) {
        throw new Error("ClientSession requires a topology");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new Error("ClientSession requires a ServerSessionPool");
      }
      options = options || {};
      clientOptions = clientOptions || {};
      this.topology = topology;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this[kServerSession] = void 0;
      this.supports = {
        causalConsistency: typeof options.causalConsistency !== "undefined" ? options.causalConsistency : true
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = null;
      this.explicit = !!options.explicit;
      this.owner = options.owner;
      this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
      this.transaction = new Transaction();
    }
    get id() {
      return this.serverSession.id;
    }
    get serverSession() {
      if (this[kServerSession] == null) {
        this[kServerSession] = this.sessionPool.acquire();
      }
      return this[kServerSession];
    }
    endSession(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const session = this;
      return maybePromise(this, callback, (done) => {
        if (session.hasEnded) {
          return done();
        }
        function completeEndSession() {
          session.sessionPool.release(session.serverSession);
          session[kServerSession] = void 0;
          session.hasEnded = true;
          session.emit("ended", session);
          done();
        }
        if (session.serverSession && session.inTransaction()) {
          session.abortTransaction((err) => {
            if (err)
              return done(err);
            completeEndSession();
          });
          return;
        }
        completeEndSession();
      });
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      return this.id.id.buffer.equals(session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this.serverSession.txnNumber++;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      assertAlive(this);
      if (this.inTransaction()) {
        throw new MongoError("Transaction already in progress");
      }
      const topologyMaxWireVersion = maxWireVersion(this.topology);
      if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.incrementTransactionNumber();
      this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));
      this.transaction.transition(TxnState.STARTING_TRANSACTION);
    }
    commitTransaction(callback) {
      return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
    }
    abortTransaction(callback) {
      return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
    }
    toBSON() {
      throw new Error("ClientSession cannot be serialized to BSON.");
    }
    withTransaction(fn, options) {
      const startTime = now();
      return attemptTransaction(this, startTime, fn, options);
    }
  };
  var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
  var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
  var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
  var MAX_TIME_MS_EXPIRED_CODE = 50;
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);
  function hasNotTimedOut(startTime, max) {
    return calculateDurationInMs(startTime) < max;
  }
  function isUnknownTransactionCommitResult(err) {
    return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
  }
  function isMaxTimeMSExpiredError(err) {
    if (err == null)
      return false;
    return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
  }
  function attemptTransactionCommit(session, startTime, fn, options) {
    return session.commitTransaction().catch((err) => {
      if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
        if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
          return attemptTransactionCommit(session, startTime, fn, options);
        }
        if (err.hasErrorLabel("TransientTransactionError")) {
          return attemptTransaction(session, startTime, fn, options);
        }
      }
      throw err;
    });
  }
  var USER_EXPLICIT_TXN_END_STATES = new Set([
    TxnState.NO_TRANSACTION,
    TxnState.TRANSACTION_COMMITTED,
    TxnState.TRANSACTION_ABORTED
  ]);
  function userExplicitlyEndedTransaction(session) {
    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
  }
  function attemptTransaction(session, startTime, fn, options) {
    session.startTransaction(options);
    let promise;
    try {
      promise = fn(session);
    } catch (err) {
      promise = Promise.reject(err);
    }
    if (!isPromiseLike(promise)) {
      session.abortTransaction();
      throw new TypeError("Function provided to `withTransaction` must return a Promise");
    }
    return promise.then(() => {
      if (userExplicitlyEndedTransaction(session)) {
        return;
      }
      return attemptTransactionCommit(session, startTime, fn, options);
    }).catch((err) => {
      function maybeRetryOrThrow(err2) {
        if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
          return attemptTransaction(session, startTime, fn, options);
        }
        if (isMaxTimeMSExpiredError(err2)) {
          err2.addErrorLabel("UnknownTransactionCommitResult");
        }
        throw err2;
      }
      if (session.transaction.isActive) {
        return session.abortTransaction().then(() => maybeRetryOrThrow(err));
      }
      return maybeRetryOrThrow(err);
    });
  }
  function endTransaction(session, commandName, callback) {
    if (!assertAlive(session, callback)) {
      return;
    }
    let txnState = session.transaction.state;
    if (txnState === TxnState.NO_TRANSACTION) {
      callback(new MongoError("No transaction started"));
      return;
    }
    if (commandName === "commitTransaction") {
      if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
        session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
        callback(null, null);
        return;
      }
      if (txnState === TxnState.TRANSACTION_ABORTED) {
        callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
        return;
      }
    } else {
      if (txnState === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        callback(null, null);
        return;
      }
      if (txnState === TxnState.TRANSACTION_ABORTED) {
        callback(new MongoError("Cannot call abortTransaction twice"));
        return;
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
        callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
        return;
      }
    }
    const command = {[commandName]: 1};
    let writeConcern;
    if (session.transaction.options.writeConcern) {
      writeConcern = Object.assign({}, session.transaction.options.writeConcern);
    } else if (session.clientOptions && session.clientOptions.w) {
      writeConcern = {w: session.clientOptions.w};
    }
    if (txnState === TxnState.TRANSACTION_COMMITTED) {
      writeConcern = Object.assign({wtimeout: 1e4}, writeConcern, {w: "majority"});
    }
    if (writeConcern) {
      Object.assign(command, {writeConcern});
    }
    if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
      Object.assign(command, {maxTimeMS: session.transaction.options.maxTimeMS});
    }
    function commandHandler(e, r) {
      if (commandName === "commitTransaction") {
        session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
        if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
          if (isUnknownTransactionCommitResult(e)) {
            e.addErrorLabel("UnknownTransactionCommitResult");
            session.transaction.unpinServer();
          }
        }
      } else {
        session.transaction.transition(TxnState.TRANSACTION_ABORTED);
      }
      callback(e, r);
    }
    function transactionError(err) {
      return commandName === "commitTransaction" ? err : null;
    }
    if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
      command.recoveryToken = session.transaction.recoveryToken;
    }
    session.topology.command("admin.$cmd", command, {session}, (err, reply) => {
      if (err && isRetryableError(err)) {
        if (command.commitTransaction) {
          session.transaction.unpinServer();
          command.writeConcern = Object.assign({wtimeout: 1e4}, command.writeConcern, {
            w: "majority"
          });
        }
        return session.topology.command("admin.$cmd", command, {session}, (_err, _reply) => commandHandler(transactionError(_err), _reply));
      }
      commandHandler(transactionError(err), reply);
    });
  }
  function supportsRecoveryToken(session) {
    const topology = session.topology;
    return !!topology.s.options.useRecoveryToken;
  }
  var ServerSession = class {
    constructor() {
      this.id = {id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID)};
      this.lastUse = now();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
  };
  var ServerSessionPool = class {
    constructor(topology) {
      if (topology == null) {
        throw new Error("ServerSessionPool requires a topology");
      }
      this.topology = topology;
      this.sessions = [];
    }
    endAllPooledSessions(callback) {
      if (this.sessions.length) {
        this.topology.endSessions(this.sessions.map((session) => session.id), () => {
          this.sessions = [];
          if (typeof callback === "function") {
            callback();
          }
        });
        return;
      }
      if (typeof callback === "function") {
        callback();
      }
    }
    acquire() {
      const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
      while (this.sessions.length) {
        const session = this.sessions.shift();
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          return session;
        }
      }
      return new ServerSession();
    }
    release(session) {
      const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
      while (this.sessions.length) {
        const pooledSession = this.sessions[this.sessions.length - 1];
        if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
          this.sessions.pop();
        } else {
          break;
        }
      }
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  };
  function commandSupportsReadConcern(command, options) {
    if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
      return true;
    }
    if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
      return true;
    }
    return false;
  }
  function applySession(session, command, options) {
    if (session.hasEnded) {
      return new MongoError("Cannot use a session that has ended");
    }
    if (options && options.writeConcern && options.writeConcern.w === 0) {
      return;
    }
    const serverSession = session.serverSession;
    serverSession.lastUse = now();
    command.lsid = serverSession.id;
    const inTransaction = session.inTransaction() || isTransactionCommand(command);
    const isRetryableWrite = options.willRetryWrite;
    const shouldApplyReadConcern = commandSupportsReadConcern(command, options);
    if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
      command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTransaction) {
      if (session.transaction.state !== TxnState.NO_TRANSACTION) {
        session.transaction.transition(TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
      }
      return;
    }
    if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {
      return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);
    }
    command.autocommit = false;
    if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
      }
    }
  }
  function updateSessionFromResponse(session, document2) {
    if (document2.$clusterTime) {
      resolveClusterTime(session, document2.$clusterTime);
    }
    if (document2.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document2.operationTime);
    }
    if (document2.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document2.recoveryToken;
    }
  }
  module2.exports = {
    ClientSession,
    ServerSession,
    ServerSessionPool,
    TxnState,
    applySession,
    updateSessionFromResponse,
    commandSupportsReadConcern
  };
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var EventEmitter = require("events").EventEmitter;
  var MongoError = require_error().MongoError;
  var MongoTimeoutError = require_error().MongoTimeoutError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var Logger = require_logger();
  var f = require("util").format;
  var Msg = require_msg().Msg;
  var CommandResult = require_command_result();
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
  var opcodes = require_shared().opcodes;
  var compress = require_compression().compress;
  var compressorIDs = require_compression().compressorIDs;
  var uncompressibleCommands = require_compression().uncompressibleCommands;
  var apm = require_apm();
  var Buffer2 = require_safe_buffer().Buffer;
  var connect = require_connect();
  var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
  var eachAsync = require_utils2().eachAsync;
  var makeStateMachine = require_utils2().makeStateMachine;
  var now = require_utils4().now;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var DRAINING = "draining";
  var DESTROYING = "destroying";
  var DESTROYED = "destroyed";
  var stateTransition = makeStateMachine({
    [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
    [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
    [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
    [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
    [DESTROYING]: [DESTROYING, DESTROYED],
    [DESTROYED]: [DESTROYED]
  });
  var CONNECTION_EVENTS = new Set([
    "error",
    "close",
    "timeout",
    "parseError",
    "connect",
    "message"
  ]);
  var _id = 0;
  var Pool = function(topology, options) {
    EventEmitter.call(this);
    this.topology = topology;
    this.s = {
      state: DISCONNECTED,
      cancellationToken: new EventEmitter()
    };
    this.s.cancellationToken.setMaxListeners(Infinity);
    this.options = Object.assign({
      host: "localhost",
      port: 27017,
      size: 5,
      minSize: 0,
      connectionTimeout: 3e4,
      socketTimeout: 0,
      keepAlive: true,
      keepAliveInitialDelay: 12e4,
      noDelay: true,
      ssl: false,
      checkServerIdentity: true,
      ca: null,
      crl: null,
      cert: null,
      key: null,
      passphrase: null,
      rejectUnauthorized: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      reconnect: true,
      reconnectInterval: 1e3,
      reconnectTries: 30,
      domainsEnabled: false,
      legacyCompatMode: true
    }, options);
    this.id = _id++;
    this.retriesLeft = this.options.reconnectTries;
    this.reconnectId = null;
    this.reconnectError = null;
    if (!options.bson || options.bson && (typeof options.bson.serialize !== "function" || typeof options.bson.deserialize !== "function")) {
      throw new Error("must pass in valid bson parser");
    }
    this.logger = Logger("Pool", options);
    this.availableConnections = [];
    this.inUseConnections = [];
    this.connectingConnections = 0;
    this.executing = false;
    this.queue = [];
    this.numberOfConsecutiveTimeouts = 0;
    this.connectionIndex = 0;
    const pool = this;
    this._messageHandler = messageHandler(this);
    this._connectionCloseHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "close", err, connection);
    };
    this._connectionErrorHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "error", err, connection);
    };
    this._connectionTimeoutHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "timeout", err, connection);
    };
    this._connectionParseErrorHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "parseError", err, connection);
    };
  };
  inherits(Pool, EventEmitter);
  Object.defineProperty(Pool.prototype, "size", {
    enumerable: true,
    get: function() {
      return this.options.size;
    }
  });
  Object.defineProperty(Pool.prototype, "minSize", {
    enumerable: true,
    get: function() {
      return this.options.minSize;
    }
  });
  Object.defineProperty(Pool.prototype, "connectionTimeout", {
    enumerable: true,
    get: function() {
      return this.options.connectionTimeout;
    }
  });
  Object.defineProperty(Pool.prototype, "socketTimeout", {
    enumerable: true,
    get: function() {
      return this.options.socketTimeout;
    }
  });
  Object.defineProperty(Pool.prototype, "state", {
    enumerable: true,
    get: function() {
      return this.s.state;
    }
  });
  function resetPoolState(pool) {
    pool.inUseConnections = [];
    pool.availableConnections = [];
    pool.connectingConnections = 0;
    pool.executing = false;
    pool.numberOfConsecutiveTimeouts = 0;
    pool.connectionIndex = 0;
    pool.retriesLeft = pool.options.reconnectTries;
    pool.reconnectId = null;
  }
  function connectionFailureHandler(pool, event, err, conn) {
    if (conn) {
      if (conn._connectionFailHandled) {
        return;
      }
      conn._connectionFailHandled = true;
      conn.destroy();
      removeConnection(pool, conn);
      conn.flush(err);
    }
    if (event === "timeout") {
      pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
      if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
        pool.numberOfConsecutiveTimeouts = 0;
        pool.destroy(true);
        return pool.emit("close", pool);
      }
    }
    if (pool.socketCount() === 0) {
      if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
        if (pool.options.reconnect) {
          stateTransition(pool, DISCONNECTED);
        }
      }
      event = event === "error" ? "close" : event;
      pool.emit(event, err);
    }
    if (!pool.reconnectId && pool.options.reconnect) {
      pool.reconnectError = err;
      pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
    }
    const totalConnections = totalConnectionCount(pool);
    if (totalConnections < pool.minSize) {
      createConnection(pool);
    }
  }
  function attemptReconnect(pool, callback) {
    return function() {
      pool.emit("attemptReconnect", pool);
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.retriesLeft = pool.retriesLeft - 1;
      if (pool.retriesLeft <= 0) {
        pool.destroy();
        const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
        pool.emit("reconnectFailed", error);
        if (typeof callback === "function") {
          callback(error);
        }
        return;
      }
      pool.reconnectId = null;
      createConnection(pool, (err, conn) => {
        if (err == null) {
          pool.reconnectId = null;
          pool.retriesLeft = pool.options.reconnectTries;
          pool.emit("reconnect", pool);
        }
        if (typeof callback === "function") {
          callback(err, conn);
        }
      });
    };
  }
  function moveConnectionBetween(connection, from, to) {
    var index = from.indexOf(connection);
    if (index !== -1) {
      from.splice(index, 1);
      to.push(connection);
    }
  }
  function messageHandler(self2) {
    return function(message, connection) {
      var workItem = null;
      for (var i = 0; i < connection.workItems.length; i++) {
        if (connection.workItems[i].requestId === message.responseTo) {
          workItem = connection.workItems[i];
          connection.workItems.splice(i, 1);
        }
      }
      if (workItem && workItem.monitoring) {
        moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
      }
      self2.numberOfConsecutiveTimeouts = 0;
      if (workItem && workItem.socketTimeout) {
        connection.resetSocketTimeout();
      }
      if (self2.logger.isDebug()) {
        self2.logger.debug(f("message [%s] received from %s:%s", message.raw.toString("hex"), self2.options.host, self2.options.port));
      }
      function handleOperationCallback(self3, cb, err, result) {
        if (!self3.options.domainsEnabled) {
          return process.nextTick(function() {
            return cb(err, result);
          });
        }
        cb(err, result);
      }
      if (!self2.executing) {
        process.nextTick(function() {
          _execute(self2)();
        });
      }
      if (workItem && !workItem.immediateRelease) {
        try {
          message.parse(workItem);
        } catch (err) {
          return handleOperationCallback(self2, workItem.cb, new MongoError(err));
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = workItem.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (self2.topology && document2.$clusterTime) {
            self2.topology.clusterTime = document2.$clusterTime;
          }
        }
        if (workItem.command && message.documents[0]) {
          const responseDoc = message.documents[0];
          if (responseDoc.writeConcernError) {
            const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
            return handleOperationCallback(self2, workItem.cb, err);
          }
          if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
          }
        }
        message.hashedName = connection.hashedName;
        handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
      }
    };
  }
  Pool.prototype.socketCount = function() {
    return this.availableConnections.length + this.inUseConnections.length;
  };
  function totalConnectionCount(pool) {
    return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
  }
  Pool.prototype.allConnections = function() {
    return this.availableConnections.concat(this.inUseConnections);
  };
  Pool.prototype.get = function() {
    return this.allConnections()[0];
  };
  Pool.prototype.isConnected = function() {
    if (this.state === DESTROYED || this.state === DESTROYING) {
      return false;
    }
    var connections = this.availableConnections.concat(this.inUseConnections);
    for (var i = 0; i < connections.length; i++) {
      if (connections[i].isConnected())
        return true;
    }
    return false;
  };
  Pool.prototype.isDestroyed = function() {
    return this.state === DESTROYED || this.state === DESTROYING;
  };
  Pool.prototype.isDisconnected = function() {
    return this.state === DISCONNECTED;
  };
  Pool.prototype.connect = function(callback) {
    if (this.state !== DISCONNECTED) {
      throw new MongoError("connection in unlawful state " + this.state);
    }
    stateTransition(this, CONNECTING);
    createConnection(this, (err, conn) => {
      if (err) {
        if (typeof callback === "function") {
          this.destroy();
          callback(err);
          return;
        }
        if (this.state === CONNECTING) {
          this.emit("error", err);
        }
        this.destroy();
        return;
      }
      stateTransition(this, CONNECTED);
      if (this.minSize) {
        for (let i = 0; i < this.minSize; i++) {
          createConnection(this);
        }
      }
      if (typeof callback === "function") {
        callback(null, conn);
      } else {
        this.emit("connect", this, conn);
      }
    });
  };
  Pool.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Pool.prototype.logout = function(dbName, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Pool.prototype.unref = function() {
    var connections = this.availableConnections.concat(this.inUseConnections);
    connections.forEach(function(c) {
      c.unref();
    });
  };
  function destroy(self2, connections, options, callback) {
    stateTransition(self2, DESTROYING);
    self2.s.cancellationToken.emit("cancel");
    eachAsync(connections, (conn, cb) => {
      for (const eventName of CONNECTION_EVENTS) {
        conn.removeAllListeners(eventName);
      }
      conn.on("error", () => {
      });
      conn.destroy(options, cb);
    }, (err) => {
      if (err) {
        if (typeof callback === "function")
          callback(err, null);
        return;
      }
      resetPoolState(self2);
      self2.queue = [];
      stateTransition(self2, DESTROYED);
      if (typeof callback === "function")
        callback(null, null);
    });
  }
  Pool.prototype.destroy = function(force, callback) {
    var self2 = this;
    if (typeof force === "function") {
      callback = force;
      force = false;
    }
    if (this.state === DESTROYED || self2.state === DESTROYING) {
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    stateTransition(this, DRAINING);
    if (force) {
      var connections = self2.availableConnections.concat(self2.inUseConnections);
      while (self2.queue.length > 0) {
        var workItem = self2.queue.shift();
        if (typeof workItem.cb === "function") {
          workItem.cb(new MongoError("Pool was force destroyed"));
        }
      }
      return destroy(self2, connections, {force: true}, callback);
    }
    if (this.reconnectId) {
      clearTimeout(this.reconnectId);
    }
    function checkStatus() {
      if (self2.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      flushMonitoringOperations(self2.queue);
      if (self2.queue.length === 0) {
        var connections2 = self2.availableConnections.concat(self2.inUseConnections);
        for (var i = 0; i < connections2.length; i++) {
          if (connections2[i].workItems.length > 0) {
            return setTimeout(checkStatus, 1);
          }
        }
        destroy(self2, connections2, {force: false}, callback);
      } else {
        _execute(self2)();
        setTimeout(checkStatus, 1);
      }
    }
    checkStatus();
  };
  Pool.prototype.reset = function(callback) {
    if (this.s.state !== CONNECTED) {
      if (typeof callback === "function") {
        callback(new MongoError("pool is not connected, reset aborted"));
      }
      return;
    }
    this.s.cancellationToken.emit("cancel");
    const connections = this.availableConnections.concat(this.inUseConnections);
    eachAsync(connections, (conn, cb) => {
      for (const eventName of CONNECTION_EVENTS) {
        conn.removeAllListeners(eventName);
      }
      conn.destroy({force: true}, cb);
    }, (err) => {
      if (err) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
      }
      resetPoolState(this);
      createConnection(this, () => {
        if (typeof callback === "function") {
          callback(null, null);
        }
      });
    });
  };
  function serializeCommand(self2, command, callback) {
    const originalCommandBuffer = command.toBin();
    const shouldCompress = !!self2.options.agreedCompressor;
    if (!shouldCompress || !canCompress(command)) {
      return callback(null, originalCommandBuffer);
    }
    const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
    compress(self2, messageToBeCompressed, function(err, compressedMessage) {
      if (err)
        return callback(err, null);
      const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
      msgHeader.writeInt32LE(command.requestId, 4);
      msgHeader.writeInt32LE(0, 8);
      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
      const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0);
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
      compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
      return callback(null, [msgHeader, compressionDetails, compressedMessage]);
    });
  }
  Pool.prototype.write = function(command, options, cb) {
    var self2 = this;
    if (typeof options === "function") {
      cb = options;
    }
    options = options || {};
    if (!(typeof cb === "function") && !options.noResponse) {
      throw new MongoError("write method must provide a callback");
    }
    if (this.state === DESTROYED || this.state === DESTROYING) {
      cb(new MongoError("pool destroyed"));
      return;
    }
    if (this.state === DRAINING) {
      cb(new MongoError("pool is draining, new operations prohibited"));
      return;
    }
    if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
      var oldCb = cb;
      cb = process.domain.bind(function() {
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        process.nextTick(function() {
          oldCb.apply(null, args);
        });
      });
    }
    var operation = {
      cb,
      raw: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      fullResult: false
    };
    operation.promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : true;
    operation.promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : true;
    operation.promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false;
    operation.raw = typeof options.raw === "boolean" ? options.raw : false;
    operation.immediateRelease = typeof options.immediateRelease === "boolean" ? options.immediateRelease : false;
    operation.documentsReturnedIn = options.documentsReturnedIn;
    operation.command = typeof options.command === "boolean" ? options.command : false;
    operation.fullResult = typeof options.fullResult === "boolean" ? options.fullResult : false;
    operation.noResponse = typeof options.noResponse === "boolean" ? options.noResponse : false;
    operation.session = options.session || null;
    operation.socketTimeout = options.socketTimeout;
    operation.monitoring = options.monitoring;
    operation.requestId = command.requestId;
    if (self2.options.monitorCommands) {
      this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
      operation.started = now();
      operation.cb = (err, reply) => {
        if (err) {
          self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
        } else {
          if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
          } else {
            self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
          }
        }
        if (typeof cb === "function")
          cb(err, reply);
      };
    }
    serializeCommand(self2, command, (err, serializedBuffers) => {
      if (err)
        throw err;
      operation.buffer = serializedBuffers;
      if (options.monitoring) {
        self2.queue.unshift(operation);
      } else {
        self2.queue.push(operation);
      }
      if (!self2.executing) {
        process.nextTick(function() {
          _execute(self2)();
        });
      }
    });
  };
  function canCompress(command) {
    const commandDoc = command instanceof Msg ? command.command : command.query;
    const commandName = Object.keys(commandDoc)[0];
    return !uncompressibleCommands.has(commandName);
  }
  function remove(connection, connections) {
    for (var i = 0; i < connections.length; i++) {
      if (connections[i] === connection) {
        connections.splice(i, 1);
        return true;
      }
    }
  }
  function removeConnection(self2, connection) {
    if (remove(connection, self2.availableConnections))
      return;
    if (remove(connection, self2.inUseConnections))
      return;
  }
  function createConnection(pool, callback) {
    if (pool.state === DESTROYED || pool.state === DESTROYING) {
      if (typeof callback === "function") {
        callback(new MongoError("Cannot create connection when pool is destroyed"));
      }
      return;
    }
    pool.connectingConnections++;
    connect(pool.options, pool.s.cancellationToken, (err, connection) => {
      pool.connectingConnections--;
      if (err) {
        if (pool.logger.isDebug()) {
          pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
        }
        if (!pool.reconnectId && pool.options.reconnect) {
          if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
            callback(err);
            return;
          }
          pool.reconnectError = err;
          pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
          return;
        }
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Pool was destroyed after connection creation"));
        }
        connection.destroy();
        return;
      }
      connection.on("error", pool._connectionErrorHandler);
      connection.on("close", pool._connectionCloseHandler);
      connection.on("timeout", pool._connectionTimeoutHandler);
      connection.on("parseError", pool._connectionParseErrorHandler);
      connection.on("message", pool._messageHandler);
      pool.availableConnections.push(connection);
      if (typeof callback === "function") {
        callback(null, connection);
      }
      _execute(pool)();
    });
  }
  function flushMonitoringOperations(queue) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].monitoring) {
        var workItem = queue[i];
        queue.splice(i, 1);
        workItem.cb(new MongoError({message: "no connection available for monitoring", driver: true}));
      }
    }
  }
  function _execute(self2) {
    return function() {
      if (self2.state === DESTROYED)
        return;
      if (self2.executing)
        return;
      self2.executing = true;
      if (self2.connectingConnections > 0) {
        self2.executing = false;
        return;
      }
      while (true) {
        const totalConnections = totalConnectionCount(self2);
        if (self2.availableConnections.length === 0) {
          flushMonitoringOperations(self2.queue);
          if (totalConnections < self2.options.size && self2.queue.length > 0) {
            createConnection(self2);
          }
          break;
        }
        if (self2.queue.length === 0) {
          break;
        }
        var connection = null;
        const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
        if (connections.length === 0) {
          connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
        } else {
          connection = connections[self2.connectionIndex++ % connections.length];
        }
        if (!connection.isConnected()) {
          removeConnection(self2, connection);
          flushMonitoringOperations(self2.queue);
          break;
        }
        var workItem = self2.queue.shift();
        if (workItem.monitoring) {
          var foundValidConnection = false;
          for (let i = 0; i < self2.availableConnections.length; i++) {
            if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
              foundValidConnection = true;
              connection = self2.availableConnections[i];
              break;
            }
          }
          if (!foundValidConnection) {
            self2.queue.unshift(workItem);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            setTimeout(() => _execute(self2)(), 10);
            break;
          }
        }
        if (totalConnections < self2.options.size) {
          if (connection.workItems.length > 0) {
            self2.queue.unshift(workItem);
            createConnection(self2);
            break;
          }
        }
        var buffer = workItem.buffer;
        if (workItem.monitoring) {
          moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
        }
        if (!workItem.noResponse) {
          connection.workItems.push(workItem);
        }
        if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
          connection.setSocketTimeout(workItem.socketTimeout);
        }
        var writeSuccessful = true;
        if (Array.isArray(buffer)) {
          for (let i = 0; i < buffer.length; i++) {
            writeSuccessful = connection.write(buffer[i]);
          }
        } else {
          writeSuccessful = connection.write(buffer);
        }
        if (workItem.noResponse && typeof workItem.cb === "function") {
          workItem.cb(null, null);
        }
        if (writeSuccessful === false) {
          self2.queue.unshift(workItem);
          removeConnection(self2, connection);
          flushMonitoringOperations(self2.queue);
          break;
        }
      }
      self2.executing = false;
    };
  }
  Pool._execute = _execute;
  module2.exports = Pool;
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS((exports2, module2) => {
  "use strict";
  var Query = require_commands().Query;
  var Msg = require_msg().Msg;
  var MongoError = require_error().MongoError;
  var getReadPreference = require_shared().getReadPreference;
  var isSharded = require_shared().isSharded;
  var databaseNamespace = require_shared().databaseNamespace;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var applySession = require_sessions().applySession;
  var MongoNetworkError = require_error().MongoNetworkError;
  var maxWireVersion = require_utils2().maxWireVersion;
  function isClientEncryptionEnabled(server) {
    const wireVersion = maxWireVersion(server);
    return wireVersion && server.autoEncrypter;
  }
  function command(server, ns, cmd, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (cmd == null) {
      return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
    }
    if (!isClientEncryptionEnabled(server)) {
      _command(server, ns, cmd, options, callback);
      return;
    }
    const wireVersion = maxWireVersion(server);
    if (typeof wireVersion !== "number" || wireVersion < 8) {
      callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
      return;
    }
    _cryptCommand(server, ns, cmd, options, callback);
  }
  function _command(server, ns, cmd, options, callback) {
    const bson = server.s.bson;
    const pool = server.s.pool;
    const readPreference = getReadPreference(cmd, options);
    const shouldUseOpMsg = supportsOpMsg(server);
    const session = options.session;
    let clusterTime = server.clusterTime;
    let finalCmd = Object.assign({}, cmd);
    if (hasSessionSupport(server) && session) {
      if (session.clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
        clusterTime = session.clusterTime;
      }
      const err = applySession(session, finalCmd, options);
      if (err) {
        return callback(err);
      }
    }
    if (clusterTime) {
      finalCmd.$clusterTime = clusterTime;
    }
    if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
      finalCmd = {
        $query: finalCmd,
        $readPreference: readPreference.toJSON()
      };
    }
    const commandOptions = Object.assign({
      command: true,
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false
    }, options);
    commandOptions.slaveOk = readPreference.slaveOk();
    const cmdNs = `${databaseNamespace(ns)}.$cmd`;
    const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
    const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
    const commandResponseHandler = inTransaction ? function(err) {
      if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
        err.addErrorLabel("TransientTransactionError");
      }
      if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
        session.transaction.unpinServer();
      }
      return callback.apply(null, arguments);
    } : callback;
    try {
      pool.write(message, commandOptions, commandResponseHandler);
    } catch (err) {
      commandResponseHandler(err);
    }
  }
  function hasSessionSupport(topology) {
    if (topology == null)
      return false;
    if (topology.description) {
      return topology.description.maxWireVersion >= 6;
    }
    return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
  }
  function supportsOpMsg(topologyOrServer) {
    const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
    if (description == null) {
      return false;
    }
    return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
  }
  function _cryptCommand(server, ns, cmd, options, callback) {
    const autoEncrypter = server.autoEncrypter;
    function commandResponseHandler(err, response) {
      if (err || response == null) {
        callback(err, response);
        return;
      }
      autoEncrypter.decrypt(response.result, options, (err2, decrypted) => {
        if (err2) {
          callback(err2, null);
          return;
        }
        response.result = decrypted;
        response.message.documents = [decrypted];
        callback(null, response);
      });
    }
    autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {
      if (err) {
        callback(err, null);
        return;
      }
      _command(server, ns, encrypted, options, commandResponseHandler);
    });
  }
  module2.exports = command;
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var ExplainVerbosity = {
    queryPlanner: "queryPlanner",
    queryPlannerExtended: "queryPlannerExtended",
    executionStats: "executionStats",
    allPlansExecution: "allPlansExecution"
  };
  var Explain = class {
    constructor(verbosity) {
      if (typeof verbosity === "boolean") {
        this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
      } else {
        this.verbosity = verbosity;
      }
    }
    static fromOptions(options) {
      if (options == null || options.explain === void 0) {
        return;
      }
      const explain = options.explain;
      if (typeof explain === "boolean" || explain in ExplainVerbosity) {
        return new Explain(options.explain);
      }
      throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
    }
  };
  module2.exports = {Explain};
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var collectionNamespace = require_shared().collectionNamespace;
  var command = require_command();
  var decorateWithExplain = require_utils4().decorateWithExplain;
  var Explain = require_explain().Explain;
  function writeCommand(server, type, opsField, ns, ops, options, callback) {
    if (ops.length === 0)
      throw new MongoError(`${type} must contain at least one document`);
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const writeConcern = options.writeConcern;
    let writeCommand2 = {};
    writeCommand2[type] = collectionNamespace(ns);
    writeCommand2[opsField] = ops;
    writeCommand2.ordered = ordered;
    if (writeConcern && Object.keys(writeConcern).length > 0) {
      writeCommand2.writeConcern = writeConcern;
    }
    if (options.collation) {
      for (let i = 0; i < writeCommand2[opsField].length; i++) {
        if (!writeCommand2[opsField][i].collation) {
          writeCommand2[opsField][i].collation = options.collation;
        }
      }
    }
    if (options.bypassDocumentValidation === true) {
      writeCommand2.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    const explain = Explain.fromOptions(options);
    if (explain) {
      writeCommand2 = decorateWithExplain(writeCommand2, explain);
    }
    const commandOptions = Object.assign({
      checkKeys: type === "insert",
      numberToReturn: 1
    }, options);
    command(server, ns, writeCommand2, commandOptions, callback);
  }
  module2.exports = writeCommand;
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS((exports2, module2) => {
  "use strict";
  var KillCursor = require_commands().KillCursor;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var collectionNamespace = require_shared().collectionNamespace;
  var maxWireVersion = require_utils2().maxWireVersion;
  var command = require_command();
  function killCursors(server, ns, cursorState, callback) {
    callback = typeof callback === "function" ? callback : () => {
    };
    const cursorId = cursorState.cursorId;
    if (maxWireVersion(server) < 4) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const killCursor = new KillCursor(bson, ns, [cursorId]);
      const options2 = {
        immediateRelease: true,
        noResponse: true
      };
      if (typeof cursorState.session === "object") {
        options2.session = cursorState.session;
      }
      if (pool && pool.isConnected()) {
        try {
          pool.write(killCursor, options2, callback);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err, null);
          } else {
            console.warn(err);
          }
        }
      }
      return;
    }
    const killCursorCmd = {
      killCursors: collectionNamespace(ns),
      cursors: [cursorId]
    };
    const options = {};
    if (typeof cursorState.session === "object")
      options.session = cursorState.session;
    command(server, ns, killCursorCmd, options, (err, result) => {
      if (err) {
        return callback(err);
      }
      const response = result.message;
      if (response.cursorNotFound) {
        return callback(new MongoNetworkError("cursor killed or timed out"), null);
      }
      if (!Array.isArray(response.documents) || response.documents.length === 0) {
        return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
      }
      callback(null, response.documents[0]);
    });
  }
  module2.exports = killCursors;
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS((exports2, module2) => {
  "use strict";
  var GetMore = require_commands().GetMore;
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var collectionNamespace = require_shared().collectionNamespace;
  var maxWireVersion = require_utils2().maxWireVersion;
  var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
  var command = require_command();
  function getMore(server, ns, cursorState, batchSize, options, callback) {
    options = options || {};
    const wireVersion = maxWireVersion(server);
    function queryCallback(err, result) {
      if (err)
        return callback(err);
      const response = result.message;
      if (response.cursorNotFound) {
        return callback(new MongoNetworkError("cursor killed or timed out"), null);
      }
      if (wireVersion < 4) {
        const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
        cursorState.documents = response.documents;
        cursorState.cursorId = cursorId3;
        callback(null, null, response.connection);
        return;
      }
      if (response.documents[0].ok === 0) {
        return callback(new MongoError(response.documents[0]));
      }
      const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
      cursorState.documents = response.documents[0].cursor.nextBatch;
      cursorState.cursorId = cursorId2;
      callback(null, response.documents[0], response.connection);
    }
    if (wireVersion < 4) {
      const bson = server.s.bson;
      const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
      const queryOptions = applyCommonQueryOptions({}, cursorState);
      server.s.pool.write(getMoreOp, queryOptions, queryCallback);
      return;
    }
    const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
    const getMoreCmd = {
      getMore: cursorId,
      collection: collectionNamespace(ns),
      batchSize: Math.abs(batchSize)
    };
    if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
      getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
    }
    const commandOptions = Object.assign({
      returnFieldSelector: null,
      documentsReturnedIn: "nextBatch"
    }, options);
    if (cursorState.session) {
      commandOptions.session = cursorState.session;
    }
    command(server, ns, getMoreCmd, commandOptions, queryCallback);
  }
  module2.exports = getMore;
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS((exports2, module2) => {
  "use strict";
  var Query = require_commands().Query;
  var MongoError = require_error().MongoError;
  var getReadPreference = require_shared().getReadPreference;
  var collectionNamespace = require_shared().collectionNamespace;
  var isSharded = require_shared().isSharded;
  var maxWireVersion = require_utils2().maxWireVersion;
  var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
  var command = require_command();
  var decorateWithExplain = require_utils4().decorateWithExplain;
  var Explain = require_explain().Explain;
  function query(server, ns, cmd, cursorState, options, callback) {
    options = options || {};
    if (cursorState.cursorId != null) {
      return callback();
    }
    if (cmd == null) {
      return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
    }
    if (maxWireVersion(server) < 4) {
      const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options);
      const queryOptions = applyCommonQueryOptions({}, cursorState);
      if (typeof query2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
      }
      server.s.pool.write(query2, queryOptions, callback);
      return;
    }
    const readPreference = getReadPreference(cmd, options);
    let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options);
    const explain = Explain.fromOptions(options);
    if (explain) {
      findCmd = decorateWithExplain(findCmd, explain);
    }
    cmd.virtual = false;
    const commandOptions = Object.assign({
      documentsReturnedIn: "firstBatch",
      numberToReturn: 1,
      slaveOk: readPreference.slaveOk()
    }, options);
    if (cmd.readPreference) {
      commandOptions.readPreference = readPreference;
    }
    if (cursorState.session) {
      commandOptions.session = cursorState.session;
    }
    command(server, ns, findCmd, commandOptions, callback);
  }
  function prepareFindCommand(server, ns, cmd, cursorState) {
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    const findCmd = {
      find: collectionNamespace(ns)
    };
    if (cmd.query) {
      if (cmd.query["$query"]) {
        findCmd.filter = cmd.query["$query"];
      } else {
        findCmd.filter = cmd.query;
      }
    }
    let sortValue = cmd.sort;
    if (Array.isArray(sortValue)) {
      const sortObject = {};
      if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
        let sortDirection = sortValue[1];
        if (sortDirection === "asc") {
          sortDirection = 1;
        } else if (sortDirection === "desc") {
          sortDirection = -1;
        }
        sortObject[sortValue[0]] = sortDirection;
      } else {
        for (let i = 0; i < sortValue.length; i++) {
          let sortDirection = sortValue[i][1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[i][0]] = sortDirection;
        }
      }
      sortValue = sortObject;
    }
    if (typeof cmd.allowDiskUse === "boolean") {
      findCmd.allowDiskUse = cmd.allowDiskUse;
    }
    if (cmd.sort)
      findCmd.sort = sortValue;
    if (cmd.fields)
      findCmd.projection = cmd.fields;
    if (cmd.hint)
      findCmd.hint = cmd.hint;
    if (cmd.skip)
      findCmd.skip = cmd.skip;
    if (cmd.limit)
      findCmd.limit = cmd.limit;
    if (cmd.limit < 0) {
      findCmd.limit = Math.abs(cmd.limit);
      findCmd.singleBatch = true;
    }
    if (typeof cmd.batchSize === "number") {
      if (cmd.batchSize < 0) {
        if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
          findCmd.limit = Math.abs(cmd.batchSize);
        }
        findCmd.singleBatch = true;
      }
      findCmd.batchSize = Math.abs(cmd.batchSize);
    }
    if (cmd.comment)
      findCmd.comment = cmd.comment;
    if (cmd.maxScan)
      findCmd.maxScan = cmd.maxScan;
    if (cmd.maxTimeMS)
      findCmd.maxTimeMS = cmd.maxTimeMS;
    if (cmd.min)
      findCmd.min = cmd.min;
    if (cmd.max)
      findCmd.max = cmd.max;
    findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
    findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
    if (cmd.snapshot)
      findCmd.snapshot = cmd.snapshot;
    if (cmd.tailable)
      findCmd.tailable = cmd.tailable;
    if (cmd.oplogReplay)
      findCmd.oplogReplay = cmd.oplogReplay;
    if (cmd.noCursorTimeout)
      findCmd.noCursorTimeout = cmd.noCursorTimeout;
    if (cmd.awaitData)
      findCmd.awaitData = cmd.awaitData;
    if (cmd.awaitdata)
      findCmd.awaitData = cmd.awaitdata;
    if (cmd.partial)
      findCmd.partial = cmd.partial;
    if (cmd.collation)
      findCmd.collation = cmd.collation;
    if (cmd.readConcern)
      findCmd.readConcern = cmd.readConcern;
    return findCmd;
  }
  function prepareLegacyFindQuery(server, ns, cmd, cursorState, options) {
    options = options || {};
    const bson = server.s.bson;
    const readPreference = getReadPreference(cmd, options);
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    let numberToReturn = 0;
    if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
      numberToReturn = cursorState.limit;
    } else {
      numberToReturn = cursorState.batchSize;
    }
    const numberToSkip = cursorState.skip || 0;
    const findCmd = {};
    if (isSharded(server) && readPreference) {
      findCmd["$readPreference"] = readPreference.toJSON();
    }
    if (cmd.sort)
      findCmd["$orderby"] = cmd.sort;
    if (cmd.hint)
      findCmd["$hint"] = cmd.hint;
    if (cmd.snapshot)
      findCmd["$snapshot"] = cmd.snapshot;
    if (typeof cmd.returnKey !== "undefined")
      findCmd["$returnKey"] = cmd.returnKey;
    if (cmd.maxScan)
      findCmd["$maxScan"] = cmd.maxScan;
    if (cmd.min)
      findCmd["$min"] = cmd.min;
    if (cmd.max)
      findCmd["$max"] = cmd.max;
    if (typeof cmd.showDiskLoc !== "undefined")
      findCmd["$showDiskLoc"] = cmd.showDiskLoc;
    if (cmd.comment)
      findCmd["$comment"] = cmd.comment;
    if (cmd.maxTimeMS)
      findCmd["$maxTimeMS"] = cmd.maxTimeMS;
    if (options.explain !== void 0) {
      numberToReturn = -Math.abs(cmd.limit || 0);
      findCmd["$explain"] = true;
    }
    findCmd["$query"] = cmd.query;
    if (cmd.readConcern && cmd.readConcern.level !== "local") {
      throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
    }
    if (cmd.readConcern) {
      cmd = Object.assign({}, cmd);
      delete cmd["readConcern"];
    }
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
    const query2 = new Query(bson, ns, findCmd, {
      numberToSkip,
      numberToReturn,
      pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
      checkKeys: false,
      returnFieldSelector: cmd.fields,
      serializeFunctions,
      ignoreUndefined
    });
    if (typeof cmd.tailable === "boolean")
      query2.tailable = cmd.tailable;
    if (typeof cmd.oplogReplay === "boolean")
      query2.oplogReplay = cmd.oplogReplay;
    if (typeof cmd.noCursorTimeout === "boolean")
      query2.noCursorTimeout = cmd.noCursorTimeout;
    if (typeof cmd.awaitData === "boolean")
      query2.awaitData = cmd.awaitData;
    if (typeof cmd.partial === "boolean")
      query2.partial = cmd.partial;
    query2.slaveOk = readPreference.slaveOk();
    return query2;
  }
  module2.exports = query;
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS((exports2, module2) => {
  "use strict";
  var writeCommand = require_write_command();
  module2.exports = {
    insert: function insert(server, ns, ops, options, callback) {
      writeCommand(server, "insert", "documents", ns, ops, options, callback);
    },
    update: function update(server, ns, ops, options, callback) {
      writeCommand(server, "update", "updates", ns, ops, options, callback);
    },
    remove: function remove(server, ns, ops, options, callback) {
      writeCommand(server, "delete", "deletes", ns, ops, options, callback);
    },
    killCursors: require_kill_cursors(),
    getMore: require_get_more(),
    query: require_query(),
    command: require_command()
  };
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports2, module2) => {
  "use strict";
  var Explain = require_explain().Explain;
  var MongoError = require_core2().MongoError;
  var Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
    NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
    EXPLAINABLE: Symbol("EXPLAINABLE")
  };
  var OperationBase = class {
    constructor(options) {
      this.options = Object.assign({}, options);
      if (this.hasAspect(Aspect.EXPLAINABLE)) {
        this.explain = Explain.fromOptions(options);
      } else if (this.options.explain !== void 0) {
        throw new MongoError(`explain is not supported on this command`);
      }
    }
    hasAspect(aspect) {
      if (this.constructor.aspects == null) {
        return false;
      }
      return this.constructor.aspects.has(aspect);
    }
    set session(session) {
      Object.assign(this.options, {session});
    }
    get session() {
      return this.options.session;
    }
    clearSession() {
      delete this.options.session;
    }
    get canRetryRead() {
      return true;
    }
    execute() {
      throw new TypeError("`execute` must be implemented for OperationBase subclasses");
    }
  };
  function defineAspects(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  }
  module2.exports = {
    Aspect,
    defineAspects,
    OperationBase
  };
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_read_preference();
  var isRetryableError = require_error().isRetryableError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var isUnifiedTopology = require_utils2().isUnifiedTopology;
  function executeOperation(topology, operation, callback) {
    if (topology == null) {
      throw new TypeError("This method requires a valid topology instance");
    }
    if (!(operation instanceof OperationBase)) {
      throw new TypeError("This method requires a valid operation instance");
    }
    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
      return selectServerForSessionSupport(topology, operation, callback);
    }
    const Promise2 = topology.s.promiseLibrary;
    let session, owner;
    if (topology.hasSessionSupport()) {
      if (operation.session == null) {
        owner = Symbol();
        session = topology.startSession({owner});
        operation.session = session;
      } else if (operation.session.hasEnded) {
        throw new MongoError("Use of expired sessions is not permitted");
      }
    }
    let result;
    if (typeof callback !== "function") {
      result = new Promise2((resolve, reject) => {
        callback = (err, res) => {
          if (err)
            return reject(err);
          resolve(res);
        };
      });
    }
    function executeCallback(err, result2) {
      if (session && session.owner === owner) {
        session.endSession();
        if (operation.session === session) {
          operation.clearSession();
        }
      }
      callback(err, result2);
    }
    try {
      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
        executeWithServerSelection(topology, operation, executeCallback);
      } else {
        operation.execute(executeCallback);
      }
    } catch (e) {
      if (session && session.owner === owner) {
        session.endSession();
        if (operation.session === session) {
          operation.clearSession();
        }
      }
      throw e;
    }
    return result;
  }
  function supportsRetryableReads(server) {
    return maxWireVersion(server) >= 6;
  }
  function executeWithServerSelection(topology, operation, callback) {
    const readPreference = operation.readPreference || ReadPreference.primary;
    const inTransaction = operation.session && operation.session.inTransaction();
    if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
      callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
      return;
    }
    const serverSelectionOptions = {
      readPreference,
      session: operation.session
    };
    function callbackWithRetry(err, result) {
      if (err == null) {
        return callback(null, result);
      }
      if (!isRetryableError(err)) {
        return callback(err);
      }
      topology.selectServer(serverSelectionOptions, (err2, server) => {
        if (err2 || !supportsRetryableReads(server)) {
          callback(err2, null);
          return;
        }
        operation.execute(server, callback);
      });
    }
    topology.selectServer(serverSelectionOptions, (err, server) => {
      if (err) {
        callback(err, null);
        return;
      }
      const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
      if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
        operation.execute(server, callbackWithRetry);
        return;
      }
      operation.execute(server, callback);
    });
  }
  function selectServerForSessionSupport(topology, operation, callback) {
    const Promise2 = topology.s.promiseLibrary;
    let result;
    if (typeof callback !== "function") {
      result = new Promise2((resolve, reject) => {
        callback = (err, result2) => {
          if (err)
            return reject(err);
          resolve(result2);
        };
      });
    }
    topology.selectServer(ReadPreference.primaryPreferred, (err) => {
      if (err) {
        callback(err);
        return;
      }
      executeOperation(topology, operation, callback);
    });
    return result;
  }
  module2.exports = executeOperation;
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Logger = require_logger();
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var collationNotSupported = require_utils2().collationNotSupported;
  var ReadPreference = require_read_preference();
  var isUnifiedTopology = require_utils2().isUnifiedTopology;
  var executeOperation = require_execute_operation();
  var Readable = require("stream").Readable;
  var SUPPORTS = require_utils4().SUPPORTS;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var mergeOptions = require_utils4().mergeOptions;
  var OperationBase = require_operation().OperationBase;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var CursorState = {
    INIT: 0,
    OPEN: 1,
    CLOSED: 2,
    GET_MORE: 3
  };
  function handleCallback(callback, err, result) {
    try {
      callback(err, result);
    } catch (err2) {
      process.nextTick(function() {
        throw err2;
      });
    }
  }
  var CoreCursor = class extends Readable {
    constructor(topology, ns, cmd, options) {
      super({objectMode: true});
      options = options || {};
      if (ns instanceof OperationBase) {
        this.operation = ns;
        ns = this.operation.ns.toString();
        options = this.operation.options;
        cmd = this.operation.cmd ? this.operation.cmd : {};
      }
      this.pool = null;
      this.server = null;
      this.disconnectHandler = options.disconnectHandler;
      this.bson = topology.s.bson;
      this.ns = ns;
      this.namespace = MongoDBNamespace.fromString(ns);
      this.cmd = cmd;
      this.options = options;
      this.topology = topology;
      this.cursorState = {
        cursorId: null,
        cmd,
        documents: options.documents || [],
        cursorIndex: 0,
        dead: false,
        killed: false,
        init: false,
        notified: false,
        limit: options.limit || cmd.limit || 0,
        skip: options.skip || cmd.skip || 0,
        batchSize: options.batchSize || cmd.batchSize || 1e3,
        currentLimit: 0,
        transforms: options.transforms,
        raw: options.raw || cmd && cmd.raw
      };
      if (typeof options.session === "object") {
        this.cursorState.session = options.session;
      }
      const topologyOptions = topology.s.options;
      if (typeof topologyOptions.promoteLongs === "boolean") {
        this.cursorState.promoteLongs = topologyOptions.promoteLongs;
      } else if (typeof options.promoteLongs === "boolean") {
        this.cursorState.promoteLongs = options.promoteLongs;
      }
      if (typeof topologyOptions.promoteValues === "boolean") {
        this.cursorState.promoteValues = topologyOptions.promoteValues;
      } else if (typeof options.promoteValues === "boolean") {
        this.cursorState.promoteValues = options.promoteValues;
      }
      if (typeof topologyOptions.promoteBuffers === "boolean") {
        this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
      } else if (typeof options.promoteBuffers === "boolean") {
        this.cursorState.promoteBuffers = options.promoteBuffers;
      }
      if (topologyOptions.reconnect) {
        this.cursorState.reconnect = topologyOptions.reconnect;
      }
      this.logger = Logger("Cursor", topologyOptions);
      if (typeof cmd === "number") {
        this.cursorState.cursorId = Long2.fromNumber(cmd);
        this.cursorState.lastCursorId = this.cursorState.cursorId;
      } else if (cmd instanceof Long2) {
        this.cursorState.cursorId = cmd;
        this.cursorState.lastCursorId = cmd;
      }
      if (this.operation) {
        this.operation.cursorState = this.cursorState;
      }
    }
    setCursorBatchSize(value) {
      this.cursorState.batchSize = value;
    }
    cursorBatchSize() {
      return this.cursorState.batchSize;
    }
    setCursorLimit(value) {
      this.cursorState.limit = value;
    }
    cursorLimit() {
      return this.cursorState.limit;
    }
    setCursorSkip(value) {
      this.cursorState.skip = value;
    }
    cursorSkip() {
      return this.cursorState.skip;
    }
    _next(callback) {
      nextFunction(this, callback);
    }
    clone() {
      const clonedOptions = mergeOptions({}, this.options);
      delete clonedOptions.session;
      return this.topology.cursor(this.ns, this.cmd, clonedOptions);
    }
    isDead() {
      return this.cursorState.dead === true;
    }
    isKilled() {
      return this.cursorState.killed === true;
    }
    isNotified() {
      return this.cursorState.notified === true;
    }
    bufferedCount() {
      return this.cursorState.documents.length - this.cursorState.cursorIndex;
    }
    readBufferedDocuments(number) {
      const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
      const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
      let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
      if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
        for (let i = 0; i < elements.length; i++) {
          elements[i] = this.cursorState.transforms.doc(elements[i]);
        }
      }
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
        elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
        this.kill();
      }
      this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
      this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
      return elements;
    }
    kill(callback) {
      this.cursorState.dead = true;
      this.cursorState.killed = true;
      this.cursorState.documents = [];
      if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
        if (callback)
          callback(null, null);
        return;
      }
      this.server.killCursors(this.ns, this.cursorState, callback);
    }
    rewind() {
      if (this.cursorState.init) {
        if (!this.cursorState.dead) {
          this.kill();
        }
        this.cursorState.currentLimit = 0;
        this.cursorState.init = false;
        this.cursorState.dead = false;
        this.cursorState.killed = false;
        this.cursorState.notified = false;
        this.cursorState.documents = [];
        this.cursorState.cursorId = null;
        this.cursorState.cursorIndex = 0;
      }
    }
    _read() {
      if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
        return this.push(null);
      }
      this._next((err, result) => {
        if (err) {
          if (this.listeners("error") && this.listeners("error").length > 0) {
            this.emit("error", err);
          }
          if (!this.isDead())
            this.close();
          this.emit("end");
          return this.emit("finish");
        }
        if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
          return this.push(this.cursorState.streamOptions.transform(result));
        }
        this.push(result);
        if (result === null && this.isDead()) {
          this.once("end", () => {
            this.close();
            this.emit("finish");
          });
        }
      });
    }
    _endSession(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const session = this.cursorState.session;
      if (session && (options.force || session.owner === this)) {
        this.cursorState.session = void 0;
        if (this.operation) {
          this.operation.clearSession();
        }
        session.endSession(callback);
        return true;
      }
      if (callback) {
        callback();
      }
      return false;
    }
    _getMore(callback) {
      if (this.logger.isDebug()) {
        this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
      }
      let batchSize = this.cursorState.batchSize;
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
        batchSize = this.cursorState.limit - this.cursorState.currentLimit;
      }
      const cursorState = this.cursorState;
      this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
          this._endSession();
        }
        callback(err, result, conn);
      });
    }
    _initializeCursor(callback) {
      const cursor = this;
      if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
        cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
          if (err) {
            callback(err);
            return;
          }
          this._initializeCursor(callback);
        });
        return;
      }
      function done(err, result) {
        const cursorState = cursor.cursorState;
        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
          cursor._endSession();
        }
        if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
          return setCursorNotified(cursor, callback);
        }
        callback(err, result);
      }
      const queryCallback = (err, r) => {
        if (err) {
          return done(err);
        }
        const result = r.message;
        if (Array.isArray(result.documents) && result.documents.length === 1) {
          const document2 = result.documents[0];
          if (result.queryFailure) {
            return done(new MongoError(document2), null);
          }
          if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
            if (document2.$err || document2.errmsg) {
              return done(new MongoError(document2), null);
            }
            if (document2.cursor != null && typeof document2.cursor !== "string") {
              const id = document2.cursor.id;
              if (document2.cursor.ns) {
                cursor.ns = document2.cursor.ns;
              }
              cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
              cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
              cursor.cursorState.operationTime = document2.operationTime;
              if (Array.isArray(document2.cursor.firstBatch)) {
                cursor.cursorState.documents = document2.cursor.firstBatch;
              }
              return done(null, result);
            }
          }
        }
        const cursorId = result.cursorId || 0;
        cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
        cursor.cursorState.documents = result.documents;
        cursor.cursorState.lastCursorId = result.cursorId;
        if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
          cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
        }
        done(null, result);
      };
      if (cursor.operation) {
        if (cursor.logger.isDebug()) {
          cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
        }
        executeOperation(cursor.topology, cursor.operation, (err, result) => {
          if (err) {
            done(err);
            return;
          }
          cursor.server = cursor.operation.server;
          cursor.cursorState.init = true;
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          queryCallback(err, result);
        });
        return;
      }
      const serverSelectOptions = {};
      if (cursor.cursorState.session) {
        serverSelectOptions.session = cursor.cursorState.session;
      }
      if (cursor.operation) {
        serverSelectOptions.readPreference = cursor.operation.readPreference;
      } else if (cursor.options.readPreference) {
        serverSelectOptions.readPreference = cursor.options.readPreference;
      }
      return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
        if (err) {
          const disconnectHandler = cursor.disconnectHandler;
          if (disconnectHandler != null) {
            return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
          }
          return callback(err);
        }
        cursor.server = server;
        cursor.cursorState.init = true;
        if (collationNotSupported(cursor.server, cursor.cmd)) {
          return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
        }
        if (cursor.cursorState.cursorId != null) {
          return done();
        }
        if (cursor.logger.isDebug()) {
          cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
        }
        if (cursor.cmd.find != null) {
          server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
          return;
        }
        const commandOptions = Object.assign({session: cursor.cursorState.session}, cursor.options);
        server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
      });
    }
  };
  if (SUPPORTS.ASYNC_ITERATOR) {
    CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
  }
  function isConnectionDead(self2, callback) {
    if (self2.pool && self2.pool.isDestroyed()) {
      self2.cursorState.killed = true;
      const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
      _setCursorNotifiedImpl(self2, () => callback(err));
      return true;
    }
    return false;
  }
  function isCursorDeadButNotkilled(self2, callback) {
    if (self2.cursorState.dead && !self2.cursorState.killed) {
      self2.cursorState.killed = true;
      setCursorNotified(self2, callback);
      return true;
    }
    return false;
  }
  function isCursorDeadAndKilled(self2, callback) {
    if (self2.cursorState.dead && self2.cursorState.killed) {
      handleCallback(callback, new MongoError("cursor is dead"));
      return true;
    }
    return false;
  }
  function isCursorKilled(self2, callback) {
    if (self2.cursorState.killed) {
      setCursorNotified(self2, callback);
      return true;
    }
    return false;
  }
  function setCursorDeadAndNotified(self2, callback) {
    self2.cursorState.dead = true;
    setCursorNotified(self2, callback);
  }
  function setCursorNotified(self2, callback) {
    _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
  }
  function _setCursorNotifiedImpl(self2, callback) {
    self2.cursorState.notified = true;
    self2.cursorState.documents = [];
    self2.cursorState.cursorIndex = 0;
    if (self2.cursorState.session) {
      self2._endSession(callback);
      return;
    }
    return callback();
  }
  function nextFunction(self2, callback) {
    if (self2.cursorState.notified) {
      return callback(new Error("cursor is exhausted"));
    }
    if (isCursorKilled(self2, callback))
      return;
    if (isCursorDeadButNotkilled(self2, callback))
      return;
    if (isCursorDeadAndKilled(self2, callback))
      return;
    if (!self2.cursorState.init) {
      if (!self2.topology.isConnected(self2.options)) {
        if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
          return callback(new MongoError("no connection available"));
        }
        if (self2.disconnectHandler != null) {
          if (self2.topology.isDestroyed()) {
            return callback(new MongoError("Topology was destroyed"));
          }
          self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
          return;
        }
      }
      self2._initializeCursor((err, result) => {
        if (err || result === null) {
          callback(err, result);
          return;
        }
        nextFunction(self2, callback);
      });
      return;
    }
    if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
      self2.kill(() => setCursorDeadAndNotified(self2, callback));
    } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.topology.isDestroyed())
        return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
      if (isConnectionDead(self2, callback))
        return;
      self2._getMore(function(err, doc, connection) {
        if (err) {
          return handleCallback(callback, err);
        }
        self2.connection = connection;
        if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
          return handleCallback(callback, new MongoError({
            message: "No more documents in tailed cursor",
            tailable: self2.cmd.tailable,
            awaitData: self2.cmd.awaitData
          }));
        } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
          return nextFunction(self2, callback);
        }
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          return setCursorDeadAndNotified(self2, callback);
        }
        nextFunction(self2, callback);
      });
    } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
      return handleCallback(callback, new MongoError({
        message: "No more documents in tailed cursor",
        tailable: self2.cmd.tailable,
        awaitData: self2.cmd.awaitData
      }));
    } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
      setCursorDeadAndNotified(self2, callback);
    } else {
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
        return;
      }
      self2.cursorState.currentLimit += 1;
      let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
      if (!doc || doc.$err) {
        self2.kill(() => setCursorDeadAndNotified(self2, function() {
          handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
        }));
        return;
      }
      if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
        doc = self2.cursorState.transforms.doc(doc);
      }
      handleCallback(callback, null, doc);
    }
  }
  module2.exports = {
    CursorState,
    CoreCursor
  };
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter = require("events").EventEmitter;
  var ReadPreference = require_read_preference();
  var Logger = require_logger();
  var debugOptions = require_utils3().debugOptions;
  var retrieveBSON = require_utils3().retrieveBSON;
  var Pool = require_pool();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var wireProtocol = require_wireprotocol();
  var CoreCursor = require_cursor().CoreCursor;
  var sdam = require_shared2();
  var createCompressionInfo = require_shared2().createCompressionInfo;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var SessionMixins = require_shared2().SessionMixins;
  var relayEvents = require_utils2().relayEvents;
  var collationNotSupported = require_utils2().collationNotSupported;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var debugFields = [
    "reconnect",
    "reconnectTries",
    "reconnectInterval",
    "emitError",
    "cursorFactory",
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "checkServerIdentity",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "key",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "servername"
  ];
  var id = 0;
  var serverAccounting = false;
  var servers = {};
  var BSON2 = retrieveBSON();
  function topologyId(server) {
    return server.s.parent == null ? server.id : server.s.parent.id;
  }
  var Server = function(options) {
    options = options || {};
    EventEmitter.call(this);
    this.id = id++;
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      logger: Logger("Server", options),
      Cursor: options.cursorFactory || CoreCursor,
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      pool: null,
      disconnectHandler: options.disconnectHandler,
      monitoring: typeof options.monitoring === "boolean" ? options.monitoring : true,
      inTopology: !!options.parent,
      monitoringInterval: typeof options.monitoringInterval === "number" ? options.monitoringInterval : 5e3,
      compression: {compressors: createCompressionInfo(options)},
      parent: options.parent
    };
    if (!this.s.parent) {
      this.s.clusterTime = null;
    }
    this.ismaster = null;
    this.lastIsMasterMS = -1;
    this.monitoringProcessId = null;
    this.initialConnect = true;
    this._type = "server";
    this.lastUpdateTime = 0;
    this.lastWriteDate = 0;
    this.staleness = 0;
  };
  inherits(Server, EventEmitter);
  Object.assign(Server.prototype, SessionMixins);
  Object.defineProperty(Server.prototype, "type", {
    enumerable: true,
    get: function() {
      return this._type;
    }
  });
  Object.defineProperty(Server.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      if (!this.ismaster)
        return null;
      return this.ismaster.logicalSessionTimeoutMinutes || null;
    }
  });
  Object.defineProperty(Server.prototype, "clientMetadata", {
    enumerable: true,
    get: function() {
      return this.s.options.metadata;
    }
  });
  Object.defineProperty(Server.prototype, "clusterTime", {
    enumerable: true,
    set: function(clusterTime) {
      const settings = this.s.parent ? this.s.parent : this.s;
      resolveClusterTime(settings, clusterTime);
    },
    get: function() {
      const settings = this.s.parent ? this.s.parent : this.s;
      return settings.clusterTime || null;
    }
  });
  Server.enableServerAccounting = function() {
    serverAccounting = true;
    servers = {};
  };
  Server.disableServerAccounting = function() {
    serverAccounting = false;
  };
  Server.servers = function() {
    return servers;
  };
  Object.defineProperty(Server.prototype, "name", {
    enumerable: true,
    get: function() {
      return this.s.options.host + ":" + this.s.options.port;
    }
  });
  function disconnectHandler(self2, type, ns, cmd, options, callback) {
    if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options.monitoring) {
      self2.s.disconnectHandler.add(type, ns, cmd, options, callback);
      return true;
    }
    if (!self2.s.pool.isConnected()) {
      callback(new MongoError(f("no connection available to server %s", self2.name)));
      return true;
    }
  }
  function monitoringProcess(self2) {
    return function() {
      if (self2.s.pool.isDestroyed())
        return;
      self2.emit("monitoring", self2);
      var start = new Date().getTime();
      self2.command("admin.$cmd", {ismaster: true}, {
        socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
        monitoring: true
      }, (err, result) => {
        self2.lastIsMasterMS = new Date().getTime() - start;
        if (self2.s.pool.isDestroyed())
          return;
        if (result) {
          self2.ismaster = result.result;
        }
        self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
      });
    };
  }
  var eventHandler = function(self2, event) {
    return function(err, conn) {
      if (self2.s.logger.isInfo()) {
        var object = err instanceof MongoError ? JSON.stringify(err) : {};
        self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
      }
      if (event === "connect") {
        self2.initialConnect = false;
        self2.ismaster = conn.ismaster;
        self2.lastIsMasterMS = conn.lastIsMasterMS;
        if (conn.agreedCompressor) {
          self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
        }
        if (conn.zlibCompressionLevel) {
          self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
        }
        if (conn.ismaster.$clusterTime) {
          const $clusterTime = conn.ismaster.$clusterTime;
          self2.clusterTime = $clusterTime;
        }
        if (self2.ismaster.msg === "isdbgrid") {
          self2._type = "mongos";
        }
        if (self2.s.monitoring) {
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        }
        sdam.emitServerDescriptionChanged(self2, {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: sdam.getTopologyType(self2)
        });
        if (!self2.s.inTopology) {
          sdam.emitTopologyDescriptionChanged(self2, {
            topologyType: "Single",
            servers: [
              {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: sdam.getTopologyType(self2)
              }
            ]
          });
        }
        if (self2.s.logger.isInfo()) {
          self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
        }
        self2.emit("connect", self2);
      } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
        if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
          if (!self2.s.inTopology) {
            self2.emit("topologyOpening", {topologyId: self2.id});
          }
          delete servers[self2.id];
        }
        if (event === "close") {
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: "Unknown"
          });
        }
        if (event === "reconnectFailed") {
          self2.emit("reconnectFailed", err);
          if (self2.listeners("error").length > 0) {
            self2.emit("error", err);
          }
          return;
        }
        if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
          self2.initialConnect = false;
          return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
        }
        if (event === "reconnect") {
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          return self2.emit(event, self2);
        }
        self2.emit(event, err);
      }
    };
  };
  Server.prototype.connect = function(options) {
    var self2 = this;
    options = options || {};
    if (serverAccounting)
      servers[this.id] = this;
    if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
      throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
    }
    self2.s.pool = new Pool(this, Object.assign(self2.s.options, options, {bson: this.s.bson}));
    self2.s.pool.on("close", eventHandler(self2, "close"));
    self2.s.pool.on("error", eventHandler(self2, "error"));
    self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
    self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
    self2.s.pool.on("connect", eventHandler(self2, "connect"));
    self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
    self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
    relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
    if (!self2.s.inTopology) {
      this.emit("topologyOpening", {topologyId: topologyId(self2)});
    }
    self2.emit("serverOpening", {topologyId: topologyId(self2), address: self2.name});
    self2.s.pool.connect();
  };
  Server.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Server.prototype.getDescription = function() {
    var ismaster = this.ismaster || {};
    var description = {
      type: sdam.getTopologyType(this),
      address: this.name
    };
    if (ismaster.hosts)
      description.hosts = ismaster.hosts;
    if (ismaster.arbiters)
      description.arbiters = ismaster.arbiters;
    if (ismaster.passives)
      description.passives = ismaster.passives;
    if (ismaster.setName)
      description.setName = ismaster.setName;
    return description;
  };
  Server.prototype.lastIsMaster = function() {
    return this.ismaster;
  };
  Server.prototype.unref = function() {
    this.s.pool.unref();
  };
  Server.prototype.isConnected = function() {
    if (!this.s.pool)
      return false;
    return this.s.pool.isConnected();
  };
  Server.prototype.isDestroyed = function() {
    if (!this.s.pool)
      return false;
    return this.s.pool.isDestroyed();
  };
  function basicWriteValidations(self2) {
    if (!self2.s.pool)
      return new MongoError("server instance is not connected");
    if (self2.s.pool.isDestroyed())
      return new MongoError("server instance pool was destroyed");
  }
  function basicReadValidations(self2, options) {
    basicWriteValidations(self2, options);
    if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
      throw new Error("readPreference must be an instance of ReadPreference");
    }
  }
  Server.prototype.command = function(ns, cmd, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicReadValidations(self2, options);
    if (result)
      return callback(result);
    options = Object.assign({}, options, {wireProtocolCommand: false});
    if (self2.s.logger.isDebug())
      self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
        ns,
        cmd,
        options: debugOptions(debugFields, options)
      }), self2.name));
    if (disconnectHandler(self2, "command", ns, cmd, options, callback))
      return;
    if (collationNotSupported(this, cmd)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    wireProtocol.command(self2, ns, cmd, options, callback);
  };
  Server.prototype.query = function(ns, cmd, cursorState, options, callback) {
    wireProtocol.query(this, ns, cmd, cursorState, options, callback);
  };
  Server.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {
    wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);
  };
  Server.prototype.killCursors = function(ns, cursorState, callback) {
    wireProtocol.killCursors(this, ns, cursorState, callback);
  };
  Server.prototype.insert = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "insert", ns, ops, options, callback))
      return;
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.insert(self2, ns, ops, options, callback);
  };
  Server.prototype.update = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "update", ns, ops, options, callback))
      return;
    if (collationNotSupported(this, options)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.update(self2, ns, ops, options, callback);
  };
  Server.prototype.remove = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "remove", ns, ops, options, callback))
      return;
    if (collationNotSupported(this, options)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.remove(self2, ns, ops, options, callback);
  };
  Server.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  Server.prototype.equals = function(server) {
    if (typeof server === "string")
      return this.name.toLowerCase() === server.toLowerCase();
    if (server.name)
      return this.name.toLowerCase() === server.name.toLowerCase();
    return false;
  };
  Server.prototype.connections = function() {
    return this.s.pool.allConnections();
  };
  Server.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector, selector = void 0;
    callback(null, this);
  };
  var listeners = ["close", "error", "timeout", "parseError", "connect"];
  Server.prototype.destroy = function(options, callback) {
    if (this._destroyed) {
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var self2 = this;
    if (serverAccounting)
      delete servers[this.id];
    if (this.monitoringProcessId) {
      clearTimeout(this.monitoringProcessId);
    }
    if (!self2.s.pool || this._destroyed) {
      this._destroyed = true;
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    this._destroyed = true;
    if (options.emitClose) {
      self2.emit("close", self2);
    }
    if (options.emitDestroy) {
      self2.emit("destroy", self2);
    }
    listeners.forEach(function(event) {
      self2.s.pool.removeAllListeners(event);
    });
    if (self2.listeners("serverClosed").length > 0)
      self2.emit("serverClosed", {topologyId: topologyId(self2), address: self2.name});
    if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
      self2.emit("topologyClosed", {topologyId: topologyId(self2)});
    }
    if (self2.s.logger.isDebug()) {
      self2.s.logger.debug(f("destroy called on server %s", self2.name));
    }
    this.s.pool.destroy(options.force, callback);
  };
  module2.exports = Server;
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var diff = require_shared2().diff;
  var EventEmitter = require("events").EventEmitter;
  var Logger = require_logger();
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var Buffer2 = require_safe_buffer().Buffer;
  var TopologyType = {
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown"
  };
  var ServerType = {
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown"
  };
  var ReplSetState = function(options) {
    options = options || {};
    EventEmitter.call(this);
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    this.setName = options.setName;
    this.set = {};
    this.id = options.id;
    this.setName = options.setName;
    this.logger = options.logger || Logger("ReplSet", options);
    this.index = 0;
    this.acceptableLatency = options.acceptableLatency || 15;
    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
    this.primary = null;
    this.secondaries = [];
    this.arbiters = [];
    this.passives = [];
    this.ghosts = [];
    this.unknownServers = [];
    this.set = {};
    this.maxElectionId = null;
    this.maxSetVersion = 0;
    this.replicasetDescription = {
      topologyType: "Unknown",
      servers: []
    };
    this.logicalSessionTimeoutMinutes = void 0;
  };
  inherits(ReplSetState, EventEmitter);
  ReplSetState.prototype.hasPrimaryAndSecondary = function() {
    return this.primary != null && this.secondaries.length > 0;
  };
  ReplSetState.prototype.hasPrimaryOrSecondary = function() {
    return this.hasPrimary() || this.hasSecondary();
  };
  ReplSetState.prototype.hasPrimary = function() {
    return this.primary != null;
  };
  ReplSetState.prototype.hasSecondary = function() {
    return this.secondaries.length > 0;
  };
  ReplSetState.prototype.get = function(host) {
    var servers = this.allServers();
    for (var i = 0; i < servers.length; i++) {
      if (servers[i].name.toLowerCase() === host.toLowerCase()) {
        return servers[i];
      }
    }
    return null;
  };
  ReplSetState.prototype.allServers = function(options) {
    options = options || {};
    var servers = this.primary ? [this.primary] : [];
    servers = servers.concat(this.secondaries);
    if (!options.ignoreArbiters)
      servers = servers.concat(this.arbiters);
    servers = servers.concat(this.passives);
    return servers;
  };
  ReplSetState.prototype.destroy = function(options, callback) {
    const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
    if (this.primary)
      serversToDestroy.push(this.primary);
    let serverCount = serversToDestroy.length;
    const serverDestroyed = () => {
      serverCount--;
      if (serverCount > 0) {
        return;
      }
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.primary = null;
      emitTopologyDescriptionChanged(this);
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (serverCount === 0) {
      serverDestroyed();
      return;
    }
    serversToDestroy.forEach((server) => server.destroy(options, serverDestroyed));
  };
  ReplSetState.prototype.remove = function(server, options) {
    options = options || {};
    var serverName = server.name.toLowerCase();
    var servers = this.primary ? [this.primary] : [];
    servers = servers.concat(this.secondaries);
    servers = servers.concat(this.arbiters);
    servers = servers.concat(this.passives);
    for (var i = 0; i < servers.length; i++) {
      if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
        return;
      }
    }
    if (this.set[serverName]) {
      this.set[serverName].type = ServerType.Unknown;
      this.set[serverName].electionId = null;
      this.set[serverName].setName = null;
      this.set[serverName].setVersion = null;
    }
    var removeType = null;
    if (this.primary && this.primary.equals(server)) {
      this.primary = null;
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      removeType = "primary";
    }
    removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
    removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
    removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
    removeFrom(server, this.ghosts);
    removeFrom(server, this.unknownServers);
    this.unknownServers.push(serverName);
    if (removeType) {
      this.emit("left", removeType, server);
    }
  };
  var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
  ReplSetState.prototype.update = function(server) {
    var self2 = this;
    var ismaster = server.lastIsMaster();
    var serverName = server.name.toLowerCase();
    if (ismaster) {
      var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
      hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
      hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
      hosts = hosts.map(function(s) {
        return s.toLowerCase();
      });
      for (var i = 0; i < hosts.length; i++) {
        if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
          this.unknownServers.push(hosts[i].toLowerCase());
        }
        if (!this.set[hosts[i]]) {
          this.set[hosts[i]] = {
            type: ServerType.Unknown,
            electionId: null,
            setName: null,
            setVersion: null
          };
        }
      }
    }
    if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
      self2.set[serverName] = {
        type: ServerType.Unknown,
        setVersion: null,
        electionId: null,
        setName: null
      };
      self2.set[serverName].type = ServerType.Unknown;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      if (self2.unknownServers.indexOf(server.name) === -1) {
        self2.unknownServers.push(serverName);
      }
      return false;
    }
    if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
      if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
        self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
      } else {
        self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
      }
    }
    if (ismaster && ismaster.msg === "isdbgrid") {
      if (this.primary && this.primary.name === serverName) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      return false;
    }
    if (ismaster.isreplicaset) {
      self2.set[serverName] = {
        type: ServerType.RSGhost,
        setVersion: null,
        electionId: null,
        setName: ismaster.setName
      };
      if (this.primary && this.primary.name === serverName) {
        this.primary = null;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      return false;
    }
    if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
      self2.set[serverName] = {
        type: ServerType.RSOther,
        setVersion: null,
        electionId: null,
        setName: ismaster.setName
      };
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      return false;
    }
    if (ismaster && ismaster.ismaster && !ismaster.setName) {
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
      this.remove(server, {force: true});
      return false;
    }
    if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
      this.remove(server, {force: true});
      return false;
    }
    if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
      if (this.logger.isWarn()) {
        this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
      }
      delete this.set[serverName];
      removeFrom(server, self2.unknownServers);
      server.destroy({force: true});
      if (this.primary && !this.primary.equals(server)) {
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
      } else {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      if (!this.primary && ismaster.primary) {
        this.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setName: null,
          electionId: null,
          setVersion: null
        };
      }
      return false;
    }
    if (!this.primary && ismaster.ismaster && ismaster.setName) {
      var ismasterElectionId = server.lastIsMaster().electionId;
      if (this.setName && this.setName !== ismaster.setName) {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
      }
      if (!this.maxElectionId && ismasterElectionId) {
        this.maxElectionId = ismasterElectionId;
      } else if (this.maxElectionId && ismasterElectionId) {
        var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
        var ismasterSetVersion = server.lastIsMaster().setVersion;
        if (result === 1) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return false;
        } else if (result === 0 && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          }
        }
        this.maxSetVersion = ismasterSetVersion;
        this.maxElectionId = ismasterElectionId;
      }
      var normalizedHosts = ismaster.hosts.map(function(x) {
        return x.toLowerCase();
      });
      var locationIndex = normalizedHosts.indexOf(serverName);
      if (locationIndex !== -1) {
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
      } else {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      emitTopologyDescriptionChanged(self2);
      return true;
    } else if (ismaster.ismaster && ismaster.setName) {
      var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
      var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
      var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
      ismasterElectionId = server.lastIsMaster().electionId;
      ismasterSetVersion = server.lastIsMaster().setVersion;
      var ismasterSetName = server.lastIsMaster().setName;
      if (this.primary.equals(server) && currentSetName === ismasterSetName) {
        return false;
      }
      if (currentSetName && currentSetName !== ismasterSetName) {
        if (!this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (currentElectionId && ismasterElectionId) {
        result = compareObjectIds(currentElectionId, ismasterElectionId);
        if (result === 1) {
          return false;
        } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
          return false;
        }
      } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
        if (ismasterSetVersion < this.maxSetVersion) {
          return false;
        }
      }
      if (!this.maxElectionId && ismasterElectionId) {
        this.maxElectionId = ismasterElectionId;
      } else if (this.maxElectionId && ismasterElectionId) {
        result = compareObjectIds(this.maxElectionId, ismasterElectionId);
        if (result === 1) {
          return false;
        } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        } else {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        this.maxElectionId = ismasterElectionId;
        this.maxSetVersion = ismasterSetVersion;
      } else {
        this.maxSetVersion = ismasterSetVersion;
      }
      self2.set[self2.primary.name.toLowerCase()] = {
        type: ServerType.Unknown,
        setVersion: null,
        electionId: null,
        setName: null
      };
      self2.emit("left", "primary", this.primary);
      self2.primary.destroy({force: true});
      self2.primary = server;
      self2.set[serverName] = {
        type: ServerType.RSPrimary,
        setVersion: ismaster.setVersion,
        electionId: ismaster.electionId,
        setName: ismaster.setName
      };
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      removeFrom(server, self2.secondaries);
      removeFrom(server, self2.passives);
      self2.emit("joined", "primary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (!this.primary && ismaster.primary) {
      self2.set[ismaster.primary.toLowerCase()] = {
        type: ServerType.PossiblePrimary,
        setVersion: null,
        electionId: null,
        setName: null
      };
    }
    if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      if (this.primary && this.primary.name.toLowerCase() === serverName) {
        server.destroy({force: true});
        this.primary = null;
        self2.emit("left", "primary", server);
      }
      self2.emit("joined", "secondary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      self2.emit("joined", "arbiter", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      if (this.primary && this.primary.name.toLowerCase() === serverName) {
        server.destroy({force: true});
        this.primary = null;
        self2.emit("left", "primary", server);
      }
      self2.emit("joined", "secondary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
      self2.emit("left", "primary", this.primary);
      this.primary.destroy({force: true});
      this.primary = null;
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      return false;
    }
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    return false;
  };
  ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
    var max = 0;
    for (var i = 0; i < this.secondaries.length; i++) {
      max = Math.max(max, this.secondaries[i].lastWriteDate);
    }
    if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
      server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
    } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
      server.staleness = max - server.lastWriteDate + haInterval;
    }
  };
  ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
    for (var i = 0; i < this.secondaries.length; i++) {
      this.updateServerMaxStaleness(this.secondaries[i], haInterval);
    }
  };
  ReplSetState.prototype.pickServer = function(readPreference) {
    readPreference = readPreference || ReadPreference.primary;
    if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
      return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
    }
    var allservers = this.primary ? [this.primary] : [];
    allservers = allservers.concat(this.secondaries);
    if (readPreference.maxStalenessSeconds != null) {
      for (var i = 0; i < allservers.length; i++) {
        if (allservers[i].ismaster.maxWireVersion < 5) {
          return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
        }
      }
    }
    if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
      return pickNearest(this, readPreference);
    } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
      return pickNearestMaxStalenessSeconds(this, readPreference);
    }
    var secondaries = this.secondaries;
    if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
      return new MongoError("no secondary server available");
    }
    if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
      return new MongoError("no secondary or primary server available");
    }
    if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
      return new MongoError("no primary server available");
    }
    if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
      if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
        var server = pickNearest(this, readPreference);
        if (server) {
          return server;
        }
      } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
        server = pickNearestMaxStalenessSeconds(this, readPreference);
        if (server) {
          return server;
        }
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.primary;
      }
      return null;
    }
    if (readPreference.equals(ReadPreference.primaryPreferred)) {
      server = null;
      if (this.primary) {
        return this.primary;
      }
      if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
        server = pickNearest(this, readPreference);
      } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
        server = pickNearestMaxStalenessSeconds(this, readPreference);
      }
      if (server)
        return server;
    }
    return this.primary;
  };
  var filterByTags = function(readPreference, servers) {
    if (readPreference.tags == null)
      return servers;
    var filteredServers = [];
    var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
    for (var j = 0; j < tagsArray.length; j++) {
      var tags = tagsArray[j];
      for (var i = 0; i < servers.length; i++) {
        var serverTag = servers[i].lastIsMaster().tags || {};
        var found = true;
        for (var name in tags) {
          if (serverTag[name] !== tags[name]) {
            found = false;
          }
        }
        if (found) {
          filteredServers.push(servers[i]);
        }
      }
    }
    return filteredServers;
  };
  function pickNearestMaxStalenessSeconds(self2, readPreference) {
    var servers = [];
    var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
    if (maxStalenessMS < 90 * 1e3) {
      return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
    }
    if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    for (var i = 0; i < self2.secondaries.length; i++) {
      servers.push(self2.secondaries[i]);
    }
    if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    servers = filterByTags(readPreference, servers);
    servers = servers.filter(function(s) {
      return s.staleness <= maxStalenessMS;
    });
    servers.sort(function(a, b) {
      return a.lastIsMasterMS - b.lastIsMasterMS;
    });
    if (servers.length === 0) {
      return null;
    }
    self2.index = self2.index % servers.length;
    var server = servers[self2.index];
    self2.index = self2.index + 1;
    return server;
  }
  function pickNearest(self2, readPreference) {
    var servers = [];
    if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    for (var i = 0; i < self2.secondaries.length; i++) {
      servers.push(self2.secondaries[i]);
    }
    if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    servers = filterByTags(readPreference, servers);
    servers.sort(function(a, b) {
      return a.lastIsMasterMS - b.lastIsMasterMS;
    });
    var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
    servers = servers.filter(function(s) {
      return s.lastIsMasterMS <= lowest + self2.acceptableLatency;
    });
    if (servers.length === 0) {
      return null;
    }
    self2.index = self2.index % servers.length;
    var server = servers[self2.index];
    self2.index = self2.index + 1;
    return server;
  }
  function inList(ismaster, server, list) {
    for (var i = 0; i < list.length; i++) {
      if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
        return true;
    }
    return false;
  }
  function addToList(self2, type, ismaster, server, list) {
    var serverName = server.name.toLowerCase();
    self2.set[serverName].type = type;
    self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
    self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
    self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
    list.push(server);
  }
  function compareObjectIds(id1, id2) {
    var a = Buffer2.from(id1.toHexString(), "hex");
    var b = Buffer2.from(id2.toHexString(), "hex");
    if (a === b) {
      return 0;
    }
    if (typeof Buffer2.compare === "function") {
      return Buffer2.compare(a, b);
    }
    var x = a.length;
    var y = b.length;
    var len = Math.min(x, y);
    for (var i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        break;
      }
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    return x < y ? -1 : y < x ? 1 : 0;
  }
  function removeFrom(server, list) {
    for (var i = 0; i < list.length; i++) {
      if (list[i].equals && list[i].equals(server)) {
        list.splice(i, 1);
        return true;
      } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
        list.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  function emitTopologyDescriptionChanged(self2) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      var topology = "Unknown";
      var setName = self2.setName;
      if (self2.hasPrimaryAndSecondary()) {
        topology = "ReplicaSetWithPrimary";
      } else if (!self2.hasPrimary() && self2.hasSecondary()) {
        topology = "ReplicaSetNoPrimary";
      }
      var description = {
        topologyType: topology,
        setName,
        servers: []
      };
      if (self2.hasPrimary()) {
        var desc = self2.primary.getDescription();
        desc.type = "RSPrimary";
        description.servers.push(desc);
      }
      description.servers = description.servers.concat(self2.secondaries.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSSecondary";
        return description2;
      }));
      description.servers = description.servers.concat(self2.arbiters.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSArbiter";
        return description2;
      }));
      description.servers = description.servers.concat(self2.passives.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSSecondary";
        return description2;
      }));
      var diffResult = diff(self2.replicasetDescription, description);
      var result = {
        topologyId: self2.id,
        previousDescription: self2.replicasetDescription,
        newDescription: description,
        diff: diffResult
      };
      self2.emit("topologyDescriptionChanged", result);
      self2.replicasetDescription = description;
    }
  }
  module2.exports = ReplSetState;
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter = require("events").EventEmitter;
  var ReadPreference = require_read_preference();
  var CoreCursor = require_cursor().CoreCursor;
  var retrieveBSON = require_utils3().retrieveBSON;
  var Logger = require_logger();
  var MongoError = require_error().MongoError;
  var Server = require_server();
  var ReplSetState = require_replset_state();
  var Timeout = require_shared2().Timeout;
  var Interval = require_shared2().Interval;
  var SessionMixins = require_shared2().SessionMixins;
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = retrieveBSON();
  var getMMAPError = require_shared2().getMMAPError;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var UNREFERENCED = "unreferenced";
  var DESTROYED = "destroyed";
  function stateTransition(self2, newState) {
    var legalTransitions = {
      disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
      connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
      connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
      unreferenced: [UNREFERENCED, DESTROYED],
      destroyed: [DESTROYED]
    };
    var legalStates = legalTransitions[self2.state];
    if (legalStates && legalStates.indexOf(newState) !== -1) {
      self2.state = newState;
    } else {
      self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
    }
  }
  var id = 1;
  var handlers = ["connect", "close", "error", "timeout", "parseError"];
  var ReplSet = function(seedlist, options) {
    var self2 = this;
    options = options || {};
    if (!Array.isArray(seedlist))
      throw new MongoError("seedlist must be an array");
    if (seedlist.length === 0)
      throw new MongoError("seedlist must contain at least one entry");
    seedlist.forEach(function(e) {
      if (typeof e.host !== "string" || typeof e.port !== "number")
        throw new MongoError("seedlist entry must contain a host and port");
    });
    EventEmitter.call(this);
    this.id = id++;
    var localThresholdMS = options.localThresholdMS || 15;
    if (options.acceptableLatency)
      localThresholdMS = options.acceptableLatency;
    var logger = Logger("ReplSet", options);
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      Cursor: options.cursorFactory || CoreCursor,
      logger,
      seedlist,
      replicaSetState: new ReplSetState({
        id: this.id,
        setName: options.setName,
        acceptableLatency: localThresholdMS,
        heartbeatFrequencyMS: options.haInterval ? options.haInterval : 1e4,
        logger
      }),
      connectingServers: [],
      haInterval: options.haInterval ? options.haInterval : 1e4,
      minHeartbeatFrequencyMS: 500,
      disconnectHandler: options.disconnectHandler,
      index: 0,
      connectOptions: {},
      debug: typeof options.debug === "boolean" ? options.debug : false
    };
    this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
      self2.emit("topologyDescriptionChanged", r);
    });
    if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
      this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
    }
    var types = ["joined", "left"];
    types.forEach(function(x) {
      self2.s.replicaSetState.on(x, function(t, s) {
        self2.emit(x, t, s);
      });
    });
    this.initialConnectState = {
      connect: false,
      fullsetup: false,
      all: false
    };
    this.state = DISCONNECTED;
    this.haTimeoutId = null;
    this.ismaster = null;
    this.intervalIds = [];
    this.clusterTime = null;
  };
  inherits(ReplSet, EventEmitter);
  Object.assign(ReplSet.prototype, SessionMixins);
  Object.defineProperty(ReplSet.prototype, "type", {
    enumerable: true,
    get: function() {
      return "replset";
    }
  });
  Object.defineProperty(ReplSet.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
    }
  });
  function rexecuteOperations(self2) {
    if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute();
    } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute({executePrimary: true});
    } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute({executeSecondary: true});
    }
  }
  function connectNewServers(self2, servers, callback) {
    if (servers.length === 0) {
      return callback();
    }
    var count = servers.length;
    var error = null;
    function done() {
      count = count - 1;
      if (count === 0) {
        callback(error);
      }
    }
    var _handleEvent = function(self3, event) {
      return function(err) {
        var _self = this;
        if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
          this.destroy({force: true});
          return done();
        }
        if (event === "connect") {
          var result = self3.s.replicaSetState.update(_self);
          if (result) {
            if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
              self3.ismaster = _self.lastIsMaster();
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            monitorServer(_self.lastIsMaster().me, self3, {});
            rexecuteOperations(self3);
          } else {
            _self.destroy({force: true});
          }
        } else if (event === "error") {
          error = err;
        }
        rexecuteOperations(self3);
        done();
      };
    };
    function execute(_server, i2) {
      setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return;
        }
        const existingServerIdx = self2.s.connectingServers.findIndex((s) => s.name === _server);
        if (existingServerIdx >= 0) {
          const connectingServer = self2.s.connectingServers[existingServerIdx];
          connectingServer.destroy({force: true});
          self2.s.connectingServers.splice(existingServerIdx, 1);
          return done();
        }
        var server = new Server(Object.assign({}, self2.s.options, {
          host: _server.split(":")[0],
          port: parseInt(_server.split(":")[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        server.once("connect", _handleEvent(self2, "connect"));
        server.once("close", _handleEvent(self2, "close"));
        server.once("timeout", _handleEvent(self2, "timeout"));
        server.once("error", _handleEvent(self2, "error"));
        server.once("parseError", _handleEvent(self2, "parseError"));
        server.on("serverOpening", (e) => self2.emit("serverOpening", e));
        server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
        server.on("serverClosed", (e) => self2.emit("serverClosed", e));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        self2.s.connectingServers.push(server);
        server.connect(self2.s.connectOptions);
      }, i2);
    }
    for (var i = 0; i < servers.length; i++) {
      execute(servers[i], i);
    }
  }
  var pingServer = function(self2, server, cb) {
    var start = new Date().getTime();
    emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: server.name});
    server.command("admin.$cmd", {
      ismaster: true
    }, {
      monitoring: true,
      socketTimeout: self2.s.options.connectionTimeout || 2e3
    }, function(err, r) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        server.destroy({force: true});
        return cb(err, r);
      }
      var latencyMS = new Date().getTime() - start;
      server.lastUpdateTime = now();
      if (err) {
        emitSDAMEvent(self2, "serverHeartbeatFailed", {
          durationMS: latencyMS,
          failure: err,
          connectionId: server.name
        });
        self2.s.replicaSetState.remove(server);
      } else {
        server.ismaster = r.result;
        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
        }
        if (server.lastIsMasterMS === -1) {
          server.lastIsMasterMS = latencyMS;
        } else if (server.lastIsMasterMS) {
          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
        }
        if (self2.s.replicaSetState.update(server)) {
          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
            self2.ismaster = server.lastIsMaster();
          }
        }
        emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
          durationMS: latencyMS,
          reply: r.result,
          connectionId: server.name
        });
      }
      self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
      cb(err, r);
    });
  };
  var monitorServer = function(host, self2, options) {
    if (!options.haInterval) {
      for (var i = 0; i < self2.intervalIds.length; i++) {
        if (self2.intervalIds[i].__host === host) {
          return;
        }
      }
    }
    var _process = options.haInterval ? Timeout : Interval;
    var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
    var intervalId = new _process(function() {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        intervalId.stop();
        return;
      }
      var _server = self2.s.replicaSetState.get(host);
      if (_server) {
        return pingServer(self2, _server, function(err) {
          if (err) {
            return;
          }
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            intervalId.stop();
            return;
          }
          self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
            return intervalId2.isRunning();
          });
          if (_process === Timeout) {
            if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
              stateTransition(self2, CONNECTED);
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else {
            if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
              stateTransition(self2, CONNECTED);
              rexecuteOperations(self2);
              process.nextTick(function() {
                self2.emit("reconnect", self2);
              });
            }
          }
          if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
            self2.initialConnectState.fullsetup = true;
            self2.initialConnectState.all = true;
            process.nextTick(function() {
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            });
          }
        });
      }
    }, _haInterval);
    intervalId.start();
    intervalId.__host = host;
    self2.intervalIds.push(intervalId);
  };
  function topologyMonitor(self2, options) {
    if (self2.state === DESTROYED || self2.state === UNREFERENCED)
      return;
    options = options || {};
    var servers = Object.keys(self2.s.replicaSetState.set);
    var _process = options.haInterval ? Timeout : Interval;
    var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
    if (_process === Timeout) {
      return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return;
        }
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
          if (err) {
            return self2.emit("error", err);
          }
          self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
          return self2.destroy({force: true});
        } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          if (err) {
            return self2.emit("error", err);
          }
          self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
          return self2.destroy({force: true});
        }
        for (var i2 = 0; i2 < servers.length; i2++) {
          monitorServer(servers[i2], self2, options);
        }
      });
    } else {
      for (var i = 0; i < servers.length; i++) {
        monitorServer(servers[i], self2, options);
      }
    }
    function executeReconnect(self3) {
      return function() {
        if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
          return;
        }
        connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
          var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
          self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
        });
      };
    }
    var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
    self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
  }
  function addServerToList(list, server) {
    for (var i = 0; i < list.length; i++) {
      if (list[i].name.toLowerCase() === server.name.toLowerCase())
        return true;
    }
    list.push(server);
  }
  function handleEvent(self2, event) {
    return function() {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
      }
      self2.s.replicaSetState.remove(this);
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
        stateTransition(self2, DISCONNECTED);
      } else if (!self2.s.replicaSetState.hasPrimary()) {
        stateTransition(self2, DISCONNECTED);
      }
      addServerToList(self2.s.connectingServers, this);
    };
  }
  function shouldTriggerConnect(self2) {
    const isConnecting = self2.state === CONNECTING;
    const hasPrimary = self2.s.replicaSetState.hasPrimary();
    const hasSecondary = self2.s.replicaSetState.hasSecondary();
    const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
    const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
    return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
  }
  function handleInitialConnectEvent(self2, event) {
    return function() {
      var _this = this;
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
      }
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        return this.destroy({force: true});
      }
      if (event === "connect") {
        var result = self2.s.replicaSetState.update(_this);
        if (result === true) {
          if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
            self2.ismaster = _this.lastIsMaster();
          }
          if (self2.s.logger.isDebug()) {
            self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
          }
          for (let i2 = 0; i2 < handlers.length; i2++) {
            _this.removeAllListeners(handlers[i2]);
          }
          _this.on("error", handleEvent(self2, "error"));
          _this.on("close", handleEvent(self2, "close"));
          _this.on("timeout", handleEvent(self2, "timeout"));
          _this.on("parseError", handleEvent(self2, "parseError"));
          if (shouldTriggerConnect(self2)) {
            stateTransition(self2, CONNECTED);
            self2.initialConnectState.connect = true;
            process.nextTick(function() {
              self2.emit("connect", self2);
            });
            topologyMonitor(self2, {});
          }
        } else if (result instanceof MongoError) {
          _this.destroy({force: true});
          self2.destroy({force: true});
          return self2.emit("error", result);
        } else {
          _this.destroy({force: true});
        }
      } else {
        self2.emit("failed", this);
        addServerToList(self2.s.connectingServers, this);
        self2.s.replicaSetState.remove(this);
      }
      if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
        self2.initialConnectState.fullsetup = true;
        self2.initialConnectState.all = true;
        process.nextTick(function() {
          self2.emit("fullsetup", self2);
          self2.emit("all", self2);
        });
      }
      for (var i = 0; i < self2.s.connectingServers.length; i++) {
        if (self2.s.connectingServers[i].equals(this)) {
          self2.s.connectingServers.splice(i, 1);
        }
      }
      if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
        topologyMonitor(self2, {haInterval: 1});
      }
    };
  }
  function connectServers(self2, servers) {
    self2.s.connectingServers = self2.s.connectingServers.concat(servers);
    var timeoutInterval = 0;
    function connect(server, timeoutInterval2) {
      setTimeout(function() {
        if (self2.s.replicaSetState.update(server)) {
          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
            self2.ismaster = server.lastIsMaster();
          }
        }
        server.once("close", handleInitialConnectEvent(self2, "close"));
        server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
        server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
        server.once("error", handleInitialConnectEvent(self2, "error"));
        server.once("connect", handleInitialConnectEvent(self2, "connect"));
        server.on("serverOpening", (e) => self2.emit("serverOpening", e));
        server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
        server.on("serverClosed", (e) => self2.emit("serverClosed", e));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        server.connect(self2.s.connectOptions);
      }, timeoutInterval2);
    }
    while (servers.length > 0) {
      connect(servers.shift(), timeoutInterval++);
    }
  }
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  ReplSet.prototype.connect = function(options) {
    var self2 = this;
    this.s.connectOptions = options || {};
    stateTransition(this, CONNECTING);
    var servers = this.s.seedlist.map(function(x) {
      return new Server(Object.assign({}, self2.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self2
      }));
    });
    if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
      return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
    }
    emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
    connectServers(self2, servers);
  };
  ReplSet.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  ReplSet.prototype.destroy = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    let destroyCount = this.s.connectingServers.length + 1;
    const serverDestroyed = () => {
      destroyCount--;
      if (destroyCount > 0) {
        return;
      }
      emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (this.state === DESTROYED) {
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    stateTransition(this, DESTROYED);
    if (this.haTimeoutId)
      clearTimeout(this.haTimeoutId);
    for (var i = 0; i < this.intervalIds.length; i++) {
      this.intervalIds[i].stop();
    }
    this.intervalIds = [];
    if (destroyCount === 0) {
      serverDestroyed();
      return;
    }
    this.s.replicaSetState.destroy(options, serverDestroyed);
    this.s.connectingServers.forEach(function(x) {
      x.destroy(options, serverDestroyed);
    });
  };
  ReplSet.prototype.unref = function() {
    stateTransition(this, UNREFERENCED);
    this.s.replicaSetState.allServers().forEach(function(x) {
      x.unref();
    });
    clearTimeout(this.haTimeoutId);
  };
  ReplSet.prototype.lastIsMaster = function() {
    if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
      return this.s.replicaSetState.secondaries[0].lastIsMaster();
    }
    return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
  };
  ReplSet.prototype.connections = function() {
    var servers = this.s.replicaSetState.allServers();
    var connections = [];
    for (var i = 0; i < servers.length; i++) {
      connections = connections.concat(servers[i].connections());
    }
    return connections;
  };
  ReplSet.prototype.isConnected = function(options) {
    options = options || {};
    if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
      return this.s.replicaSetState.hasSecondary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
      return this.s.replicaSetState.hasPrimary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
      return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
      return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
    }
    if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
      return true;
    }
    return this.s.replicaSetState.hasPrimary();
  };
  ReplSet.prototype.isDestroyed = function() {
    return this.state === DESTROYED;
  };
  var SERVER_SELECTION_TIMEOUT_MS = 1e4;
  var SERVER_SELECTION_INTERVAL_MS = 1e3;
  ReplSet.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector;
    options = options || {};
    let readPreference;
    if (selector instanceof ReadPreference) {
      readPreference = selector;
    } else {
      readPreference = options.readPreference || ReadPreference.primary;
    }
    let lastError;
    const start = now();
    const _selectServer = () => {
      if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
        if (lastError != null) {
          callback(lastError, null);
        } else {
          callback(new MongoError("Server selection timed out"));
        }
        return;
      }
      const server = this.s.replicaSetState.pickServer(readPreference);
      if (server == null) {
        setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
        return;
      }
      if (!(server instanceof Server)) {
        lastError = server;
        setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", options.readPreference, server);
      callback(null, server);
    };
    _selectServer();
  };
  ReplSet.prototype.getServers = function() {
    return this.s.replicaSetState.allServers();
  };
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const self2 = args.self;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    if (self2.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
    if (!self2.s.replicaSetState.hasPrimary()) {
      if (self2.s.disconnectHandler) {
        return self2.s.disconnectHandler.add(op, ns, ops, options, callback);
      } else if (!willRetryWrite) {
        return callback(new MongoError("no primary server found"));
      }
    }
    const handler = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        err = getMMAPError(err);
        return callback(err);
      }
      if (willRetryWrite) {
        const newArgs = Object.assign({}, args, {retrying: true});
        return executeWriteOperation(newArgs, options, callback);
      }
      if (self2.s.replicaSetState.primary) {
        self2.s.replicaSetState.primary.destroy();
        self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, {force: true});
      }
      return callback(err);
    };
    if (callback.operationId) {
      handler.operationId = callback.operationId;
    }
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    self2.s.replicaSetState.primary[op](ns, ops, options, handler);
  }
  ReplSet.prototype.insert = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "insert", ns, ops}, options, callback);
  };
  ReplSet.prototype.update = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "update", ns, ops}, options, callback);
  };
  ReplSet.prototype.remove = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "remove", ns, ops}, options, callback);
  };
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  ReplSet.prototype.command = function(ns, cmd, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED)
      return callback(new MongoError(f("topology was destroyed")));
    var self2 = this;
    var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
    if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    }
    var server = this.s.replicaSetState.pickServer(readPreference);
    if (!(server instanceof Server))
      return callback(server);
    if (self2.s.debug)
      self2.emit("pickedServer", ReadPreference.primary, server);
    if (server == null) {
      return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
    }
    const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
    const cb = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        return callback(err);
      }
      if (willRetryWrite) {
        const newOptions = Object.assign({}, options, {retrying: true});
        return this.command(ns, cmd, newOptions, callback);
      }
      if (this.s.replicaSetState.primary) {
        this.s.replicaSetState.primary.destroy();
        this.s.replicaSetState.remove(this.s.replicaSetState.primary, {force: true});
      }
      return callback(err);
    };
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    server.command(ns, cmd, options, cb);
  };
  ReplSet.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  module2.exports = ReplSet;
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter = require("events").EventEmitter;
  var CoreCursor = require_cursor().CoreCursor;
  var Logger = require_logger();
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var Server = require_server();
  var diff = require_shared2().diff;
  var cloneOptions = require_shared2().cloneOptions;
  var SessionMixins = require_shared2().SessionMixins;
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = retrieveBSON();
  var getMMAPError = require_shared2().getMMAPError;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var UNREFERENCED = "unreferenced";
  var DESTROYING = "destroying";
  var DESTROYED = "destroyed";
  function stateTransition(self2, newState) {
    var legalTransitions = {
      disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
      connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
      connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
      unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
      destroyed: [DESTROYED]
    };
    var legalStates = legalTransitions[self2.state];
    if (legalStates && legalStates.indexOf(newState) !== -1) {
      self2.state = newState;
    } else {
      self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
    }
  }
  var id = 1;
  var handlers = ["connect", "close", "error", "timeout", "parseError"];
  var Mongos = function(seedlist, options) {
    options = options || {};
    this.id = id++;
    if (Array.isArray(seedlist)) {
      seedlist = seedlist.reduce((seeds, seed) => {
        if (seeds.find((s) => s.host === seed.host && s.port === seed.port)) {
          return seeds;
        }
        seeds.push(seed);
        return seeds;
      }, []);
    }
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      Cursor: options.cursorFactory || CoreCursor,
      logger: Logger("Mongos", options),
      seedlist,
      haInterval: options.haInterval ? options.haInterval : 1e4,
      disconnectHandler: options.disconnectHandler,
      index: 0,
      connectOptions: {},
      debug: typeof options.debug === "boolean" ? options.debug : false,
      localThresholdMS: options.localThresholdMS || 15
    };
    if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
      this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
    }
    this.state = DISCONNECTED;
    this.connectingProxies = [];
    this.connectedProxies = [];
    this.disconnectedProxies = [];
    this.index = 0;
    this.haTimeoutId = null;
    this.ismaster = null;
    this.topologyDescription = {
      topologyType: "Unknown",
      servers: []
    };
    this.clusterTime = null;
    EventEmitter.call(this);
  };
  inherits(Mongos, EventEmitter);
  Object.assign(Mongos.prototype, SessionMixins);
  Object.defineProperty(Mongos.prototype, "type", {
    enumerable: true,
    get: function() {
      return "mongos";
    }
  });
  Object.defineProperty(Mongos.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      if (!this.ismaster)
        return null;
      return this.ismaster.logicalSessionTimeoutMinutes || null;
    }
  });
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
  function destroyServer(server, options, callback) {
    options = options || {};
    SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
    server.destroy(options, callback);
  }
  Mongos.prototype.connect = function(options) {
    var self2 = this;
    this.s.connectOptions = options || {};
    stateTransition(this, CONNECTING);
    var servers = this.s.seedlist.map(function(x) {
      const server = new Server(Object.assign({}, self2.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self2
      }));
      relayEvents(server, self2, ["serverDescriptionChanged"]);
      return server;
    });
    emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
    connectProxies(self2, servers);
  };
  Mongos.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  function handleEvent(self2) {
    return function() {
      if (self2.state === DESTROYED || self2.state === DESTROYING) {
        return;
      }
      moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
      emitTopologyDescriptionChanged(self2);
      self2.emit("left", "mongos", this);
      self2.emit("serverClosed", {
        topologyId: self2.id,
        address: this.name
      });
    };
  }
  function handleInitialConnectEvent(self2, event) {
    return function() {
      var _this = this;
      if (self2.state === DESTROYED) {
        emitTopologyDescriptionChanged(self2);
        moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
        return this.destroy();
      }
      if (event === "connect") {
        self2.ismaster = _this.lastIsMaster();
        if (self2.ismaster.msg === "isdbgrid") {
          for (let i = 0; i < self2.connectedProxies.length; i++) {
            if (self2.connectedProxies[i].name === _this.name) {
              moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
              emitTopologyDescriptionChanged(self2);
              _this.destroy();
              return self2.emit("failed", _this);
            }
          }
          for (let i = 0; i < handlers.length; i++) {
            _this.removeAllListeners(handlers[i]);
          }
          _this.on("error", handleEvent(self2, "error"));
          _this.on("close", handleEvent(self2, "close"));
          _this.on("timeout", handleEvent(self2, "timeout"));
          _this.on("parseError", handleEvent(self2, "parseError"));
          moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
          self2.emit("joined", "mongos", _this);
        } else {
          if (self2.s.logger.isWarn()) {
            var message = "expected mongos proxy, but found replicaset member mongod for server %s";
            if (!self2.ismaster.hosts) {
              message = "expected mongos proxy, but found standalone mongod for server %s";
            }
            self2.s.logger.warn(f(message, _this.name));
          }
          _this.destroy(true);
          removeProxyFrom(self2.connectingProxies, _this);
          self2.emit("left", "server", _this);
          self2.emit("failed", _this);
        }
      } else {
        moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
        self2.emit("left", "mongos", this);
        self2.emit("failed", this);
      }
      emitTopologyDescriptionChanged(self2);
      if (self2.connectingProxies.length === 0) {
        if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
          stateTransition(self2, CONNECTED);
          self2.emit("connect", self2);
          self2.emit("fullsetup", self2);
          self2.emit("all", self2);
        } else if (self2.disconnectedProxies.length === 0) {
          if (self2.s.logger.isWarn()) {
            self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
          }
          return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
        }
        topologyMonitor(self2, {firstConnect: true});
      }
    };
  }
  function connectProxies(self2, servers) {
    self2.connectingProxies = self2.connectingProxies.concat(servers);
    var timeoutInterval = 0;
    function connect(server, timeoutInterval2) {
      setTimeout(function() {
        self2.emit("serverOpening", {
          topologyId: self2.id,
          address: server.name
        });
        emitTopologyDescriptionChanged(self2);
        server.once("close", handleInitialConnectEvent(self2, "close"));
        server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
        server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
        server.once("error", handleInitialConnectEvent(self2, "error"));
        server.once("connect", handleInitialConnectEvent(self2, "connect"));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        server.connect(self2.s.connectOptions);
      }, timeoutInterval2);
    }
    servers.forEach((server) => connect(server, timeoutInterval++));
  }
  function pickProxy(self2, session) {
    const transaction = session && session.transaction;
    if (transaction && transaction.server) {
      if (transaction.server.isConnected()) {
        return transaction.server;
      } else {
        transaction.unpinServer();
      }
    }
    var connectedProxies = self2.connectedProxies.slice(0);
    var lowerBoundLatency = Number.MAX_VALUE;
    for (var i = 0; i < connectedProxies.length; i++) {
      if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
        lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
      }
    }
    connectedProxies = connectedProxies.filter(function(server) {
      if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
        return true;
      }
    });
    let proxy;
    if (connectedProxies.length === 0) {
      proxy = self2.connectedProxies[0];
    } else {
      proxy = connectedProxies[self2.index % connectedProxies.length];
      self2.index = (self2.index + 1) % connectedProxies.length;
    }
    if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
      transaction.pinServer(proxy);
    }
    return proxy;
  }
  function moveServerFrom(from, to, proxy) {
    for (var i = 0; i < from.length; i++) {
      if (from[i].name === proxy.name) {
        from.splice(i, 1);
      }
    }
    for (i = 0; i < to.length; i++) {
      if (to[i].name === proxy.name) {
        to.splice(i, 1);
      }
    }
    to.push(proxy);
  }
  function removeProxyFrom(from, proxy) {
    for (var i = 0; i < from.length; i++) {
      if (from[i].name === proxy.name) {
        from.splice(i, 1);
      }
    }
  }
  function reconnectProxies(self2, proxies, callback) {
    var count = proxies.length;
    var _handleEvent = function(self3, event) {
      return function() {
        var _self = this;
        count = count - 1;
        if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
          moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
          return this.destroy();
        }
        if (event === "connect") {
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return _self.destroy();
          }
          for (var i2 = 0; i2 < handlers.length; i2++) {
            _self.removeAllListeners(handlers[i2]);
          }
          _self.on("error", handleEvent(self3, "error"));
          _self.on("close", handleEvent(self3, "close"));
          _self.on("timeout", handleEvent(self3, "timeout"));
          _self.on("parseError", handleEvent(self3, "parseError"));
          moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
          emitTopologyDescriptionChanged(self3);
          self3.emit("joined", "mongos", _self);
        } else {
          moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
          this.destroy();
        }
        if (count === 0) {
          callback();
        }
      };
    };
    if (count === 0) {
      return callback();
    }
    function execute(_server, i2) {
      setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        var server = new Server(Object.assign({}, self2.s.options, {
          host: _server.name.split(":")[0],
          port: parseInt(_server.name.split(":")[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        destroyServer(_server, {force: true});
        removeProxyFrom(self2.disconnectedProxies, _server);
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        self2.emit("serverOpening", {
          topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
          address: server.name
        });
        server.once("connect", _handleEvent(self2, "connect"));
        server.once("close", _handleEvent(self2, "close"));
        server.once("timeout", _handleEvent(self2, "timeout"));
        server.once("error", _handleEvent(self2, "error"));
        server.once("parseError", _handleEvent(self2, "parseError"));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        self2.connectingProxies.push(server);
        server.connect(self2.s.connectOptions);
      }, i2);
    }
    for (var i = 0; i < proxies.length; i++) {
      execute(proxies[i], i);
    }
  }
  function topologyMonitor(self2, options) {
    options = options || {};
    if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
      return;
    }
    self2.haTimeoutId = setTimeout(function() {
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      if (self2.isConnected() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      }
      var proxies = self2.connectedProxies.slice(0);
      var count = proxies.length;
      function pingServer(_self, _server, cb) {
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: _server.name});
        _server.command("admin.$cmd", {
          ismaster: true
        }, {
          monitoring: true,
          socketTimeout: self2.s.options.connectionTimeout || 2e3
        }, function(err, r) {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            _server.destroy();
            return cb(err, r);
          }
          var latencyMS = new Date().getTime() - start;
          if (err) {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: _server.name
            });
            moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
          } else {
            _server.ismaster = r.result;
            _server.lastIsMasterMS = latencyMS;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: _server.name
            });
          }
          cb(err, r);
        });
      }
      if (proxies.length === 0) {
        if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
          self2.emit("error", new MongoError("no mongos proxy available"));
        } else {
          self2.emit("close", self2);
        }
        return reconnectProxies(self2, self2.disconnectedProxies, function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          if (self2.state === CONNECTING && options.firstConnect) {
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.isConnected()) {
            self2.emit("reconnect", self2);
          } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
            self2.emit("close", self2);
          }
          topologyMonitor(self2);
        });
      }
      for (var i = 0; i < proxies.length; i++) {
        pingServer(self2, proxies[i], function() {
          count = count - 1;
          if (count === 0) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            reconnectProxies(self2, self2.disconnectedProxies, function() {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              topologyMonitor(self2);
            });
          }
        });
      }
    }, self2.s.haInterval);
  }
  Mongos.prototype.lastIsMaster = function() {
    return this.ismaster;
  };
  Mongos.prototype.unref = function() {
    stateTransition(this, UNREFERENCED);
    var proxies = this.connectedProxies.concat(this.connectingProxies);
    proxies.forEach(function(x) {
      x.unref();
    });
    clearTimeout(this.haTimeoutId);
  };
  Mongos.prototype.destroy = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    stateTransition(this, DESTROYING);
    if (this.haTimeoutId) {
      clearTimeout(this.haTimeoutId);
    }
    const proxies = this.connectedProxies.concat(this.connectingProxies);
    let serverCount = proxies.length;
    const serverDestroyed = () => {
      serverCount--;
      if (serverCount > 0) {
        return;
      }
      emitTopologyDescriptionChanged(this);
      emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
      stateTransition(this, DESTROYED);
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (serverCount === 0) {
      serverDestroyed();
      return;
    }
    proxies.forEach((server) => {
      this.emit("serverClosed", {
        topologyId: this.id,
        address: server.name
      });
      destroyServer(server, options, serverDestroyed);
      moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
    });
  };
  Mongos.prototype.isConnected = function() {
    return this.connectedProxies.length > 0;
  };
  Mongos.prototype.isDestroyed = function() {
    return this.state === DESTROYED;
  };
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const self2 = args.self;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    let server = pickProxy(self2, options.session);
    if (!server)
      return callback(new MongoError("no mongos proxy available"));
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
    const handler = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
        err = getMMAPError(err);
        return callback(err);
      }
      server = pickProxy(self2, options.session);
      if (!server) {
        return callback(err);
      }
      const newArgs = Object.assign({}, args, {retrying: true});
      return executeWriteOperation(newArgs, options, callback);
    };
    if (callback.operationId) {
      handler.operationId = callback.operationId;
    }
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    server[op](ns, ops, options, handler);
  }
  Mongos.prototype.insert = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("insert", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "insert", ns, ops}, options, callback);
  };
  Mongos.prototype.update = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("update", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "update", ns, ops}, options, callback);
  };
  Mongos.prototype.remove = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("remove", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "remove", ns, ops}, options, callback);
  };
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  Mongos.prototype.command = function(ns, cmd, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    var self2 = this;
    var server = pickProxy(self2, options.session);
    if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    }
    if (server == null) {
      return callback(new MongoError("no mongos proxy available"));
    }
    var clonedOptions = cloneOptions(options);
    clonedOptions.topology = self2;
    const willRetryWrite = !options.retrying && options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
    const cb = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        return callback(err);
      }
      if (willRetryWrite) {
        const newOptions = Object.assign({}, clonedOptions, {retrying: true});
        return this.command(ns, cmd, newOptions, callback);
      }
      return callback(err);
    };
    if (willRetryWrite) {
      clonedOptions.session.incrementTransactionNumber();
      clonedOptions.willRetryWrite = willRetryWrite;
    }
    server.command(ns, cmd, clonedOptions, cb);
  };
  Mongos.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  Mongos.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector, selector = void 0;
    options = options || {};
    const server = pickProxy(this, options.session);
    if (server == null) {
      callback(new MongoError("server selection failed"));
      return;
    }
    if (this.s.debug)
      this.emit("pickedServer", null, server);
    callback(null, server);
  };
  Mongos.prototype.connections = function() {
    var connections = [];
    for (var i = 0; i < this.connectedProxies.length; i++) {
      connections = connections.concat(this.connectedProxies[i].connections());
    }
    return connections;
  };
  function emitTopologyDescriptionChanged(self2) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      var topology = "Unknown";
      if (self2.connectedProxies.length > 0) {
        topology = "Sharded";
      }
      var description = {
        topologyType: topology,
        servers: []
      };
      var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
      description.servers = description.servers.concat(proxies.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "Unknown";
        return description2;
      }));
      description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "Mongos";
        return description2;
      }));
      var diffResult = diff(self2.topologyDescription, description);
      var result = {
        topologyId: self2.id,
        previousDescription: self2.topologyDescription,
        newDescription: description,
        diff: diffResult
      };
      if (diffResult.servers.length > 0) {
        self2.emit("topologyDescriptionChanged", result);
      }
      self2.topologyDescription = description;
    }
  }
  module2.exports = Mongos;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports2, module2) => {
  "use strict";
  function Denque(array, options) {
    var options = options || {};
    this._head = 0;
    this._tail = 0;
    this._capacity = options.capacity;
    this._capacityMask = 3;
    this._list = new Array(4);
    if (Array.isArray(array)) {
      this._fromArray(array);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return void 0;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return void 0;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (item === void 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return void 0;
    var item = this._list[head];
    this._list[head] = void 0;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (item === void 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return void 0;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = void 0;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return void 0;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index; k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index; k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return void 0;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0; k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index; k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index); k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return void 0;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0; k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i; k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0; k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0; k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    for (var i = 0; i < array.length; i++)
      this.push(array[i]);
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy) {
    var newArray = [];
    var list = this._list;
    var len = list.length;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head; i < len; i++)
        newArray.push(list[i]);
      for (i = 0; i < this._tail; i++)
        newArray.push(list[i]);
    } else {
      for (i = this._head; i < this._tail; i++)
        newArray.push(list[i]);
    }
    return newArray;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head) {
      this._list = this._copyArray(true);
      this._head = 0;
    }
    this._tail = this._list.length;
    this._list.length *= 2;
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  module2.exports = Denque;
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS((exports2, module2) => {
  "use strict";
  var ServerDescriptionChangedEvent = class {
    constructor(topologyId, address, previousDescription, newDescription) {
      Object.assign(this, {topologyId, address, previousDescription, newDescription});
    }
  };
  var ServerOpeningEvent = class {
    constructor(topologyId, address) {
      Object.assign(this, {topologyId, address});
    }
  };
  var ServerClosedEvent = class {
    constructor(topologyId, address) {
      Object.assign(this, {topologyId, address});
    }
  };
  var TopologyDescriptionChangedEvent = class {
    constructor(topologyId, previousDescription, newDescription) {
      Object.assign(this, {topologyId, previousDescription, newDescription});
    }
  };
  var TopologyOpeningEvent = class {
    constructor(topologyId) {
      Object.assign(this, {topologyId});
    }
  };
  var TopologyClosedEvent = class {
    constructor(topologyId) {
      Object.assign(this, {topologyId});
    }
  };
  var ServerHeartbeatStartedEvent = class {
    constructor(connectionId) {
      Object.assign(this, {connectionId});
    }
  };
  var ServerHeartbeatSucceededEvent = class {
    constructor(duration, reply, connectionId) {
      Object.assign(this, {connectionId, duration, reply});
    }
  };
  var ServerHeartbeatFailedEvent = class {
    constructor(duration, failure, connectionId) {
      Object.assign(this, {connectionId, duration, failure});
    }
  };
  module2.exports = {
    ServerDescriptionChangedEvent,
    ServerOpeningEvent,
    ServerClosedEvent,
    TopologyDescriptionChangedEvent,
    TopologyOpeningEvent,
    TopologyClosedEvent,
    ServerHeartbeatStartedEvent,
    ServerHeartbeatSucceededEvent,
    ServerHeartbeatFailedEvent
  };
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util = require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module2.exports = util.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module2.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node2()
  };
  var Stream = require_stream2();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream2();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = require("util");
  var debug6 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug6 = debugUtil.debuglog("stream");
  } else {
    debug6 = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug6("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug6("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug6("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug6("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug6("reading or ended", doRead);
    } else if (doRead) {
      debug6("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug6("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug6("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug6("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug6("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug6("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug6("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug6("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug6("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug6("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug6("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug6("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug6("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug6("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug6("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug6("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug6("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug6("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug6("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug6("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug6("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug6("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug6("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug6("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var Duplex = require_stream_duplex();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS((exports2, module2) => {
  "use strict";
  var DuplexStream = require_readable().Duplex;
  var util = require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  function BufferList(callback) {
    if (!(this instanceof BufferList))
      return new BufferList(callback);
    this._bufs = [];
    this.length = 0;
    if (typeof callback == "function") {
      this._callback = callback;
      var piper = function piper2(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
    } else {
      this.append(callback);
    }
    DuplexStream.call(this);
  }
  util.inherits(BufferList, DuplexStream);
  BufferList.prototype._offset = function _offset(offset) {
    var tot = 0, i = 0, _t;
    if (offset === 0)
      return [0, 0];
    for (; i < this._bufs.length; i++) {
      _t = tot + this._bufs[i].length;
      if (offset < _t || i == this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    var bufferId = blOffset[0];
    var offset = blOffset[1];
    for (var i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.append = function append(buf) {
    var i = 0;
    if (Buffer2.isBuffer(buf)) {
      this._appendBuffer(buf);
    } else if (Array.isArray(buf)) {
      for (; i < buf.length; i++)
        this.append(buf[i]);
    } else if (buf instanceof BufferList) {
      for (; i < buf._bufs.length; i++)
        this.append(buf._bufs[i]);
    } else if (buf != null) {
      if (typeof buf == "number")
        buf = buf.toString();
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback == "function")
      callback();
  };
  BufferList.prototype._read = function _read(size) {
    if (!this.length)
      return this.push(null);
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferList.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return void 0;
    }
    var offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start == "number" && start < 0)
      start += this.length;
    if (typeof end == "number" && end < 0)
      end += this.length;
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart != "number" || srcStart < 0)
      srcStart = 0;
    if (typeof srcEnd != "number" || srcEnd > this.length)
      srcEnd = this.length;
    if (srcStart >= this.length)
      return dst || Buffer2.alloc(0);
    if (srcEnd <= 0)
      return dst || Buffer2.alloc(0);
    var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
    if (srcStart === 0 && srcEnd == this.length) {
      if (!copy2) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy2)
      dst = Buffer2.allocUnsafe(len);
    for (i = off[0]; i < this._bufs.length; i++) {
      l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start)
        start = 0;
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0)
      start += this.length;
    if (end < 0)
      end += this.length;
    if (start === end) {
      return new BufferList();
    }
    var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] == 0)
      buffers.pop();
    else
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    if (startOffset[1] != 0)
      buffers[0] = buffers[0].slice(startOffset[1]);
    return new BufferList(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    var i = 0, copy = new BufferList();
    for (; i < this._bufs.length; i++)
      copy.append(this._bufs[i]);
    return copy;
  };
  BufferList.prototype.destroy = function destroy() {
    this._bufs.length = 0;
    this.length = 0;
    this.push(null);
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (search instanceof BufferList) {
      search = search.slice();
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    var blOffset = this._offset(offset);
    var blIndex = blOffset[0];
    var buffOffset = blOffset[1];
    for (blIndex; blIndex < this._bufs.length; blIndex++) {
      var buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        var availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          var nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          var revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    var methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (var m in methods) {
      (function(m2) {
        if (methods[m2] === null) {
          BufferList.prototype[m2] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m2](0, byteLength);
          };
        } else {
          BufferList.prototype[m2] = function(offset) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        }
      })(m);
    }
  })();
  module2.exports = BufferList;
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Duplex = require("stream").Duplex;
  var BufferList = require_bl();
  var MongoParseError = require_error().MongoParseError;
  var decompress = require_compression().decompress;
  var Response = require_commands().Response;
  var BinMsg = require_msg().BinMsg;
  var MongoError = require_error().MongoError;
  var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
  var OP_MSG = require_shared().opcodes.OP_MSG;
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
  var opcodes = require_shared().opcodes;
  var compress = require_compression().compress;
  var compressorIDs = require_compression().compressorIDs;
  var uncompressibleCommands = require_compression().uncompressibleCommands;
  var Msg = require_msg().Msg;
  var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
  var kBuffer = Symbol("buffer");
  var MessageStream = class extends Duplex {
    constructor(options) {
      options = options || {};
      super(options);
      this.bson = options.bson;
      this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
      this[kBuffer] = new BufferList();
    }
    _write(chunk, _, callback) {
      const buffer = this[kBuffer];
      buffer.append(chunk);
      processIncomingData(this, callback);
    }
    _read() {
      return;
    }
    writeCommand(command, operationDescription) {
      const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        const data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      }
      const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress({options: operationDescription}, messageToBeCompressed, (err, compressedMessage) => {
        if (err) {
          operationDescription.cb(err, null);
          return;
        }
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      });
    }
  };
  function canCompress(command) {
    const commandDoc = command instanceof Msg ? command.command : command.query;
    const commandName = Object.keys(commandDoc)[0];
    return !uncompressibleCommands.has(commandName);
  }
  function processIncomingData(stream, callback) {
    const buffer = stream[kBuffer];
    if (buffer.length < 4) {
      callback();
      return;
    }
    const sizeOfMessage = buffer.readInt32LE(0);
    if (sizeOfMessage < 0) {
      callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
      return;
    }
    if (sizeOfMessage > stream.maxBsonMessageSize) {
      callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
      return;
    }
    if (sizeOfMessage > buffer.length) {
      callback();
      return;
    }
    const message = buffer.slice(0, sizeOfMessage);
    buffer.consume(sizeOfMessage);
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
    const responseOptions = stream.responseOptions;
    if (messageHeader.opCode !== OP_COMPRESSED) {
      const messageBody = message.slice(MESSAGE_HEADER_SIZE);
      stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
      return;
    }
    messageHeader.fromCompressed = true;
    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
    decompress(compressorID, compressedBuffer, (err, messageBody) => {
      if (err) {
        callback(err);
        return;
      }
      if (messageBody.length !== messageHeader.length) {
        callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
        return;
      }
      stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
    });
  }
  module2.exports = MessageStream;
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports2, module2) => {
  "use strict";
  var parseServerType = require_server_description().parseServerType;
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "__nodejs_mock_server__"
  ];
  var StreamDescription = class {
    constructor(address, options) {
      this.address = address;
      this.type = parseServerType(null);
      this.minWireVersion = void 0;
      this.maxWireVersion = void 0;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48e6;
      this.maxWriteBatchSize = 1e5;
      this.compressors = options && options.compression && Array.isArray(options.compression.compressors) ? options.compression.compressors : [];
    }
    receiveResponse(response) {
      this.type = parseServerType(response);
      RESPONSE_FIELDS.forEach((field) => {
        if (typeof response[field] !== "undefined") {
          this[field] = response[field];
        }
      });
      if (response.compression) {
        this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
      }
    }
  };
  module2.exports = {
    StreamDescription
  };
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var MessageStream = require_message_stream();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var CommandResult = require_command_result();
  var StreamDescription = require_stream_description().StreamDescription;
  var wp = require_wireprotocol();
  var apm = require_apm();
  var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
  var uuidV4 = require_utils2().uuidV4;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var kStream = Symbol("stream");
  var kQueue = Symbol("queue");
  var kMessageStream = Symbol("messageStream");
  var kGeneration = Symbol("generation");
  var kLastUseTime = Symbol("lastUseTime");
  var kClusterTime = Symbol("clusterTime");
  var kDescription = Symbol("description");
  var kIsMaster = Symbol("ismaster");
  var kAutoEncrypter = Symbol("autoEncrypter");
  var Connection = class extends EventEmitter {
    constructor(stream, options) {
      super(options);
      this.id = options.id;
      this.address = streamIdentifier(stream);
      this.bson = options.bson;
      this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      this.host = options.host || "localhost";
      this.port = options.port || 27017;
      this.monitorCommands = typeof options.monitorCommands === "boolean" ? options.monitorCommands : false;
      this.closed = false;
      this.destroyed = false;
      this[kDescription] = new StreamDescription(this.address, options);
      this[kGeneration] = options.generation;
      this[kLastUseTime] = now();
      if (options.autoEncrypter) {
        this[kAutoEncrypter] = options.autoEncrypter;
      }
      this[kQueue] = new Map();
      this[kMessageStream] = new MessageStream(options);
      this[kMessageStream].on("message", messageHandler(this));
      this[kStream] = stream;
      stream.on("error", () => {
      });
      stream.on("close", () => {
        if (this.closed) {
          return;
        }
        this.closed = true;
        this[kQueue].forEach((op) => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`)));
        this[kQueue].clear();
        this.emit("close");
      });
      stream.on("timeout", () => {
        if (this.closed) {
          return;
        }
        stream.destroy();
        this.closed = true;
        this[kQueue].forEach((op) => op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
          beforeHandshake: this[kIsMaster] == null
        })));
        this[kQueue].clear();
        this.emit("close");
      });
      stream.pipe(this[kMessageStream]);
      this[kMessageStream].pipe(stream);
    }
    get description() {
      return this[kDescription];
    }
    get ismaster() {
      return this[kIsMaster];
    }
    set ismaster(response) {
      this[kDescription].receiveResponse(response);
      this[kIsMaster] = response;
    }
    get generation() {
      return this[kGeneration] || 0;
    }
    get idleTime() {
      return calculateDurationInMs(this[kLastUseTime]);
    }
    get clusterTime() {
      return this[kClusterTime];
    }
    get stream() {
      return this[kStream];
    }
    markAvailable() {
      this[kLastUseTime] = now();
    }
    destroy(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = Object.assign({force: false}, options);
      if (this[kStream] == null || this.destroyed) {
        this.destroyed = true;
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      if (options.force) {
        this[kStream].destroy();
        this.destroyed = true;
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      this[kStream].end((err) => {
        this.destroyed = true;
        if (typeof callback === "function") {
          callback(err);
        }
      });
    }
    command(ns, cmd, options, callback) {
      wp.command(makeServerTrampoline(this), ns, cmd, options, callback);
    }
    query(ns, cmd, cursorState, options, callback) {
      wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);
    }
    getMore(ns, cursorState, batchSize, options, callback) {
      wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);
    }
    killCursors(ns, cursorState, callback) {
      wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
    }
    insert(ns, ops, options, callback) {
      wp.insert(makeServerTrampoline(this), ns, ops, options, callback);
    }
    update(ns, ops, options, callback) {
      wp.update(makeServerTrampoline(this), ns, ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      wp.remove(makeServerTrampoline(this), ns, ops, options, callback);
    }
  };
  function makeServerTrampoline(connection) {
    const server = {
      description: connection.description,
      clusterTime: connection[kClusterTime],
      s: {
        bson: connection.bson,
        pool: {write: write.bind(connection), isConnected: () => true}
      }
    };
    if (connection[kAutoEncrypter]) {
      server.autoEncrypter = connection[kAutoEncrypter];
    }
    return server;
  }
  function messageHandler(conn) {
    return function messageHandler2(message) {
      conn.emit("message", message);
      if (!conn[kQueue].has(message.responseTo)) {
        return;
      }
      const operationDescription = conn[kQueue].get(message.responseTo);
      const callback = operationDescription.cb;
      conn[kQueue].delete(message.responseTo);
      if (message.moreToCome) {
        conn[kQueue].set(message.requestId, operationDescription);
      } else if (operationDescription.socketTimeoutOverride) {
        conn[kStream].setTimeout(conn.socketTimeout);
      }
      try {
        message.parse(operationDescription);
      } catch (err) {
        callback(new MongoError(err));
        return;
      }
      if (message.documents[0]) {
        const document2 = message.documents[0];
        const session = operationDescription.session;
        if (session) {
          updateSessionFromResponse(session, document2);
        }
        if (document2.$clusterTime) {
          conn[kClusterTime] = document2.$clusterTime;
          conn.emit("clusterTimeReceived", document2.$clusterTime);
        }
        if (operationDescription.command) {
          if (document2.writeConcernError) {
            callback(new MongoWriteConcernError(document2.writeConcernError, document2));
            return;
          }
          if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
            callback(new MongoError(document2));
            return;
          }
        }
      }
      callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
    };
  }
  function streamIdentifier(stream) {
    if (typeof stream.address === "function") {
      return `${stream.remoteAddress}:${stream.remotePort}`;
    }
    return uuidV4().toString("hex");
  }
  function write(command, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    options = options || {};
    const operationDescription = {
      requestId: command.requestId,
      cb: callback,
      session: options.session,
      fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false,
      noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
      documentsReturnedIn: options.documentsReturnedIn,
      command: !!options.command,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      raw: typeof options.raw === "boolean" ? options.raw : false
    };
    if (this[kDescription] && this[kDescription].compressor) {
      operationDescription.agreedCompressor = this[kDescription].compressor;
      if (this[kDescription].zlibCompressionLevel) {
        operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
      }
    }
    if (typeof options.socketTimeout === "number") {
      operationDescription.socketTimeoutOverride = true;
      this[kStream].setTimeout(options.socketTimeout);
    }
    if (this.monitorCommands) {
      this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
      operationDescription.started = now();
      operationDescription.cb = (err, reply) => {
        if (err) {
          this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
        } else {
          if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
          } else {
            this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
          }
        }
        if (typeof callback === "function") {
          callback(err, reply);
        }
      };
    }
    if (!operationDescription.noResponse) {
      this[kQueue].set(operationDescription.requestId, operationDescription);
    }
    try {
      this[kMessageStream].writeCommand(command, operationDescription);
    } catch (e) {
      if (!operationDescription.noResponse) {
        this[kQueue].delete(operationDescription.requestId);
        operationDescription.cb(e);
        return;
      }
    }
    if (operationDescription.noResponse) {
      operationDescription.cb();
    }
  }
  module2.exports = {
    Connection
  };
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors2 = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var PoolClosedError = class extends MongoError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.name = "MongoPoolClosedError";
      this.address = pool.address;
    }
  };
  var WaitQueueTimeoutError = class extends MongoError {
    constructor(pool) {
      super("Timed out while checking out a connection from connection pool");
      this.name = "MongoWaitQueueTimeoutError";
      this.address = pool.address;
    }
  };
  module2.exports = {
    PoolClosedError,
    WaitQueueTimeoutError
  };
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS((exports2, module2) => {
  "use strict";
  var ConnectionPoolMonitoringEvent = class {
    constructor(pool) {
      this.time = new Date();
      this.address = pool.address;
    }
  };
  var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.options = pool.options;
    }
  };
  var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason) {
      super(pool);
      this.connectionId = connection.id;
      this.reason = reason || "unknown";
    }
  };
  var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason) {
      super(pool);
      this.reason = reason;
    }
  };
  var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var CMAP_EVENT_NAMES = [
    "connectionPoolCreated",
    "connectionPoolClosed",
    "connectionCreated",
    "connectionReady",
    "connectionClosed",
    "connectionCheckOutStarted",
    "connectionCheckOutFailed",
    "connectionCheckedOut",
    "connectionCheckedIn",
    "connectionPoolCleared"
  ];
  module2.exports = {
    CMAP_EVENT_NAMES,
    ConnectionPoolCreatedEvent,
    ConnectionPoolClosedEvent,
    ConnectionCreatedEvent,
    ConnectionReadyEvent,
    ConnectionClosedEvent,
    ConnectionCheckOutStartedEvent,
    ConnectionCheckOutFailedEvent,
    ConnectionCheckedOutEvent,
    ConnectionCheckedInEvent,
    ConnectionPoolClearedEvent
  };
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter = require("events").EventEmitter;
  var Logger = require_logger();
  var makeCounter = require_utils4().makeCounter;
  var MongoError = require_error().MongoError;
  var Connection = require_connection2().Connection;
  var eachAsync = require_utils2().eachAsync;
  var connect = require_connect();
  var relayEvents = require_utils2().relayEvents;
  var errors = require_errors2();
  var PoolClosedError = errors.PoolClosedError;
  var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
  var events = require_events2();
  var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
  var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
  var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
  var ConnectionReadyEvent = events.ConnectionReadyEvent;
  var ConnectionClosedEvent = events.ConnectionClosedEvent;
  var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
  var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
  var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
  var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
  var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
  var kLogger = Symbol("logger");
  var kConnections = Symbol("connections");
  var kPermits = Symbol("permits");
  var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
  var kGeneration = Symbol("generation");
  var kConnectionCounter = Symbol("connectionCounter");
  var kCancellationToken = Symbol("cancellationToken");
  var kWaitQueue = Symbol("waitQueue");
  var kCancelled = Symbol("cancelled");
  var VALID_POOL_OPTIONS = new Set([
    "ssl",
    "bson",
    "connectionType",
    "monitorCommands",
    "socketTimeout",
    "credentials",
    "compression",
    "host",
    "port",
    "localAddress",
    "localPort",
    "family",
    "hints",
    "lookup",
    "path",
    "ca",
    "cert",
    "sigalgs",
    "ciphers",
    "clientCertEngine",
    "crl",
    "dhparam",
    "ecdhCurve",
    "honorCipherOrder",
    "key",
    "privateKeyEngine",
    "privateKeyIdentifier",
    "maxVersion",
    "minVersion",
    "passphrase",
    "pfx",
    "secureOptions",
    "secureProtocol",
    "sessionIdContext",
    "allowHalfOpen",
    "rejectUnauthorized",
    "pskCallback",
    "ALPNProtocols",
    "servername",
    "checkServerIdentity",
    "session",
    "minDHSize",
    "secureContext",
    "maxPoolSize",
    "minPoolSize",
    "maxIdleTimeMS",
    "waitQueueTimeoutMS"
  ]);
  function resolveOptions(options, defaults) {
    const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
      if (Object.prototype.hasOwnProperty.call(options, key)) {
        obj[key] = options[key];
      }
      return obj;
    }, {});
    return Object.freeze(Object.assign({}, defaults, newOptions));
  }
  var ConnectionPool = class extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      this.closed = false;
      this.options = resolveOptions(options, {
        connectionType: Connection,
        maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : 100,
        minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : 0,
        maxIdleTimeMS: typeof options.maxIdleTimeMS === "number" ? options.maxIdleTimeMS : 0,
        waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === "number" ? options.waitQueueTimeoutMS : 0,
        autoEncrypter: options.autoEncrypter,
        metadata: options.metadata
      });
      if (options.minSize > options.maxSize) {
        throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
      }
      this[kLogger] = Logger("ConnectionPool", options);
      this[kConnections] = new Denque();
      this[kPermits] = this.options.maxPoolSize;
      this[kMinPoolSizeTimer] = void 0;
      this[kGeneration] = 0;
      this[kConnectionCounter] = makeCounter(1);
      this[kCancellationToken] = new EventEmitter();
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kWaitQueue] = new Denque();
      process.nextTick(() => {
        this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
        ensureMinPoolSize(this);
      });
    }
    get address() {
      return `${this.options.host}:${this.options.port}`;
    }
    get generation() {
      return this[kGeneration];
    }
    get totalConnectionCount() {
      return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
    }
    get availableConnectionCount() {
      return this[kConnections].length;
    }
    get waitQueueSize() {
      return this[kWaitQueue].length;
    }
    checkOut(callback) {
      this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
      if (this.closed) {
        this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
        callback(new PoolClosedError(this));
        return;
      }
      const waitQueueMember = {callback};
      const pool = this;
      const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = setTimeout(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = void 0;
          pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
          waitQueueMember.callback(new WaitQueueTimeoutError(pool));
        }, waitQueueTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(() => processWaitQueue(this));
    }
    checkIn(connection) {
      const poolClosed = this.closed;
      const stale = connectionIsStale(this, connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].push(connection);
      }
      this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        destroyConnection(this, connection, reason);
      }
      process.nextTick(() => processWaitQueue(this));
    }
    clear() {
      this[kGeneration] += 1;
      this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
    }
    close(options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      options = Object.assign({force: false}, options);
      if (this.closed) {
        return callback();
      }
      this[kCancellationToken].emit("cancel");
      while (this.waitQueueSize) {
        const waitQueueMember = this[kWaitQueue].pop();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(new MongoError("connection pool closed"));
        }
      }
      if (this[kMinPoolSizeTimer]) {
        clearTimeout(this[kMinPoolSizeTimer]);
      }
      if (typeof this[kConnectionCounter].return === "function") {
        this[kConnectionCounter].return();
      }
      this.closed = true;
      eachAsync(this[kConnections].toArray(), (conn, cb) => {
        this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy(options, cb);
      }, (err) => {
        this[kConnections].clear();
        this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
        callback(err);
      });
    }
    withConnection(fn, callback) {
      this.checkOut((err, conn) => {
        fn(err, conn, (fnErr, result) => {
          if (typeof callback === "function") {
            if (fnErr) {
              callback(fnErr);
            } else {
              callback(void 0, result);
            }
          }
          if (conn) {
            this.checkIn(conn);
          }
        });
      });
    }
  };
  function ensureMinPoolSize(pool) {
    if (pool.closed || pool.options.minPoolSize === 0) {
      return;
    }
    const minPoolSize = pool.options.minPoolSize;
    for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
      createConnection(pool);
    }
    pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
  }
  function connectionIsStale(pool, connection) {
    return connection.generation !== pool[kGeneration];
  }
  function connectionIsIdle(pool, connection) {
    return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
  }
  function createConnection(pool, callback) {
    const connectOptions = Object.assign({
      id: pool[kConnectionCounter].next().value,
      generation: pool[kGeneration]
    }, pool.options);
    pool[kPermits]--;
    connect(connectOptions, pool[kCancellationToken], (err, connection) => {
      if (err) {
        pool[kPermits]++;
        pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (pool.closed) {
        connection.destroy({force: true});
        return;
      }
      relayEvents(connection, pool, [
        "commandStarted",
        "commandFailed",
        "commandSucceeded",
        "clusterTimeReceived"
      ]);
      pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
      connection.markAvailable();
      pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
      if (typeof callback === "function") {
        callback(void 0, connection);
        return;
      }
      pool[kConnections].push(connection);
      process.nextTick(() => processWaitQueue(pool));
    });
  }
  function destroyConnection(pool, connection, reason) {
    pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
    pool[kPermits]++;
    process.nextTick(() => connection.destroy());
  }
  function processWaitQueue(pool) {
    if (pool.closed) {
      return;
    }
    while (pool.waitQueueSize) {
      const waitQueueMember = pool[kWaitQueue].peekFront();
      if (waitQueueMember[kCancelled]) {
        pool[kWaitQueue].shift();
        continue;
      }
      if (!pool.availableConnectionCount) {
        break;
      }
      const connection = pool[kConnections].shift();
      const isStale = connectionIsStale(pool, connection);
      const isIdle = connectionIsIdle(pool, connection);
      if (!isStale && !isIdle && !connection.closed) {
        pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
        clearTimeout(waitQueueMember.timer);
        pool[kWaitQueue].shift();
        waitQueueMember.callback(void 0, connection);
        return;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      destroyConnection(pool, connection, reason);
    }
    const maxPoolSize = pool.options.maxPoolSize;
    if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
      createConnection(pool, (err, connection) => {
        const waitQueueMember = pool[kWaitQueue].shift();
        if (waitQueueMember == null || waitQueueMember[kCancelled]) {
          if (err == null) {
            pool[kConnections].push(connection);
          }
          return;
        }
        if (err) {
          pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
        } else {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(err, connection);
      });
      return;
    }
  }
  module2.exports = {
    ConnectionPool
  };
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var EventEmitter = require("events");
  var connect = require_connect();
  var Connection = require_connection2().Connection;
  var common = require_common2();
  var makeStateMachine = require_utils2().makeStateMachine;
  var MongoNetworkError = require_error().MongoNetworkError;
  var BSON2 = require_utils3().retrieveBSON();
  var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var now = require_utils4().now;
  var sdamEvents = require_events();
  var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
  var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
  var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
  var kServer = Symbol("server");
  var kMonitorId = Symbol("monitorId");
  var kConnection = Symbol("connection");
  var kCancellationToken = Symbol("cancellationToken");
  var kRTTPinger = Symbol("rttPinger");
  var kRoundTripTime = Symbol("roundTripTime");
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = makeStateMachine({
    [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
    [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
  function isInCloseState(monitor) {
    return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
  }
  var Monitor = class extends EventEmitter {
    constructor(server, options) {
      super(options);
      this[kServer] = server;
      this[kConnection] = void 0;
      this[kCancellationToken] = new EventEmitter();
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kMonitorId] = null;
      this.s = {
        state: STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 1e4,
        heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === "number" ? options.heartbeatFrequencyMS : 1e4,
        minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === "number" ? options.minHeartbeatFrequencyMS : 500
      });
      const connectOptions = Object.assign({
        id: "<monitor>",
        host: server.description.host,
        port: server.description.port,
        bson: server.s.bson,
        connectionType: Connection
      }, server.s.options, this.options, {
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      });
      delete connectOptions.credentials;
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this[kMonitorId].wake();
    }
    reset() {
      const topologyVersion = this[kServer].description.topologyVersion;
      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }
      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, STATE_CLOSED);
    }
  };
  function resetMonitorState(monitor) {
    if (monitor[kMonitorId]) {
      monitor[kMonitorId].stop();
      monitor[kMonitorId] = null;
    }
    if (monitor[kRTTPinger]) {
      monitor[kRTTPinger].close();
      monitor[kRTTPinger] = void 0;
    }
    monitor[kCancellationToken].emit("cancel");
    if (monitor[kMonitorId]) {
      clearTimeout(monitor[kMonitorId]);
      monitor[kMonitorId] = void 0;
    }
    if (monitor[kConnection]) {
      monitor[kConnection].destroy({force: true});
    }
  }
  function checkServer(monitor, callback) {
    let start = now();
    monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
    function failureHandler(err) {
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({force: true});
        monitor[kConnection] = void 0;
      }
      monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
      monitor.emit("resetServer", err);
      monitor.emit("resetConnectionPool");
      callback(err);
    }
    if (monitor[kConnection] != null && !monitor[kConnection].closed) {
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const topologyVersion = monitor[kServer].description.topologyVersion;
      const isAwaitable = topologyVersion != null;
      const cmd = {ismaster: true};
      const options = {socketTimeout: connectTimeoutMS};
      if (isAwaitable) {
        cmd.maxAwaitTimeMS = maxAwaitTimeMS;
        cmd.topologyVersion = makeTopologyVersion(topologyVersion);
        if (connectTimeoutMS) {
          options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
        }
        options.exhaustAllowed = true;
        if (monitor[kRTTPinger] == null) {
          monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
        }
      }
      monitor[kConnection].command("admin.$cmd", cmd, options, (err, result) => {
        if (err) {
          failureHandler(err);
          return;
        }
        const isMaster = result.result;
        const duration = isAwaitable ? monitor[kRTTPinger].roundTripTime : calculateDurationInMs(start);
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
        if (isAwaitable && isMaster.topologyVersion) {
          monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
          start = now();
        } else {
          if (monitor[kRTTPinger]) {
            monitor[kRTTPinger].close();
            monitor[kRTTPinger] = void 0;
          }
          callback(void 0, isMaster);
        }
      });
      return;
    }
    connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
      if (conn && isInCloseState(monitor)) {
        conn.destroy({force: true});
        return;
      }
      if (err) {
        monitor[kConnection] = void 0;
        if (!(err instanceof MongoNetworkError)) {
          monitor.emit("resetConnectionPool");
        }
        failureHandler(err);
        return;
      }
      monitor[kConnection] = conn;
      monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
      callback(void 0, conn.ismaster);
    });
  }
  function monitorServer(monitor) {
    return (callback) => {
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback();
      }
      process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
      checkServer(monitor, (err, isMaster) => {
        if (err) {
          if (monitor[kServer].description.type === ServerType.Unknown) {
            monitor.emit("resetServer", err);
            return done();
          }
        }
        if (isMaster && isMaster.topologyVersion) {
          setTimeout(() => {
            if (!isInCloseState(monitor)) {
              monitor[kMonitorId].wake();
            }
          });
        }
        done();
      });
    };
  }
  function makeTopologyVersion(tv) {
    return {
      processId: tv.processId,
      counter: BSON2.Long.fromNumber(tv.counter)
    };
  }
  var RTTPinger = class {
    constructor(cancellationToken, options) {
      this[kConnection] = null;
      this[kCancellationToken] = cancellationToken;
      this[kRoundTripTime] = 0;
      this.closed = false;
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this[kRoundTripTime];
    }
    close() {
      this.closed = true;
      clearTimeout(this[kMonitorId]);
      this[kMonitorId] = void 0;
      if (this[kConnection]) {
        this[kConnection].destroy({force: true});
      }
    }
  };
  function measureRoundTripTime(rttPinger, options) {
    const start = now();
    const cancellationToken = rttPinger[kCancellationToken];
    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    if (rttPinger.closed) {
      return;
    }
    function measureAndReschedule(conn) {
      if (rttPinger.closed) {
        conn.destroy({force: true});
        return;
      }
      if (rttPinger[kConnection] == null) {
        rttPinger[kConnection] = conn;
      }
      rttPinger[kRoundTripTime] = calculateDurationInMs(start);
      rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
    }
    if (rttPinger[kConnection] == null) {
      connect(options, cancellationToken, (err, conn) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule(conn);
      });
      return;
    }
    rttPinger[kConnection].command("admin.$cmd", {ismaster: 1}, (err) => {
      if (err) {
        rttPinger[kConnection] = void 0;
        rttPinger[kRoundTripTime] = 0;
        return;
      }
      measureAndReschedule();
    });
  }
  module2.exports = {
    Monitor
  };
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var ConnectionPool = require_connection_pool().ConnectionPool;
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var MongoError = require_error().MongoError;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = require_utils3().retrieveBSON();
  var Logger = require_logger();
  var ServerDescription = require_server_description().ServerDescription;
  var compareTopologyVersion = require_server_description().compareTopologyVersion;
  var ReadPreference = require_read_preference();
  var Monitor = require_monitor().Monitor;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var collationNotSupported = require_utils2().collationNotSupported;
  var debugOptions = require_utils3().debugOptions;
  var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
  var isRetryableWriteError = require_error().isRetryableWriteError;
  var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
  var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
  var maxWireVersion = require_utils2().maxWireVersion;
  var makeStateMachine = require_utils2().makeStateMachine;
  var common = require_common2();
  var ServerType = common.ServerType;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var DEBUG_FIELDS = [
    "reconnect",
    "reconnectTries",
    "reconnectInterval",
    "emitError",
    "cursorFactory",
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "checkServerIdentity",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "key",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "servername"
  ];
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CONNECTING = common.STATE_CONNECTING;
  var STATE_CONNECTED = common.STATE_CONNECTED;
  var stateTransition = makeStateMachine({
    [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
    [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
    [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
    [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
  });
  var kMonitor = Symbol("monitor");
  var Server = class extends EventEmitter {
    constructor(description, options, topology) {
      super();
      this.s = {
        description,
        options,
        logger: Logger("Server", options),
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        state: STATE_CLOSED,
        credentials: options.credentials,
        topology
      };
      const poolOptions = Object.assign({host: this.description.host, port: this.description.port, bson: this.s.bson}, options);
      this.s.pool = new ConnectionPool(poolOptions);
      relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
      this.s.pool.on("clusterTimeReceived", (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      this[kMonitor] = new Monitor(this, this.s.options);
      relayEvents(this[kMonitor], this, [
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "monitoring"
      ]);
      this[kMonitor].on("resetConnectionPool", () => {
        this.s.pool.clear();
      });
      this[kMonitor].on("resetServer", (error) => markServerUnknown(this, error));
      this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
        this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
        }));
        if (this.s.state === STATE_CONNECTING) {
          stateTransition(this, STATE_CONNECTED);
          this.emit("connect", this);
        }
      });
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return null;
    }
    connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }
      stateTransition(this, STATE_CONNECTING);
      this[kMonitor].connect();
    }
    destroy(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, {force: false}, options);
      if (this.s.state === STATE_CLOSED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CLOSING);
      this[kMonitor].close();
      this.s.pool.close(options, (err) => {
        stateTransition(this, STATE_CLOSED);
        this.emit("closed");
        if (typeof callback === "function") {
          callback(err);
        }
      });
    }
    requestCheck() {
      this[kMonitor].requestCheck();
    }
    command(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      const error = basicReadValidations(this, options);
      if (error) {
        return callback(error);
      }
      options = Object.assign({}, options, {wireProtocolCommand: false});
      if (this.s.logger.isDebug()) {
        this.s.logger.debug(`executing command [${JSON.stringify({
          ns,
          cmd,
          options: debugOptions(DEBUG_FIELDS, options)
        })}] against ${this.name}`);
      }
      if (collationNotSupported(this, cmd)) {
        callback(new MongoError(`server ${this.name} does not support collation`));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));
      }, callback);
    }
    query(ns, cmd, cursorState, options, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));
      }, callback);
    }
    getMore(ns, cursorState, batchSize, options, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, conn, null, options, cb));
      }, callback);
    }
    killCursors(ns, cursorState, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        if (typeof callback === "function") {
          callback(new MongoError("server is closed"));
        }
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
      }, callback);
    }
    insert(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "insert", ns, ops}, options, callback);
    }
    update(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "update", ns, ops}, options, callback);
    }
    remove(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "remove", ns, ops}, options, callback);
    }
  };
  Object.defineProperty(Server.prototype, "clusterTime", {
    get: function() {
      return this.s.topology.clusterTime;
    },
    set: function(clusterTime) {
      this.s.topology.clusterTime = clusterTime;
    }
  });
  function supportsRetryableWrites(server) {
    return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
  }
  function calculateRoundTripTime(oldRtt, duration) {
    if (oldRtt === -1) {
      return duration;
    }
    const alpha = 0.2;
    return alpha * duration + (1 - alpha) * oldRtt;
  }
  function basicReadValidations(server, options) {
    if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
      return new MongoError("readPreference must be an instance of ReadPreference");
    }
  }
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const server = args.server;
    const op = args.op;
    const ns = args.ns;
    const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
    if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
      callback(new MongoError("server is closed"));
      return;
    }
    if (collationNotSupported(server, options)) {
      callback(new MongoError(`server ${server.name} does not support collation`));
      return;
    }
    const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
    if (unacknowledgedWrite || maxWireVersion(server) < 5) {
      if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
        callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
        return;
      }
    }
    server.s.pool.withConnection((err, conn, cb) => {
      if (err) {
        markServerUnknown(server, err);
        return cb(err);
      }
      conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));
    }, callback);
  }
  function markServerUnknown(server, error) {
    if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {
      server[kMonitor].reset();
    }
    server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
      error,
      topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion
    }));
  }
  function connectionIsStale(pool, connection) {
    return connection.generation !== pool.generation;
  }
  function shouldHandleStateChangeError(server, err) {
    const etv = err.topologyVersion;
    const stv = server.description.topologyVersion;
    return compareTopologyVersion(stv, etv) < 0;
  }
  function inActiveTransaction(session, cmd) {
    return session && session.inTransaction() && !isTransactionCommand(cmd);
  }
  function makeOperationHandler(server, connection, cmd, options, callback) {
    const session = options && options.session;
    return function handleOperationResult(err, result) {
      if (err && !connectionIsStale(server.s.pool, connection)) {
        if (err instanceof MongoNetworkError) {
          if (session && !session.hasEnded) {
            session.serverSession.isDirty = true;
          }
          if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
            err.addErrorLabel("RetryableWriteError");
          }
          if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
            markServerUnknown(server, err);
            server.s.pool.clear();
          }
        } else {
          if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
            err.addErrorLabel("RetryableWriteError");
          }
          if (isSDAMUnrecoverableError(err)) {
            if (shouldHandleStateChangeError(server, err)) {
              if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                server.s.pool.clear();
              }
              markServerUnknown(server, err);
              process.nextTick(() => server.requestCheck());
            }
          }
        }
      }
      callback(err, result);
    };
  }
  module2.exports = {
    Server
  };
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports2, module2) => {
  "use strict";
  var Logger = require_logger();
  var EventEmitter = require("events").EventEmitter;
  var dns = require("dns");
  function matchesParentDomain(srvAddress, parentDomain) {
    const regex = /^.*?\./;
    const srv = `.${srvAddress.replace(regex, "")}`;
    const parent = `.${parentDomain.replace(regex, "")}`;
    return srv.endsWith(parent);
  }
  var SrvPollingEvent = class {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    addresses() {
      return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
    }
  };
  var SrvPoller = class extends EventEmitter {
    constructor(options) {
      super();
      if (!options || !options.srvHost) {
        throw new TypeError("options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.rescanSrvIntervalMS = 6e4;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
      this.logger = Logger("srvPoller", options);
      this.haMode = false;
      this.generation = 0;
      this._timeout = null;
    }
    get srvAddress() {
      return `_mongodb._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        clearTimeout(this._timeout);
        this.generation += 1;
        this._timeout = null;
      }
    }
    schedule() {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => this._poll(), this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
    }
    failure(message, obj) {
      this.logger.warn(message, obj);
      this.haMode = true;
      this.schedule();
    }
    parentDomainMismatch(srvRecord) {
      this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
    }
    _poll() {
      const generation = this.generation;
      dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
        if (generation !== this.generation) {
          return;
        }
        if (err) {
          this.failure("DNS error", err);
          return;
        }
        const finalAddresses = [];
        srvRecords.forEach((record) => {
          if (matchesParentDomain(record.name, this.srvHost)) {
            finalAddresses.push(record);
          } else {
            this.parentDomainMismatch(record);
          }
        });
        if (!finalAddresses.length) {
          this.failure("No valid addresses found at host");
          return;
        }
        this.success(finalAddresses);
      });
    }
  };
  module2.exports.SrvPollingEvent = SrvPollingEvent;
  module2.exports.SrvPoller = SrvPoller;
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var TopologyType = require_common2().TopologyType;
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  function writableServerSelector() {
    return function(topologyDescription, servers) {
      return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
    };
  }
  function maxStalenessReducer(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
    if (maxStaleness < maxStalenessVariance) {
      throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1e3;
        if (staleness <= readPreference.maxStalenessSeconds)
          result.push(server);
        return result;
      }, []);
    }
    if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1e3;
        if (staleness <= readPreference.maxStalenessSeconds)
          result.push(server);
        return result;
      }, []);
    }
    return servers;
  }
  function tagSetMatch(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  }
  function tagSetReducer(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i = 0; i < readPreference.tags.length; ++i) {
      const tagSet = readPreference.tags[i];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  }
  function latencyWindowReducer(topologyDescription, servers) {
    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  }
  function primaryFilter(server) {
    return server.type === ServerType.RSPrimary;
  }
  function secondaryFilter(server) {
    return server.type === ServerType.RSSecondary;
  }
  function nearestFilter(server) {
    return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
  }
  function knownFilter(server) {
    return server.type !== ServerType.Unknown;
  }
  function readPreferenceServerSelector(readPreference) {
    if (!readPreference.isValid()) {
      throw new TypeError("Invalid read preference specified");
    }
    return function(topologyDescription, servers) {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  }
  module2.exports = {
    writableServerSelector,
    readPreferenceServerSelector
  };
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter = require("events");
  var ServerDescription = require_server_description().ServerDescription;
  var ServerType = require_common2().ServerType;
  var TopologyDescription = require_topology_description().TopologyDescription;
  var TopologyType = require_common2().TopologyType;
  var events = require_events();
  var Server = require_server2().Server;
  var relayEvents = require_utils2().relayEvents;
  var ReadPreference = require_read_preference();
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var CoreCursor = require_cursor().CoreCursor;
  var deprecate = require("util").deprecate;
  var BSON2 = require_utils3().retrieveBSON();
  var createCompressionInfo = require_shared2().createCompressionInfo;
  var ClientSession = require_sessions().ClientSession;
  var MongoError = require_error().MongoError;
  var MongoServerSelectionError = require_error().MongoServerSelectionError;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var SrvPoller = require_srv_polling().SrvPoller;
  var getMMAPError = require_shared2().getMMAPError;
  var makeStateMachine = require_utils2().makeStateMachine;
  var eachAsync = require_utils2().eachAsync;
  var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
  var ServerSessionPool = require_sessions().ServerSessionPool;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var compareTopologyVersion = require_server_description().compareTopologyVersion;
  var common = require_common2();
  var drainTimerQueue = common.drainTimerQueue;
  var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
  var serverSelection = require_server_selection();
  var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
  var writableServerSelector = serverSelection.writableServerSelector;
  var globalTopologyCounter = 0;
  var SERVER_RELAY_EVENTS = [
    "serverHeartbeatStarted",
    "serverHeartbeatSucceeded",
    "serverHeartbeatFailed",
    "commandStarted",
    "commandSucceeded",
    "commandFailed",
    "monitoring"
  ].concat(CMAP_EVENT_NAMES);
  var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CONNECTING = common.STATE_CONNECTING;
  var STATE_CONNECTED = common.STATE_CONNECTED;
  var stateTransition = makeStateMachine({
    [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
    [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
    [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
    [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
  });
  var DEPRECATED_OPTIONS = new Set([
    "autoReconnect",
    "reconnectTries",
    "reconnectInterval",
    "bufferMaxEntries"
  ]);
  var kCancelled = Symbol("cancelled");
  var kWaitQueue = Symbol("waitQueue");
  var Topology = class extends EventEmitter {
    constructor(seedlist, options) {
      super();
      if (typeof options === "undefined" && typeof seedlist !== "string") {
        options = seedlist;
        seedlist = [];
        if (options.host) {
          seedlist.push({host: options.host, port: options.port});
        }
      }
      seedlist = seedlist || [];
      if (typeof seedlist === "string") {
        seedlist = parseStringSeedlist(seedlist);
      }
      options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);
      options = Object.freeze(Object.assign(options, {
        metadata: makeClientMetadata(options),
        compression: {compressors: createCompressionInfo(options)}
      }));
      DEPRECATED_OPTIONS.forEach((optionName) => {
        if (options[optionName]) {
          emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
      const topologyType = topologyTypeFromSeedlist(seedlist, options);
      const topologyId = globalTopologyCounter++;
      const serverDescriptions = seedlist.reduce((result, seed) => {
        if (seed.domain_socket)
          seed.host = seed.domain_socket;
        const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
        result.set(address, new ServerDescription(address));
        return result;
      }, new Map());
      this[kWaitQueue] = new Denque();
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: STATE_CLOSED,
        description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, null, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        Cursor: options.cursorFactory || CoreCursor,
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        servers: new Map(),
        sessionPool: new ServerSessionPool(this),
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise,
        credentials: options.credentials,
        clusterTime: null,
        connectionTimers: new Set()
      };
      if (options.srvHost) {
        this.s.srvPoller = options.srvPoller || new SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          logger: options.logger,
          loggerLevel: options.loggerLevel
        });
        this.s.detectTopologyDescriptionChange = (ev) => {
          const previousType = ev.previousDescription.type;
          const newType = ev.newDescription.type;
          if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
            this.s.handleSrvPolling = srvPollingHandler(this);
            this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
            this.s.srvPoller.start();
          }
        };
        this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
      }
      this.setMaxListeners(Infinity);
    }
    get description() {
      return this.s.description;
    }
    get parserType() {
      return BSON2.native ? "c++" : "js";
    }
    connect(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.state === STATE_CONNECTED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CONNECTING);
      this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
      this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
      connectServers(this, Array.from(this.s.description.servers.values()));
      ReadPreference.translate(options);
      const readPreference = options.readPreference || ReadPreference.primary;
      const connectHandler = (err) => {
        if (err) {
          this.close();
          if (typeof callback === "function") {
            callback(err);
          } else {
            this.emit("error", err);
          }
          return;
        }
        stateTransition(this, STATE_CONNECTED);
        this.emit("open", err, this);
        this.emit("connect", this);
        if (typeof callback === "function")
          callback(err, this);
      };
      if (this.s.credentials) {
        this.command("admin.$cmd", {ping: 1}, {readPreference}, connectHandler);
        return;
      }
      this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);
    }
    close(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (typeof options === "boolean") {
        options = {force: options};
      }
      options = options || {};
      if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CLOSING);
      drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
      drainTimerQueue(this.s.connectionTimers);
      if (this.s.srvPoller) {
        this.s.srvPoller.stop();
        if (this.s.handleSrvPolling) {
          this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
          delete this.s.handleSrvPolling;
        }
      }
      if (this.s.detectTopologyDescriptionChange) {
        this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        delete this.s.detectTopologyDescriptionChange;
      }
      this.s.sessions.forEach((session) => session.endSession());
      this.s.sessionPool.endAllPooledSessions(() => {
        eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options, cb), (err) => {
          this.s.servers.clear();
          this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
          stateTransition(this, STATE_CLOSED);
          this.emit("close");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      });
    }
    selectServer(selector, options, callback) {
      if (typeof options === "function") {
        callback = options;
        if (typeof selector !== "function") {
          options = selector;
          let readPreference;
          if (selector instanceof ReadPreference) {
            readPreference = selector;
          } else if (typeof selector === "string") {
            readPreference = new ReadPreference(selector);
          } else {
            ReadPreference.translate(options);
            readPreference = options.readPreference || ReadPreference.primary;
          }
          selector = readPreferenceServerSelector(readPreference);
        } else {
          options = {};
        }
      }
      options = Object.assign({}, {serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS}, options);
      const isSharded = this.description.type === TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        callback(void 0, transaction.server);
        return;
      }
      let serverSelector = selector;
      if (typeof selector === "object") {
        const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
        serverSelector = readPreferenceServerSelector(readPreference);
      }
      const waitQueueMember = {
        serverSelector,
        transaction,
        callback
      };
      const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
      if (serverSelectionTimeoutMS) {
        waitQueueMember.timer = setTimeout(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = void 0;
          const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
          waitQueueMember.callback(timeoutError);
        }, serverSelectionTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    }
    shouldCheckForSessionSupport() {
      if (this.description.type === TopologyType.Single) {
        return !this.description.hasKnownServers;
      }
      return !this.description.hasDataBearingServers;
    }
    hasSessionSupport() {
      return this.description.logicalSessionTimeoutMinutes != null;
    }
    startSession(options, clientOptions) {
      const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
      session.once("ended", () => {
        this.s.sessions.delete(session);
      });
      this.s.sessions.add(session);
      return session;
    }
    endSessions(sessions, callback) {
      if (!Array.isArray(sessions)) {
        sessions = [sessions];
      }
      this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred, noResponse: true}, () => {
        if (typeof callback === "function")
          callback();
      });
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        resolveClusterTime(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit("error", new MongoError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
      }
      updateServers(this, serverDescription);
      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback) {
      if (typeof credentials === "function")
        callback = credentials, credentials = null;
      if (typeof callback === "function")
        callback(null, true);
    }
    logout(callback) {
      if (typeof callback === "function")
        callback(null, true);
    }
    insert(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "insert", ns, ops}, options, callback);
    }
    update(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "update", ns, ops}, options, callback);
    }
    remove(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "remove", ns, ops}, options, callback);
    }
    command(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      ReadPreference.translate(options);
      const readPreference = options.readPreference || ReadPreference.primary;
      this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
        if (err) {
          callback(err);
          return;
        }
        const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(this) && !options.session.inTransaction() && isWriteCommand(cmd);
        const cb = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            return callback(err2);
          }
          if (willRetryWrite) {
            const newOptions = Object.assign({}, options, {retrying: true});
            return this.command(ns, cmd, newOptions, callback);
          }
          return callback(err2);
        };
        if (willRetryWrite) {
          options.session.incrementTransactionNumber();
          options.willRetryWrite = willRetryWrite;
        }
        server.command(ns, cmd, options, cb);
      });
    }
    cursor(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      const CursorClass = options.cursorFactory || this.s.Cursor;
      ReadPreference.translate(options);
      return new CursorClass(topology, ns, cmd, options);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === STATE_CLOSED;
    }
    unref() {
      console.log("not implemented: `unref`");
    }
    lastIsMaster() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
      const result = sd || {maxWireVersion: this.description.commonWireVersion};
      return result;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get bson() {
      return this.s.bson;
    }
  };
  Object.defineProperty(Topology.prototype, "clusterTime", {
    enumerable: true,
    get: function() {
      return this.s.clusterTime;
    },
    set: function(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  });
  Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  function isStaleServerDescription(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription.topologyVersion;
    return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  }
  function destroyServer(server, topology, options, callback) {
    options = options || {};
    LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
    server.destroy(options, () => {
      topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
      SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
      if (typeof callback === "function") {
        callback();
      }
    });
  }
  function parseStringSeedlist(seedlist) {
    return seedlist.split(",").map((seed) => ({
      host: seed.split(":")[0],
      port: seed.split(":")[1] || 27017
    }));
  }
  function topologyTypeFromSeedlist(seedlist, options) {
    if (options.directConnection) {
      return TopologyType.Single;
    }
    const replicaSet = options.replicaSet || options.setName || options.rs_name;
    if (replicaSet == null) {
      return TopologyType.Unknown;
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  function randomSelection(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
  function createAndConnectServer(topology, serverDescription, connectDelay) {
    topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new Server(serverDescription, topology.s.options, topology);
    relayEvents(server, topology, SERVER_RELAY_EVENTS);
    server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
    if (connectDelay) {
      const connectTimer = setTimeout(() => {
        clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
        server.connect();
      }, connectDelay);
      topology.s.connectionTimers.add(connectTimer);
      return server;
    }
    server.connect();
    return server;
  }
  function connectServers(topology, serverDescriptions) {
    topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
      const server = createAndConnectServer(topology, serverDescription);
      servers.set(serverDescription.address, server);
      return servers;
    }, new Map());
  }
  function updateServers(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      server.s.description = incomingServerDescription;
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      destroyServer(server, topology);
    }
  }
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const topology = args.topology;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(topology) && !options.session.inTransaction() && options.explain === void 0;
    topology.selectServer(writableServerSelector(), options, (err, server) => {
      if (err) {
        callback(err, null);
        return;
      }
      const handler = (err2, result) => {
        if (!err2)
          return callback(null, result);
        if (!shouldRetryOperation(err2)) {
          err2 = getMMAPError(err2);
          return callback(err2);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, {retrying: true});
          return executeWriteOperation(newArgs, options, callback);
        }
        return callback(err2);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options, handler);
    });
  }
  function shouldRetryOperation(err) {
    return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
  }
  function srvPollingHandler(topology) {
    return function handleSrvPolling(ev) {
      const previousTopologyDescription = topology.s.description;
      topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
      if (topology.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(topology);
      topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
    };
  }
  function drainWaitQueue(queue, err) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      clearTimeout(waitQueueMember.timer);
      if (!waitQueueMember[kCancelled]) {
        waitQueueMember.callback(err);
      }
    }
  }
  function processWaitQueue(topology) {
    if (topology.s.state === STATE_CLOSED) {
      drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
      return;
    }
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology[kWaitQueue].length;
    for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
      const waitQueueMember = topology[kWaitQueue].shift();
      if (waitQueueMember[kCancelled]) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
      } catch (e) {
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(e);
        continue;
      }
      if (selectedDescriptions.length === 0) {
        topology[kWaitQueue].push(waitQueueMember);
        continue;
      }
      const selectedServerDescription = randomSelection(selectedDescriptions);
      const selectedServer = topology.s.servers.get(selectedServerDescription.address);
      const transaction = waitQueueMember.transaction;
      const isSharded = topology.description.type === TopologyType.Sharded;
      if (isSharded && transaction && transaction.isActive) {
        transaction.pinServer(selectedServer);
      }
      clearTimeout(waitQueueMember.timer);
      waitQueueMember.callback(void 0, selectedServer);
    }
    if (topology[kWaitQueue].length > 0) {
      topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
    }
  }
  module2.exports = {
    Topology
  };
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS((exports2, module2) => {
  "use strict";
  var URL = require("url");
  var qs = require("querystring");
  var dns = require("dns");
  var MongoParseError = require_error().MongoParseError;
  var ReadPreference = require_read_preference();
  var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
  var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
  function matchesParentDomain(srvAddress, parentDomain) {
    const regex = /^.*?\./;
    const srv = `.${srvAddress.replace(regex, "")}`;
    const parent = `.${parentDomain.replace(regex, "")}`;
    return srv.endsWith(parent);
  }
  function parseSrvConnectionString(uri, options, callback) {
    const result = URL.parse(uri, true);
    if (options.directConnection || options.directconnection) {
      return callback(new MongoParseError("directConnection not supported with SRV URI"));
    }
    if (result.hostname.split(".").length < 3) {
      return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
    }
    result.domainLength = result.hostname.split(".").length;
    if (result.pathname && result.pathname.match(",")) {
      return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
    }
    if (result.port) {
      return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
    }
    const lookupAddress = result.host;
    dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
      if (err)
        return callback(err);
      if (addresses.length === 0) {
        return callback(new MongoParseError("No addresses found at host"));
      }
      for (let i = 0; i < addresses.length; i++) {
        if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
          return callback(new MongoParseError("Server record does not share hostname with parent URI"));
        }
      }
      result.protocol = "mongodb";
      result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
      if (!("ssl" in options) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
        result.query.ssl = true;
      }
      dns.resolveTxt(lookupAddress, (err2, record) => {
        if (err2) {
          if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
            return callback(err2);
          }
          record = null;
        }
        if (record) {
          if (record.length > 1) {
            return callback(new MongoParseError("Multiple text records not allowed"));
          }
          record = qs.parse(record[0].join(""));
          if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
            return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
          }
          result.query = Object.assign({}, record, result.query);
        }
        result.search = qs.stringify(result.query);
        const finalString = URL.format(result);
        parseConnectionString(finalString, options, (err3, ret) => {
          if (err3) {
            callback(err3);
            return;
          }
          callback(null, Object.assign({}, ret, {srvHost: lookupAddress}));
        });
      });
    });
  }
  function parseQueryStringItemValue(key, value) {
    if (Array.isArray(value)) {
      value = value.filter((v, idx) => value.indexOf(v) === idx);
      if (value.length === 1)
        value = value[0];
    } else if (value.indexOf(":") > 0) {
      value = value.split(",").reduce((result, pair) => {
        const parts = pair.split(":");
        result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
        return result;
      }, {});
    } else if (value.indexOf(",") > 0) {
      value = value.split(",").map((v) => {
        return parseQueryStringItemValue(key, v);
      });
    } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
      value = value.toLowerCase() === "true";
    } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
      const numericValue = parseFloat(value);
      if (!Number.isNaN(numericValue)) {
        value = parseFloat(value);
      }
    }
    return value;
  }
  var BOOLEAN_OPTIONS = new Set([
    "slaveok",
    "slave_ok",
    "sslvalidate",
    "fsync",
    "safe",
    "retrywrites",
    "j"
  ]);
  var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
  var AUTH_MECHANISMS = new Set([
    "GSSAPI",
    "MONGODB-AWS",
    "MONGODB-X509",
    "MONGODB-CR",
    "DEFAULT",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256",
    "PLAIN"
  ]);
  var CASE_TRANSLATION = {
    replicaset: "replicaSet",
    connecttimeoutms: "connectTimeoutMS",
    sockettimeoutms: "socketTimeoutMS",
    maxpoolsize: "maxPoolSize",
    minpoolsize: "minPoolSize",
    maxidletimems: "maxIdleTimeMS",
    waitqueuemultiple: "waitQueueMultiple",
    waitqueuetimeoutms: "waitQueueTimeoutMS",
    wtimeoutms: "wtimeoutMS",
    readconcern: "readConcern",
    readconcernlevel: "readConcernLevel",
    readpreference: "readPreference",
    maxstalenessseconds: "maxStalenessSeconds",
    readpreferencetags: "readPreferenceTags",
    authsource: "authSource",
    authmechanism: "authMechanism",
    authmechanismproperties: "authMechanismProperties",
    gssapiservicename: "gssapiServiceName",
    localthresholdms: "localThresholdMS",
    serverselectiontimeoutms: "serverSelectionTimeoutMS",
    serverselectiontryonce: "serverSelectionTryOnce",
    heartbeatfrequencyms: "heartbeatFrequencyMS",
    retrywrites: "retryWrites",
    uuidrepresentation: "uuidRepresentation",
    zlibcompressionlevel: "zlibCompressionLevel",
    tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
    tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
    tlsinsecure: "tlsInsecure",
    tlscafile: "tlsCAFile",
    tlscertificatekeyfile: "tlsCertificateKeyFile",
    tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
    wtimeout: "wTimeoutMS",
    j: "journal",
    directconnection: "directConnection"
  };
  function applyConnectionStringOption(obj, key, value, options) {
    if (key === "journal") {
      key = "j";
    } else if (key === "wtimeoutms") {
      key = "wtimeout";
    }
    if (BOOLEAN_OPTIONS.has(key)) {
      value = value === "true" || value === true;
    } else if (key === "appname") {
      value = decodeURIComponent(value);
    } else if (key === "readconcernlevel") {
      obj["readConcernLevel"] = value;
      key = "readconcern";
      value = {level: value};
    }
    if (key === "compressors") {
      value = Array.isArray(value) ? value : [value];
      if (!value.every((c) => c === "snappy" || c === "zlib")) {
        throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
      }
    }
    if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
      throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
    }
    if (key === "readpreference" && !ReadPreference.isValid(value)) {
      throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
    }
    if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
      throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
    }
    if (key === "compressors" || key === "zlibcompressionlevel") {
      obj.compression = obj.compression || {};
      obj = obj.compression;
    }
    if (key === "authmechanismproperties") {
      if (typeof value.SERVICE_NAME === "string")
        obj.gssapiServiceName = value.SERVICE_NAME;
      if (typeof value.SERVICE_REALM === "string")
        obj.gssapiServiceRealm = value.SERVICE_REALM;
      if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
        obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
      }
    }
    if (key === "readpreferencetags") {
      value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
    }
    if (options.caseTranslate && CASE_TRANSLATION[key]) {
      obj[CASE_TRANSLATION[key]] = value;
      return;
    }
    obj[key] = value;
  }
  var USERNAME_REQUIRED_MECHANISMS = new Set([
    "GSSAPI",
    "MONGODB-CR",
    "PLAIN",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256"
  ]);
  function splitArrayOfMultipleReadPreferenceTags(value) {
    const parsedTags = [];
    for (let i = 0; i < value.length; i++) {
      parsedTags[i] = {};
      value[i].split(",").forEach((individualTag) => {
        const splitTag = individualTag.split(":");
        parsedTags[i][splitTag[0]] = splitTag[1];
      });
    }
    return parsedTags;
  }
  function applyAuthExpectations(parsed) {
    if (parsed.options == null) {
      return;
    }
    const options = parsed.options;
    const authSource = options.authsource || options.authSource;
    if (authSource != null) {
      parsed.auth = Object.assign({}, parsed.auth, {db: authSource});
    }
    const authMechanism = options.authmechanism || options.authMechanism;
    if (authMechanism != null) {
      if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
        throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
      }
      if (authMechanism === "GSSAPI") {
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "MONGODB-AWS") {
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "MONGODB-X509") {
        if (parsed.auth && parsed.auth.password != null) {
          throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
        }
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "PLAIN") {
        if (parsed.auth && parsed.auth.db == null) {
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
      }
    }
    if (parsed.auth && parsed.auth.db == null) {
      parsed.auth = Object.assign({}, parsed.auth, {db: "admin"});
    }
    return parsed;
  }
  function parseQueryString(query, options) {
    const result = {};
    let parsedQueryString = qs.parse(query);
    checkTLSOptions(parsedQueryString);
    for (const key in parsedQueryString) {
      const value = parsedQueryString[key];
      if (value === "" || value == null) {
        throw new MongoParseError("Incomplete key value pair for option");
      }
      const normalizedKey = key.toLowerCase();
      const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
      applyConnectionStringOption(result, normalizedKey, parsedValue, options);
    }
    if (result.wtimeout && result.wtimeoutms) {
      delete result.wtimeout;
      console.warn("Unsupported option `wtimeout` specified");
    }
    return Object.keys(result).length ? result : null;
  }
  function translateTLSOptions(queryString) {
    if (queryString.tls) {
      queryString.ssl = queryString.tls;
    }
    if (queryString.tlsInsecure) {
      queryString.checkServerIdentity = false;
      queryString.sslValidate = false;
    } else {
      Object.assign(queryString, {
        checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
        sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
      });
    }
    if (queryString.tlsCAFile) {
      queryString.ssl = true;
      queryString.sslCA = queryString.tlsCAFile;
    }
    if (queryString.tlsCertificateKeyFile) {
      queryString.ssl = true;
      if (queryString.tlsCertificateFile) {
        queryString.sslCert = queryString.tlsCertificateFile;
        queryString.sslKey = queryString.tlsCertificateKeyFile;
      } else {
        queryString.sslKey = queryString.tlsCertificateKeyFile;
        queryString.sslCert = queryString.tlsCertificateKeyFile;
      }
    }
    if (queryString.tlsCertificateKeyFilePassword) {
      queryString.ssl = true;
      queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
    }
    return queryString;
  }
  function checkTLSOptions(queryString) {
    const queryStringKeys = Object.keys(queryString);
    if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
      throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
    }
    const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
    const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
    if (tlsValue != null && sslValue != null) {
      if (tlsValue !== sslValue) {
        throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
      }
    }
  }
  function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
    const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
    let optionValue;
    if (Array.isArray(queryString[optionName])) {
      optionValue = queryString[optionName][0];
    } else {
      optionValue = queryString[optionName];
    }
    if (queryStringHasTLSOption) {
      if (Array.isArray(queryString[optionName])) {
        const firstValue = queryString[optionName][0];
        queryString[optionName].forEach((tlsValue) => {
          if (tlsValue !== firstValue) {
            throw new MongoParseError(`All values of ${optionName} must be the same.`);
          }
        });
      }
    }
    return optionValue;
  }
  var PROTOCOL_MONGODB = "mongodb";
  var PROTOCOL_MONGODB_SRV = "mongodb+srv";
  var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
  function parseConnectionString(uri, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, {caseTranslate: true}, options);
    try {
      URL.parse(uri);
    } catch (e) {
      return callback(new MongoParseError("URI malformed, cannot be parsed"));
    }
    const cap = uri.match(HOSTS_RX);
    if (!cap) {
      return callback(new MongoParseError("Invalid connection string"));
    }
    const protocol = cap[1];
    if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
      return callback(new MongoParseError("Invalid protocol provided"));
    }
    const dbAndQuery = cap[4].split("?");
    const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
    const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
    let parsedOptions;
    try {
      parsedOptions = parseQueryString(query, options);
    } catch (parseError) {
      return callback(parseError);
    }
    parsedOptions = Object.assign({}, parsedOptions, options);
    if (protocol === PROTOCOL_MONGODB_SRV) {
      return parseSrvConnectionString(uri, parsedOptions, callback);
    }
    const auth = {username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null};
    if (parsedOptions.auth) {
      if (parsedOptions.auth.username)
        auth.username = parsedOptions.auth.username;
      if (parsedOptions.auth.user)
        auth.username = parsedOptions.auth.user;
      if (parsedOptions.auth.password)
        auth.password = parsedOptions.auth.password;
    } else {
      if (parsedOptions.username)
        auth.username = parsedOptions.username;
      if (parsedOptions.user)
        auth.username = parsedOptions.user;
      if (parsedOptions.password)
        auth.password = parsedOptions.password;
    }
    if (cap[4].split("?")[0].indexOf("@") !== -1) {
      return callback(new MongoParseError("Unescaped slash in userinfo section"));
    }
    const authorityParts = cap[3].split("@");
    if (authorityParts.length > 2) {
      return callback(new MongoParseError("Unescaped at-sign in authority section"));
    }
    if (authorityParts[0] == null || authorityParts[0] === "") {
      return callback(new MongoParseError("No username provided in authority section"));
    }
    if (authorityParts.length > 1) {
      const authParts = authorityParts.shift().split(":");
      if (authParts.length > 2) {
        return callback(new MongoParseError("Unescaped colon in authority section"));
      }
      if (authParts[0] === "") {
        return callback(new MongoParseError("Invalid empty username provided"));
      }
      if (!auth.username)
        auth.username = qs.unescape(authParts[0]);
      if (!auth.password)
        auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
    }
    let hostParsingError = null;
    const hosts = authorityParts.shift().split(",").map((host) => {
      let parsedHost = URL.parse(`mongodb://${host}`);
      if (parsedHost.path === "/:") {
        hostParsingError = new MongoParseError("Double colon in host identifier");
        return null;
      }
      if (host.match(/\.sock/)) {
        parsedHost.hostname = qs.unescape(host);
        parsedHost.port = null;
      }
      if (Number.isNaN(parsedHost.port)) {
        hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
        return;
      }
      const result2 = {
        host: parsedHost.hostname,
        port: parsedHost.port ? parseInt(parsedHost.port) : 27017
      };
      if (result2.port === 0) {
        hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
        return;
      }
      if (result2.port > 65535) {
        hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
        return;
      }
      if (result2.port < 0) {
        hostParsingError = new MongoParseError("Invalid port (negative number)");
        return;
      }
      return result2;
    }).filter((host) => !!host);
    if (hostParsingError) {
      return callback(hostParsingError);
    }
    if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
      return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
    }
    const directConnection = !!parsedOptions.directConnection;
    if (directConnection && hosts.length !== 1) {
      return callback(new MongoParseError("directConnection option requires exactly one host"));
    }
    if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
      parsedOptions.directConnection = true;
    }
    const result = {
      hosts,
      auth: auth.db || auth.username ? auth : null,
      options: Object.keys(parsedOptions).length ? parsedOptions : null
    };
    if (result.auth && result.auth.db) {
      result.defaultDatabase = result.auth.db;
    } else {
      result.defaultDatabase = "test";
    }
    result.options = translateTLSOptions(result.options);
    try {
      applyAuthExpectations(result);
    } catch (authError) {
      return callback(authError);
    }
    callback(null, result);
  }
  module2.exports = parseConnectionString;
});

// node_modules/mongodb/lib/core/index.js
var require_core2 = __commonJS((exports2, module2) => {
  "use strict";
  var BSON2 = require_bson2();
  var require_optional = require_require_optional();
  var EJSON = require_utils2().retrieveEJSON();
  try {
    const BSONNative = require_optional("bson-ext");
    if (BSONNative) {
      BSON2 = BSONNative;
    }
  } catch (err) {
  }
  module2.exports = {
    MongoError: require_error().MongoError,
    MongoNetworkError: require_error().MongoNetworkError,
    MongoParseError: require_error().MongoParseError,
    MongoTimeoutError: require_error().MongoTimeoutError,
    MongoServerSelectionError: require_error().MongoServerSelectionError,
    MongoWriteConcernError: require_error().MongoWriteConcernError,
    Connection: require_connection(),
    Server: require_server(),
    ReplSet: require_replset(),
    Mongos: require_mongos(),
    Logger: require_logger(),
    Cursor: require_cursor().CoreCursor,
    ReadPreference: require_read_preference(),
    Sessions: require_sessions(),
    BSON: BSON2,
    EJSON,
    Topology: require_topology().Topology,
    Query: require_commands().Query,
    MongoCredentials: require_mongo_credentials().MongoCredentials,
    defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
    MongoCR: require_mongocr(),
    X509: require_x509(),
    Plain: require_plain(),
    GSSAPI: require_gssapi(),
    ScramSHA1: require_scram().ScramSHA1,
    ScramSHA256: require_scram().ScramSHA256,
    parseConnectionString: require_uri_parser()
  };
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events").EventEmitter;
  var Instrumentation = class extends EventEmitter {
    constructor() {
      super();
    }
    instrument(MongoClient2, callback) {
      this.$MongoClient = MongoClient2;
      const $prototypeConnect = this.$prototypeConnect = MongoClient2.prototype.connect;
      const instrumentation = this;
      MongoClient2.prototype.connect = function(callback2) {
        this.s.options.monitorCommands = true;
        this.on("commandStarted", (event) => instrumentation.emit("started", event));
        this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
        this.on("commandFailed", (event) => instrumentation.emit("failed", event));
        return $prototypeConnect.call(this, callback2);
      };
      if (typeof callback === "function")
        callback(null, this);
    }
    uninstrument() {
      this.$MongoClient.prototype.connect = this.$prototypeConnect;
    }
  };
  module2.exports = Instrumentation;
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS((exports2, module2) => {
  "use strict";
  var MongoNetworkError = require_core2().MongoNetworkError;
  var GET_MORE_RESUMABLE_CODES = new Set([
    6,
    7,
    89,
    91,
    189,
    262,
    9001,
    10107,
    11600,
    11602,
    13435,
    13436,
    63,
    150,
    13388,
    234,
    133,
    43
  ]);
  function isResumableError(error, wireVersion) {
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion >= 9) {
      if (error.code === 43) {
        return true;
      }
      return error.hasErrorLabel("ResumableChangeStreamError");
    }
    return GET_MORE_RESUMABLE_CODES.has(error.code);
  }
  module2.exports = {GET_MORE_RESUMABLE_CODES, isResumableError};
});

// node_modules/mongodb/lib/constants.js
var require_constants3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
    SYSTEM_INDEX_COLLECTION: "system.indexes",
    SYSTEM_PROFILE_COLLECTION: "system.profile",
    SYSTEM_USER_COLLECTION: "system.users",
    SYSTEM_COMMAND_COLLECTION: "$cmd",
    SYSTEM_JS_COLLECTION: "system.js"
  };
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core2().BSON.Code;
  var debugOptions = require_utils4().debugOptions;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var parseIndexOptions = require_utils4().parseIndexOptions;
  var ReadPreference = require_core2().ReadPreference;
  var toError = require_utils4().toError;
  var CONSTANTS = require_constants3();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var debugFields = [
    "authSource",
    "w",
    "wtimeout",
    "j",
    "native_parser",
    "forceServerObjectId",
    "serializeFunctions",
    "raw",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bufferMaxEntries",
    "numberOfRetries",
    "retryMiliSeconds",
    "readPreference",
    "pkFactory",
    "parentDb",
    "promiseLibrary",
    "noListener"
  ];
  function createIndex(db, name, fieldOrSpec, options, callback) {
    let finalOptions = Object.assign({}, {readPreference: ReadPreference.PRIMARY}, options);
    finalOptions = applyWriteConcern(finalOptions, {db}, options);
    if (finalOptions.writeConcern && typeof callback !== "function") {
      throw MongoError.create({
        message: "Cannot use a writeConcern without a provided callback",
        driver: true
      });
    }
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
      if (err == null)
        return handleCallback(callback, err, result);
      if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
        return handleCallback(callback, err, result);
      }
      const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
      finalOptions.checkKeys = false;
      db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
        if (callback == null)
          return;
        if (err2)
          return handleCallback(callback, err2);
        if (result2 == null)
          return handleCallback(callback, null, null);
        if (result2.result.writeErrors)
          return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      });
    });
  }
  function createListener(db, e, object) {
    function listener(err) {
      if (object.listeners(e).length > 0) {
        object.emit(e, err, db);
        for (let i = 0; i < db.s.children.length; i++) {
          db.s.children[i].emit(e, err, db.s.children[i]);
        }
      }
    }
    return listener;
  }
  function ensureIndex(db, name, fieldOrSpec, options, callback) {
    const finalOptions = applyWriteConcern({}, {db}, options);
    const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
    const index_name = selector.name;
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    finalOptions.readPreference = ReadPreference.PRIMARY;
    indexInformation(db, name, finalOptions, (err, indexInformation2) => {
      if (err != null && err.code !== 26)
        return handleCallback(callback, err, null);
      if (indexInformation2 == null || !indexInformation2[index_name]) {
        createIndex(db, name, fieldOrSpec, options, callback);
      } else {
        if (typeof callback === "function")
          return handleCallback(callback, null, index_name);
      }
    });
  }
  function evaluate(db, code, parameters, options, callback) {
    let finalCode = code;
    let finalParameters = [];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    if (!(finalCode && finalCode._bsontype === "Code"))
      finalCode = new Code2(finalCode);
    if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
      finalParameters = [parameters];
    } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
      finalParameters = parameters;
    }
    let cmd = {$eval: finalCode, args: finalParameters};
    if (options["nolock"]) {
      cmd["nolock"] = options["nolock"];
    }
    options.readPreference = new ReadPreference(ReadPreference.PRIMARY);
    executeCommand(db, cmd, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result && result.ok === 1)
        return handleCallback(callback, null, result.retval);
      if (result)
        return handleCallback(callback, MongoError.create({message: `eval failed: ${result.errmsg}`, driver: true}), null);
      handleCallback(callback, err, result);
    });
  }
  function executeCommand(db, command, options, callback) {
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    const dbName = options.dbName || options.authdb || db.databaseName;
    options.readPreference = ReadPreference.resolve(db, options);
    if (db.s.logger.isDebug())
      db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
    db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options, (err, result) => {
      if (err)
        return handleCallback(callback, err);
      if (options.full)
        return handleCallback(callback, null, result);
      handleCallback(callback, null, result.result);
    });
  }
  function executeDbAdminCommand(db, command, options, callback) {
    const namespace = new MongoDBNamespace("admin", "$cmd");
    db.s.topology.command(namespace, command, options, (err, result) => {
      if (db.serverConfig && db.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      if (err)
        return handleCallback(callback, err);
      handleCallback(callback, null, result.result);
    });
  }
  function indexInformation(db, name, options, callback) {
    const full = options["full"] == null ? false : options["full"];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    function processResults(indexes) {
      let info = {};
      for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        info[index.name] = [];
        for (let name2 in index.key) {
          info[index.name].push([name2, index.key[name2]]);
        }
      }
      return info;
    }
    db.collection(name).listIndexes(options).toArray((err, indexes) => {
      if (err)
        return callback(toError(err));
      if (!Array.isArray(indexes))
        return handleCallback(callback, null, []);
      if (full)
        return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
  }
  function profilingInfo(db, options, callback) {
    try {
      db.collection("system.profile").find({}, options).toArray(callback);
    } catch (err) {
      return callback(err, null);
    }
  }
  function validateDatabaseName(databaseName) {
    if (typeof databaseName !== "string")
      throw MongoError.create({message: "database name must be a string", driver: true});
    if (databaseName.length === 0)
      throw MongoError.create({message: "database name cannot be the empty string", driver: true});
    if (databaseName === "$external")
      return;
    const invalidChars = [" ", ".", "$", "/", "\\"];
    for (let i = 0; i < invalidChars.length; i++) {
      if (databaseName.indexOf(invalidChars[i]) !== -1)
        throw MongoError.create({
          message: "database names cannot contain the character '" + invalidChars[i] + "'",
          driver: true
        });
    }
  }
  function createCreateIndexCommand(db, name, fieldOrSpec, options) {
    const indexParameters = parseIndexOptions(fieldOrSpec);
    const fieldHash = indexParameters.fieldHash;
    const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
    const selector = {
      ns: db.s.namespace.withCollection(name).toString(),
      key: fieldHash,
      name: indexName
    };
    const finalUnique = options == null || typeof options === "object" ? false : options;
    options = options == null || typeof options === "boolean" ? {} : options;
    const keysToOmit = Object.keys(selector);
    for (let optionName in options) {
      if (keysToOmit.indexOf(optionName) === -1) {
        selector[optionName] = options[optionName];
      }
    }
    if (selector["unique"] == null)
      selector["unique"] = finalUnique;
    const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
    for (let i = 0; i < removeKeys.length; i++) {
      delete selector[removeKeys[i]];
    }
    return selector;
  }
  function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {
    const indexParameters = parseIndexOptions(fieldOrSpec);
    const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
    const indexes = [{name: indexName, key: indexParameters.fieldHash}];
    const keysToOmit = Object.keys(indexes[0]).concat([
      "writeConcern",
      "w",
      "wtimeout",
      "j",
      "fsync",
      "readPreference",
      "session"
    ]);
    for (let optionName in options) {
      if (keysToOmit.indexOf(optionName) === -1) {
        indexes[0][optionName] = options[optionName];
      }
    }
    const capabilities = db.s.topology.capabilities();
    if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
      const error = new MongoError("server/primary/mongos does not support collation");
      error.code = 67;
      return callback(error);
    }
    const cmd = applyWriteConcern({createIndexes: name, indexes}, {db}, options);
    options.readPreference = ReadPreference.PRIMARY;
    executeCommand(db, cmd, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result.ok === 0)
        return handleCallback(callback, toError(result), null);
      handleCallback(callback, null, indexName);
    });
  }
  module2.exports = {
    createListener,
    createIndex,
    ensureIndex,
    evaluate,
    executeCommand,
    executeDbAdminCommand,
    indexInformation,
    profilingInfo,
    validateDatabaseName
  };
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS((exports2, module2) => {
  "use strict";
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var ReadPreference = require_core2().ReadPreference;
  var toError = require_utils4().toError;
  var CursorState = require_cursor().CursorState;
  var maxWireVersion = require_utils2().maxWireVersion;
  function buildCountCommand(collectionOrCursor, query, options) {
    const skip = options.skip;
    const limit = options.limit;
    let hint = options.hint;
    const maxTimeMS = options.maxTimeMS;
    query = query || {};
    const cmd = {
      count: options.collectionName,
      query
    };
    if (collectionOrCursor.s.numberOfRetries) {
      if (collectionOrCursor.options.hint) {
        hint = collectionOrCursor.options.hint;
      } else if (collectionOrCursor.cmd.hint) {
        hint = collectionOrCursor.cmd.hint;
      }
      decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
    } else {
      decorateWithCollation(cmd, collectionOrCursor, options);
    }
    if (typeof skip === "number")
      cmd.skip = skip;
    if (typeof limit === "number")
      cmd.limit = limit;
    if (typeof maxTimeMS === "number")
      cmd.maxTimeMS = maxTimeMS;
    if (hint)
      cmd.hint = hint;
    decorateWithReadConcern(cmd, collectionOrCursor);
    return cmd;
  }
  function findAndModify(coll, query, sort, doc, options, callback) {
    const queryObject = {
      findAndModify: coll.collectionName,
      query
    };
    sort = formattedOrderClause(sort);
    if (sort) {
      queryObject.sort = sort;
    }
    queryObject.new = options.new ? true : false;
    queryObject.remove = options.remove ? true : false;
    queryObject.upsert = options.upsert ? true : false;
    const projection = options.projection || options.fields;
    if (projection) {
      queryObject.fields = projection;
    }
    if (options.arrayFilters) {
      queryObject.arrayFilters = options.arrayFilters;
      delete options.arrayFilters;
    }
    if (doc && !options.remove) {
      queryObject.update = doc;
    }
    if (options.maxTimeMS)
      queryObject.maxTimeMS = options.maxTimeMS;
    options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    options.checkKeys = false;
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (finalOptions.writeConcern) {
      queryObject.writeConcern = finalOptions.writeConcern;
    }
    if (finalOptions.bypassDocumentValidation === true) {
      queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
    }
    finalOptions.readPreference = ReadPreference.primary;
    try {
      decorateWithCollation(queryObject, coll, finalOptions);
    } catch (err) {
      return callback(err, null);
    }
    executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      return handleCallback(callback, null, result);
    });
  }
  function indexInformation(db, name, options, callback) {
    const full = options["full"] == null ? false : options["full"];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    function processResults(indexes) {
      let info = {};
      for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        info[index.name] = [];
        for (let name2 in index.key) {
          info[index.name].push([name2, index.key[name2]]);
        }
      }
      return info;
    }
    db.collection(name).listIndexes(options).toArray((err, indexes) => {
      if (err)
        return callback(toError(err));
      if (!Array.isArray(indexes))
        return handleCallback(callback, null, []);
      if (full)
        return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
  }
  function prepareDocs(coll, docs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docs;
    }
    return docs.map((doc) => {
      if (forceServerObjectId !== true && doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    });
  }
  function nextObject(cursor, callback) {
    if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
      return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
    }
    if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
      try {
        cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
      } catch (err) {
        return handleCallback(callback, err);
      }
    }
    cursor._next((err, doc) => {
      cursor.s.state = CursorState.OPEN;
      if (err)
        return handleCallback(callback, err);
      handleCallback(callback, null, doc);
    });
  }
  function insertDocuments(coll, docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    docs = Array.isArray(docs) ? docs : [docs];
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (finalOptions.keepGoing === true)
      finalOptions.ordered = false;
    finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    docs = prepareDocs(coll, docs, options);
    coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors)
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      result.ops = docs;
      handleCallback(callback, null, result);
    });
  }
  function removeDocuments(coll, selector, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {};
    } else if (typeof selector === "function") {
      callback = selector;
      options = {};
      selector = {};
    }
    options = options || {};
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (selector == null)
      selector = {};
    const op = {q: selector, limit: 0};
    if (options.single) {
      op.limit = 1;
    } else if (finalOptions.retryWrites) {
      finalOptions.retryWrites = false;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    try {
      decorateWithCollation(finalOptions, coll, options);
    } catch (err) {
      return callback(err, null);
    }
    if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
      return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
    }
    coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors) {
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      }
      handleCallback(callback, null, result);
    });
  }
  function updateDocuments(coll, selector, document2, options, callback) {
    if (typeof options === "function")
      callback = options, options = null;
    if (options == null)
      options = {};
    if (!(typeof callback === "function"))
      callback = null;
    if (selector == null || typeof selector !== "object")
      return callback(toError("selector must be a valid JavaScript object"));
    if (document2 == null || typeof document2 !== "object")
      return callback(toError("document must be a valid JavaScript object"));
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    const op = {q: selector, u: document2};
    op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
    op.multi = options.multi !== void 0 ? !!options.multi : false;
    if (options.hint) {
      op.hint = options.hint;
    }
    if (finalOptions.arrayFilters) {
      op.arrayFilters = finalOptions.arrayFilters;
      delete finalOptions.arrayFilters;
    }
    if (finalOptions.retryWrites && op.multi) {
      finalOptions.retryWrites = false;
    }
    try {
      decorateWithCollation(finalOptions, coll, options);
    } catch (err) {
      return callback(err, null);
    }
    if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
      return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
    }
    coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors)
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      handleCallback(callback, null, result);
    });
  }
  module2.exports = {
    buildCountCommand,
    findAndModify,
    indexInformation,
    nextObject,
    prepareDocs,
    insertDocuments,
    removeDocuments,
    updateDocuments
  };
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core2().BSON.Code;
  var createIndexDb = require_db_ops().createIndex;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var ensureIndexDb = require_db_ops().ensureIndex;
  var evaluate = require_db_ops().evaluate;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var indexInformationDb = require_db_ops().indexInformation;
  var Long2 = require_core2().BSON.Long;
  var MongoError = require_core2().MongoError;
  var ReadPreference = require_core2().ReadPreference;
  var insertDocuments = require_common_functions().insertDocuments;
  var updateDocuments = require_common_functions().updateDocuments;
  var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
  function createIndex(coll, fieldOrSpec, options, callback) {
    createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
  }
  function createIndexes(coll, indexSpecs, options, callback) {
    const capabilities = coll.s.topology.capabilities();
    for (let i = 0; i < indexSpecs.length; i++) {
      if (indexSpecs[i].name == null) {
        const keys = [];
        if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        for (let name in indexSpecs[i].key) {
          keys.push(`${name}_${indexSpecs[i].key[name]}`);
        }
        indexSpecs[i].name = keys.join("_");
      }
    }
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    executeCommand(coll.s.db, {
      createIndexes: coll.collectionName,
      indexes: indexSpecs
    }, options, callback);
  }
  function ensureIndex(coll, fieldOrSpec, options, callback) {
    ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
  }
  function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {
    if (command) {
      const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
      const selector = {
        group: {
          ns: coll.collectionName,
          $reduce: reduceFunction,
          cond: condition,
          initial,
          out: "inline"
        }
      };
      if (finalize != null)
        selector.group["finalize"] = finalize;
      if (typeof keys === "function" || keys && keys._bsontype === "Code") {
        selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
      } else {
        const hash = {};
        keys.forEach((key) => {
          hash[key] = 1;
        });
        selector.group.key = hash;
      }
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      decorateWithReadConcern(selector, coll, options);
      try {
        decorateWithCollation(selector, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, selector, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result.retval);
      });
    } else {
      const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
      scope.ns = coll.collectionName;
      scope.keys = keys;
      scope.condition = condition;
      scope.initial = initial;
      const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
      evaluate(coll.s.db, new Code2(groupfn, scope), null, options, (err, results) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, results.result || results);
      });
    }
  }
  function indexes(coll, options, callback) {
    options = Object.assign({}, {full: true}, options);
    indexInformationDb(coll.s.db, coll.collectionName, options, callback);
  }
  function indexExists(coll, indexes2, options, callback) {
    indexInformation(coll, options, (err, indexInformation2) => {
      if (err != null)
        return handleCallback(callback, err, null);
      if (!Array.isArray(indexes2))
        return handleCallback(callback, null, indexInformation2[indexes2] != null);
      for (let i = 0; i < indexes2.length; i++) {
        if (indexInformation2[indexes2[i]] == null) {
          return handleCallback(callback, null, false);
        }
      }
      return handleCallback(callback, null, true);
    });
  }
  function indexInformation(coll, options, callback) {
    indexInformationDb(coll.s.db, coll.collectionName, options, callback);
  }
  function parallelCollectionScan(coll, options, callback) {
    const commandObject = {
      parallelCollectionScan: coll.collectionName,
      numCursors: options.numCursors
    };
    decorateWithReadConcern(commandObject, coll, options);
    const raw = options.raw;
    delete options["raw"];
    executeCommand(coll.s.db, commandObject, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
      options = Object.assign({explicitlyIgnoreSession: true}, options);
      const cursors = [];
      if (raw)
        options.raw = raw;
      for (let i = 0; i < result.cursors.length; i++) {
        const rawId = result.cursors[i].cursor.id;
        const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
        cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));
      }
      handleCallback(callback, null, cursors);
    });
  }
  function save(coll, doc, options, callback) {
    const finalOptions = applyWriteConcern(Object.assign({}, options), {db: coll.s.db, collection: coll}, options);
    if (doc._id != null) {
      finalOptions.upsert = true;
      return updateDocuments(coll, {_id: doc._id}, doc, finalOptions, callback);
    }
    insertDocuments(coll, [doc], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (doc == null)
        return handleCallback(callback, null, null);
      if (err)
        return handleCallback(callback, err, null);
      handleCallback(callback, null, result);
    });
  }
  module2.exports = {
    createIndex,
    createIndexes,
    ensureIndex,
    group,
    indexes,
    indexExists,
    indexInformation,
    parallelCollectionScan,
    save
  };
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS((exports2, module2) => {
  "use strict";
  var buildCountCommand = require_collection_ops().buildCountCommand;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var push = Array.prototype.push;
  var CursorState = require_cursor().CursorState;
  function count(cursor, applySkipLimit, opts, callback) {
    if (applySkipLimit) {
      if (typeof cursor.cursorSkip() === "number")
        opts.skip = cursor.cursorSkip();
      if (typeof cursor.cursorLimit() === "number")
        opts.limit = cursor.cursorLimit();
    }
    if (opts.readPreference) {
      cursor.setReadPreference(opts.readPreference);
    }
    if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
      opts.maxTimeMS = cursor.cmd.maxTimeMS;
    }
    let options = {};
    options.skip = opts.skip;
    options.limit = opts.limit;
    options.hint = opts.hint;
    options.maxTimeMS = opts.maxTimeMS;
    options.collectionName = cursor.namespace.collection;
    let command;
    try {
      command = buildCountCommand(cursor, cursor.cmd.query, options);
    } catch (err) {
      return callback(err);
    }
    cursor.server = cursor.topology.s.coreTopology;
    cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
      callback(err, result ? result.result.n : null);
    });
  }
  function each(cursor, callback) {
    if (!callback)
      throw MongoError.create({message: "callback is mandatory", driver: true});
    if (cursor.isNotified())
      return;
    if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
      return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
    }
    if (cursor.s.state === CursorState.INIT) {
      cursor.s.state = CursorState.OPEN;
    }
    let fn = null;
    if (cursor.bufferedCount() > 0) {
      while (fn = loop(cursor, callback))
        fn(cursor, callback);
      each(cursor, callback);
    } else {
      cursor.next((err, item) => {
        if (err)
          return handleCallback(callback, err);
        if (item == null) {
          return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, null));
        }
        if (handleCallback(callback, null, item) === false)
          return;
        each(cursor, callback);
      });
    }
  }
  function loop(cursor, callback) {
    if (cursor.bufferedCount() === 0)
      return;
    cursor._next(callback);
    return loop;
  }
  function toArray(cursor, callback) {
    const items = [];
    cursor.rewind();
    cursor.s.state = CursorState.INIT;
    const fetchDocs = () => {
      cursor._next((err, doc) => {
        if (err) {
          return handleCallback(callback, err);
        }
        if (doc == null) {
          return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, items));
        }
        items.push(doc);
        if (cursor.bufferedCount() > 0) {
          let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
          if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
            docs = docs.map(cursor.s.transforms.doc);
          }
          push.apply(items, docs);
        }
        fetchDocs();
      });
    };
    fetchDocs();
  }
  module2.exports = {count, each, toArray};
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports2, module2) => {
  "use strict";
  var buildCountCommand = require_common_functions().buildCountCommand;
  var OperationBase = require_operation().OperationBase;
  var CountOperation = class extends OperationBase {
    constructor(cursor, applySkipLimit, options) {
      super(options);
      this.cursor = cursor;
      this.applySkipLimit = applySkipLimit;
    }
    execute(callback) {
      const cursor = this.cursor;
      const applySkipLimit = this.applySkipLimit;
      const options = this.options;
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          options.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          options.limit = cursor.cursorLimit();
      }
      if (options.readPreference) {
        cursor.setReadPreference(options.readPreference);
      }
      if (typeof options.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        options.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let finalOptions = {};
      finalOptions.skip = options.skip;
      finalOptions.limit = options.limit;
      finalOptions.hint = options.hint;
      finalOptions.maxTimeMS = options.maxTimeMS;
      finalOptions.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
  };
  module2.exports = CountOperation;
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS((exports2, module2) => {
  "use strict";
  var Transform = require("stream").Transform;
  var PassThrough = require("stream").PassThrough;
  var deprecate = require("util").deprecate;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core2().ReadPreference;
  var MongoError = require_core2().MongoError;
  var CoreCursor = require_cursor().CoreCursor;
  var CursorState = require_cursor().CursorState;
  var Map2 = require_core2().BSON.Map;
  var maybePromise = require_utils4().maybePromise;
  var executeOperation = require_execute_operation();
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var Explain = require_explain().Explain;
  var Aspect = require_operation().Aspect;
  var each = require_cursor_ops().each;
  var CountOperation = require_count();
  var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
  var fields = ["numberOfRetries", "tailableRetryInterval"];
  var Cursor = class extends CoreCursor {
    constructor(topology, ns, cmd, options) {
      super(topology, ns, cmd, options);
      if (this.operation) {
        options = this.operation.options;
      }
      const numberOfRetries = options.numberOfRetries || 5;
      const tailableRetryInterval = options.tailableRetryInterval || 500;
      const currentNumberOfRetries = numberOfRetries;
      const promiseLibrary = options.promiseLibrary || Promise;
      this.s = {
        numberOfRetries,
        tailableRetryInterval,
        currentNumberOfRetries,
        state: CursorState.INIT,
        promiseLibrary,
        explicitlyIgnoreSession: !!options.explicitlyIgnoreSession
      };
      if (!options.explicitlyIgnoreSession && options.session) {
        this.cursorState.session = options.session;
      }
      if (this.options.noCursorTimeout === true) {
        this.addCursorFlag("noCursorTimeout", true);
      }
      let batchSize = 1e3;
      if (this.cmd.cursor && this.cmd.cursor.batchSize) {
        batchSize = this.cmd.cursor.batchSize;
      } else if (options.cursor && options.cursor.batchSize) {
        batchSize = options.cursor.batchSize;
      } else if (typeof options.batchSize === "number") {
        batchSize = options.batchSize;
      }
      this.setCursorBatchSize(batchSize);
    }
    get readPreference() {
      if (this.operation) {
        return this.operation.readPreference;
      }
      return this.options.readPreference;
    }
    get sortValue() {
      return this.cmd.sort;
    }
    _initializeCursor(callback) {
      if (this.operation && this.operation.session != null) {
        this.cursorState.session = this.operation.session;
      } else {
        if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
          this.cursorState.session = this.topology.startSession({owner: this});
          if (this.operation) {
            this.operation.session = this.cursorState.session;
          }
        }
      }
      super._initializeCursor(callback);
    }
    hasNext(callback) {
      if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        if (cursor.isNotified()) {
          return cb(null, false);
        }
        cursor._next((err, doc) => {
          if (err)
            return cb(err);
          if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
            return cb(null, false);
          }
          cursor.s.state = CursorState.OPEN;
          cursor.cursorState.cursorIndex--;
          if (cursor.cursorState.limit > 0) {
            cursor.cursorState.currentLimit--;
          }
          cb(null, true);
        });
      });
    }
    next(callback) {
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
          cb(MongoError.create({message: "Cursor is closed", driver: true}));
          return;
        }
        if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
          try {
            cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
          } catch (err) {
            return cb(err);
          }
        }
        cursor._next((err, doc) => {
          if (err)
            return cb(err);
          cursor.s.state = CursorState.OPEN;
          cb(null, doc);
        });
      });
    }
    filter(filter) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.query = filter;
      return this;
    }
    maxScan(maxScan) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxScan = maxScan;
      return this;
    }
    hint(hint) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.hint = hint;
      return this;
    }
    min(min) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.min = min;
      return this;
    }
    max(max) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.max = max;
      return this;
    }
    returnKey(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.returnKey = value;
      return this;
    }
    showRecordId(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.showDiskLoc = value;
      return this;
    }
    snapshot(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.snapshot = value;
      return this;
    }
    setCursorOption(field, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (fields.indexOf(field) === -1) {
        throw MongoError.create({
          message: `option ${field} is not a supported option ${fields}`,
          driver: true
        });
      }
      this.s[field] = value;
      if (field === "numberOfRetries")
        this.s.currentNumberOfRetries = value;
      return this;
    }
    addCursorFlag(flag, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (flags.indexOf(flag) === -1) {
        throw MongoError.create({
          message: `flag ${flag} is not a supported flag ${flags}`,
          driver: true
        });
      }
      if (typeof value !== "boolean") {
        throw MongoError.create({message: `flag ${flag} must be a boolean value`, driver: true});
      }
      this.cmd[flag] = value;
      return this;
    }
    addQueryModifier(name, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (name[0] !== "$") {
        throw MongoError.create({message: `${name} is not a valid query modifier`, driver: true});
      }
      const field = name.substr(1);
      this.cmd[field] = value;
      if (field === "orderby")
        this.cmd.sort = this.cmd[field];
      return this;
    }
    comment(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.comment = value;
      return this;
    }
    maxAwaitTimeMS(value) {
      if (typeof value !== "number") {
        throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxAwaitTimeMS = value;
      return this;
    }
    maxTimeMS(value) {
      if (typeof value !== "number") {
        throw MongoError.create({message: "maxTimeMS must be a number", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxTimeMS = value;
      return this;
    }
    project(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.fields = value;
      return this;
    }
    sort(keyOrList, direction) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      let order = keyOrList;
      if (Array.isArray(order) && Array.isArray(order[0])) {
        order = new Map2(order.map((x) => {
          const value = [x[0], null];
          if (x[1] === "asc") {
            value[1] = 1;
          } else if (x[1] === "desc") {
            value[1] = -1;
          } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
            value[1] = x[1];
          } else {
            throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
          }
          return value;
        }));
      }
      if (direction != null) {
        order = [[keyOrList, direction]];
      }
      this.cmd.sort = order;
      return this;
    }
    batchSize(value) {
      if (this.options.tailable) {
        throw MongoError.create({
          message: "Tailable cursor doesn't support batchSize",
          driver: true
        });
      }
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      this.cmd.batchSize = value;
      this.setCursorBatchSize(value);
      return this;
    }
    collation(value) {
      this.cmd.collation = value;
      return this;
    }
    limit(value) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support limit", driver: true});
      }
      if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "limit requires an integer", driver: true});
      }
      this.cmd.limit = value;
      this.setCursorLimit(value);
      return this;
    }
    skip(value) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support skip", driver: true});
      }
      if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "skip requires an integer", driver: true});
      }
      this.cmd.skip = value;
      this.setCursorSkip(value);
      return this;
    }
    each(callback) {
      this.rewind();
      this.s.state = CursorState.INIT;
      each(this, callback);
    }
    forEach(iterator, callback) {
      this.rewind();
      this.s.state = CursorState.INIT;
      if (typeof callback === "function") {
        each(this, (err, doc) => {
          if (err) {
            callback(err);
            return false;
          }
          if (doc != null) {
            iterator(doc);
            return true;
          }
          if (doc == null && callback) {
            const internalCallback = callback;
            callback = null;
            internalCallback(null);
            return false;
          }
        });
      } else {
        return new this.s.promiseLibrary((fulfill, reject) => {
          each(this, (err, doc) => {
            if (err) {
              reject(err);
              return false;
            } else if (doc == null) {
              fulfill(null);
              return false;
            } else {
              iterator(doc);
              return true;
            }
          });
        });
      }
    }
    setReadPreference(readPreference) {
      if (this.s.state !== CursorState.INIT) {
        throw MongoError.create({
          message: "cannot change cursor readPreference after cursor has been accessed",
          driver: true
        });
      }
      if (readPreference instanceof ReadPreference) {
        this.options.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.options.readPreference = new ReadPreference(readPreference);
      } else {
        throw new TypeError("Invalid read preference: " + readPreference);
      }
      return this;
    }
    toArray(callback) {
      if (this.options.tailable) {
        throw MongoError.create({
          message: "Tailable cursor cannot be converted to array",
          driver: true
        });
      }
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        const items = [];
        cursor.rewind();
        cursor.s.state = CursorState.INIT;
        const fetchDocs = () => {
          cursor._next((err, doc) => {
            if (err) {
              return handleCallback(cb, err);
            }
            if (doc == null) {
              return cursor.close({skipKillCursors: true}, () => handleCallback(cb, null, items));
            }
            items.push(doc);
            if (cursor.bufferedCount() > 0) {
              let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
              Array.prototype.push.apply(items, docs);
            }
            fetchDocs();
          });
        };
        fetchDocs();
      });
    }
    count(applySkipLimit, opts, callback) {
      if (this.cmd.query == null)
        throw MongoError.create({
          message: "count can only be used with find command",
          driver: true
        });
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      if (typeof applySkipLimit === "function") {
        callback = applySkipLimit;
        applySkipLimit = true;
      }
      if (this.cursorState.session) {
        opts = Object.assign({}, opts, {session: this.cursorState.session});
      }
      const countOperation = new CountOperation(this, applySkipLimit, opts);
      return executeOperation(this.topology, countOperation, callback);
    }
    close(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, {skipKillCursors: false}, options);
      return maybePromise(this, callback, (cb) => {
        this.s.state = CursorState.CLOSED;
        if (!options.skipKillCursors) {
          this.kill();
        }
        this._endSession(() => {
          this.emit("close");
          cb(null, this);
        });
      });
    }
    map(transform) {
      if (this.cursorState.transforms && this.cursorState.transforms.doc) {
        const oldTransform = this.cursorState.transforms.doc;
        this.cursorState.transforms.doc = (doc) => {
          return transform(oldTransform(doc));
        };
      } else {
        this.cursorState.transforms = {doc: transform};
      }
      return this;
    }
    isClosed() {
      return this.isDead();
    }
    destroy(err) {
      if (err)
        this.emit("error", err);
      this.pause();
      this.close();
    }
    stream(options) {
      this.cursorState.streamOptions = options || {};
      return this;
    }
    transformStream(options) {
      const streamOptions = options || {};
      if (typeof streamOptions.transform === "function") {
        const stream = new Transform({
          objectMode: true,
          transform: function(chunk, encoding, callback) {
            this.push(streamOptions.transform(chunk));
            callback();
          }
        });
        return this.pipe(stream);
      }
      return this.pipe(new PassThrough({objectMode: true}));
    }
    explain(verbosity, callback) {
      if (typeof verbosity === "function")
        callback = verbosity, verbosity = true;
      if (verbosity === void 0)
        verbosity = true;
      if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
        throw new MongoError("This command cannot be explained");
      }
      this.operation.explain = new Explain(verbosity);
      return maybePromise(this, callback, (cb) => {
        CoreCursor.prototype._next.apply(this, [cb]);
      });
    }
    getLogger() {
      return this.logger;
    }
  };
  Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
  deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
  deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
  deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
  module2.exports = Cursor;
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_core2().ReadPreference;
  var ReadConcern = require_read_concern();
  var WriteConcern = require_write_concern();
  var maxWireVersion = require_utils2().maxWireVersion;
  var decorateWithExplain = require_utils4().decorateWithExplain;
  var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
  var MongoError = require_error().MongoError;
  var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
  var CommandOperationV2 = class extends OperationBase {
    constructor(parent, options, operationOptions) {
      super(options);
      this.ns = parent.s.namespace.withCollection("$cmd");
      const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
      this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
      this.readConcern = resolveReadConcern(propertyProvider, this.options);
      this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
      if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
        this.fullResponse = true;
      }
      this.options.readPreference = this.readPreference;
      if (parent.s.logger) {
        this.logger = parent.s.logger;
      } else if (parent.s.db && parent.s.db.logger) {
        this.logger = parent.s.db.logger;
      }
    }
    executeCommand(server, cmd, callback) {
      this.server = server;
      const options = this.options;
      const serverWireVersion = maxWireVersion(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
        Object.assign(cmd, {readConcern: this.readConcern});
      }
      if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
        return;
      }
      if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
          Object.assign(cmd, {writeConcern: this.writeConcern});
        }
        if (options.collation && typeof options.collation === "object") {
          Object.assign(cmd, {collation: options.collation});
        }
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment === "string") {
        cmd.comment = options.comment;
      }
      if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
        if (serverWireVersion < 6 && cmd.aggregate) {
          cmd.explain = true;
        } else {
          cmd = decorateWithExplain(cmd, this.explain);
        }
      }
      if (this.logger && this.logger.isDebug()) {
        this.logger.debug(`executing command ${JSON.stringify(cmd)} against ${this.ns}`);
      }
      server.command(this.ns.toString(), cmd, this.options, (err, result) => {
        if (err) {
          callback(err, null);
          return;
        }
        if (this.fullResponse) {
          callback(null, result);
          return;
        }
        callback(null, result.result);
      });
    }
  };
  function resolveWriteConcern(parent, options) {
    return WriteConcern.fromOptions(options) || parent && parent.writeConcern;
  }
  function resolveReadConcern(parent, options) {
    return ReadConcern.fromOptions(options) || parent && parent.readConcern;
  }
  module2.exports = CommandOperationV2;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var MongoError = require_core2().MongoError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var ReadPreference = require_core2().ReadPreference;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
  var AggregateOperation = class extends CommandOperationV2 {
    constructor(parent, pipeline, options) {
      super(parent, options, {fullResponse: true});
      this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline;
      this.hasWriteStage = false;
      if (typeof options.out === "string") {
        this.pipeline = this.pipeline.concat({$out: options.out});
        this.hasWriteStage = true;
      } else if (pipeline.length > 0) {
        const finalStage = pipeline[pipeline.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.readPreference = ReadPreference.primary;
      }
      if (this.explain && this.writeConcern) {
        throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
      }
      if (options.cursor != null && typeof options.cursor !== "object") {
        throw new MongoError("cursor options must be an object");
      }
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    execute(server, callback) {
      const options = this.options;
      const serverWireVersion = maxWireVersion(server);
      const command = {aggregate: this.target, pipeline: this.pipeline};
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = null;
      }
      if (serverWireVersion >= 5) {
        if (this.hasWriteStage && this.writeConcern) {
          Object.assign(command, {writeConcern: this.writeConcern});
        }
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (this.explain) {
        options.full = false;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      super.executeCommand(server, command, callback);
    }
  };
  defineAspects(AggregateOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION,
    Aspect.EXPLAINABLE
  ]);
  module2.exports = AggregateOperation;
});

// node_modules/mongodb/lib/bulk/common.js
var require_common3 = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_core2().BSON.Long;
  var MongoError = require_core2().MongoError;
  var ObjectID2 = require_core2().BSON.ObjectID;
  var BSON2 = require_core2().BSON;
  var MongoWriteConcernError = require_core2().MongoWriteConcernError;
  var toError = require_utils4().toError;
  var handleCallback = require_utils4().handleCallback;
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var isPromiseLike = require_utils4().isPromiseLike;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var maxWireVersion = require_utils2().maxWireVersion;
  var WRITE_CONCERN_ERROR = 64;
  var INSERT = 1;
  var UPDATE = 2;
  var REMOVE = 3;
  var bson = new BSON2([
    BSON2.Binary,
    BSON2.Code,
    BSON2.DBRef,
    BSON2.Decimal128,
    BSON2.Double,
    BSON2.Int32,
    BSON2.Long,
    BSON2.Map,
    BSON2.MaxKey,
    BSON2.MinKey,
    BSON2.ObjectId,
    BSON2.BSONRegExp,
    BSON2.Symbol,
    BSON2.Timestamp
  ]);
  var Batch = class {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  };
  var BulkWriteResult = class {
    constructor(bulkResult) {
      this.result = bulkResult;
    }
    get ok() {
      return this.result.ok;
    }
    get nInserted() {
      return this.result.nInserted;
    }
    get nUpserted() {
      return this.result.nUpserted;
    }
    get nMatched() {
      return this.result.nMatched;
    }
    get nModified() {
      return this.result.nModified;
    }
    get nRemoved() {
      return this.result.nRemoved;
    }
    getInsertedIds() {
      return this.result.insertedIds;
    }
    getUpsertedIds() {
      return this.result.upserted;
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      if (index < this.result.writeErrors.length) {
        return this.result.writeErrors[index];
      }
      return null;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getLastOp() {
      return this.result.lastOp;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return null;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
          const err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg;
          if (i === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({errmsg, code: WRITE_CONCERN_ERROR});
      }
    }
    toJSON() {
      return this.result;
    }
    toString() {
      return `BulkWriteResult(${this.toJSON(this.result)})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  };
  var WriteConcernError = class {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    toJSON() {
      return {code: this.err.code, errmsg: this.err.errmsg};
    }
    toString() {
      return `WriteConcernError(${this.err.errmsg})`;
    }
  };
  var WriteError = class {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return {code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op};
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  };
  function mergeBatchResults(batch, bulkResult, err, result) {
    if (err) {
      result = err;
    } else if (result && result.result) {
      result = result.result;
    } else if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (result.opTime || result.lastOp) {
      const opTime = result.lastOp || result.opTime;
      let lastOpTS = null;
      let lastOpT = null;
      if (opTime && opTime._bsontype === "Timestamp") {
        if (bulkResult.lastOp == null) {
          bulkResult.lastOp = opTime;
        } else if (opTime.greaterThan(bulkResult.lastOp)) {
          bulkResult.lastOp = opTime;
        }
      } else {
        if (bulkResult.lastOp) {
          lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
          lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
        }
        const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
        const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
        if (bulkResult.lastOp == null) {
          bulkResult.lastOp = opTime;
        } else if (opTimeTS.greaterThan(lastOpTS)) {
          bulkResult.lastOp = opTime;
        } else if (opTimeTS.equals(lastOpTS)) {
          if (opTimeT.greaterThan(lastOpT)) {
            bulkResult.lastOp = opTime;
          }
        }
      }
    }
    if (batch.batchType === INSERT && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (batch.batchType === REMOVE && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i = 0; i < result.upserted.length; i++) {
        bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex,
          _id: result.upserted[i]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (batch.batchType === UPDATE && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = null;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i = 0; i < result.writeErrors.length; i++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i].index],
          code: result.writeErrors[i].code,
          errmsg: result.writeErrors[i].errmsg,
          op: batch.operations[result.writeErrors[i].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  }
  function executeCommands(bulkOperation, options, callback) {
    if (bulkOperation.s.batches.length === 0) {
      return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
    }
    const batch = bulkOperation.s.batches.shift();
    function resultHandler(err, result) {
      if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
        return handleCallback(callback, err);
      }
      if (err)
        err.ok = 0;
      if (err instanceof MongoWriteConcernError) {
        return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
      }
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
      const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
      if (mergeResult != null) {
        return handleCallback(callback, null, writeResult);
      }
      if (bulkOperation.handleWriteError(callback, writeResult))
        return;
      executeCommands(bulkOperation, options, callback);
    }
    bulkOperation.finalOptionsHandler({options, batch, resultHandler}, callback);
  }
  function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
    mergeBatchResults(batch, bulkResult, null, err.result);
    const wrappedWriteConcernError = new WriteConcernError({
      errmsg: err.result.writeConcernError.errmsg,
      code: err.result.writeConcernError.result
    });
    return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
  }
  var BulkWriteError = class extends MongoError {
    constructor(error, result) {
      const message = error.err || error.errmsg || error.errMessage || error;
      super(message);
      Object.assign(this, error);
      this.name = "BulkWriteError";
      this.result = result;
    }
  };
  var FindOperators = class {
    constructor(bulkOperation) {
      this.s = bulkOperation.s;
    }
    update(updateDocument) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: updateDocument,
        multi: true,
        upsert
      };
      if (updateDocument.hint) {
        document2.hint = updateDocument.hint;
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    updateOne(updateDocument) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: updateDocument,
        multi: false,
        upsert
      };
      if (updateDocument.hint) {
        document2.hint = updateDocument.hint;
      }
      if (!hasAtomicOperators(updateDocument)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    replaceOne(replacement) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: replacement,
        multi: false,
        upsert
      };
      if (replacement.hint) {
        document2.hint = replacement.hint;
      }
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not use atomic operators");
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    upsert() {
      this.s.currentOp.upsert = true;
      return this;
    }
    deleteOne() {
      const document2 = {
        q: this.s.currentOp.selector,
        limit: 1
      };
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, REMOVE, document2);
    }
    delete() {
      const document2 = {
        q: this.s.currentOp.selector,
        limit: 0
      };
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, REMOVE, document2);
    }
    removeOne() {
      return this.deleteOne();
    }
    remove() {
      return this.delete();
    }
  };
  var BulkOperationBase = class {
    constructor(topology, collection, options, isOrdered) {
      this.isOrdered = isOrdered;
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = null;
      const bson2 = topology.bson;
      const isMaster = topology.lastIsMaster();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
      finalOptions = applyWriteConcern(finalOptions, {collection}, options);
      const writeConcern = finalOptions.writeConcern;
      const promiseLibrary = options.promiseLibrary || Promise;
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: null,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: null,
        currentUpdateBatch: null,
        currentRemoveBatch: null,
        batches: [],
        writeConcern,
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        bson: bson2,
        topology,
        options: finalOptions,
        currentOp,
        executed,
        collection,
        promiseLibrary,
        err: null,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : true
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document2) {
      if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
        document2._id = new ObjectID2();
      return this.s.options.addToOperationsList(this, INSERT, document2);
    }
    find(selector) {
      if (!selector) {
        throw toError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      const key = Object.keys(op)[0];
      const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
      if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
        op[key].multi = op.updateOne || op.replaceOne ? false : true;
        return this.s.options.addToOperationsList(this, UPDATE, op[key]);
      }
      if (op.updateOne || op.updateMany || op.replaceOne) {
        if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        const multi = op.updateOne || op.replaceOne ? false : true;
        const operation = {
          q: op[key].filter,
          u: op[key].update || op[key].replacement,
          multi
        };
        if (op[key].hint) {
          operation.hint = op[key].hint;
        }
        if (this.isOrdered) {
          operation.upsert = op[key].upsert ? true : false;
          if (op.collation)
            operation.collation = op.collation;
        } else {
          if (op[key].upsert)
            operation.upsert = true;
        }
        if (op[key].arrayFilters) {
          if (maxWireVersion(this.s.topology) < 6) {
            throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
          }
          operation.arrayFilters = op[key].arrayFilters;
        }
        return this.s.options.addToOperationsList(this, UPDATE, operation);
      }
      if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
        op[key].limit = op.removeOne ? 1 : 0;
        return this.s.options.addToOperationsList(this, REMOVE, op[key]);
      }
      if (op.deleteOne || op.deleteMany) {
        const limit = op.deleteOne ? 1 : 0;
        const operation = {q: op[key].filter, limit};
        if (op[key].hint) {
          operation.hint = op[key].hint;
        }
        if (this.isOrdered) {
          if (op.collation)
            operation.collation = op.collation;
        }
        return this.s.options.addToOperationsList(this, REMOVE, operation);
      }
      if (op.insertOne && op.insertOne.document == null) {
        if (forceServerObjectId !== true && op.insertOne._id == null)
          op.insertOne._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
      } else if (op.insertOne && op.insertOne.document) {
        if (forceServerObjectId !== true && op.insertOne.document._id == null)
          op.insertOne.document._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
      }
      if (op.insertMany) {
        for (let i = 0; i < op.insertMany.length; i++) {
          if (forceServerObjectId !== true && op.insertMany[i]._id == null)
            op.insertMany[i]._id = new ObjectID2();
          this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
        }
        return;
      }
      throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
    }
    _handleEarlyError(err, callback) {
      if (typeof callback === "function") {
        callback(err, null);
        return;
      }
      return this.s.promiseLibrary.reject(err);
    }
    bulkExecute(_writeConcern, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (typeof _writeConcern === "function") {
        callback = _writeConcern;
      } else if (_writeConcern && typeof _writeConcern === "object") {
        this.s.writeConcern = _writeConcern;
      }
      if (this.s.executed) {
        const executedError = toError("batch cannot be re-executed");
        return this._handleEarlyError(executedError, callback);
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        const emptyBatchError = toError("Invalid Operation, no operations specified");
        return this._handleEarlyError(emptyBatchError, callback);
      }
      return {options, callback};
    }
    execute(_writeConcern, options, callback) {
      const ret = this.bulkExecute(_writeConcern, options, callback);
      if (!ret || isPromiseLike(ret)) {
        return ret;
      }
      options = ret.options;
      callback = ret.callback;
      return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);
    }
    finalOptionsHandler(config, callback) {
      const finalOptions = Object.assign({ordered: this.isOrdered}, config.options);
      if (this.s.writeConcern != null) {
        finalOptions.writeConcern = this.s.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation !== true) {
        delete finalOptions.bypassDocumentValidation;
      }
      if (this.operationId) {
        config.resultHandler.operationId = this.operationId;
      }
      if (this.s.options.serializeFunctions) {
        finalOptions.serializeFunctions = true;
      }
      if (this.s.options.ignoreUndefined) {
        finalOptions.ignoreUndefined = true;
      }
      if (this.s.bypassDocumentValidation === true) {
        finalOptions.bypassDocumentValidation = true;
      }
      if (this.s.checkKeys === false) {
        finalOptions.checkKeys = false;
      }
      if (finalOptions.retryWrites) {
        if (config.batch.batchType === UPDATE) {
          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
        }
        if (config.batch.batchType === REMOVE) {
          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
        }
      }
      try {
        if (config.batch.batchType === INSERT) {
          this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        } else if (config.batch.batchType === UPDATE) {
          this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        } else if (config.batch.batchType === REMOVE) {
          this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        }
      } catch (err) {
        err.ok = 0;
        handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
      }
    }
    handleWriteError(callback, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        handleCallback(callback, new BulkWriteError(toError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }), writeResult), null);
        return true;
      }
      if (writeResult.getWriteConcernError()) {
        handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
        return true;
      }
    }
  };
  Object.defineProperty(BulkOperationBase.prototype, "length", {
    enumerable: true,
    get: function() {
      return this.s.currentIndex;
    }
  });
  module2.exports = {
    Batch,
    BulkOperationBase,
    bson,
    INSERT,
    UPDATE,
    REMOVE,
    BulkWriteError
  };
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common3();
  var BulkOperationBase = common.BulkOperationBase;
  var Batch = common.Batch;
  var bson = common.bson;
  var utils2 = require_utils4();
  var toError = utils2.toError;
  function addToOperationsList(bulkOperation, docType, document2) {
    const bsonSize = bson.calculateObjectSize(document2, {
      checkKeys: false,
      ignoreUndefined: false
    });
    if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
      throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
    bulkOperation.s.currentBatch = null;
    if (docType === common.INSERT) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
    } else if (docType === common.UPDATE) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
    } else if (docType === common.REMOVE) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
    }
    const maxKeySize = bulkOperation.s.maxKeySize;
    if (bulkOperation.s.currentBatch == null)
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
      bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    }
    if (Array.isArray(document2)) {
      throw toError("operation passed in cannot be an Array");
    }
    bulkOperation.s.currentBatch.operations.push(document2);
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
    if (docType === common.INSERT) {
      bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
      bulkOperation.s.bulkResult.insertedIds.push({
        index: bulkOperation.s.bulkResult.insertedIds.length,
        _id: document2._id
      });
    } else if (docType === common.UPDATE) {
      bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
    } else if (docType === common.REMOVE) {
      bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
    }
    bulkOperation.s.currentBatch.size += 1;
    bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
    return bulkOperation;
  }
  var UnorderedBulkOperation = class extends BulkOperationBase {
    constructor(topology, collection, options) {
      options = options || {};
      options = Object.assign(options, {addToOperationsList});
      super(topology, collection, options, false);
    }
    handleWriteError(callback, writeResult) {
      if (this.s.batches.length) {
        return false;
      }
      return super.handleWriteError(callback, writeResult);
    }
  };
  function initializeUnorderedBulkOp(topology, collection, options) {
    return new UnorderedBulkOperation(topology, collection, options);
  }
  initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
  module2.exports = initializeUnorderedBulkOp;
  module2.exports.Bulk = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common3();
  var BulkOperationBase = common.BulkOperationBase;
  var Batch = common.Batch;
  var bson = common.bson;
  var utils2 = require_utils4();
  var toError = utils2.toError;
  function addToOperationsList(bulkOperation, docType, document2) {
    const bsonSize = bson.calculateObjectSize(document2, {
      checkKeys: false,
      ignoreUndefined: false
    });
    if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
      throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
    if (bulkOperation.s.currentBatch == null)
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    const maxKeySize = bulkOperation.s.maxKeySize;
    if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
      bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatchSize = 0;
      bulkOperation.s.currentBatchSizeBytes = 0;
    }
    if (docType === common.INSERT) {
      bulkOperation.s.bulkResult.insertedIds.push({
        index: bulkOperation.s.currentIndex,
        _id: document2._id
      });
    }
    if (Array.isArray(document2)) {
      throw toError("operation passed in cannot be an Array");
    }
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentBatch.operations.push(document2);
    bulkOperation.s.currentBatchSize += 1;
    bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
    bulkOperation.s.currentIndex += 1;
    return bulkOperation;
  }
  var OrderedBulkOperation = class extends BulkOperationBase {
    constructor(topology, collection, options) {
      options = options || {};
      options = Object.assign(options, {addToOperationsList});
      super(topology, collection, options, true);
    }
  };
  function initializeOrderedBulkOp(topology, collection, options) {
    return new OrderedBulkOperation(topology, collection, options);
  }
  initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
  module2.exports = initializeOrderedBulkOp;
  module2.exports.Bulk = OrderedBulkOperation;
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_core2().MongoError;
  var Cursor = require_cursor2();
  var CursorState = require_cursor().CursorState;
  var AggregationCursor = class extends Cursor {
    constructor(topology, operation, options) {
      super(topology, operation, options);
    }
    batchSize(value) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      this.operation.options.batchSize = value;
      this.setCursorBatchSize(value);
      return this;
    }
    geoNear(document2) {
      this.operation.addToPipeline({$geoNear: document2});
      return this;
    }
    group(document2) {
      this.operation.addToPipeline({$group: document2});
      return this;
    }
    limit(value) {
      this.operation.addToPipeline({$limit: value});
      return this;
    }
    match(document2) {
      this.operation.addToPipeline({$match: document2});
      return this;
    }
    maxTimeMS(value) {
      this.operation.options.maxTimeMS = value;
      return this;
    }
    out(destination) {
      this.operation.addToPipeline({$out: destination});
      return this;
    }
    project(document2) {
      this.operation.addToPipeline({$project: document2});
      return this;
    }
    lookup(document2) {
      this.operation.addToPipeline({$lookup: document2});
      return this;
    }
    redact(document2) {
      this.operation.addToPipeline({$redact: document2});
      return this;
    }
    skip(value) {
      this.operation.addToPipeline({$skip: value});
      return this;
    }
    sort(document2) {
      this.operation.addToPipeline({$sort: document2});
      return this;
    }
    unwind(field) {
      this.operation.addToPipeline({$unwind: field});
      return this;
    }
    getLogger() {
      return this.logger;
    }
  };
  AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
  module2.exports = AggregationCursor;
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_core2().ReadPreference;
  var MongoError = require_core2().MongoError;
  var Cursor = require_cursor2();
  var CursorState = require_cursor().CursorState;
  var CommandCursor = class extends Cursor {
    constructor(topology, ns, cmd, options) {
      super(topology, ns, cmd, options);
    }
    setReadPreference(readPreference) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (this.s.state !== CursorState.INIT) {
        throw MongoError.create({
          message: "cannot change cursor readPreference after cursor has been accessed",
          driver: true
        });
      }
      if (readPreference instanceof ReadPreference) {
        this.options.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.options.readPreference = new ReadPreference(readPreference);
      } else {
        throw new TypeError("Invalid read preference: " + readPreference);
      }
      return this;
    }
    batchSize(value) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      if (this.cmd.cursor) {
        this.cmd.cursor.batchSize = value;
      }
      this.setCursorBatchSize(value);
      return this;
    }
    maxTimeMS(value) {
      if (this.topology.lastIsMaster().minWireVersion > 2) {
        this.cmd.maxTimeMS = value;
      }
      return this;
    }
    getLogger() {
      return this.logger;
    }
  };
  CommandCursor.prototype.get = CommandCursor.prototype.toArray;
  module2.exports = CommandCursor;
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports2, module2) => {
  "use strict";
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var MongoError = require_core2().MongoError;
  var OperationBase = require_operation().OperationBase;
  var BulkWriteOperation = class extends OperationBase {
    constructor(collection, operations, options) {
      super(options);
      this.collection = collection;
      this.operations = operations;
    }
    execute(callback) {
      const coll = this.collection;
      const operations = this.operations;
      let options = this.options;
      if (coll.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = coll.s.options.ignoreUndefined;
      }
      const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options);
      let collation = false;
      try {
        for (let i = 0; i < operations.length; i++) {
          const key = Object.keys(operations[i])[0];
          if (operations[i][key].collation) {
            collation = true;
          }
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback(err, null);
      }
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
      const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
      const capabilities = coll.s.topology.capabilities();
      if (collation && capabilities && !capabilities.commandsTakeCollation) {
        return callback(new MongoError("server/primary/mongos does not support collation"));
      }
      bulk.execute(writeCon, finalOptions, (err, r) => {
        if (!r && err) {
          return callback(err, null);
        }
        r.insertedCount = r.nInserted;
        r.matchedCount = r.nMatched;
        r.modifiedCount = r.nModified || 0;
        r.deletedCount = r.nRemoved;
        r.upsertedCount = r.getUpsertedIds().length;
        r.upsertedIds = {};
        r.insertedIds = {};
        r.n = r.insertedCount;
        const inserted = r.getInsertedIds();
        for (let i = 0; i < inserted.length; i++) {
          r.insertedIds[inserted[i].index] = inserted[i]._id;
        }
        const upserted = r.getUpsertedIds();
        for (let i = 0; i < upserted.length; i++) {
          r.upsertedIds[upserted[i].index] = upserted[i]._id;
        }
        callback(null, r);
      });
    }
  };
  module2.exports = BulkWriteOperation;
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS((exports2, module2) => {
  "use strict";
  var AggregateOperation = require_aggregate();
  var CountDocumentsOperation = class extends AggregateOperation {
    constructor(collection, query, options) {
      const pipeline = [{$match: query}];
      if (typeof options.skip === "number") {
        pipeline.push({$skip: options.skip});
      }
      if (typeof options.limit === "number") {
        pipeline.push({$limit: options.limit});
      }
      pipeline.push({$group: {_id: 1, n: {$sum: 1}}});
      super(collection, pipeline, options);
    }
    execute(server, callback) {
      super.execute(server, (err, result) => {
        if (err) {
          callback(err, null);
          return;
        }
        const response = result.result;
        if (response.cursor == null || response.cursor.firstBatch == null) {
          callback(null, 0);
          return;
        }
        const docs = response.cursor.firstBatch;
        callback(null, docs.length ? docs[0].n : 0);
      });
    }
  };
  module2.exports = CountDocumentsOperation;
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var MongoError = require_core2().MongoError;
  var parseIndexOptions = require_utils4().parseIndexOptions;
  var maxWireVersion = require_utils2().maxWireVersion;
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);
  var CreateIndexesOperation = class extends CommandOperationV2 {
    constructor(parent, collection, indexes, options) {
      super(parent, options);
      this.collection = collection;
      if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
        this.onlyReturnNameOfCreatedIndex = true;
        const indexParameters = parseIndexOptions(indexes);
        const name = typeof options.name === "string" ? options.name : indexParameters.name;
        const indexSpec = {name, key: indexParameters.fieldHash};
        for (let optionName in options) {
          if (VALID_INDEX_OPTIONS.has(optionName)) {
            indexSpec[optionName] = options[optionName];
          }
        }
        this.indexes = [indexSpec];
        return;
      }
      this.indexes = indexes;
    }
    execute(server, callback) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = maxWireVersion(server);
      for (let i = 0; i < indexes.length; i++) {
        if (indexes[i].collation && serverWireVersion < 5) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (indexes[i].name == null) {
          const keys = [];
          for (let name in indexes[i].key) {
            keys.push(`${name}_${indexes[i].key[name]}`);
          }
          indexes[i].name = keys.join("_");
        }
      }
      const cmd = {createIndexes: this.collection, indexes};
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
          return;
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = void 0;
      super.executeCommand(server, cmd, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
      });
    }
  };
  defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
  module2.exports = CreateIndexesOperation;
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var removeDocuments = require_common_functions().removeDocuments;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DeleteManyOperation = class extends OperationBase {
    constructor(collection, filter, options) {
      super(options);
      this.collection = collection;
      this.filter = filter;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const options = this.options;
      options.single = false;
      removeDocuments(coll, filter, options, (err, r) => {
        if (callback == null)
          return;
        if (err && callback)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        if (this.explain)
          return callback(void 0, r.result);
        r.deletedCount = r.result.n;
        callback(null, r);
      });
    }
  };
  defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
  module2.exports = DeleteManyOperation;
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var removeDocuments = require_common_functions().removeDocuments;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DeleteOneOperation = class extends OperationBase {
    constructor(collection, filter, options) {
      super(options);
      this.collection = collection;
      this.filter = filter;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const options = this.options;
      options.single = true;
      removeDocuments(coll, filter, options, (err, r) => {
        if (callback == null)
          return;
        if (err && callback)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        if (this.explain)
          return callback(void 0, r.result);
        r.deletedCount = r.result.n;
        callback(null, r);
      });
    }
  };
  defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
  module2.exports = DeleteOneOperation;
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error2().MongoError;
  var DistinctOperation = class extends CommandOperationV2 {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    execute(server, callback) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      decorateWithReadConcern(cmd, coll, options);
      try {
        decorateWithCollation(cmd, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (this.explain && maxWireVersion(server) < 4) {
        callback(new MongoError(`server does not support explain on distinct`));
        return;
      }
      super.executeCommand(server, cmd, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, this.options.full || this.explain ? result : result.values);
      });
    }
  };
  defineAspects(DistinctOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION,
    Aspect.EXPLAINABLE
  ]);
  module2.exports = DistinctOperation;
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var debugOptions = require_utils4().debugOptions;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var ReadPreference = require_core2().ReadPreference;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var debugFields = [
    "authSource",
    "w",
    "wtimeout",
    "j",
    "native_parser",
    "forceServerObjectId",
    "serializeFunctions",
    "raw",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bufferMaxEntries",
    "numberOfRetries",
    "retryMiliSeconds",
    "readPreference",
    "pkFactory",
    "parentDb",
    "promiseLibrary",
    "noListener"
  ];
  var CommandOperation = class extends OperationBase {
    constructor(db, options, collection, command) {
      super(options);
      if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
        if (collection != null) {
          this.options.readPreference = ReadPreference.resolve(collection, options);
        } else {
          this.options.readPreference = ReadPreference.resolve(db, options);
        }
      } else {
        if (collection != null) {
          applyWriteConcern(this.options, {db, coll: collection}, this.options);
        } else {
          applyWriteConcern(this.options, {db}, this.options);
        }
        this.options.readPreference = ReadPreference.primary;
      }
      this.db = db;
      if (command != null) {
        this.command = command;
      }
      if (collection != null) {
        this.collection = collection;
      }
    }
    _buildCommand() {
      if (this.command != null) {
        return this.command;
      }
    }
    execute(callback) {
      const db = this.db;
      const options = Object.assign({}, this.options);
      if (db.serverConfig && db.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      let command;
      try {
        command = this._buildCommand();
      } catch (e) {
        return callback(e);
      }
      const dbName = options.dbName || options.authdb || db.databaseName;
      if (this.hasAspect(Aspect.WRITE_OPERATION)) {
        if (options.writeConcern && (!options.session || !options.session.inTransaction())) {
          command.writeConcern = options.writeConcern;
        }
      }
      if (db.s.logger.isDebug()) {
        db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
      }
      const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
      db.s.topology.command(namespace, command, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
  };
  module2.exports = CommandOperation;
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var handleCallback = require_utils4().handleCallback;
  var DropOperation = class extends CommandOperation {
    constructor(db, options) {
      const finalOptions = Object.assign({}, options, db.s.options);
      if (options.session) {
        finalOptions.session = options.session;
      }
      super(db, finalOptions);
    }
    execute(callback) {
      super.execute((err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (result.ok)
          return handleCallback(callback, null, true);
        handleCallback(callback, null, false);
      });
    }
  };
  defineAspects(DropOperation, Aspect.WRITE_OPERATION);
  var DropCollectionOperation = class extends DropOperation {
    constructor(db, name, options) {
      super(db, options);
      this.name = name;
      this.namespace = `${db.namespace}.${name}`;
    }
    _buildCommand() {
      return {drop: this.name};
    }
  };
  var DropDatabaseOperation = class extends DropOperation {
    _buildCommand() {
      return {dropDatabase: 1};
    }
  };
  module2.exports = {
    DropOperation,
    DropCollectionOperation,
    DropDatabaseOperation
  };
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperation = require_command2();
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var handleCallback = require_utils4().handleCallback;
  var DropIndexOperation = class extends CommandOperation {
    constructor(collection, indexName, options) {
      super(collection.s.db, options, collection);
      this.collection = collection;
      this.indexName = indexName;
    }
    _buildCommand() {
      const collection = this.collection;
      const indexName = this.indexName;
      const options = this.options;
      let cmd = {dropIndexes: collection.collectionName, index: indexName};
      cmd = applyWriteConcern(cmd, {db: collection.s.db, collection}, options);
      return cmd;
    }
    execute(callback) {
      super.execute((err, result) => {
        if (typeof callback !== "function")
          return;
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
  };
  defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
  module2.exports = DropIndexOperation;
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DropIndexOperation = require_drop_index();
  var handleCallback = require_utils4().handleCallback;
  var DropIndexesOperation = class extends DropIndexOperation {
    constructor(collection, options) {
      super(collection, "*", options);
    }
    execute(callback) {
      super.execute((err) => {
        if (err)
          return handleCallback(callback, err, false);
        handleCallback(callback, null, true);
      });
    }
  };
  defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
  module2.exports = DropIndexesOperation;
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
    constructor(collection, query, options) {
      if (typeof options === "undefined") {
        options = query;
        query = void 0;
      }
      super(collection, options);
      this.collectionName = collection.s.namespace.collection;
      if (query) {
        this.query = query;
      }
    }
    execute(server, callback) {
      const options = this.options;
      const cmd = {count: this.collectionName};
      if (this.query) {
        cmd.query = this.query;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (options.hint) {
        cmd.hint = options.hint;
      }
      super.executeCommand(server, cmd, (err, response) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, response.n);
      });
    }
  };
  defineAspects(EstimatedDocumentCountOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = EstimatedDocumentCountOperation;
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var ReadPreference = require_core2().ReadPreference;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error().MongoError;
  var FindOperation = class extends OperationBase {
    constructor(collection, ns, command, options) {
      super(options);
      this.ns = ns;
      this.cmd = command;
      this.readPreference = ReadPreference.resolve(collection, this.options);
    }
    execute(server, callback) {
      this.server = server;
      if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
        callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
        return;
      }
      if (this.explain) {
        this.options.explain = this.explain.verbosity;
      }
      const cursorState = this.cursorState || {};
      server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
    }
  };
  defineAspects(FindOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION,
    Aspect.EXPLAINABLE
  ]);
  module2.exports = FindOperation;
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS((exports2, module2) => {
  "use strict";
  var handleCallback = require_utils4().handleCallback;
  var OperationBase = require_operation().OperationBase;
  var toError = require_utils4().toError;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var FindOneOperation = class extends OperationBase {
    constructor(collection, query, options) {
      super(options);
      this.collection = collection;
      this.query = query;
    }
    execute(callback) {
      const coll = this.collection;
      const query = this.query;
      const options = this.options;
      try {
        const cursor = coll.find(query, options).limit(-1).batchSize(1);
        cursor.next((err, item) => {
          if (err != null)
            return handleCallback(callback, toError(err), null);
          handleCallback(callback, null, item);
        });
      } catch (e) {
        callback(e);
      }
    }
  };
  defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
  module2.exports = FindOneOperation;
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var executeCommand = require_db_ops().executeCommand;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core2().ReadPreference;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error2().MongoError;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var decorateWithExplain = require_utils4().decorateWithExplain;
  var FindAndModifyOperation = class extends OperationBase {
    constructor(collection, query, sort, doc, options) {
      super(options);
      this.collection = collection;
      this.query = query;
      this.sort = sort;
      this.doc = doc;
    }
    execute(callback) {
      const coll = this.collection;
      const query = this.query;
      const sort = formattedOrderClause(this.sort);
      const doc = this.doc;
      let options = this.options;
      let queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options.new ? true : false;
      queryObject.remove = options.remove ? true : false;
      queryObject.upsert = options.upsert ? true : false;
      const projection = options.projection || options.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options.arrayFilters) {
        queryObject.arrayFilters = options.arrayFilters;
      }
      if (doc && !options.remove) {
        queryObject.update = doc;
      }
      if (options.maxTimeMS)
        queryObject.maxTimeMS = options.maxTimeMS;
      options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      options.checkKeys = false;
      options = applyRetryableWrites(options, coll.s.db);
      options = applyWriteConcern(options, {db: coll.s.db, collection: coll}, options);
      if (options.writeConcern) {
        queryObject.writeConcern = options.writeConcern;
      }
      if (options.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      options.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.hint) {
        const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
        if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
          callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
          return;
        }
        queryObject.hint = options.hint;
      }
      if (this.explain) {
        if (maxWireVersion(coll.s.topology) < 4) {
          callback(new MongoError(`server does not support explain on findAndModify`));
          return;
        }
        queryObject = decorateWithExplain(queryObject, this.explain);
      }
      executeCommand(coll.s.db, queryObject, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
  };
  defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
  module2.exports = FindAndModifyOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.remove = true;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      super(collection, filter, finalOptions.sort, null, finalOptions);
    }
  };
  module2.exports = FindOneAndDeleteOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.update = true;
      finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
      finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new TypeError("Replacement parameter must be an object");
      }
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, finalOptions.sort, replacement, finalOptions);
    }
  };
  module2.exports = FindOneAndReplaceOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.update = true;
      finalOptions.new = typeof options.returnOriginal === "boolean" ? !options.returnOriginal : false;
      finalOptions.upsert = typeof options.upsert === "boolean" ? options.upsert : false;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      if (update == null || typeof update !== "object") {
        throw new TypeError("Update parameter must be an object");
      }
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      super(collection, filter, finalOptions.sort, update, finalOptions);
    }
  };
  module2.exports = FindOneAndUpdateOperation;
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var OperationBase = require_operation().OperationBase;
  var decorateCommand = require_utils4().decorateCommand;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core2().ReadPreference;
  var toError = require_utils4().toError;
  var GeoHaystackSearchOperation = class extends OperationBase {
    constructor(collection, x, y, options) {
      super(options);
      this.collection = collection;
      this.x = x;
      this.y = y;
    }
    execute(callback) {
      const coll = this.collection;
      const x = this.x;
      const y = this.y;
      let options = this.options;
      let commandObject = {
        geoSearch: coll.collectionName,
        near: [x, y]
      };
      commandObject = decorateCommand(commandObject, options, ["readPreference", "session"]);
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      decorateWithReadConcern(commandObject, coll, options);
      executeCommand(coll.s.db, commandObject, options, (err, res) => {
        if (err)
          return handleCallback(callback, err);
        if (res.err || res.errmsg)
          handleCallback(callback, toError(res));
        handleCallback(callback, null, res);
      });
    }
  };
  defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
  module2.exports = GeoHaystackSearchOperation;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var indexInformation = require_common_functions().indexInformation;
  var IndexesOperation = class extends OperationBase {
    constructor(collection, options) {
      super(options);
      this.collection = collection;
    }
    execute(callback) {
      const coll = this.collection;
      let options = this.options;
      options = Object.assign({}, {full: true}, options);
      indexInformation(coll.s.db, coll.collectionName, options, callback);
    }
  };
  module2.exports = IndexesOperation;
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var indexInformationDb = require_db_ops().indexInformation;
  var IndexExistsOperation = class extends OperationBase {
    constructor(collection, indexes, options) {
      super(options);
      this.collection = collection;
      this.indexes = indexes;
    }
    execute(callback) {
      const coll = this.collection;
      const indexes = this.indexes;
      const options = this.options;
      indexInformationDb(coll.s.db, coll.collectionName, options, (err, indexInformation) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, indexInformation[indexes] != null);
        for (let i = 0; i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
  };
  module2.exports = IndexExistsOperation;
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var indexInformation = require_common_functions().indexInformation;
  var IndexInformationOperation = class extends OperationBase {
    constructor(db, name, options) {
      super(options);
      this.db = db;
      this.name = name;
    }
    execute(callback) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      indexInformation(db, name, options, callback);
    }
  };
  module2.exports = IndexInformationOperation;
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var BulkWriteOperation = require_bulk_write();
  var MongoError = require_core2().MongoError;
  var prepareDocs = require_common_functions().prepareDocs;
  var InsertManyOperation = class extends OperationBase {
    constructor(collection, docs, options) {
      super(options);
      this.collection = collection;
      this.docs = docs;
    }
    execute(callback) {
      const coll = this.collection;
      let docs = this.docs;
      const options = this.options;
      if (!Array.isArray(docs)) {
        return callback(MongoError.create({message: "docs parameter must be an array of documents", driver: true}));
      }
      options["serializeFunctions"] = options["serializeFunctions"] || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options);
      const operations = [
        {
          insertMany: docs
        }
      ];
      const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);
      bulkWriteOperation.execute((err, result) => {
        if (err)
          return callback(err, null);
        callback(null, mapInsertManyResults(docs, result));
      });
    }
  };
  function mapInsertManyResults(docs, r) {
    const finalResult = {
      result: {ok: 1, n: r.insertedCount},
      ops: docs,
      insertedCount: r.insertedCount,
      insertedIds: r.insertedIds
    };
    if (r.getLastOp()) {
      finalResult.result.opTime = r.getLastOp();
    }
    return finalResult;
  }
  module2.exports = InsertManyOperation;
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_core2().MongoError;
  var OperationBase = require_operation().OperationBase;
  var insertDocuments = require_common_functions().insertDocuments;
  var InsertOneOperation = class extends OperationBase {
    constructor(collection, doc, options) {
      super(options);
      this.collection = collection;
      this.doc = doc;
    }
    execute(callback) {
      const coll = this.collection;
      const doc = this.doc;
      const options = this.options;
      if (Array.isArray(doc)) {
        return callback(MongoError.create({message: "doc parameter must be an object", driver: true}));
      }
      insertDocuments(coll, [doc], options, (err, r) => {
        if (callback == null)
          return;
        if (err && callback)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        r.insertedCount = r.result.n;
        r.insertedId = doc._id;
        if (callback)
          callback(null, r);
      });
    }
  };
  module2.exports = InsertOneOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var OptionsOperation = class extends OperationBase {
    constructor(collection, options) {
      super(options);
      this.collection = collection;
    }
    execute(callback) {
      const coll = this.collection;
      const opts = this.options;
      coll.s.db.listCollections({name: coll.collectionName}, opts).toArray((err, collections) => {
        if (err)
          return handleCallback(callback, err);
        if (collections.length === 0) {
          return handleCallback(callback, MongoError.create({message: `collection ${coll.namespace} not found`, driver: true}));
        }
        handleCallback(callback, err, collections[0].options || null);
      });
    }
  };
  module2.exports = OptionsOperation;
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports2, module2) => {
  "use strict";
  var OptionsOperation = require_options_operation();
  var handleCallback = require_utils4().handleCallback;
  var IsCappedOperation = class extends OptionsOperation {
    constructor(collection, options) {
      super(collection, options);
    }
    execute(callback) {
      super.execute((err, document2) => {
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, !!(document2 && document2.capped));
      });
    }
  };
  module2.exports = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var maxWireVersion = require_utils2().maxWireVersion;
  var LIST_INDEXES_WIRE_VERSION = 3;
  var ListIndexesOperation = class extends CommandOperationV2 {
    constructor(collection, options) {
      super(collection, options, {fullResponse: true});
      this.collectionNamespace = collection.s.namespace;
    }
    execute(server, callback) {
      const serverWireVersion = maxWireVersion(server);
      if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
        const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
        const collectionNS = this.collectionNamespace.toString();
        server.query(systemIndexesNS, {query: {ns: collectionNS}}, {}, this.options, callback);
        return;
      }
      const cursor = this.options.batchSize ? {batchSize: this.options.batchSize} : {};
      super.executeCommand(server, {listIndexes: this.collectionNamespace.collection, cursor}, callback);
    }
  };
  defineAspects(ListIndexesOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListIndexesOperation;
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var crypto = require("crypto");
  var handleCallback = require_utils4().handleCallback;
  var toError = require_utils4().toError;
  var AddUserOperation = class extends CommandOperation {
    constructor(db, username, password, options) {
      super(db, options);
      this.username = username;
      this.password = password;
    }
    _buildCommand() {
      const db = this.db;
      const username = this.username;
      const password = this.password;
      const options = this.options;
      let roles = [];
      if (Array.isArray(options.roles))
        roles = options.roles;
      if (typeof options.roles === "string")
        roles = [options.roles];
      if (roles.length === 0) {
        console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
      }
      if ((db.databaseName.toLowerCase() === "admin" || options.dbName === "admin") && !Array.isArray(options.roles)) {
        roles = ["root"];
      } else if (!Array.isArray(options.roles)) {
        roles = ["dbOwner"];
      }
      const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
      let userPassword = password;
      if (!digestPassword) {
        const md5 = crypto.createHash("md5");
        md5.update(username + ":mongo:" + password);
        userPassword = md5.digest("hex");
      }
      const command = {
        createUser: username,
        customData: options.customData || {},
        roles,
        digestPassword
      };
      if (typeof password === "string") {
        command.pwd = userPassword;
      }
      return command;
    }
    execute(callback) {
      const options = this.options;
      if (options.digestPassword != null) {
        return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
      }
      super.execute((err, r) => {
        if (!err) {
          return handleCallback(callback, err, r);
        }
        return handleCallback(callback, err, null);
      });
    }
  };
  defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
  module2.exports = AddUserOperation;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var collection;
  function loadCollection() {
    if (!collection) {
      collection = require_collection();
    }
    return collection;
  }
  var CollectionsOperation = class extends OperationBase {
    constructor(db, options) {
      super(options);
      this.db = db;
    }
    execute(callback) {
      const db = this.db;
      let options = this.options;
      let Collection2 = loadCollection();
      options = Object.assign({}, options, {nameOnly: true});
      db.listCollections({}, options).toArray((err, documents) => {
        if (err != null)
          return handleCallback(callback, err, null);
        documents = documents.filter((doc) => {
          return doc.name.indexOf("$") === -1;
        });
        handleCallback(callback, null, documents.map((d) => {
          return new Collection2(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);
        }));
      });
    }
  };
  module2.exports = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var defineAspects = require_operation().defineAspects;
  var Aspect = require_operation().Aspect;
  var RunCommandOperation = class extends CommandOperationV2 {
    constructor(parent, command, options) {
      super(parent, options);
      this.command = command;
    }
    execute(server, callback) {
      const command = this.command;
      this.executeCommand(server, command, callback);
    }
  };
  defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
  module2.exports = RunCommandOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperation = require_command2();
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var loadCollection = require_dynamic_loaders().loadCollection;
  var MongoError = require_core2().MongoError;
  var ReadPreference = require_core2().ReadPreference;
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "j",
    "fsync",
    "autoIndexId",
    "strict",
    "serializeFunctions",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern"
  ]);
  var CreateCollectionOperation = class extends CommandOperation {
    constructor(db, name, options) {
      super(db, options);
      this.name = name;
    }
    _buildCommand() {
      const name = this.name;
      const options = this.options;
      const cmd = {create: name};
      for (let n in options) {
        if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
          cmd[n] = options[n];
        }
      }
      return cmd;
    }
    execute(callback) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const Collection2 = loadCollection();
      let listCollectionOptions = Object.assign({nameOnly: true, strict: false}, options);
      listCollectionOptions = applyWriteConcern(listCollectionOptions, {db}, listCollectionOptions);
      function done(err) {
        if (err) {
          return callback(err);
        }
        try {
          callback(null, new Collection2(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));
        } catch (err2) {
          callback(err2);
        }
      }
      const strictMode = listCollectionOptions.strict;
      if (strictMode) {
        db.listCollections({name}, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
          if (err) {
            return callback(err);
          }
          if (collections.length > 0) {
            return callback(new MongoError(`Collection ${name} already exists. Currently in strict mode.`));
          }
          super.execute(done);
        });
        return;
      }
      super.execute(done);
    }
  };
  defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
  module2.exports = CreateCollectionOperation;
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core2().MongoError;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ExecuteDbAdminCommandOperation = class extends OperationBase {
    constructor(db, selector, options) {
      super(options);
      this.db = db;
      this.selector = selector;
    }
    execute(callback) {
      const db = this.db;
      const selector = this.selector;
      const options = this.options;
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, selector, options, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
  };
  module2.exports = ExecuteDbAdminCommandOperation;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var maxWireVersion = require_utils2().maxWireVersion;
  var CONSTANTS = require_constants3();
  var LIST_COLLECTIONS_WIRE_VERSION = 3;
  function listCollectionsTransforms(databaseName) {
    const matching = `${databaseName}.`;
    return {
      doc: (doc) => {
        const index = doc.name.indexOf(matching);
        if (doc.name && index === 0) {
          doc.name = doc.name.substr(index + matching.length);
        }
        return doc;
      }
    };
  }
  var ListCollectionsOperation = class extends CommandOperationV2 {
    constructor(db, filter, options) {
      super(db, options, {fullResponse: true});
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    execute(server, callback) {
      if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
        let filter = this.filter;
        const databaseName = this.db.s.namespace.db;
        if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
          filter = Object.assign({}, filter);
          filter.name = this.db.s.namespace.withCollection(filter.name).toString();
        }
        if (filter == null) {
          filter.name = `/${databaseName}/`;
        }
        if (filter.name) {
          filter = {$and: [{name: filter.name}, {name: /^((?!\$).)*$/}]};
        } else {
          filter = {name: /^((?!\$).)*$/};
        }
        const transforms = listCollectionsTransforms(databaseName);
        server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, {query: filter}, {batchSize: this.batchSize || 1e3}, {}, (err, result) => {
          if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
            result.message.documents = result.message.documents.map(transforms.doc);
          }
          callback(err, result);
        });
        return;
      }
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? {batchSize: this.batchSize} : {},
        nameOnly: this.nameOnly
      };
      return super.executeCommand(server, command, callback);
    }
  };
  defineAspects(ListCollectionsOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListCollectionsOperation;
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var ProfilingLevelOperation = class extends CommandOperation {
    constructor(db, command, options) {
      super(db, options);
    }
    _buildCommand() {
      const command = {profile: -1};
      return command;
    }
    execute(callback) {
      super.execute((err, doc) => {
        if (err == null && doc.ok === 1) {
          const was = doc.was;
          if (was === 0)
            return callback(null, "off");
          if (was === 1)
            return callback(null, "slow_only");
          if (was === 2)
            return callback(null, "all");
          return callback(new Error("Error: illegal profiling level value " + was), null);
        } else {
          err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        }
      });
    }
  };
  module2.exports = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var handleCallback = require_utils4().handleCallback;
  var WriteConcern = require_write_concern();
  var RemoveUserOperation = class extends CommandOperation {
    constructor(db, username, options) {
      const commandOptions = {};
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern != null) {
        commandOptions.writeConcern = writeConcern;
      }
      if (options.dbName) {
        commandOptions.dbName = options.dbName;
      }
      if (typeof options.maxTimeMS === "number") {
        commandOptions.maxTimeMS = options.maxTimeMS;
      }
      super(db, commandOptions);
      this.username = username;
    }
    _buildCommand() {
      const username = this.username;
      const command = {dropUser: username};
      return command;
    }
    execute(callback) {
      super.execute((err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, err, result.ok ? true : false);
      });
    }
  };
  defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
  module2.exports = RemoveUserOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var checkCollectionName = require_utils4().checkCollectionName;
  var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
  var handleCallback = require_utils4().handleCallback;
  var loadCollection = require_dynamic_loaders().loadCollection;
  var toError = require_utils4().toError;
  var RenameOperation = class extends OperationBase {
    constructor(collection, newName, options) {
      super(options);
      this.collection = collection;
      this.newName = newName;
    }
    execute(callback) {
      const coll = this.collection;
      const newName = this.newName;
      const options = this.options;
      let Collection2 = loadCollection();
      checkCollectionName(newName);
      const renameCollection = coll.namespace;
      const toCollection = coll.s.namespace.withCollection(newName).toString();
      const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
      const cmd = {renameCollection, to: toCollection, dropTarget};
      applyWriteConcern(cmd, {db: coll.s.db, collection: coll}, options);
      executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => {
        if (err)
          return handleCallback(callback, err, null);
        if (doc.errmsg)
          return handleCallback(callback, toError(doc), null);
        try {
          return handleCallback(callback, null, new Collection2(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
        } catch (err2) {
          return handleCallback(callback, toError(err2), null);
        }
      });
    }
  };
  module2.exports = RenameOperation;
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var levelValues = new Set(["off", "slow_only", "all"]);
  var SetProfilingLevelOperation = class extends CommandOperation {
    constructor(db, level, options) {
      let profile = 0;
      if (level === "off") {
        profile = 0;
      } else if (level === "slow_only") {
        profile = 1;
      } else if (level === "all") {
        profile = 2;
      }
      super(db, options);
      this.level = level;
      this.profile = profile;
    }
    _buildCommand() {
      const profile = this.profile;
      const command = {profile};
      return command;
    }
    execute(callback) {
      const level = this.level;
      if (!levelValues.has(level)) {
        return callback(new Error("Error: illegal profiling level value " + level));
      }
      super.execute((err, doc) => {
        if (err == null && doc.ok === 1)
          return callback(null, level);
        return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
      });
    }
  };
  module2.exports = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var ValidateCollectionOperation = class extends CommandOperation {
    constructor(admin, collectionName, options) {
      let command = {validate: collectionName};
      const keys = Object.keys(options);
      for (let i = 0; i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
          command[keys[i]] = options[keys[i]];
        }
      }
      super(admin.s.db, options, null, command);
      this.collectionName = collectionName;
    }
    execute(callback) {
      const collectionName = this.collectionName;
      super.execute((err, doc) => {
        if (err != null)
          return callback(err, null);
        if (doc.ok === 0)
          return callback(new Error("Error with validate command"), null);
        if (doc.result != null && doc.result.constructor !== String)
          return callback(new Error("Error with validation data"), null);
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
          return callback(new Error("Error: invalid collection " + collectionName), null);
        if (doc.valid != null && !doc.valid)
          return callback(new Error("Error: invalid collection " + collectionName), null);
        return callback(null, doc);
      });
    }
  };
  module2.exports = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ListDatabasesOperation = class extends CommandOperationV2 {
    constructor(db, options) {
      super(db, options);
      this.ns = new MongoDBNamespace("admin", "$cmd");
    }
    execute(server, callback) {
      const cmd = {listDatabases: 1};
      if (this.options.nameOnly) {
        cmd.nameOnly = Number(cmd.nameOnly);
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      super.executeCommand(server, cmd, callback);
    }
  };
  defineAspects(ListDatabasesOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListDatabasesOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var AddUserOperation = require_add_user();
  var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
  var RemoveUserOperation = require_remove_user();
  var ValidateCollectionOperation = require_validate_collection();
  var ListDatabasesOperation = require_list_databases();
  var executeOperation = require_execute_operation();
  function Admin(db, topology, promiseLibrary) {
    if (!(this instanceof Admin))
      return new Admin(db, topology);
    this.s = {
      db,
      topology,
      promiseLibrary
    };
  }
  Admin.prototype.command = function(command, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options);
    return executeOperation(this.s.db.s.topology, commandOperation, callback);
  };
  Admin.prototype.buildInfo = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {buildinfo: 1};
    const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
  };
  Admin.prototype.serverInfo = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {buildinfo: 1};
    const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
  };
  Admin.prototype.serverStatus = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {serverStatus: 1}, options);
    return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
  };
  Admin.prototype.ping = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {ping: 1};
    const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, pingOperation, callback);
  };
  Admin.prototype.addUser = function(username, password, options, callback) {
    const args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    if (typeof username === "string" && password != null && typeof password === "object") {
      options = password;
      password = null;
    }
    options = args.length ? args.shift() : {};
    options = Object.assign({}, options);
    options = applyWriteConcern(options, {db: this.s.db});
    options.dbName = "admin";
    const addUserOperation = new AddUserOperation(this.s.db, username, password, options);
    return executeOperation(this.s.db.s.topology, addUserOperation, callback);
  };
  Admin.prototype.removeUser = function(username, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    options = Object.assign({}, options);
    options = applyWriteConcern(options, {db: this.s.db});
    options.dbName = "admin";
    const removeUserOperation = new RemoveUserOperation(this.s.db, username, options);
    return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
  };
  Admin.prototype.validateCollection = function(collectionName, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options);
    return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
  };
  Admin.prototype.listDatabases = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options), callback);
  };
  Admin.prototype.replSetGetStatus = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {replSetGetStatus: 1}, options);
    return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
  };
  module2.exports = Admin;
});

// node_modules/mongodb/lib/db.js
var require_db2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events").EventEmitter;
  var inherits = require("util").inherits;
  var getSingleProperty = require_utils4().getSingleProperty;
  var CommandCursor = require_command_cursor();
  var handleCallback = require_utils4().handleCallback;
  var filterOptions = require_utils4().filterOptions;
  var toError = require_utils4().toError;
  var ReadPreference = require_core2().ReadPreference;
  var MongoError = require_core2().MongoError;
  var ObjectID2 = require_core2().ObjectID;
  var Logger = require_core2().Logger;
  var Collection2 = require_collection();
  var mergeOptionsAndWriteConcern = require_utils4().mergeOptionsAndWriteConcern;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var ChangeStream = require_change_stream();
  var deprecate = require("util").deprecate;
  var deprecateOptions = require_utils4().deprecateOptions;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var CONSTANTS = require_constants3();
  var WriteConcern = require_write_concern();
  var ReadConcern = require_read_concern();
  var AggregationCursor = require_aggregation_cursor();
  var createListener = require_db_ops().createListener;
  var ensureIndex = require_db_ops().ensureIndex;
  var evaluate = require_db_ops().evaluate;
  var profilingInfo = require_db_ops().profilingInfo;
  var validateDatabaseName = require_db_ops().validateDatabaseName;
  var AggregateOperation = require_aggregate();
  var AddUserOperation = require_add_user();
  var CollectionsOperation = require_collections();
  var CommandOperation = require_command2();
  var RunCommandOperation = require_run_command();
  var CreateCollectionOperation = require_create_collection();
  var CreateIndexesOperation = require_create_indexes();
  var DropCollectionOperation = require_drop().DropCollectionOperation;
  var DropDatabaseOperation = require_drop().DropDatabaseOperation;
  var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
  var IndexInformationOperation = require_index_information();
  var ListCollectionsOperation = require_list_collections();
  var ProfilingLevelOperation = require_profiling_level();
  var RemoveUserOperation = require_remove_user();
  var RenameOperation = require_rename();
  var SetProfilingLevelOperation = require_set_profiling_level();
  var executeOperation = require_execute_operation();
  var legalOptionNames = [
    "w",
    "wtimeout",
    "fsync",
    "j",
    "writeConcern",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "bufferMaxEntries",
    "authSource",
    "ignoreUndefined",
    "promoteLongs",
    "promiseLibrary",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "parentDb",
    "noListener",
    "loggerLevel",
    "logger",
    "promoteBuffers",
    "promoteLongs",
    "promoteValues",
    "compression",
    "retryWrites"
  ];
  function Db(databaseName, topology, options) {
    options = options || {};
    if (!(this instanceof Db))
      return new Db(databaseName, topology, options);
    EventEmitter.call(this);
    const promiseLibrary = options.promiseLibrary || Promise;
    options = filterOptions(options, legalOptionNames);
    options.promiseLibrary = promiseLibrary;
    this.s = {
      dbCache: {},
      children: [],
      topology,
      options,
      logger: Logger("Db", options),
      bson: topology ? topology.bson : null,
      readPreference: ReadPreference.fromOptions(options),
      bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : -1,
      parentDb: options.parentDb || null,
      pkFactory: options.pkFactory || ObjectID2,
      nativeParser: options.nativeParser || options.native_parser,
      promiseLibrary,
      noListener: typeof options.noListener === "boolean" ? options.noListener : false,
      readConcern: ReadConcern.fromOptions(options),
      writeConcern: WriteConcern.fromOptions(options),
      namespace: new MongoDBNamespace(databaseName)
    };
    validateDatabaseName(databaseName);
    getSingleProperty(this, "serverConfig", this.s.topology);
    getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
    getSingleProperty(this, "databaseName", this.s.namespace.db);
    if (options.parentDb)
      return;
    if (this.s.noListener)
      return;
    topology.on("error", createListener(this, "error", this));
    topology.on("timeout", createListener(this, "timeout", this));
    topology.on("close", createListener(this, "close", this));
    topology.on("parseError", createListener(this, "parseError", this));
    topology.once("open", createListener(this, "open", this));
    topology.once("fullsetup", createListener(this, "fullsetup", this));
    topology.once("all", createListener(this, "all", this));
    topology.on("reconnect", createListener(this, "reconnect", this));
  }
  inherits(Db, EventEmitter);
  Db.prototype.on = deprecate(function() {
    return Db.super_.prototype.on.apply(this, arguments);
  }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
  Db.prototype.once = deprecate(function() {
    return Db.super_.prototype.once.apply(this, arguments);
  }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
  Object.defineProperty(Db.prototype, "topology", {
    enumerable: true,
    get: function() {
      return this.s.topology;
    }
  });
  Object.defineProperty(Db.prototype, "options", {
    enumerable: true,
    get: function() {
      return this.s.options;
    }
  });
  Object.defineProperty(Db.prototype, "slaveOk", {
    enumerable: true,
    get: function() {
      if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
        return true;
      }
      return false;
    }
  });
  Object.defineProperty(Db.prototype, "readConcern", {
    enumerable: true,
    get: function() {
      return this.s.readConcern;
    }
  });
  Object.defineProperty(Db.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      if (this.s.readPreference == null) {
        return ReadPreference.primary;
      }
      return this.s.readPreference;
    }
  });
  Object.defineProperty(Db.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(Db.prototype, "namespace", {
    enumerable: true,
    get: function() {
      return this.s.namespace.toString();
    }
  });
  Db.prototype.command = function(command, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    const commandOperation = new RunCommandOperation(this, command, options);
    return executeOperation(this.s.topology, commandOperation, callback);
  };
  Db.prototype.aggregate = function(pipeline, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options == null && callback == null) {
      options = {};
    }
    const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  };
  Db.prototype.admin = function() {
    const Admin = require_admin();
    return new Admin(this, this.s.topology, this.s.promiseLibrary);
  };
  var collectionKeys = [
    "pkFactory",
    "readPreference",
    "serializeFunctions",
    "strict",
    "readConcern",
    "ignoreUndefined",
    "promoteValues",
    "promoteBuffers",
    "promoteLongs"
  ];
  Db.prototype.collection = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options = Object.assign({}, options);
    options.promiseLibrary = this.s.promiseLibrary;
    options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
    if (this.s.options.ignoreUndefined) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);
    if (options == null || !options.strict) {
      try {
        const collection = new Collection2(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options);
        if (callback)
          callback(null, collection);
        return collection;
      } catch (err) {
        if (err instanceof MongoError && callback)
          return callback(err);
        throw err;
      }
    }
    if (typeof callback !== "function") {
      throw toError(`A callback is required in strict mode. While getting collection ${name}`);
    }
    if (this.serverConfig && this.serverConfig.isDestroyed()) {
      return callback(new MongoError("topology was destroyed"));
    }
    const listCollectionOptions = Object.assign({}, options, {nameOnly: true});
    this.listCollections({name}, listCollectionOptions).toArray((err, collections) => {
      if (err != null)
        return handleCallback(callback, err, null);
      if (collections.length === 0)
        return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);
      try {
        return handleCallback(callback, null, new Collection2(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options));
      } catch (err2) {
        return handleCallback(callback, err2, null);
      }
    });
  };
  Db.prototype.createCollection = deprecateOptions({
    name: "Db.createCollection",
    deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
    optionsIndex: 1
  }, function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
    options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
    const createCollectionOperation = new CreateCollectionOperation(this, name, options);
    return executeOperation(this.s.topology, createCollectionOperation, callback);
  });
  Db.prototype.stats = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const commandObject = {dbStats: true};
    if (options["scale"] != null)
      commandObject["scale"] = options["scale"];
    if (options.readPreference == null && this.s.readPreference) {
      options.readPreference = this.s.readPreference;
    }
    const statsOperation = new CommandOperation(this, options, null, commandObject);
    return executeOperation(this.s.topology, statsOperation, callback);
  };
  Db.prototype.listCollections = function(filter, options) {
    filter = filter || {};
    options = options || {};
    return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options), options);
  };
  Db.prototype.eval = deprecate(function(code, parameters, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    parameters = args.length ? args.shift() : parameters;
    options = args.length ? args.shift() || {} : {};
    return executeLegacyOperation(this.s.topology, evaluate, [
      this,
      code,
      parameters,
      options,
      callback
    ]);
  }, "Db.eval is deprecated as of MongoDB version 3.2");
  Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    options.new_collection = true;
    const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options);
    return executeOperation(this.s.topology, renameOperation, callback);
  };
  Db.prototype.dropCollection = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropCollectionOperation = new DropCollectionOperation(this, name, options);
    return executeOperation(this.s.topology, dropCollectionOperation, callback);
  };
  Db.prototype.dropDatabase = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropDatabaseOperation = new DropDatabaseOperation(this, options);
    return executeOperation(this.s.topology, dropDatabaseOperation, callback);
  };
  Db.prototype.collections = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const collectionsOperation = new CollectionsOperation(this, options);
    return executeOperation(this.s.topology, collectionsOperation, callback);
  };
  Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options.readPreference = ReadPreference.resolve(this, options);
    const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options);
    return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
  };
  Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, ensureIndex, [
      this,
      name,
      fieldOrSpec,
      options,
      callback
    ]);
  }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
  Db.prototype.addChild = function(db) {
    if (this.s.parentDb)
      return this.s.parentDb.addChild(db);
    this.s.children.push(db);
  };
  Db.prototype.addUser = function(username, password, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (typeof username === "string" && password != null && typeof password === "object") {
      options = password;
      password = null;
    }
    const addUserOperation = new AddUserOperation(this, username, password, options);
    return executeOperation(this.s.topology, addUserOperation, callback);
  };
  Db.prototype.removeUser = function(username, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const removeUserOperation = new RemoveUserOperation(this, username, options);
    return executeOperation(this.s.topology, removeUserOperation, callback);
  };
  Db.prototype.setProfilingLevel = function(level, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options);
    return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
  };
  Db.prototype.profilingInfo = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, profilingInfo, [this, options, callback]);
  }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
  Db.prototype.profilingLevel = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const profilingLevelOperation = new ProfilingLevelOperation(this, options);
    return executeOperation(this.s.topology, profilingLevelOperation, callback);
  };
  Db.prototype.indexInformation = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexInformationOperation = new IndexInformationOperation(this, name, options);
    return executeOperation(this.s.topology, indexInformationOperation, callback);
  };
  Db.prototype.unref = function() {
    this.s.topology.unref();
  };
  Db.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  Db.prototype.getLogger = function() {
    return this.s.logger;
  };
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  module2.exports = Db;
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS((exports2, module2) => {
  "use strict";
  var collection;
  var cursor;
  var db;
  function loadCollection() {
    if (!collection) {
      collection = require_collection();
    }
    return collection;
  }
  function loadCursor() {
    if (!cursor) {
      cursor = require_cursor2();
    }
    return cursor;
  }
  function loadDb() {
    if (!db) {
      db = require_db2();
    }
    return db;
  }
  module2.exports = {
    loadCollection,
    loadCursor,
    loadDb
  };
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core2().BSON.Code;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var isObject = require_utils4().isObject;
  var loadDb = require_dynamic_loaders().loadDb;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_core2().ReadPreference;
  var toError = require_utils4().toError;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var decorateWithExplain = require_utils4().decorateWithExplain;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error2().MongoError;
  var exclusionList = [
    "explain",
    "readPreference",
    "session",
    "bypassDocumentValidation",
    "w",
    "wtimeout",
    "j",
    "writeConcern"
  ];
  var MapReduceOperation = class extends OperationBase {
    constructor(collection, map, reduce, options) {
      super(options);
      this.collection = collection;
      this.map = map;
      this.reduce = reduce;
    }
    execute(callback) {
      const coll = this.collection;
      const map = this.map;
      const reduce = this.reduce;
      let options = this.options;
      let mapCommandHash = {
        mapReduce: coll.collectionName,
        map,
        reduce
      };
      for (let n in options) {
        if (n === "scope") {
          mapCommandHash[n] = processScope(options[n]);
        } else {
          if (exclusionList.indexOf(n) === -1) {
            mapCommandHash[n] = options[n];
          }
        }
      }
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      if (options.readPreference !== false && options.readPreference !== "primary" && options["out"] && options["out"].inline !== 1 && options["out"] !== "inline") {
        options.readPreference = "primary";
        applyWriteConcern(mapCommandHash, {db: coll.s.db, collection: coll}, options);
      } else {
        decorateWithReadConcern(mapCommandHash, coll, options);
      }
      if (options.bypassDocumentValidation === true) {
        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      try {
        decorateWithCollation(mapCommandHash, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (this.explain) {
        if (maxWireVersion(coll.s.topology) < 9) {
          callback(new MongoError(`server does not support explain on mapReduce`));
          return;
        }
        mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
      }
      executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (result.ok !== 1 || result.err || result.errmsg) {
          return handleCallback(callback, toError(result));
        }
        if (this.explain)
          return callback(void 0, result);
        const stats = {};
        if (result.timeMillis)
          stats["processtime"] = result.timeMillis;
        if (result.counts)
          stats["counts"] = result.counts;
        if (result.timing)
          stats["timing"] = result.timing;
        if (result.results) {
          if (options["verbose"] == null || !options["verbose"]) {
            return handleCallback(callback, null, result.results);
          }
          return handleCallback(callback, null, {results: result.results, stats});
        }
        let collection = null;
        if (result.result != null && typeof result.result === "object") {
          const doc = result.result;
          let Db = loadDb();
          collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
        } else {
          collection = coll.s.db.collection(result.result);
        }
        if (options["verbose"] == null || !options["verbose"]) {
          return handleCallback(callback, err, collection);
        }
        handleCallback(callback, err, {collection, stats});
      });
    }
  };
  function processScope(scope) {
    if (!isObject(scope) || scope._bsontype === "ObjectID") {
      return scope;
    }
    const keys = Object.keys(scope);
    let key;
    const new_scope = {};
    for (let i = keys.length - 1; i >= 0; i--) {
      key = keys[i];
      if (typeof scope[key] === "function") {
        new_scope[key] = new Code2(String(scope[key]));
      } else {
        new_scope[key] = processScope(scope[key]);
      }
    }
    return new_scope;
  }
  defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
  module2.exports = MapReduceOperation;
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var serverType = require_common2().serverType;
  var ServerType = require_common2().ServerType;
  var MongoError = require_core2().MongoError;
  var ReIndexOperation = class extends CommandOperationV2 {
    constructor(collection, options) {
      super(collection, options);
      this.collectionName = collection.collectionName;
    }
    execute(server, callback) {
      if (serverType(server) !== ServerType.Standalone) {
        callback(new MongoError(`reIndex can only be executed on standalone servers.`));
        return;
      }
      super.executeCommand(server, {reIndex: this.collectionName}, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, !!result.ok);
      });
    }
  };
  defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
  module2.exports = ReIndexOperation;
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var ReplaceOneOperation = class extends OperationBase {
    constructor(collection, filter, replacement, options) {
      super(options);
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not contain atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.replacement = replacement;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const replacement = this.replacement;
      const options = this.options;
      options.multi = false;
      updateDocuments(coll, filter, replacement, options, (err, r) => replaceCallback(err, r, replacement, callback));
    }
  };
  function replaceCallback(err, r, doc, callback) {
    if (callback == null)
      return;
    if (err && callback)
      return callback(err);
    if (r == null)
      return callback(null, {result: {ok: 1}});
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if (callback)
      callback(null, r);
  }
  module2.exports = ReplaceOneOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var StatsOperation = class extends CommandOperation {
    constructor(collection, options) {
      super(collection.s.db, options, collection);
    }
    _buildCommand() {
      const collection = this.collection;
      const options = this.options;
      const command = {
        collStats: collection.collectionName
      };
      if (options["scale"] != null) {
        command["scale"] = options["scale"];
      }
      return command;
    }
  };
  defineAspects(StatsOperation, Aspect.READ_OPERATION);
  module2.exports = StatsOperation;
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var UpdateManyOperation = class extends OperationBase {
    constructor(collection, filter, update, options) {
      super(options);
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.update = update;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const update = this.update;
      const options = this.options;
      options.multi = true;
      updateDocuments(coll, filter, update, options, (err, r) => {
        if (callback == null)
          return;
        if (err)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        if (this.explain)
          return callback(void 0, r.result);
        r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
        r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
        r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
        r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
        callback(null, r);
      });
    }
  };
  defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
  module2.exports = UpdateManyOperation;
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var UpdateOneOperation = class extends OperationBase {
    constructor(collection, filter, update, options) {
      super(options);
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.update = update;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const update = this.update;
      const options = this.options;
      options.multi = false;
      updateDocuments(coll, filter, update, options, (err, r) => {
        if (callback == null)
          return;
        if (err)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        if (this.explain)
          return callback(void 0, r.result);
        r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
        r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
        r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
        r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
        callback(null, r);
      });
    }
  };
  defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
  module2.exports = UpdateOneOperation;
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS((exports2, module2) => {
  "use strict";
  var deprecate = require("util").deprecate;
  var deprecateOptions = require_utils4().deprecateOptions;
  var checkCollectionName = require_utils4().checkCollectionName;
  var ObjectID2 = require_core2().BSON.ObjectID;
  var MongoError = require_core2().MongoError;
  var normalizeHintField = require_utils4().normalizeHintField;
  var decorateCommand = require_utils4().decorateCommand;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var ReadPreference = require_core2().ReadPreference;
  var unordered = require_unordered();
  var ordered = require_ordered();
  var ChangeStream = require_change_stream();
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var WriteConcern = require_write_concern();
  var ReadConcern = require_read_concern();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var AggregationCursor = require_aggregation_cursor();
  var CommandCursor = require_command_cursor();
  var ensureIndex = require_collection_ops().ensureIndex;
  var group = require_collection_ops().group;
  var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
  var removeDocuments = require_common_functions().removeDocuments;
  var save = require_collection_ops().save;
  var updateDocuments = require_common_functions().updateDocuments;
  var AggregateOperation = require_aggregate();
  var BulkWriteOperation = require_bulk_write();
  var CountDocumentsOperation = require_count_documents();
  var CreateIndexesOperation = require_create_indexes();
  var DeleteManyOperation = require_delete_many();
  var DeleteOneOperation = require_delete_one();
  var DistinctOperation = require_distinct();
  var DropCollectionOperation = require_drop().DropCollectionOperation;
  var DropIndexOperation = require_drop_index();
  var DropIndexesOperation = require_drop_indexes();
  var EstimatedDocumentCountOperation = require_estimated_document_count();
  var FindOperation = require_find();
  var FindOneOperation = require_find_one();
  var FindAndModifyOperation = require_find_and_modify();
  var FindOneAndDeleteOperation = require_find_one_and_delete();
  var FindOneAndReplaceOperation = require_find_one_and_replace();
  var FindOneAndUpdateOperation = require_find_one_and_update();
  var GeoHaystackSearchOperation = require_geo_haystack_search();
  var IndexesOperation = require_indexes();
  var IndexExistsOperation = require_index_exists();
  var IndexInformationOperation = require_index_information();
  var InsertManyOperation = require_insert_many();
  var InsertOneOperation = require_insert_one();
  var IsCappedOperation = require_is_capped();
  var ListIndexesOperation = require_list_indexes();
  var MapReduceOperation = require_map_reduce();
  var OptionsOperation = require_options_operation();
  var RenameOperation = require_rename();
  var ReIndexOperation = require_re_index();
  var ReplaceOneOperation = require_replace_one();
  var StatsOperation = require_stats();
  var UpdateManyOperation = require_update_many();
  var UpdateOneOperation = require_update_one();
  var executeOperation = require_execute_operation();
  var mergeKeys = ["ignoreUndefined"];
  function Collection2(db, topology, dbName, name, pkFactory, options) {
    checkCollectionName(name);
    const internalHint = null;
    const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
    const serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
    const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
    const promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
    const promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
    const promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
    const collectionHint = null;
    const namespace = new MongoDBNamespace(dbName, name);
    const promiseLibrary = options.promiseLibrary || Promise;
    pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
    this.s = {
      pkFactory,
      db,
      topology,
      options,
      namespace,
      readPreference: ReadPreference.fromOptions(options),
      slaveOk,
      serializeFunctions,
      raw,
      promoteLongs,
      promoteValues,
      promoteBuffers,
      internalHint,
      collectionHint,
      promiseLibrary,
      readConcern: ReadConcern.fromOptions(options),
      writeConcern: WriteConcern.fromOptions(options)
    };
  }
  Object.defineProperty(Collection2.prototype, "dbName", {
    enumerable: true,
    get: function() {
      return this.s.namespace.db;
    }
  });
  Object.defineProperty(Collection2.prototype, "collectionName", {
    enumerable: true,
    get: function() {
      return this.s.namespace.collection;
    }
  });
  Object.defineProperty(Collection2.prototype, "namespace", {
    enumerable: true,
    get: function() {
      return this.s.namespace.toString();
    }
  });
  Object.defineProperty(Collection2.prototype, "readConcern", {
    enumerable: true,
    get: function() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
  });
  Object.defineProperty(Collection2.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
  });
  Object.defineProperty(Collection2.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(Collection2.prototype, "hint", {
    enumerable: true,
    get: function() {
      return this.s.collectionHint;
    },
    set: function(v) {
      this.s.collectionHint = normalizeHintField(v);
    }
  });
  var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
  Collection2.prototype.find = deprecateOptions({
    name: "collection.find",
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  }, function(query, options, callback) {
    if (typeof callback === "object") {
      console.warn("Third parameter to `find()` must be a callback or undefined");
    }
    let selector = query;
    if (typeof callback !== "function") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      } else if (options == null) {
        callback = typeof selector === "function" ? selector : void 0;
        selector = typeof selector === "object" ? selector : void 0;
      }
    }
    selector = selector == null ? {} : selector;
    const object = selector;
    if (Buffer.isBuffer(object)) {
      const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
      if (object_size !== object.length) {
        const error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
        error.name = "MongoError";
        throw error;
      }
    }
    if (selector != null && selector._bsontype === "ObjectID") {
      selector = {_id: selector};
    }
    if (!options)
      options = {};
    let projection = options.projection || options.fields;
    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
      projection = projection.length ? projection.reduce((result, field) => {
        result[field] = 1;
        return result;
      }, {}) : {_id: 1};
    }
    let newOptions = Object.assign({}, options);
    for (let key in this.s.options) {
      if (mergeKeys.indexOf(key) !== -1) {
        newOptions[key] = this.s.options[key];
      }
    }
    newOptions.skip = options.skip ? options.skip : 0;
    newOptions.limit = options.limit ? options.limit : 0;
    newOptions.raw = typeof options.raw === "boolean" ? options.raw : this.s.raw;
    newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
    newOptions.timeout = typeof options.timeout === "undefined" ? void 0 : options.timeout;
    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
    newOptions.readPreference = ReadPreference.resolve(this, newOptions);
    if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
      newOptions.slaveOk = true;
    }
    if (selector != null && typeof selector !== "object") {
      throw MongoError.create({message: "query selector must be an object", driver: true});
    }
    const findCommand = {
      find: this.s.namespace.toString(),
      limit: newOptions.limit,
      skip: newOptions.skip,
      query: selector
    };
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (typeof newOptions.awaitdata === "boolean") {
      newOptions.awaitData = newOptions.awaitdata;
    }
    if (typeof newOptions.timeout === "boolean")
      newOptions.noCursorTimeout = !newOptions.timeout;
    decorateCommand(findCommand, newOptions, ["session", "collation"]);
    if (projection)
      findCommand.fields = projection;
    newOptions.db = this.s.db;
    newOptions.promiseLibrary = this.s.promiseLibrary;
    if (newOptions.raw == null && typeof this.s.raw === "boolean")
      newOptions.raw = this.s.raw;
    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
      newOptions.promoteLongs = this.s.promoteLongs;
    if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
      newOptions.promoteValues = this.s.promoteValues;
    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
      newOptions.promoteBuffers = this.s.promoteBuffers;
    if (findCommand.sort) {
      findCommand.sort = formattedOrderClause(findCommand.sort);
    }
    decorateWithReadConcern(findCommand, this, options);
    try {
      decorateWithCollation(findCommand, this, options);
    } catch (err) {
      if (typeof callback === "function")
        return callback(err, null);
      throw err;
    }
    const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  });
  Collection2.prototype.insertOne = function(doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const insertOneOperation = new InsertOneOperation(this, doc, options);
    return executeOperation(this.s.topology, insertOneOperation, callback);
  };
  Collection2.prototype.insertMany = function(docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {ordered: true};
    const insertManyOperation = new InsertManyOperation(this, docs, options);
    return executeOperation(this.s.topology, insertManyOperation, callback);
  };
  Collection2.prototype.bulkWrite = function(operations, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {ordered: true};
    if (!Array.isArray(operations)) {
      throw MongoError.create({message: "operations must be an array of documents", driver: true});
    }
    const bulkWriteOperation = new BulkWriteOperation(this, operations, options);
    return executeOperation(this.s.topology, bulkWriteOperation, callback);
  };
  Collection2.prototype.insert = deprecate(function(docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {ordered: false};
    docs = !Array.isArray(docs) ? [docs] : docs;
    if (options.keepGoing === true) {
      options.ordered = false;
    }
    return this.insertMany(docs, options, callback);
  }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
  Collection2.prototype.updateOne = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.replaceOne = function(filter, doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options), callback);
  };
  Collection2.prototype.updateMany = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.update = deprecate(function(selector, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, updateDocuments, [
      this,
      selector,
      update,
      options,
      callback
    ]);
  }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
  Collection2.prototype.deleteOne = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const deleteOneOperation = new DeleteOneOperation(this, filter, options);
    return executeOperation(this.s.topology, deleteOneOperation, callback);
  };
  Collection2.prototype.removeOne = Collection2.prototype.deleteOne;
  Collection2.prototype.deleteMany = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const deleteManyOperation = new DeleteManyOperation(this, filter, options);
    return executeOperation(this.s.topology, deleteManyOperation, callback);
  };
  Collection2.prototype.removeMany = Collection2.prototype.deleteMany;
  Collection2.prototype.remove = deprecate(function(selector, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, removeDocuments, [
      this,
      selector,
      options,
      callback
    ]);
  }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
  Collection2.prototype.save = deprecate(function(doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);
  }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
  Collection2.prototype.findOne = deprecateOptions({
    name: "collection.find",
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  }, function(query, options, callback) {
    if (typeof callback === "object") {
      console.warn("Third parameter to `findOne()` must be a callback or undefined");
    }
    if (typeof query === "function")
      callback = query, query = {}, options = {};
    if (typeof options === "function")
      callback = options, options = {};
    query = query || {};
    options = options || {};
    const findOneOperation = new FindOneOperation(this, query, options);
    return executeOperation(this.s.topology, findOneOperation, callback);
  });
  Collection2.prototype.rename = function(newName, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    const renameOperation = new RenameOperation(this, newName, options);
    return executeOperation(this.s.topology, renameOperation, callback);
  };
  Collection2.prototype.drop = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options);
    return executeOperation(this.s.topology, dropCollectionOperation, callback);
  };
  Collection2.prototype.options = function(opts, callback) {
    if (typeof opts === "function")
      callback = opts, opts = {};
    opts = opts || {};
    const optionsOperation = new OptionsOperation(this, opts);
    return executeOperation(this.s.topology, optionsOperation, callback);
  };
  Collection2.prototype.isCapped = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const isCappedOperation = new IsCappedOperation(this, options);
    return executeOperation(this.s.topology, isCappedOperation, callback);
  };
  Collection2.prototype.createIndex = function(fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Collection2.prototype.createIndexes = function(indexSpecs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    if (typeof options.maxTimeMS !== "number")
      delete options.maxTimeMS;
    const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Collection2.prototype.dropIndex = function(indexName, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    options.readPreference = ReadPreference.PRIMARY;
    const dropIndexOperation = new DropIndexOperation(this, indexName, options);
    return executeOperation(this.s.topology, dropIndexOperation, callback);
  };
  Collection2.prototype.dropIndexes = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    if (typeof options.maxTimeMS !== "number")
      delete options.maxTimeMS;
    const dropIndexesOperation = new DropIndexesOperation(this, options);
    return executeOperation(this.s.topology, dropIndexesOperation, callback);
  };
  Collection2.prototype.dropAllIndexes = deprecate(Collection2.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
  Collection2.prototype.reIndex = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const reIndexOperation = new ReIndexOperation(this, options);
    return executeOperation(this.s.topology, reIndexOperation, callback);
  }, "collection.reIndex is deprecated. Use db.command instead.");
  Collection2.prototype.listIndexes = function(options) {
    const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options), options);
    return cursor;
  };
  Collection2.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, ensureIndex, [
      this,
      fieldOrSpec,
      options,
      callback
    ]);
  }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
  Collection2.prototype.indexExists = function(indexes, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexExistsOperation = new IndexExistsOperation(this, indexes, options);
    return executeOperation(this.s.topology, indexExistsOperation, callback);
  };
  Collection2.prototype.indexInformation = function(options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options);
    return executeOperation(this.s.topology, indexInformationOperation, callback);
  };
  Collection2.prototype.count = deprecate(function(query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    query = args.length ? args.shift() || {} : {};
    options = args.length ? args.shift() || {} : {};
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options), callback);
  }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
  Collection2.prototype.estimatedDocumentCount = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);
    return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
  };
  Collection2.prototype.countDocuments = function(query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    query = args.length ? args.shift() || {} : {};
    options = args.length ? args.shift() || {} : {};
    const countDocumentsOperation = new CountDocumentsOperation(this, query, options);
    return executeOperation(this.s.topology, countDocumentsOperation, callback);
  };
  Collection2.prototype.distinct = function(key, query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    const queryOption = args.length ? args.shift() || {} : {};
    const optionsOption = args.length ? args.shift() || {} : {};
    const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
    return executeOperation(this.s.topology, distinctOperation, callback);
  };
  Collection2.prototype.indexes = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexesOperation = new IndexesOperation(this, options);
    return executeOperation(this.s.topology, indexesOperation, callback);
  };
  Collection2.prototype.stats = function(options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const statsOperation = new StatsOperation(this, options);
    return executeOperation(this.s.topology, statsOperation, callback);
  };
  Collection2.prototype.findOneAndDelete = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options), callback);
  };
  Collection2.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options), callback);
  };
  Collection2.prototype.findOneAndUpdate = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
  Collection2.prototype._findAndModify = _findAndModify;
  function _findAndModify(query, sort, doc, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    sort = args.length ? args.shift() || [] : [];
    doc = args.length ? args.shift() : null;
    options = args.length ? args.shift() || {} : {};
    options = Object.assign({}, options);
    options.readPreference = ReadPreference.PRIMARY;
    return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options), callback);
  }
  Collection2.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    sort = args.length ? args.shift() || [] : [];
    options = args.length ? args.shift() || {} : {};
    options.remove = true;
    return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options), callback);
  }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
  Collection2.prototype.aggregate = function(pipeline, options, callback) {
    if (Array.isArray(pipeline)) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (options == null && callback == null) {
        options = {};
      }
    } else {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      const opts = args[args.length - 1];
      options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
      pipeline = args;
    }
    const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  };
  Collection2.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  Collection2.prototype.parallelCollectionScan = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {numCursors: 1};
    options.numCursors = options.numCursors || 1;
    options.batchSize = options.batchSize || 1e3;
    options = Object.assign({}, options);
    options.readPreference = ReadPreference.resolve(this, options);
    options.promiseLibrary = this.s.promiseLibrary;
    if (options.session) {
      options.session = void 0;
    }
    return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {skipSessions: true});
  }, "parallelCollectionScan is deprecated in MongoDB v4.1");
  Collection2.prototype.geoHaystackSearch = deprecate(function(x, y, options, callback) {
    const args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);
    return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
  }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
  Collection2.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options, callback) {
    const args = Array.prototype.slice.call(arguments, 3);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    reduce = args.length ? args.shift() : null;
    finalize = args.length ? args.shift() : null;
    command = args.length ? args.shift() : null;
    options = args.length ? args.shift() || {} : {};
    if (!(typeof finalize === "function")) {
      command = finalize;
      finalize = null;
    }
    if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
      keys = Object.keys(keys);
    }
    if (typeof reduce === "function") {
      reduce = reduce.toString();
    }
    if (typeof finalize === "function") {
      finalize = finalize.toString();
    }
    command = command == null ? true : command;
    return executeLegacyOperation(this.s.topology, group, [
      this,
      keys,
      condition,
      initial,
      reduce,
      finalize,
      command,
      options,
      callback
    ]);
  }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
  Collection2.prototype.mapReduce = function(map, reduce, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    if (options.out == null) {
      throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
    }
    if (typeof map === "function") {
      map = map.toString();
    }
    if (typeof reduce === "function") {
      reduce = reduce.toString();
    }
    if (typeof options.finalize === "function") {
      options.finalize = options.finalize.toString();
    }
    const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);
    return executeOperation(this.s.topology, mapReduceOperation, callback);
  };
  Collection2.prototype.initializeUnorderedBulkOp = function(options) {
    options = options || {};
    if (options.ignoreUndefined == null) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options.promiseLibrary = this.s.promiseLibrary;
    return unordered(this.s.topology, this, options);
  };
  Collection2.prototype.initializeOrderedBulkOp = function(options) {
    options = options || {};
    if (options.ignoreUndefined == null) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options.promiseLibrary = this.s.promiseLibrary;
    return ordered(this.s.topology, this, options);
  };
  Collection2.prototype.getLogger = function() {
    return this.s.db.s.logger;
  };
  module2.exports = Collection2;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter = require("events");
  var isResumableError = require_error2().isResumableError;
  var MongoError = require_core2().MongoError;
  var Cursor = require_cursor2();
  var relayEvents = require_utils2().relayEvents;
  var maxWireVersion = require_utils2().maxWireVersion;
  var maybePromise = require_utils4().maybePromise;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var AggregateOperation = require_aggregate();
  var kResumeQueue = Symbol("resumeQueue");
  var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
  var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var ChangeStream = class extends EventEmitter {
    constructor(parent, pipeline, options) {
      super();
      const Collection2 = require_collection();
      const Db = require_db2();
      const MongoClient2 = require_mongo_client();
      this.pipeline = pipeline || [];
      this.options = options || {};
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (parent instanceof Collection2) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
        this.topology = parent.s.db.serverConfig;
      } else if (parent instanceof Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
        this.topology = parent.serverConfig;
      } else if (parent instanceof MongoClient2) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
        this.topology = parent.topology;
      } else {
        throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
      }
      this.promiseLibrary = parent.s.promiseLibrary;
      if (!this.options.readPreference && parent.s.readPreference) {
        this.options.readPreference = parent.s.readPreference;
      }
      this[kResumeQueue] = new Denque();
      this.cursor = createChangeStreamCursor(this, options);
      this.closed = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this.cursor.on("data", (change) => processNewChange(this, change));
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this.cursor.removeAllListeners("data");
        }
      });
    }
    get resumeToken() {
      return this.cursor.resumeToken;
    }
    hasNext(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        getCursor(this, (err, cursor) => {
          if (err)
            return cb(err);
          cursor.hasNext(cb);
        });
      });
    }
    next(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        getCursor(this, (err, cursor) => {
          if (err)
            return cb(err);
          cursor.next((error, change) => {
            if (error) {
              this[kResumeQueue].push(() => this.next(cb));
              processError(this, error, cb);
              return;
            }
            processNewChange(this, change, cb);
          });
        });
      });
    }
    isClosed() {
      return this.closed || this.cursor && this.cursor.isClosed();
    }
    close(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        if (this.closed)
          return cb();
        this.closed = true;
        if (!this.cursor)
          return cb();
        const cursor = this.cursor;
        return cursor.close((err) => {
          ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
          this.cursor = void 0;
          return cb(err);
        });
      });
    }
    pipe(destination, options) {
      if (!this.pipeDestinations) {
        this.pipeDestinations = [];
      }
      this.pipeDestinations.push(destination);
      return this.cursor.pipe(destination, options);
    }
    unpipe(destination) {
      if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
        this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
      }
      return this.cursor.unpipe(destination);
    }
    stream(options) {
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    pause() {
      return this.cursor.pause();
    }
    resume() {
      return this.cursor.resume();
    }
  };
  var ChangeStreamCursor = class extends Cursor {
    constructor(topology, operation, options) {
      super(topology, operation, options);
      options = options || {};
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit("resumeTokenChanged", token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const result = {};
      for (const optionName of CURSOR_OPTIONS) {
        if (this.options[optionName])
          result[optionName] = this.options[optionName];
      }
      if (this.resumeToken || this.startAtOperationTime) {
        ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
        if (this.resumeToken) {
          const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
          result[resumeKey] = this.resumeToken;
        } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
          result.startAtOperationTime = this.startAtOperationTime;
        }
      }
      return result;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
        this.resumeToken = this.cursorState.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(batchName, response) {
      const cursor = response.cursor;
      if (cursor.postBatchResumeToken) {
        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
        if (cursor[batchName].length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
    _initializeCursor(callback) {
      super._initializeCursor((err, result) => {
        if (err || result == null) {
          callback(err, result);
          return;
        }
        const response = result.documents[0];
        if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
          this.startAtOperationTime = response.operationTime;
        }
        this._processBatch("firstBatch", response);
        this.emit("init", result);
        this.emit("response");
        callback(err, result);
      });
    }
    _getMore(callback) {
      super._getMore((err, response) => {
        if (err) {
          callback(err);
          return;
        }
        this._processBatch("nextBatch", response);
        this.emit("more", response);
        this.emit("response");
        callback(err, response);
      });
    }
  };
  function createChangeStreamCursor(self2, options) {
    const changeStreamStageOptions = {fullDocument: options.fullDocument || "default"};
    applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);
    if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
      changeStreamStageOptions.allChangesForCluster = true;
    }
    const pipeline = [{$changeStream: changeStreamStageOptions}].concat(self2.pipeline);
    const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);
    const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline, options), cursorOptions);
    relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
    if (self2.listenerCount("change") > 0) {
      changeStreamCursor.on("data", function(change) {
        processNewChange(self2, change);
      });
    }
    changeStreamCursor.on("error", function(error) {
      processError(self2, error);
    });
    if (self2.pipeDestinations) {
      const cursorStream = changeStreamCursor.stream(self2.streamOptions);
      for (let pipeDestination of self2.pipeDestinations) {
        cursorStream.pipe(pipeDestination);
      }
    }
    return changeStreamCursor;
  }
  function applyKnownOptions(target, source, optionNames) {
    optionNames.forEach((name) => {
      if (source[name]) {
        target[name] = source[name];
      }
    });
    return target;
  }
  var SELECTION_TIMEOUT = 3e4;
  function waitForTopologyConnected(topology, options, callback) {
    setTimeout(() => {
      if (options && options.start == null) {
        options.start = now();
      }
      const start = options.start || now();
      const timeout = options.timeout || SELECTION_TIMEOUT;
      const readPreference = options.readPreference;
      if (topology.isConnected({readPreference})) {
        return callback();
      }
      if (calculateDurationInMs(start) > timeout) {
        return callback(new MongoError("Timed out waiting for connection"));
      }
      waitForTopologyConnected(topology, options, callback);
    }, 500);
  }
  function processNewChange(changeStream, change, callback) {
    const cursor = changeStream.cursor;
    if (change == null) {
      changeStream.closed = true;
    }
    if (changeStream.closed) {
      if (callback)
        callback(new MongoError("ChangeStream is closed"));
      return;
    }
    if (change && !change._id) {
      const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
      if (!callback)
        return changeStream.emit("error", noResumeTokenError);
      return callback(noResumeTokenError);
    }
    cursor.cacheResumeToken(change._id);
    changeStream.options.startAtOperationTime = void 0;
    if (!callback)
      return changeStream.emit("change", change);
    return callback(void 0, change);
  }
  function processError(changeStream, error, callback) {
    const topology = changeStream.topology;
    const cursor = changeStream.cursor;
    if (changeStream.closed) {
      if (callback)
        callback(new MongoError("ChangeStream is closed"));
      return;
    }
    function resumeWithCursor(newCursor) {
      changeStream.cursor = newCursor;
      processResumeQueue(changeStream);
    }
    function unresumableError(err) {
      if (!callback) {
        changeStream.emit("error", err);
        changeStream.emit("close");
      }
      processResumeQueue(changeStream, err);
      changeStream.closed = true;
    }
    if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {
      changeStream.cursor = void 0;
      ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
      cursor.close();
      waitForTopologyConnected(topology, {readPreference: cursor.options.readPreference}, (err) => {
        if (err)
          return unresumableError(err);
        const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
        if (!callback)
          return resumeWithCursor(newCursor);
        newCursor.hasNext((err2) => {
          if (err2)
            return unresumableError(err2);
          resumeWithCursor(newCursor);
        });
      });
      return;
    }
    if (!callback)
      return changeStream.emit("error", error);
    return callback(error);
  }
  function getCursor(changeStream, callback) {
    if (changeStream.isClosed()) {
      callback(new MongoError("ChangeStream is closed."));
      return;
    }
    if (changeStream.cursor) {
      callback(void 0, changeStream.cursor);
      return;
    }
    changeStream[kResumeQueue].push(callback);
  }
  function processResumeQueue(changeStream, err) {
    while (changeStream[kResumeQueue].length) {
      const request = changeStream[kResumeQueue].pop();
      if (changeStream.isClosed() && !err) {
        request(new MongoError("Change Stream is not open."));
        return;
      }
      request(err, changeStream.cursor);
    }
  }
  module2.exports = ChangeStream;
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS((exports2) => {
  "use strict";
  var EventEmitter = require("events");
  var MongoError = require_core2().MongoError;
  var f = require("util").format;
  var ReadPreference = require_core2().ReadPreference;
  var ClientSession = require_core2().Sessions.ClientSession;
  var Store = function(topology, storeOptions) {
    var self2 = this;
    var storedOps = [];
    storeOptions = storeOptions || {force: false, bufferMaxEntries: -1};
    this.s = {
      storedOps,
      storeOptions,
      topology
    };
    Object.defineProperty(this, "length", {
      enumerable: true,
      get: function() {
        return self2.s.storedOps.length;
      }
    });
  };
  Store.prototype.add = function(opType, ns, ops, options, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({message: "db closed by application", driver: true}));
    }
    if (this.s.storeOptions.bufferMaxEntries === 0) {
      return callback(MongoError.create({
        message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
        driver: true
      }));
    }
    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      return;
    }
    this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback});
  };
  Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({message: "db closed by application", driver: true}));
    }
    if (this.s.storeOptions.bufferMaxEntries === 0) {
      return callback(MongoError.create({
        message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
        driver: true
      }));
    }
    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      return;
    }
    this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback});
  };
  Store.prototype.flush = function(err) {
    while (this.s.storedOps.length > 0) {
      this.s.storedOps.shift().c(err || MongoError.create({message: f("no connection available for operation"), driver: true}));
    }
  };
  var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
  var secondaryOptions = ["secondary", "secondaryPreferred"];
  Store.prototype.execute = function(options) {
    options = options || {};
    var ops = this.s.storedOps;
    this.s.storedOps = [];
    var executePrimary = typeof options.executePrimary === "boolean" ? options.executePrimary : true;
    var executeSecondary = typeof options.executeSecondary === "boolean" ? options.executeSecondary : true;
    while (ops.length > 0) {
      var op = ops.shift();
      if (op.t === "cursor") {
        if (executePrimary && executeSecondary) {
          op.o[op.m].apply(op.o, op.p);
        } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
          op.o[op.m].apply(op.o, op.p);
        } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
          op.o[op.m].apply(op.o, op.p);
        }
      } else if (op.t === "auth") {
        this.s.topology[op.t].apply(this.s.topology, op.o);
      } else {
        if (executePrimary && executeSecondary) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        }
      }
    }
  };
  Store.prototype.all = function() {
    return this.s.storedOps;
  };
  var ServerCapabilities = function(ismaster) {
    var setup_get_property = function(object, name, value) {
      Object.defineProperty(object, name, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var aggregationCursor = false;
    var writeCommands = false;
    var textSearch = false;
    var authCommands = false;
    var listCollections = false;
    var listIndexes = false;
    var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
    var commandsTakeWriteConcern = false;
    var commandsTakeCollation = false;
    if (ismaster.minWireVersion >= 0) {
      textSearch = true;
    }
    if (ismaster.maxWireVersion >= 1) {
      aggregationCursor = true;
      authCommands = true;
    }
    if (ismaster.maxWireVersion >= 2) {
      writeCommands = true;
    }
    if (ismaster.maxWireVersion >= 3) {
      listCollections = true;
      listIndexes = true;
    }
    if (ismaster.maxWireVersion >= 5) {
      commandsTakeWriteConcern = true;
      commandsTakeCollation = true;
    }
    if (ismaster.minWireVersion == null) {
      ismaster.minWireVersion = 0;
    }
    if (ismaster.maxWireVersion == null) {
      ismaster.maxWireVersion = 0;
    }
    setup_get_property(this, "hasAggregationCursor", aggregationCursor);
    setup_get_property(this, "hasWriteCommands", writeCommands);
    setup_get_property(this, "hasTextSearch", textSearch);
    setup_get_property(this, "hasAuthCommands", authCommands);
    setup_get_property(this, "hasListCollectionsCommand", listCollections);
    setup_get_property(this, "hasListIndexesCommand", listIndexes);
    setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
    setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
    setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
    setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
    setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
  };
  var TopologyBase = class extends EventEmitter {
    constructor() {
      super();
      this.setMaxListeners(Infinity);
    }
    hasSessionSupport() {
      return this.logicalSessionTimeoutMinutes != null;
    }
    startSession(options, clientOptions) {
      const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
      session.once("ended", () => {
        this.s.sessions.delete(session);
      });
      this.s.sessions.add(session);
      return session;
    }
    endSessions(sessions, callback) {
      return this.s.coreTopology.endSessions(sessions, callback);
    }
    get clientMetadata() {
      return this.s.coreTopology.s.options.metadata;
    }
    capabilities() {
      if (this.s.sCapabilities)
        return this.s.sCapabilities;
      if (this.s.coreTopology.lastIsMaster() == null)
        return null;
      this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
      return this.s.sCapabilities;
    }
    command(ns, cmd, options, callback) {
      this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options), callback);
    }
    insert(ns, ops, options, callback) {
      this.s.coreTopology.insert(ns.toString(), ops, options, callback);
    }
    update(ns, ops, options, callback) {
      this.s.coreTopology.update(ns.toString(), ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      this.s.coreTopology.remove(ns.toString(), ops, options, callback);
    }
    isConnected(options) {
      options = options || {};
      options = ReadPreference.translate(options);
      return this.s.coreTopology.isConnected(options);
    }
    isDestroyed() {
      return this.s.coreTopology.isDestroyed();
    }
    cursor(ns, cmd, options) {
      options = options || {};
      options = ReadPreference.translate(options);
      options.disconnectHandler = this.s.store;
      options.topology = this;
      return this.s.coreTopology.cursor(ns, cmd, options);
    }
    lastIsMaster() {
      return this.s.coreTopology.lastIsMaster();
    }
    selectServer(selector, options, callback) {
      return this.s.coreTopology.selectServer(selector, options, callback);
    }
    unref() {
      return this.s.coreTopology.unref();
    }
    connections() {
      return this.s.coreTopology.connections();
    }
    close(forceClosed, callback) {
      this.s.sessions.forEach((session) => session.endSession());
      if (this.s.sessionPool) {
        this.s.sessionPool.endAllPooledSessions();
      }
      if (forceClosed === true) {
        this.s.storeOptions.force = forceClosed;
        this.s.store.flush();
      }
      this.s.coreTopology.destroy({
        force: typeof forceClosed === "boolean" ? forceClosed : false
      }, callback);
    }
  };
  Object.defineProperty(TopologyBase.prototype, "bson", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.bson;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.parserType;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.logicalSessionTimeoutMinutes;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "type", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.type;
    }
  });
  exports2.Store = Store;
  exports2.ServerCapabilities = ServerCapabilities;
  exports2.TopologyBase = TopologyBase;
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS((exports2, module2) => {
  "use strict";
  var Topology = require_core2().Topology;
  var ServerCapabilities = require_topology_base().ServerCapabilities;
  var Cursor = require_cursor2();
  var translateOptions = require_utils4().translateOptions;
  var NativeTopology = class extends Topology {
    constructor(servers, options) {
      options = options || {};
      let clonedOptions = Object.assign({}, {
        cursorFactory: Cursor,
        reconnect: false,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : typeof options.poolSize === "number" ? options.poolSize : 10,
        minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : typeof options.minSize === "number" ? options.minSize : 0,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      super(servers, clonedOptions);
    }
    capabilities() {
      if (this.s.sCapabilities)
        return this.s.sCapabilities;
      if (this.lastIsMaster() == null)
        return null;
      this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
      return this.s.sCapabilities;
    }
    command(ns, cmd, options, callback) {
      super.command(ns.toString(), cmd, options, callback);
    }
    insert(ns, ops, options, callback) {
      super.insert(ns.toString(), ops, options, callback);
    }
    update(ns, ops, options, callback) {
      super.update(ns.toString(), ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      super.remove(ns.toString(), ops, options, callback);
    }
  };
  module2.exports = NativeTopology;
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS((exports2, module2) => {
  "use strict";
  var CServer = require_core2().Server;
  var Cursor = require_cursor2();
  var TopologyBase = require_topology_base().TopologyBase;
  var Store = require_topology_base().Store;
  var MongoError = require_core2().MongoError;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "acceptableLatencyMS",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCRL",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "family",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "reconnectInterval",
    "monitoring",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "compression",
    "promiseLibrary",
    "monitorCommands"
  ];
  var Server = class extends TopologyBase {
    constructor(host, port, options) {
      super();
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      const promiseLibrary = options.promiseLibrary;
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      if (host.indexOf("/") !== -1) {
        if (port != null && typeof port === "object") {
          options = port;
          port = null;
        }
      } else if (port == null) {
        throw MongoError.create({message: "port must be specified", driver: true});
      }
      var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        host,
        port,
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      this.s = {
        coreTopology: new CServer(clonedOptions),
        sCapabilities: null,
        clonedOptions,
        reconnect: clonedOptions.reconnect,
        emitError: clonedOptions.emitError,
        poolSize: clonedOptions.size,
        storeOptions,
        store,
        host,
        port,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: promiseLibrary || Promise
      };
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = this.s.clonedOptions;
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var connectErrorHandler = function() {
        return function(err) {
          var events = ["timeout", "error", "close"];
          events.forEach(function(e) {
            self2.s.coreTopology.removeListener(e, connectHandlers[e]);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          try {
            callback(err);
          } catch (err2) {
            process.nextTick(function() {
              throw err2;
            });
          }
        };
      };
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var reconnectHandler = function() {
        self2.emit("reconnect", self2);
        self2.s.store.execute();
      };
      var reconnectFailedHandler = function(err) {
        self2.emit("reconnectFailed", err);
        self2.s.store.flush(err);
      };
      var destroyHandler = function() {
        self2.s.store.flush();
      };
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var connectHandler = function() {
        ["timeout", "error", "close", "destroy"].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("timeout", errorHandler("timeout"));
        self2.s.coreTopology.once("error", errorHandler("error"));
        self2.s.coreTopology.on("close", errorHandler("close"));
        self2.s.coreTopology.on("destroy", destroyHandler);
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var connectHandlers = {
        timeout: connectErrorHandler("timeout"),
        error: connectErrorHandler("error"),
        close: connectErrorHandler("close")
      };
      [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed"
      ].forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      self2.s.coreTopology.once("timeout", connectHandlers.timeout);
      self2.s.coreTopology.once("error", connectHandlers.error);
      self2.s.coreTopology.once("close", connectHandlers.close);
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.on("reconnect", reconnectHandler);
      self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
      self2.s.coreTopology.on("monitoring", relay("monitoring"));
      self2.s.coreTopology.connect(_options);
    }
  };
  Object.defineProperty(Server.prototype, "poolSize", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.connections().length;
    }
  });
  Object.defineProperty(Server.prototype, "autoReconnect", {
    enumerable: true,
    get: function() {
      return this.s.reconnect;
    }
  });
  Object.defineProperty(Server.prototype, "host", {
    enumerable: true,
    get: function() {
      return this.s.host;
    }
  });
  Object.defineProperty(Server.prototype, "port", {
    enumerable: true,
    get: function() {
      return this.s.port;
    }
  });
  module2.exports = Server;
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS((exports2, module2) => {
  "use strict";
  var TopologyBase = require_topology_base().TopologyBase;
  var MongoError = require_core2().MongoError;
  var CMongos = require_core2().Mongos;
  var Cursor = require_cursor2();
  var Server = require_server3();
  var Store = require_topology_base().Store;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "acceptableLatencyMS",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCRL",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "promiseLibrary",
    "monitorCommands"
  ];
  var Mongos = class extends TopologyBase {
    constructor(servers, options) {
      super();
      options = options || {};
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      var seedlist = servers.map(function(x) {
        return {host: x.host, port: x.port};
      });
      var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      this.s = {
        coreTopology: new CMongos(seedlist, clonedOptions),
        sCapabilities: null,
        debug: clonedOptions.debug,
        storeOptions,
        clonedOptions,
        store,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise
      };
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = {};
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var connectErrorHandler = function() {
        return function(err) {
          var events2 = ["timeout", "error", "close"];
          events2.forEach(function(e) {
            self2.removeListener(e, connectErrorHandler);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          self2.close(true);
          try {
            callback(err);
          } catch (err2) {
            process.nextTick(function() {
              throw err2;
            });
          }
        };
      };
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var reconnectHandler = function() {
        self2.emit("reconnect");
        self2.s.store.execute();
      };
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var connectHandler = function() {
        var events2 = ["timeout", "error", "close", "fullsetup"];
        events2.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("timeout", errorHandler("timeout"));
        self2.s.coreTopology.on("error", errorHandler("error"));
        self2.s.coreTopology.on("close", errorHandler("close"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2);
        });
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var events = [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed"
      ];
      events.forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
      self2.s.coreTopology.once("error", connectErrorHandler("error"));
      self2.s.coreTopology.once("close", connectErrorHandler("close"));
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.on("joined", relay("joined"));
      self2.s.coreTopology.on("left", relay("left"));
      self2.s.coreTopology.on("reconnect", reconnectHandler);
      self2.s.coreTopology.connect(_options);
    }
  };
  Object.defineProperty(Mongos.prototype, "haInterval", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.haInterval;
    }
  });
  module2.exports = Mongos;
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS((exports2, module2) => {
  "use strict";
  var Server = require_server3();
  var Cursor = require_cursor2();
  var MongoError = require_core2().MongoError;
  var TopologyBase = require_topology_base().TopologyBase;
  var Store = require_topology_base().Store;
  var CReplSet = require_core2().ReplSet;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "replicaSet",
    "rs_name",
    "secondaryAcceptableLatencyMS",
    "connectWithNoPrimary",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslCRL",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "strategy",
    "debug",
    "family",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "maxStalenessSeconds",
    "promiseLibrary",
    "minSize",
    "monitorCommands"
  ];
  var ReplSet = class extends TopologyBase {
    constructor(servers, options) {
      super();
      options = options || {};
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      var seedlist = servers.map(function(x) {
        return {host: x.host, port: x.port};
      });
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: false,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      var coreTopology = new CReplSet(seedlist, clonedOptions);
      coreTopology.on("reconnect", function() {
        self2.emit("reconnect");
        store.execute();
      });
      this.s = {
        coreTopology,
        sCapabilities: null,
        tag: options.tag,
        storeOptions,
        clonedOptions,
        store,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise
      };
      if (clonedOptions.debug) {
        Object.defineProperty(this, "replset", {
          enumerable: true,
          get: function() {
            return coreTopology;
          }
        });
      }
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = {};
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var events = [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "joined",
        "left",
        "ping",
        "ha"
      ];
      events.forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var replsetRelay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server.lastIsMaster(), server);
        };
      };
      var relayHa = function(t, state) {
        self2.emit("ha", t, state);
        if (t === "start") {
          self2.emit("ha_connect", t, state);
        } else if (t === "end") {
          self2.emit("ha_ismaster", t, state);
        }
      };
      self2.s.coreTopology.on("joined", replsetRelay("joined"));
      self2.s.coreTopology.on("left", relay("left"));
      self2.s.coreTopology.on("ping", relay("ping"));
      self2.s.coreTopology.on("ha", relayHa);
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.on("fullsetup", function() {
        self2.emit("fullsetup", self2, self2);
      });
      self2.s.coreTopology.on("all", function() {
        self2.emit("all", null, self2);
      });
      var connectHandler = function() {
        self2.s.coreTopology.once("timeout", errorHandler("timeout"));
        self2.s.coreTopology.once("error", errorHandler("error"));
        self2.s.coreTopology.once("close", errorHandler("close"));
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var connectErrorHandler = function() {
        return function(err) {
          ["timeout", "error", "close"].forEach(function(e) {
            self2.s.coreTopology.removeListener(e, connectErrorHandler);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          self2.s.coreTopology.destroy();
          try {
            callback(err);
          } catch (err2) {
            if (!self2.s.coreTopology.isConnected())
              process.nextTick(function() {
                throw err2;
              });
          }
        };
      };
      self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
      self2.s.coreTopology.once("error", connectErrorHandler("error"));
      self2.s.coreTopology.once("close", connectErrorHandler("close"));
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.connect(_options);
    }
    close(forceClosed, callback) {
      ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
      super.close(forceClosed, callback);
    }
  };
  Object.defineProperty(ReplSet.prototype, "haInterval", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.haInterval;
    }
  });
  module2.exports = ReplSet;
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_core2().ReadPreference;
  var parser = require("url");
  var f = require("util").format;
  var Logger = require_core2().Logger;
  var dns = require("dns");
  var ReadConcern = require_read_concern();
  var qs = require("querystring");
  var MongoParseError = require_error().MongoParseError;
  module2.exports = function(url, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    let result;
    try {
      result = parser.parse(url, true);
    } catch (e) {
      return callback(new Error("URL malformed, cannot be parsed"));
    }
    if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
      return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
    }
    if (result.protocol === "mongodb:") {
      return parseHandler(url, options, callback);
    }
    if (result.hostname.split(".").length < 3) {
      return callback(new Error("URI does not have hostname, domain name and tld"));
    }
    result.domainLength = result.hostname.split(".").length;
    if (result.pathname && result.pathname.match(",")) {
      return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
    }
    if (result.port) {
      return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
    }
    let srvAddress = `_mongodb._tcp.${result.host}`;
    dns.resolveSrv(srvAddress, function(err, addresses) {
      if (err)
        return callback(err);
      if (addresses.length === 0) {
        return callback(new Error("No addresses found at host"));
      }
      for (let i = 0; i < addresses.length; i++) {
        if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
          return callback(new Error("Server record does not share hostname with parent URI"));
        }
      }
      let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
      let connectionStrings = addresses.map(function(address, i) {
        if (i === 0)
          return `${base}${address.name}:${address.port}`;
        else
          return `${address.name}:${address.port}`;
      });
      let connectionString = connectionStrings.join(",") + "/";
      let connectionStringOptions = [];
      if (result.path) {
        let defaultDb = result.path.slice(1);
        if (defaultDb.indexOf("?") !== -1) {
          defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
        }
        connectionString += defaultDb;
      }
      if (!options.ssl && !result.search) {
        connectionStringOptions.push("ssl=true");
      } else if (!options.ssl && result.search && !result.search.match("ssl")) {
        connectionStringOptions.push("ssl=true");
      }
      if (result.search) {
        connectionStringOptions.push(result.search.replace("?", ""));
      }
      dns.resolveTxt(result.host, function(err2, record) {
        if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
          return callback(err2);
        if (err2 && err2.code === "ENODATA")
          record = null;
        if (record) {
          if (record.length > 1) {
            return callback(new MongoParseError("Multiple text records not allowed"));
          }
          record = record[0].join("");
          const parsedRecord = qs.parse(record);
          const items = Object.keys(parsedRecord);
          if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
            return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
          }
          if (items.length > 0) {
            connectionStringOptions.push(record);
          }
        }
        if (connectionStringOptions.length) {
          connectionString += `?${connectionStringOptions.join("&")}`;
        }
        parseHandler(connectionString, options, callback);
      });
    });
  };
  function matchesParentDomain(srvAddress, parentDomain) {
    let regex = /^.*?\./;
    let srv = `.${srvAddress.replace(regex, "")}`;
    let parent = `.${parentDomain.replace(regex, "")}`;
    if (srv.endsWith(parent))
      return true;
    else
      return false;
  }
  function parseHandler(address, options, callback) {
    let result, err;
    try {
      result = parseConnectionString(address, options);
    } catch (e) {
      err = e;
    }
    return err ? callback(err, null) : callback(null, result);
  }
  function parseConnectionString(url, options) {
    let connection_part = "";
    let auth_part = "";
    let query_string_part = "";
    let dbName = "admin";
    let result = parser.parse(url, true);
    if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
      throw new Error("No hostname or hostnames provided in connection string");
    }
    if (result.port === "0") {
      throw new Error("Invalid port (zero) with hostname");
    }
    if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
      throw new Error("Invalid port (larger than 65535) with hostname");
    }
    if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
      throw new Error("Missing delimiting slash between hosts and options");
    }
    if (result.query) {
      for (let name in result.query) {
        if (name.indexOf("::") !== -1) {
          throw new Error("Double colon in host identifier");
        }
        if (result.query[name] === "") {
          throw new Error("Query parameter " + name + " is an incomplete value pair");
        }
      }
    }
    if (result.auth) {
      let parts = result.auth.split(":");
      if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
        throw new Error("Username with password containing an unescaped colon");
      }
      if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
        throw new Error("Username containing an unescaped at-sign");
      }
    }
    let clean = url.split("?").shift();
    let strings = clean.split(",");
    let hosts = [];
    for (let i = 0; i < strings.length; i++) {
      let hostString = strings[i];
      if (hostString.indexOf("mongodb") !== -1) {
        if (hostString.indexOf("@") !== -1) {
          hosts.push(hostString.split("@").pop());
        } else {
          hosts.push(hostString.substr("mongodb://".length));
        }
      } else if (hostString.indexOf("/") !== -1) {
        hosts.push(hostString.split("/").shift());
      } else if (hostString.indexOf("/") === -1) {
        hosts.push(hostString.trim());
      }
    }
    for (let i = 0; i < hosts.length; i++) {
      let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
      if (r.path && r.path.indexOf(".sock") !== -1)
        continue;
      if (r.path && r.path.indexOf(":") !== -1) {
        if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
          throw new Error("Slash in host identifier");
        } else {
          throw new Error("Double colon in host identifier");
        }
      }
    }
    if (url.indexOf("?") !== -1) {
      query_string_part = url.substr(url.indexOf("?") + 1);
      connection_part = url.substring("mongodb://".length, url.indexOf("?"));
    } else {
      connection_part = url.substring("mongodb://".length);
    }
    if (connection_part.indexOf("@") !== -1) {
      auth_part = connection_part.split("@")[0];
      connection_part = connection_part.split("@")[1];
    }
    if (connection_part.split("/").length > 2) {
      throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
    }
    if (connection_part.indexOf(".sock") !== -1) {
      if (connection_part.indexOf(".sock/") !== -1) {
        dbName = connection_part.split(".sock/")[1];
        if (dbName.indexOf("/") !== -1) {
          if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
      }
    } else if (connection_part.indexOf("/") !== -1) {
      if (connection_part.split("/").length > 2) {
        if (connection_part.split("/")[2].length === 0) {
          throw new Error("Illegal trailing backslash after database name");
        }
        throw new Error("More than 1 database name in URL");
      }
      dbName = connection_part.split("/")[1];
      connection_part = connection_part.split("/")[0];
    }
    connection_part = decodeURIComponent(connection_part);
    let object = {};
    let authPart = auth_part || "";
    let auth = authPart.split(":", 2);
    let user = decodeURIComponent(auth[0]);
    if (auth[0] !== encodeURIComponent(user)) {
      throw new Error("Username contains an illegal unescaped character");
    }
    auth[0] = user;
    if (auth[1]) {
      let pass = decodeURIComponent(auth[1]);
      if (auth[1] !== encodeURIComponent(pass)) {
        throw new Error("Password contains an illegal unescaped character");
      }
      auth[1] = pass;
    }
    if (auth.length === 2)
      object.auth = {user: auth[0], password: auth[1]};
    if (options && options.auth != null)
      object.auth = options.auth;
    let hostPart;
    let urlOptions;
    let servers;
    let compression;
    let serverOptions = {socketOptions: {}};
    let dbOptions = {read_preference_tags: []};
    let replSetServersOptions = {socketOptions: {}};
    let mongosOptions = {socketOptions: {}};
    object.server_options = serverOptions;
    object.db_options = dbOptions;
    object.rs_options = replSetServersOptions;
    object.mongos_options = mongosOptions;
    if (url.match(/\.sock/)) {
      let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
      if (domainSocket.indexOf("@") !== -1)
        domainSocket = domainSocket.split("@")[1];
      domainSocket = decodeURIComponent(domainSocket);
      servers = [{domain_socket: domainSocket}];
    } else {
      hostPart = connection_part;
      let deduplicatedServers = {};
      servers = hostPart.split(",").map(function(h) {
        let _host, _port, ipv6match;
        if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
          _host = ipv6match[1];
          _port = parseInt(ipv6match[2], 10) || 27017;
        } else {
          let hostPort = h.split(":", 2);
          _host = hostPort[0] || "localhost";
          _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
          if (_host.indexOf("?") !== -1)
            _host = _host.split(/\?/)[0];
        }
        if (deduplicatedServers[_host + "_" + _port])
          return null;
        deduplicatedServers[_host + "_" + _port] = 1;
        return {host: _host, port: _port};
      }).filter(function(x) {
        return x != null;
      });
    }
    object.dbName = dbName || "admin";
    urlOptions = (query_string_part || "").split(/[&;]/);
    urlOptions.forEach(function(opt) {
      if (!opt)
        return;
      var splitOpt = opt.split("="), name = splitOpt[0], value = splitOpt[1];
      switch (name) {
        case "slaveOk":
        case "slave_ok":
          serverOptions.slave_ok = value === "true";
          dbOptions.slaveOk = value === "true";
          break;
        case "maxPoolSize":
        case "poolSize":
          serverOptions.poolSize = parseInt(value, 10);
          replSetServersOptions.poolSize = parseInt(value, 10);
          break;
        case "appname":
          object.appname = decodeURIComponent(value);
          break;
        case "autoReconnect":
        case "auto_reconnect":
          serverOptions.auto_reconnect = value === "true";
          break;
        case "ssl":
          if (value === "prefer") {
            serverOptions.ssl = value;
            replSetServersOptions.ssl = value;
            mongosOptions.ssl = value;
            break;
          }
          serverOptions.ssl = value === "true";
          replSetServersOptions.ssl = value === "true";
          mongosOptions.ssl = value === "true";
          break;
        case "sslValidate":
          serverOptions.sslValidate = value === "true";
          replSetServersOptions.sslValidate = value === "true";
          mongosOptions.sslValidate = value === "true";
          break;
        case "replicaSet":
        case "rs_name":
          replSetServersOptions.rs_name = value;
          break;
        case "reconnectWait":
          replSetServersOptions.reconnectWait = parseInt(value, 10);
          break;
        case "retries":
          replSetServersOptions.retries = parseInt(value, 10);
          break;
        case "readSecondary":
        case "read_secondary":
          replSetServersOptions.read_secondary = value === "true";
          break;
        case "fsync":
          dbOptions.fsync = value === "true";
          break;
        case "journal":
          dbOptions.j = value === "true";
          break;
        case "safe":
          dbOptions.safe = value === "true";
          break;
        case "nativeParser":
        case "native_parser":
          dbOptions.native_parser = value === "true";
          break;
        case "readConcernLevel":
          dbOptions.readConcern = new ReadConcern(value);
          break;
        case "connectTimeoutMS":
          serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          break;
        case "socketTimeoutMS":
          serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          break;
        case "w":
          dbOptions.w = parseInt(value, 10);
          if (isNaN(dbOptions.w))
            dbOptions.w = value;
          break;
        case "authSource":
          dbOptions.authSource = value;
          break;
        case "gssapiServiceName":
          dbOptions.gssapiServiceName = value;
          break;
        case "authMechanism":
          if (value === "GSSAPI") {
            if (object.auth == null) {
              let urlDecodeAuthPart = decodeURIComponent(authPart);
              if (urlDecodeAuthPart.indexOf("@") === -1)
                throw new Error("GSSAPI requires a provided principal");
              object.auth = {user: urlDecodeAuthPart, password: null};
            } else {
              object.auth.user = decodeURIComponent(object.auth.user);
            }
          } else if (value === "MONGODB-X509") {
            object.auth = {user: decodeURIComponent(authPart)};
          }
          if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
            throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
          dbOptions.authMechanism = value;
          break;
        case "authMechanismProperties":
          {
            let values = value.split(",");
            let o = {};
            values.forEach(function(x) {
              let v = x.split(":");
              o[v[0]] = v[1];
            });
            dbOptions.authMechanismProperties = o;
            if (typeof o.SERVICE_NAME === "string")
              dbOptions.gssapiServiceName = o.SERVICE_NAME;
            if (typeof o.SERVICE_REALM === "string")
              dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
            if (typeof o.CANONICALIZE_HOST_NAME === "string")
              dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
          }
          break;
        case "wtimeoutMS":
          dbOptions.wtimeout = parseInt(value, 10);
          break;
        case "readPreference":
          if (!ReadPreference.isValid(value))
            throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
          dbOptions.readPreference = value;
          break;
        case "maxStalenessSeconds":
          dbOptions.maxStalenessSeconds = parseInt(value, 10);
          break;
        case "readPreferenceTags":
          {
            value = decodeURIComponent(value);
            let tagObject = {};
            if (value == null || value === "") {
              dbOptions.read_preference_tags.push(tagObject);
              break;
            }
            let tags = value.split(/,/);
            for (let i = 0; i < tags.length; i++) {
              let parts = tags[i].trim().split(/:/);
              tagObject[parts[0]] = parts[1];
            }
            dbOptions.read_preference_tags.push(tagObject);
          }
          break;
        case "compressors":
          {
            compression = serverOptions.compression || {};
            let compressors = value.split(",");
            if (!compressors.every(function(compressor) {
              return compressor === "snappy" || compressor === "zlib";
            })) {
              throw new Error("Compressors must be at least one of snappy or zlib");
            }
            compression.compressors = compressors;
            serverOptions.compression = compression;
          }
          break;
        case "zlibCompressionLevel":
          {
            compression = serverOptions.compression || {};
            let zlibCompressionLevel = parseInt(value, 10);
            if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
              throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
            }
            compression.zlibCompressionLevel = zlibCompressionLevel;
            serverOptions.compression = compression;
          }
          break;
        case "retryWrites":
          dbOptions.retryWrites = value === "true";
          break;
        case "minSize":
          dbOptions.minSize = parseInt(value, 10);
          break;
        default:
          {
            let logger = Logger("URL Parser");
            logger.warn(`${name} is not supported as a connection string option`);
          }
          break;
      }
    });
    if (dbOptions.read_preference_tags.length === 0) {
      dbOptions.read_preference_tags = null;
    }
    if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
      throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
    if (!dbOptions.readPreference) {
      dbOptions.readPreference = "primary";
    }
    dbOptions = Object.assign(dbOptions, options);
    object.servers = servers;
    return object;
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS((exports2, module2) => {
  "use strict";
  var deprecate = require("util").deprecate;
  var Logger = require_core2().Logger;
  var MongoCredentials = require_core2().MongoCredentials;
  var MongoError = require_core2().MongoError;
  var Mongos = require_mongos2();
  var NativeTopology = require_native_topology();
  var parse = require_core2().parseConnectionString;
  var ReadConcern = require_read_concern();
  var ReadPreference = require_core2().ReadPreference;
  var ReplSet = require_replset2();
  var Server = require_server3();
  var ServerSessionPool = require_core2().Sessions.ServerSessionPool;
  var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
  var fs = require("fs");
  var WriteConcern = require_write_concern();
  var BSON2 = require_utils3().retrieveBSON();
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var client;
  function loadClient() {
    if (!client) {
      client = require_mongo_client();
    }
    return client;
  }
  var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
  var AUTH_MECHANISM_INTERNAL_MAP = {
    DEFAULT: "default",
    PLAIN: "plain",
    GSSAPI: "gssapi",
    "MONGODB-CR": "mongocr",
    "MONGODB-X509": "x509",
    "MONGODB-AWS": "mongodb-aws",
    "SCRAM-SHA-1": "scram-sha-1",
    "SCRAM-SHA-256": "scram-sha-256"
  };
  var monitoringEvents = [
    "timeout",
    "close",
    "serverOpening",
    "serverDescriptionChanged",
    "serverHeartbeatStarted",
    "serverHeartbeatSucceeded",
    "serverHeartbeatFailed",
    "serverClosed",
    "topologyOpening",
    "topologyClosed",
    "topologyDescriptionChanged",
    "commandStarted",
    "commandSucceeded",
    "commandFailed",
    "joined",
    "left",
    "ping",
    "ha",
    "all",
    "fullsetup",
    "open"
  ];
  var VALID_AUTH_MECHANISMS = new Set([
    "DEFAULT",
    "PLAIN",
    "GSSAPI",
    "MONGODB-CR",
    "MONGODB-X509",
    "MONGODB-AWS",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256"
  ]);
  var validOptionNames = [
    "poolSize",
    "ssl",
    "sslValidate",
    "sslCA",
    "sslCert",
    "sslKey",
    "sslPass",
    "sslCRL",
    "autoReconnect",
    "noDelay",
    "keepAlive",
    "keepAliveInitialDelay",
    "connectTimeoutMS",
    "family",
    "socketTimeoutMS",
    "reconnectTries",
    "reconnectInterval",
    "ha",
    "haInterval",
    "replicaSet",
    "secondaryAcceptableLatencyMS",
    "acceptableLatencyMS",
    "connectWithNoPrimary",
    "authSource",
    "w",
    "wtimeout",
    "j",
    "writeConcern",
    "forceServerObjectId",
    "serializeFunctions",
    "ignoreUndefined",
    "raw",
    "bufferMaxEntries",
    "readPreference",
    "pkFactory",
    "promiseLibrary",
    "readConcern",
    "maxStalenessSeconds",
    "loggerLevel",
    "logger",
    "promoteValues",
    "promoteBuffers",
    "promoteLongs",
    "domainsEnabled",
    "checkServerIdentity",
    "validateOptions",
    "appname",
    "auth",
    "user",
    "password",
    "authMechanism",
    "compression",
    "fsync",
    "readPreferenceTags",
    "numberOfRetries",
    "auto_reconnect",
    "minSize",
    "monitorCommands",
    "retryWrites",
    "retryReads",
    "useNewUrlParser",
    "useUnifiedTopology",
    "serverSelectionTimeoutMS",
    "useRecoveryToken",
    "autoEncryption",
    "driverInfo",
    "tls",
    "tlsInsecure",
    "tlsinsecure",
    "tlsAllowInvalidCertificates",
    "tlsAllowInvalidHostnames",
    "tlsCAFile",
    "tlsCertificateFile",
    "tlsCertificateKeyFile",
    "tlsCertificateKeyFilePassword",
    "minHeartbeatFrequencyMS",
    "heartbeatFrequencyMS",
    "directConnection",
    "appName",
    "maxPoolSize",
    "minPoolSize",
    "maxIdleTimeMS",
    "waitQueueTimeoutMS"
  ];
  var ignoreOptionNames = ["native_parser"];
  var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
  function validOptions(options) {
    const _validOptions = validOptionNames.concat(legacyOptionNames);
    for (const name in options) {
      if (ignoreOptionNames.indexOf(name) !== -1) {
        continue;
      }
      if (_validOptions.indexOf(name) === -1) {
        if (options.validateOptions) {
          return new MongoError(`option ${name} is not supported`);
        } else {
          console.warn(`the options [${name}] is not supported`);
        }
      }
      if (legacyOptionNames.indexOf(name) !== -1) {
        console.warn(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
      }
    }
  }
  var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
    obj[name.toLowerCase()] = name;
    return obj;
  }, {});
  function addListeners(mongoClient, topology) {
    topology.on("authenticated", createListener(mongoClient, "authenticated"));
    topology.on("error", createListener(mongoClient, "error"));
    topology.on("timeout", createListener(mongoClient, "timeout"));
    topology.on("close", createListener(mongoClient, "close"));
    topology.on("parseError", createListener(mongoClient, "parseError"));
    topology.once("open", createListener(mongoClient, "open"));
    topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
    topology.once("all", createListener(mongoClient, "all"));
    topology.on("reconnect", createListener(mongoClient, "reconnect"));
  }
  function assignTopology(client2, topology) {
    client2.topology = topology;
    if (!(topology instanceof NativeTopology)) {
      topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
    }
  }
  function clearAllEvents(topology) {
    monitoringEvents.forEach((event) => topology.removeAllListeners(event));
  }
  function collectEvents(mongoClient, topology) {
    let MongoClient2 = loadClient();
    const collectedEvents = [];
    if (mongoClient instanceof MongoClient2) {
      monitoringEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          if (event === "open") {
            collectedEvents.push({event, object1: mongoClient});
          } else {
            collectedEvents.push({event, object1, object2});
          }
        });
      });
    }
    return collectedEvents;
  }
  function resolveTLSOptions(options) {
    if (options.tls == null) {
      return;
    }
    ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
      if (options[optionName]) {
        options[optionName] = fs.readFileSync(options[optionName]);
      }
    });
  }
  var emitDeprecationForNonUnifiedTopology = deprecate(() => {
  }, "current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
  function connect(mongoClient, url, options, callback) {
    options = Object.assign({}, options);
    if (callback == null) {
      throw new Error("no callback function provided");
    }
    let didRequestAuthentication = false;
    const logger = Logger("MongoClient", options);
    if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
      return connectWithUrl(mongoClient, url, options, connectCallback);
    }
    const useNewUrlParser = options.useNewUrlParser !== false;
    const parseFn = useNewUrlParser ? parse : legacyParse;
    const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
    parseFn(url, options, (err, _object) => {
      if (err)
        return callback(err);
      const object = transform(_object);
      const _finalOptions = createUnifiedOptions(object, options);
      if (_finalOptions.socketTimeoutMS == null)
        _finalOptions.socketTimeoutMS = 0;
      if (_finalOptions.connectTimeoutMS == null)
        _finalOptions.connectTimeoutMS = 1e4;
      if (_finalOptions.retryWrites == null)
        _finalOptions.retryWrites = true;
      if (_finalOptions.useRecoveryToken == null)
        _finalOptions.useRecoveryToken = true;
      if (_finalOptions.readPreference == null)
        _finalOptions.readPreference = "primary";
      if (_finalOptions.db_options && _finalOptions.db_options.auth) {
        delete _finalOptions.db_options.auth;
      }
      resolveTLSOptions(_finalOptions);
      mongoClient.s.options = _finalOptions;
      mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
      mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
      if (object.servers.length === 0) {
        return callback(new Error("connection string must contain at least one seed host"));
      }
      if (_finalOptions.auth && !_finalOptions.credentials) {
        try {
          didRequestAuthentication = true;
          _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
        } catch (err2) {
          return callback(err2);
        }
      }
      if (_finalOptions.useUnifiedTopology) {
        return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
      }
      emitDeprecationForNonUnifiedTopology();
      if (_finalOptions.replicaSet || _finalOptions.rs_name) {
        return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
      } else if (object.servers.length > 1) {
        return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
      } else {
        return createServer(mongoClient, _finalOptions, connectCallback);
      }
    });
    function connectCallback(err, topology) {
      const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
      if (err && err.message === "no mongos proxies found in seed list") {
        if (logger.isWarn()) {
          logger.warn(warningMessage);
        }
        return callback(new MongoError(warningMessage));
      }
      if (didRequestAuthentication) {
        mongoClient.emit("authenticated", null, true);
      }
      callback(err, topology);
    }
  }
  function connectWithUrl(mongoClient, url, options, connectCallback) {
    assignTopology(mongoClient, url);
    addListeners(mongoClient, url);
    relayEvents(mongoClient, url);
    let finalOptions = Object.assign({}, options);
    if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
      finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);
    }
    const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
    if (isDoingAuth && !finalOptions.credentials) {
      try {
        finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
      } catch (err) {
        return connectCallback(err, url);
      }
    }
    return url.connect(finalOptions, connectCallback);
  }
  function createListener(mongoClient, event) {
    const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
    return (v1, v2) => {
      if (eventSet.has(event)) {
        return mongoClient.emit(event, mongoClient);
      }
      mongoClient.emit(event, v1, v2);
    };
  }
  function createServer(mongoClient, options, callback) {
    options.promiseLibrary = mongoClient.s.promiseLibrary;
    const servers = translateOptions(options);
    const server = servers[0];
    const collectedEvents = collectEvents(mongoClient, server);
    server.connect(options, (err, topology) => {
      if (err) {
        server.close(true);
        return callback(err);
      }
      clearAllEvents(server);
      relayEvents(mongoClient, server);
      addListeners(mongoClient, server);
      const ismaster = topology.lastIsMaster();
      assignTopology(mongoClient, topology);
      if (ismaster && ismaster.msg === "isdbgrid") {
        topology.close();
        return createTopology(mongoClient, "mongos", options, callback);
      }
      replayEvents(mongoClient, collectedEvents);
      callback(err, topology);
    });
  }
  var DEPRECATED_UNIFIED_EVENTS = new Set([
    "reconnect",
    "reconnectFailed",
    "attemptReconnect",
    "joined",
    "left",
    "ping",
    "ha",
    "all",
    "fullsetup",
    "open"
  ]);
  function registerDeprecatedEventNotifiers(client2) {
    client2.on("newListener", (eventName) => {
      if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
        emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
      }
    });
  }
  function createTopology(mongoClient, topologyType, options, callback) {
    options.promiseLibrary = mongoClient.s.promiseLibrary;
    const translationOptions = {};
    if (topologyType === "unified")
      translationOptions.createServers = false;
    const servers = translateOptions(options, translationOptions);
    if (options.autoEncryption != null) {
      let AutoEncrypter;
      try {
        require.resolve("mongodb-client-encryption");
      } catch (err) {
        callback(new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project"));
        return;
      }
      try {
        let mongodbClientEncryption = require("mongodb-client-encryption");
        if (typeof mongodbClientEncryption.extension !== "function") {
          callback(new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`"));
        }
        AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
      } catch (err) {
        callback(err);
        return;
      }
      const mongoCryptOptions = Object.assign({
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ])
      }, options.autoEncryption);
      options.autoEncrypter = new AutoEncrypter(mongoClient, mongoCryptOptions);
    }
    let topology;
    if (topologyType === "mongos") {
      topology = new Mongos(servers, options);
    } else if (topologyType === "replicaset") {
      topology = new ReplSet(servers, options);
    } else if (topologyType === "unified") {
      topology = new NativeTopology(options.servers, options);
      registerDeprecatedEventNotifiers(mongoClient);
    }
    addListeners(mongoClient, topology);
    relayEvents(mongoClient, topology);
    assignTopology(mongoClient, topology);
    if (options.autoEncrypter) {
      options.autoEncrypter.init((err) => {
        if (err) {
          callback(err);
          return;
        }
        topology.connect(options, (err2) => {
          if (err2) {
            topology.close(true);
            callback(err2);
            return;
          }
          callback(void 0, topology);
        });
      });
      return;
    }
    topology.connect(options, (err) => {
      if (err) {
        topology.close(true);
        return callback(err);
      }
      callback(void 0, topology);
      return;
    });
  }
  function createUnifiedOptions(finalOptions, options) {
    const childOptions = [
      "mongos",
      "server",
      "db",
      "replset",
      "db_options",
      "server_options",
      "rs_options",
      "mongos_options"
    ];
    const noMerge = ["readconcern", "compression", "autoencryption"];
    const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeConcern"];
    for (const name in options) {
      if (skip.indexOf(name.toLowerCase()) !== -1) {
        continue;
      } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {
        finalOptions[name] = options[name];
      } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
        finalOptions = mergeOptions(finalOptions, options[name], false);
      } else {
        if (options[name] && typeof options[name] === "object" && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
          finalOptions = mergeOptions(finalOptions, options[name], true);
        } else {
          finalOptions[name] = options[name];
        }
      }
    }
    const optionsWriteConcern = WriteConcern.fromOptions(options);
    if (optionsWriteConcern) {
      finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
    }
    return finalOptions;
  }
  function generateCredentials(client2, username, password, options) {
    options = Object.assign({}, options);
    const source = options.authSource || options.authdb || options.dbName;
    const authMechanismRaw = options.authMechanism || "DEFAULT";
    const authMechanism = authMechanismRaw.toUpperCase();
    const mechanismProperties = options.authMechanismProperties;
    if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
      throw MongoError.create({
        message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
        driver: true
      });
    }
    return new MongoCredentials({
      mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
      mechanismProperties,
      source,
      username,
      password
    });
  }
  function legacyTransformUrlOptions(object) {
    return mergeOptions(createUnifiedOptions({}, object), object, false);
  }
  function mergeOptions(target, source, flatten) {
    for (const name in source) {
      if (source[name] && typeof source[name] === "object" && flatten) {
        target = mergeOptions(target, source[name], flatten);
      } else {
        target[name] = source[name];
      }
    }
    return target;
  }
  function relayEvents(mongoClient, topology) {
    const serverOrCommandEvents = [
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "serverOpening",
      "serverClosed",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "joined",
      "left",
      "ping",
      "ha"
    ].concat(CMAP_EVENT_NAMES);
    serverOrCommandEvents.forEach((event) => {
      topology.on(event, (object1, object2) => {
        mongoClient.emit(event, object1, object2);
      });
    });
  }
  function replayEvents(mongoClient, events) {
    for (let i = 0; i < events.length; i++) {
      mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
    }
  }
  function transformUrlOptions(_object) {
    let object = Object.assign({servers: _object.hosts}, _object.options);
    for (let name in object) {
      const camelCaseName = LEGACY_OPTIONS_MAP[name];
      if (camelCaseName) {
        object[camelCaseName] = object[name];
      }
    }
    const hasUsername = _object.auth && _object.auth.username;
    const hasAuthMechanism = _object.options && _object.options.authMechanism;
    if (hasUsername || hasAuthMechanism) {
      object.auth = Object.assign({}, _object.auth);
      if (object.auth.db) {
        object.authSource = object.authSource || object.auth.db;
      }
      if (object.auth.username) {
        object.auth.user = object.auth.username;
      }
    }
    if (_object.defaultDatabase) {
      object.dbName = _object.defaultDatabase;
    }
    if (object.maxPoolSize) {
      object.poolSize = object.maxPoolSize;
    }
    if (object.readConcernLevel) {
      object.readConcern = new ReadConcern(object.readConcernLevel);
    }
    if (object.wTimeoutMS) {
      object.wtimeout = object.wTimeoutMS;
      object.wTimeoutMS = void 0;
    }
    if (_object.srvHost) {
      object.srvHost = _object.srvHost;
    }
    const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
    for (const key of wcKeys) {
      if (object[key] !== void 0) {
        if (object.writeConcern === void 0)
          object.writeConcern = {};
        object.writeConcern[key] = object[key];
        object[key] = void 0;
      }
    }
    return object;
  }
  function translateOptions(options, translationOptions) {
    translationOptions = Object.assign({}, {createServers: true}, translationOptions);
    if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
      options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
    }
    if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
      options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
    }
    if (options.maxStalenessSeconds) {
      options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
    }
    if (options.socketTimeoutMS == null)
      options.socketTimeoutMS = 0;
    if (options.connectTimeoutMS == null)
      options.connectTimeoutMS = 1e4;
    if (!translationOptions.createServers) {
      return;
    }
    return options.servers.map((serverObj) => {
      return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);
    });
  }
  module2.exports = {validOptions, connect};
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports2, module2) => {
  "use strict";
  var ChangeStream = require_change_stream();
  var Db = require_db2();
  var EventEmitter = require("events").EventEmitter;
  var inherits = require("util").inherits;
  var MongoError = require_core2().MongoError;
  var deprecate = require("util").deprecate;
  var WriteConcern = require_write_concern();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ReadPreference = require_read_preference();
  var maybePromise = require_utils4().maybePromise;
  var NativeTopology = require_native_topology();
  var connect = require_connect2().connect;
  var validOptions = require_connect2().validOptions;
  function MongoClient2(url, options) {
    if (!(this instanceof MongoClient2))
      return new MongoClient2(url, options);
    EventEmitter.call(this);
    this.s = {
      url,
      options: options || {},
      promiseLibrary: options && options.promiseLibrary || Promise,
      dbCache: new Map(),
      sessions: new Set(),
      writeConcern: WriteConcern.fromOptions(options),
      readPreference: ReadPreference.fromOptions(options) || ReadPreference.primary,
      namespace: new MongoDBNamespace("admin")
    };
  }
  inherits(MongoClient2, EventEmitter);
  Object.defineProperty(MongoClient2.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(MongoClient2.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      return this.s.readPreference;
    }
  });
  MongoClient2.prototype.connect = function(callback) {
    if (typeof callback === "string") {
      throw new TypeError("`connect` only accepts a callback");
    }
    const client = this;
    return maybePromise(this, callback, (cb) => {
      const err = validOptions(client.s.options);
      if (err)
        return cb(err);
      connect(client, client.s.url, client.s.options, (err2) => {
        if (err2)
          return cb(err2);
        cb(null, client);
      });
    });
  };
  MongoClient2.prototype.logout = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    if (typeof callback === "function")
      callback(null, true);
  }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
  MongoClient2.prototype.close = function(force, callback) {
    if (typeof force === "function") {
      callback = force;
      force = false;
    }
    const client = this;
    return maybePromise(this, callback, (cb) => {
      const completeClose = (err) => {
        client.emit("close", client);
        if (!(client.topology instanceof NativeTopology)) {
          for (const item of client.s.dbCache) {
            item[1].emit("close", client);
          }
        }
        client.removeAllListeners("close");
        cb(err);
      };
      if (client.topology == null) {
        completeClose();
        return;
      }
      client.topology.close(force, (err) => {
        const autoEncrypter = client.topology.s.options.autoEncrypter;
        if (!autoEncrypter) {
          completeClose(err);
          return;
        }
        autoEncrypter.teardown(force, (err2) => completeClose(err || err2));
      });
    });
  };
  MongoClient2.prototype.db = function(dbName, options) {
    options = options || {};
    if (!dbName) {
      dbName = this.s.options.dbName;
    }
    const finalOptions = Object.assign({}, this.s.options, options);
    if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
      return this.s.dbCache.get(dbName);
    }
    finalOptions.promiseLibrary = this.s.promiseLibrary;
    if (!this.topology) {
      throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
    }
    const db = new Db(dbName, this.topology, finalOptions);
    this.s.dbCache.set(dbName, db);
    return db;
  };
  MongoClient2.prototype.isConnected = function(options) {
    options = options || {};
    if (!this.topology)
      return false;
    return this.topology.isConnected(options);
  };
  MongoClient2.connect = function(url, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : null;
    options = options || {};
    const mongoClient = new MongoClient2(url, options);
    return mongoClient.connect(callback);
  };
  MongoClient2.prototype.startSession = function(options) {
    options = Object.assign({explicit: true}, options);
    if (!this.topology) {
      throw new MongoError("Must connect to a server before calling this method");
    }
    if (!this.topology.hasSessionSupport()) {
      throw new MongoError("Current topology does not support sessions");
    }
    return this.topology.startSession(options, this.s.options);
  };
  MongoClient2.prototype.withSession = function(options, operation) {
    if (typeof options === "function")
      operation = options, options = void 0;
    const session = this.startSession(options);
    let cleanupHandler = (err, result, opts) => {
      cleanupHandler = () => {
        throw new ReferenceError("cleanupHandler was called too many times");
      };
      opts = Object.assign({throw: true}, opts);
      session.endSession();
      if (err) {
        if (opts.throw)
          throw err;
        return Promise.reject(err);
      }
    };
    try {
      const result = operation(session);
      return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, {throw: true}));
    } catch (err) {
      return cleanupHandler(err, null, {throw: false});
    }
  };
  MongoClient2.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  MongoClient2.prototype.getLogger = function() {
    return this.s.options.logger;
  };
  module2.exports = MongoClient2;
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS((exports2, module2) => {
  "use strict";
  var Binary2 = require_core2().BSON.Binary;
  var ObjectID2 = require_core2().BSON.ObjectID;
  var Buffer2 = require_safe_buffer().Buffer;
  var Chunk = function(file, mongoObject, writeConcern) {
    if (!(this instanceof Chunk))
      return new Chunk(file, mongoObject);
    this.file = file;
    var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
    this.writeConcern = writeConcern || {w: 1};
    this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
    this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
    this.data = new Binary2();
    if (typeof mongoObjectFinal.data === "string") {
      var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
      buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
      this.data = new Binary2(buffer);
    } else if (Array.isArray(mongoObjectFinal.data)) {
      buffer = Buffer2.alloc(mongoObjectFinal.data.length);
      var data = mongoObjectFinal.data.join("");
      buffer.write(data, 0, data.length, "binary");
      this.data = new Binary2(buffer);
    } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
      this.data = mongoObjectFinal.data;
    } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
      throw Error("Illegal chunk format");
    }
    this.internalPosition = 0;
  };
  Chunk.prototype.write = function(data, callback) {
    this.data.write(data, this.internalPosition, data.length, "binary");
    this.internalPosition = this.data.length();
    if (callback != null)
      return callback(null, this);
    return this;
  };
  Chunk.prototype.read = function(length) {
    length = length == null || length === 0 ? this.length() : length;
    if (this.length() - this.internalPosition + 1 >= length) {
      var data = this.data.read(this.internalPosition, length);
      this.internalPosition = this.internalPosition + length;
      return data;
    } else {
      return "";
    }
  };
  Chunk.prototype.readSlice = function(length) {
    if (this.length() - this.internalPosition >= length) {
      var data = null;
      if (this.data.buffer != null) {
        data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
      } else {
        data = Buffer2.alloc(length);
        length = this.data.readInto(data, this.internalPosition);
      }
      this.internalPosition = this.internalPosition + length;
      return data;
    } else {
      return null;
    }
  };
  Chunk.prototype.eof = function() {
    return this.internalPosition === this.length() ? true : false;
  };
  Chunk.prototype.getc = function() {
    return this.read(1);
  };
  Chunk.prototype.rewind = function() {
    this.internalPosition = 0;
    this.data = new Binary2();
  };
  Chunk.prototype.save = function(options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    self2.file.chunkCollection(function(err, collection) {
      if (err)
        return callback(err);
      var writeOptions = {upsert: true};
      for (var name in options)
        writeOptions[name] = options[name];
      for (name in self2.writeConcern)
        writeOptions[name] = self2.writeConcern[name];
      if (self2.data.length() > 0) {
        self2.buildMongoObject(function(mongoObject) {
          var options2 = {forceServerObjectId: true};
          for (var name2 in self2.writeConcern) {
            options2[name2] = self2.writeConcern[name2];
          }
          collection.replaceOne({_id: self2.objectId}, mongoObject, writeOptions, function(err2) {
            callback(err2, self2);
          });
        });
      } else {
        callback(null, self2);
      }
    });
  };
  Chunk.prototype.buildMongoObject = function(callback) {
    var mongoObject = {
      files_id: this.file.fileId,
      n: this.chunkNumber,
      data: this.data
    };
    if (this.objectId != null)
      mongoObject._id = this.objectId;
    callback(mongoObject);
  };
  Chunk.prototype.length = function() {
    return this.data.length();
  };
  Object.defineProperty(Chunk.prototype, "position", {
    enumerable: true,
    get: function() {
      return this.internalPosition;
    },
    set: function(value) {
      this.internalPosition = value;
    }
  });
  Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
  module2.exports = Chunk;
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS((exports2, module2) => {
  "use strict";
  var Chunk = require_chunk();
  var ObjectID2 = require_core2().BSON.ObjectID;
  var ReadPreference = require_core2().ReadPreference;
  var Buffer2 = require_safe_buffer().Buffer;
  var fs = require("fs");
  var f = require("util").format;
  var util = require("util");
  var MongoError = require_core2().MongoError;
  var inherits = util.inherits;
  var Duplex = require("stream").Duplex;
  var shallowClone = require_utils4().shallowClone;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var deprecate = require("util").deprecate;
  var REFERENCE_BY_FILENAME = 0;
  var REFERENCE_BY_ID = 1;
  var deprecationFn = deprecate(() => {
  }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
  var GridStore = function GridStore2(db, id, filename, mode, options) {
    deprecationFn();
    if (!(this instanceof GridStore2))
      return new GridStore2(db, id, filename, mode, options);
    this.db = db;
    if (typeof options === "undefined")
      options = {};
    if (typeof mode === "undefined") {
      mode = filename;
      filename = void 0;
    } else if (typeof mode === "object") {
      options = mode;
      mode = filename;
      filename = void 0;
    }
    if (id && id._bsontype === "ObjectID") {
      this.referenceBy = REFERENCE_BY_ID;
      this.fileId = id;
      this.filename = filename;
    } else if (typeof filename === "undefined") {
      this.referenceBy = REFERENCE_BY_FILENAME;
      this.filename = id;
      if (mode.indexOf("w") != null) {
        this.fileId = new ObjectID2();
      }
    } else {
      this.referenceBy = REFERENCE_BY_ID;
      this.fileId = id;
      this.filename = filename;
    }
    this.mode = mode == null ? "r" : mode;
    this.options = options || {};
    this.isOpen = false;
    this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
    this.position = 0;
    this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
    this.writeConcern = _getWriteConcern(db, this.options);
    this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
    var promiseLibrary = this.options.promiseLibrary || Promise;
    this.promiseLibrary = promiseLibrary;
    Object.defineProperty(this, "chunkSize", {
      enumerable: true,
      get: function() {
        return this.internalChunkSize;
      },
      set: function(value) {
        if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
          this.internalChunkSize = this.internalChunkSize;
        } else {
          this.internalChunkSize = value;
        }
      }
    });
    Object.defineProperty(this, "md5", {
      enumerable: true,
      get: function() {
        return this.internalMd5;
      }
    });
    Object.defineProperty(this, "chunkNumber", {
      enumerable: true,
      get: function() {
        return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
      }
    });
  };
  GridStore.prototype.open = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
      throw MongoError.create({message: "Illegal mode " + this.mode, driver: true});
    }
    return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {
      skipSessions: true
    });
  };
  var open = function(self2, options, callback) {
    var writeConcern = _getWriteConcern(self2.db, self2.options);
    if (self2.mode === "w" || self2.mode === "w+") {
      var collection = self2.collection();
      collection.ensureIndex([["filename", 1]], writeConcern, function() {
        var chunkCollection = self2.chunkCollection();
        var chunkIndexOptions = shallowClone(writeConcern);
        chunkIndexOptions.unique = true;
        chunkCollection.ensureIndex([
          ["files_id", 1],
          ["n", 1]
        ], chunkIndexOptions, function() {
          _open(self2, writeConcern, function(err, r) {
            if (err)
              return callback(err);
            self2.isOpen = true;
            callback(err, r);
          });
        });
      });
    } else {
      _open(self2, writeConcern, function(err, r) {
        if (err)
          return callback(err);
        self2.isOpen = true;
        callback(err, r);
      });
    }
  };
  GridStore.prototype.eof = function() {
    return this.position === this.length ? true : false;
  };
  GridStore.prototype.getc = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {
      skipSessions: true
    });
  };
  var getc = function(self2, options, callback) {
    if (self2.eof()) {
      callback(null, null);
    } else if (self2.currentChunk.eof()) {
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        self2.currentChunk = chunk;
        self2.position = self2.position + 1;
        callback(err, self2.currentChunk.getc());
      });
    } else {
      self2.position = self2.position + 1;
      callback(null, self2.currentChunk.getc());
    }
  };
  GridStore.prototype.puts = function(string, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    var finalString = string.match(/\n$/) == null ? string + "\n" : string;
    return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options, callback], {skipSessions: true});
  };
  GridStore.prototype.stream = function() {
    return new GridStoreStream(this);
  };
  GridStore.prototype.write = function write(data, close2, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options, callback], {skipSessions: true});
  };
  GridStore.prototype.destroy = function destroy() {
    if (!this.writable)
      return;
    this.readable = false;
    if (this.writable) {
      this.writable = false;
      this._q.length = 0;
      this.emit("close");
    }
  };
  GridStore.prototype.writeFile = function(file, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {
      skipSessions: true
    });
  };
  var writeFile = function(self2, file, options, callback) {
    if (typeof file === "string") {
      fs.open(file, "r", function(err, fd) {
        if (err)
          return callback(err);
        self2.writeFile(fd, callback);
      });
      return;
    }
    self2.open(function(err, self3) {
      if (err)
        return callback(err, self3);
      fs.fstat(file, function(err2, stats) {
        if (err2)
          return callback(err2, self3);
        var offset = 0;
        var index = 0;
        var writeChunk = function() {
          var _buffer = Buffer2.alloc(self3.chunkSize);
          fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
            if (err3)
              return callback(err3, self3);
            offset = offset + bytesRead;
            var chunk = new Chunk(self3, {n: index++}, self3.writeConcern);
            chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
              if (err4)
                return callback(err4, self3);
              chunk2.save({}, function(err5) {
                if (err5)
                  return callback(err5, self3);
                self3.position = self3.position + bytesRead;
                self3.currentChunk = chunk2;
                if (offset >= stats.size) {
                  fs.close(file, function(err6) {
                    if (err6)
                      return callback(err6);
                    self3.close(function(err7) {
                      if (err7)
                        return callback(err7, self3);
                      return callback(null, self3);
                    });
                  });
                } else {
                  return process.nextTick(writeChunk);
                }
              });
            });
          });
        };
        process.nextTick(writeChunk);
      });
    });
  };
  GridStore.prototype.close = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {
      skipSessions: true
    });
  };
  var close = function(self2, options, callback) {
    if (self2.mode[0] === "w") {
      options = Object.assign({}, self2.writeConcern, options);
      if (self2.currentChunk != null && self2.currentChunk.position > 0) {
        self2.currentChunk.save({}, function(err) {
          if (err && typeof callback === "function")
            return callback(err);
          self2.collection(function(err2, files) {
            if (err2 && typeof callback === "function")
              return callback(err2);
            if (self2.uploadDate != null) {
              buildMongoObject(self2, function(err3, mongoObject) {
                if (err3) {
                  if (typeof callback === "function")
                    return callback(err3);
                  else
                    throw err3;
                }
                files.save(mongoObject, options, function(err4) {
                  if (typeof callback === "function")
                    callback(err4, mongoObject);
                });
              });
            } else {
              self2.uploadDate = new Date();
              buildMongoObject(self2, function(err3, mongoObject) {
                if (err3) {
                  if (typeof callback === "function")
                    return callback(err3);
                  else
                    throw err3;
                }
                files.save(mongoObject, options, function(err4) {
                  if (typeof callback === "function")
                    callback(err4, mongoObject);
                });
              });
            }
          });
        });
      } else {
        self2.collection(function(err, files) {
          if (err && typeof callback === "function")
            return callback(err);
          self2.uploadDate = new Date();
          buildMongoObject(self2, function(err2, mongoObject) {
            if (err2) {
              if (typeof callback === "function")
                return callback(err2);
              else
                throw err2;
            }
            files.save(mongoObject, options, function(err3) {
              if (typeof callback === "function")
                callback(err3, mongoObject);
            });
          });
        });
      }
    } else if (self2.mode[0] === "r") {
      if (typeof callback === "function")
        callback(null, null);
    } else {
      if (typeof callback === "function")
        callback(MongoError.create({message: f("Illegal mode %s", self2.mode), driver: true}));
    }
  };
  GridStore.prototype.chunkCollection = function(callback) {
    if (typeof callback === "function")
      return this.db.collection(this.root + ".chunks", callback);
    return this.db.collection(this.root + ".chunks");
  };
  GridStore.prototype.unlink = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {
      skipSessions: true
    });
  };
  var unlink = function(self2, options, callback) {
    deleteChunks(self2, function(err) {
      if (err !== null) {
        err.message = "at deleteChunks: " + err.message;
        return callback(err);
      }
      self2.collection(function(err2, collection) {
        if (err2 !== null) {
          err2.message = "at collection: " + err2.message;
          return callback(err2);
        }
        collection.remove({_id: self2.fileId}, self2.writeConcern, function(err3) {
          callback(err3, self2);
        });
      });
    });
  };
  GridStore.prototype.collection = function(callback) {
    if (typeof callback === "function")
      this.db.collection(this.root + ".files", callback);
    return this.db.collection(this.root + ".files");
  };
  GridStore.prototype.readlines = function(separator, options, callback) {
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    separator = args.length ? args.shift() : "\n";
    separator = separator || "\n";
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options, callback], {skipSessions: true});
  };
  var readlines = function(self2, separator, options, callback) {
    self2.read(function(err, data) {
      if (err)
        return callback(err);
      var items = data.toString().split(separator);
      items = items.length > 0 ? items.splice(0, items.length - 1) : [];
      for (var i = 0; i < items.length; i++) {
        items[i] = items[i] + separator;
      }
      callback(null, items);
    });
  };
  GridStore.prototype.rewind = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {
      skipSessions: true
    });
  };
  var rewind = function(self2, options, callback) {
    if (self2.currentChunk.chunkNumber !== 0) {
      if (self2.mode[0] === "w") {
        deleteChunks(self2, function(err) {
          if (err)
            return callback(err);
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.position = 0;
          callback(null, self2);
        });
      } else {
        self2.currentChunk(0, function(err, chunk) {
          if (err)
            return callback(err);
          self2.currentChunk = chunk;
          self2.currentChunk.rewind();
          self2.position = 0;
          callback(null, self2);
        });
      }
    } else {
      self2.currentChunk.rewind();
      self2.position = 0;
      callback(null, self2);
    }
  };
  GridStore.prototype.read = function(length, buffer, options, callback) {
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    length = args.length ? args.shift() : null;
    buffer = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, read, [this, length, buffer, options, callback], {skipSessions: true});
  };
  var read = function(self2, length, buffer, options, callback) {
    var finalLength = length == null ? self2.length - self2.position : length;
    var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
    finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
    if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
      var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
      slice.copy(finalBuffer, finalBuffer._index);
      self2.position = self2.position + finalBuffer.length;
      if (finalLength === 0 && finalBuffer.length === 0)
        return callback(MongoError.create({message: "File does not exist", driver: true}), null);
      return callback(null, finalBuffer);
    }
    slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
    slice.copy(finalBuffer, finalBuffer._index);
    finalBuffer._index += slice.length;
    nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
      if (err)
        return callback(err);
      if (chunk.length() > 0) {
        self2.currentChunk = chunk;
        self2.read(length, finalBuffer, callback);
      } else {
        if (finalBuffer._index > 0) {
          callback(null, finalBuffer);
        } else {
          callback(MongoError.create({
            message: "no chunks found for file, possibly corrupt",
            driver: true
          }), null);
        }
      }
    });
  };
  GridStore.prototype.tell = function(callback) {
    var self2 = this;
    if (typeof callback === "function")
      return callback(null, this.position);
    return new self2.promiseLibrary(function(resolve) {
      resolve(self2.position);
    });
  };
  GridStore.prototype.seek = function(position, seekLocation, options, callback) {
    var args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    seekLocation = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options, callback], {skipSessions: true});
  };
  var seek = function(self2, position, seekLocation, options, callback) {
    if (self2.mode !== "r") {
      return callback(MongoError.create({message: "seek is only supported for mode r", driver: true}));
    }
    var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
    var finalPosition = position;
    var targetPosition = 0;
    if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
      targetPosition = self2.position + finalPosition;
    } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
      targetPosition = self2.length + finalPosition;
    } else {
      targetPosition = finalPosition;
    }
    var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
    var seekChunk = function() {
      nthChunk(self2, newChunkNumber, function(err, chunk) {
        if (err)
          return callback(err, null);
        if (chunk == null)
          return callback(new Error("no chunk found"));
        self2.currentChunk = chunk;
        self2.position = targetPosition;
        self2.currentChunk.position = self2.position % self2.chunkSize;
        callback(err, self2);
      });
    };
    seekChunk();
  };
  var _open = function(self2, options, callback) {
    var collection = self2.collection();
    var query = self2.referenceBy === REFERENCE_BY_ID ? {_id: self2.fileId} : {filename: self2.filename};
    query = self2.fileId == null && self2.filename == null ? null : query;
    options.readPreference = self2.readPreference;
    if (query != null) {
      collection.findOne(query, options, function(err, doc) {
        if (err) {
          return error(err);
        }
        if (doc != null) {
          self2.fileId = doc._id;
          self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
          self2.contentType = doc.contentType;
          self2.internalChunkSize = doc.chunkSize;
          self2.uploadDate = doc.uploadDate;
          self2.aliases = doc.aliases;
          self2.length = doc.length;
          self2.metadata = doc.metadata;
          self2.internalMd5 = doc.md5;
        } else if (self2.mode !== "r") {
          self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
          self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
          self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
          self2.length = 0;
        } else {
          self2.length = 0;
          var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
          return error(MongoError.create({
            message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
            driver: true
          }), self2);
        }
        if (self2.mode === "r") {
          nthChunk(self2, 0, options, function(err2, chunk) {
            if (err2)
              return error(err2);
            self2.currentChunk = chunk;
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w" && doc) {
          deleteChunks(self2, options, function(err2) {
            if (err2)
              return error(err2);
            self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w") {
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
          self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = 0;
          callback(null, self2);
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options, function(err2, chunk) {
            if (err2)
              return error(err2);
            self2.currentChunk = chunk == null ? new Chunk(self2, {n: 0}, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      });
    } else {
      self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
      self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
      self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
      self2.length = 0;
      if (self2.mode === "w") {
        deleteChunks(self2, options, function(err) {
          if (err)
            return error(err);
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
          self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = 0;
          callback(null, self2);
        });
      } else if (self2.mode === "w+") {
        nthChunk(self2, lastChunkNumber(self2), options, function(err, chunk) {
          if (err)
            return error(err);
          self2.currentChunk = chunk == null ? new Chunk(self2, {n: 0}, self2.writeConcern) : chunk;
          self2.currentChunk.position = self2.currentChunk.data.length();
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = self2.length;
          callback(null, self2);
        });
      }
    }
    function error(err) {
      if (error.err)
        return;
      callback(error.err = err);
    }
  };
  var writeBuffer = function(self2, buffer, close2, callback) {
    if (typeof close2 === "function") {
      callback = close2;
      close2 = null;
    }
    var finalClose = typeof close2 === "boolean" ? close2 : false;
    if (self2.mode !== "w") {
      callback(MongoError.create({
        message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
        driver: true
      }), null);
    } else {
      if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
        var previousChunkNumber = self2.currentChunk.chunkNumber;
        var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
        var firstChunkData = buffer.slice(0, leftOverDataSize);
        var leftOverData = buffer.slice(leftOverDataSize);
        var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
        while (leftOverData.length >= self2.chunkSize) {
          var newChunk = new Chunk(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
          firstChunkData = leftOverData.slice(0, self2.chunkSize);
          leftOverData = leftOverData.slice(self2.chunkSize);
          previousChunkNumber = previousChunkNumber + 1;
          newChunk.write(firstChunkData);
          chunksToWrite.push(newChunk);
        }
        self2.currentChunk = new Chunk(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
        if (leftOverData.length > 0)
          self2.currentChunk.write(leftOverData);
        self2.position = self2.position + buffer.length;
        var numberOfChunksToWrite = chunksToWrite.length;
        for (var i = 0; i < chunksToWrite.length; i++) {
          chunksToWrite[i].save({}, function(err) {
            if (err)
              return callback(err);
            numberOfChunksToWrite = numberOfChunksToWrite - 1;
            if (numberOfChunksToWrite <= 0) {
              if (finalClose) {
                return self2.close(function(err2) {
                  callback(err2, self2);
                });
              }
              return callback(null, self2);
            }
          });
        }
      } else {
        self2.position = self2.position + buffer.length;
        self2.currentChunk.write(buffer);
        if (finalClose) {
          return self2.close(function(err) {
            callback(err, self2);
          });
        }
        return callback(null, self2);
      }
    }
  };
  var buildMongoObject = function(self2, callback) {
    var mongoObject = {
      _id: self2.fileId,
      filename: self2.filename,
      contentType: self2.contentType,
      length: self2.position ? self2.position : 0,
      chunkSize: self2.chunkSize,
      uploadDate: self2.uploadDate,
      aliases: self2.aliases,
      metadata: self2.metadata
    };
    var md5Command = {filemd5: self2.fileId, root: self2.root};
    self2.db.command(md5Command, function(err, results) {
      if (err)
        return callback(err);
      mongoObject.md5 = results.md5;
      callback(null, mongoObject);
    });
  };
  var nthChunk = function(self2, chunkNumber, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || self2.writeConcern;
    options.readPreference = self2.readPreference;
    self2.chunkCollection().findOne({files_id: self2.fileId, n: chunkNumber}, options, function(err, chunk) {
      if (err)
        return callback(err);
      var finalChunk = chunk == null ? {} : chunk;
      callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
    });
  };
  var lastChunkNumber = function(self2) {
    return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
  };
  var deleteChunks = function(self2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || self2.writeConcern;
    if (self2.fileId != null) {
      self2.chunkCollection().remove({files_id: self2.fileId}, options, function(err) {
        if (err)
          return callback(err, false);
        callback(null, true);
      });
    } else {
      callback(null, true);
    }
  };
  GridStore.DEFAULT_ROOT_COLLECTION = "fs";
  GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
  GridStore.IO_SEEK_SET = 0;
  GridStore.IO_SEEK_CUR = 1;
  GridStore.IO_SEEK_END = 2;
  GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    rootCollection = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options, callback], {skipSessions: true});
  };
  var exists = function(db, fileIdObject, rootCollection, options, callback) {
    var readPreference = options.readPreference || ReadPreference.PRIMARY;
    var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
    db.collection(rootCollectionFinal + ".files", function(err, collection) {
      if (err)
        return callback(err);
      var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? {filename: fileIdObject} : {_id: fileIdObject};
      if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
        query = fileIdObject;
      }
      collection.findOne(query, {readPreference}, function(err2, item) {
        if (err2)
          return callback(err2);
        callback(null, item == null ? false : true);
      });
    });
  };
  GridStore.list = function(db, rootCollection, options, callback) {
    var args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    rootCollection = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {
      skipSessions: true
    });
  };
  var list = function(db, rootCollection, options, callback) {
    if (rootCollection != null && typeof rootCollection === "object") {
      options = rootCollection;
      rootCollection = null;
    }
    var readPreference = options.readPreference || ReadPreference.primary;
    var byId = options["id"] != null ? options["id"] : false;
    var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
    var items = [];
    db.collection(rootCollectionFinal + ".files", function(err, collection) {
      if (err)
        return callback(err);
      collection.find({}, {readPreference}, function(err2, cursor) {
        if (err2)
          return callback(err2);
        cursor.each(function(err3, item) {
          if (item != null) {
            items.push(byId ? item._id : item.filename);
          } else {
            callback(err3, items);
          }
        });
      });
    });
  };
  GridStore.read = function(db, name, length, offset, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    length = args.length ? args.shift() : null;
    offset = args.length ? args.shift() : null;
    options = args.length ? args.shift() : null;
    options = options || {};
    return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options, callback], {skipSessions: true});
  };
  var readStatic = function(db, name, length, offset, options, callback) {
    new GridStore(db, name, "r", options).open(function(err, gridStore) {
      if (err)
        return callback(err);
      if (offset && offset >= gridStore.length)
        return callback("offset larger than size of file", null);
      if (length && length > gridStore.length)
        return callback("length is larger than the size of the file", null);
      if (offset && length && offset + length > gridStore.length)
        return callback("offset and length is larger than the size of the file", null);
      if (offset != null) {
        gridStore.seek(offset, function(err2, gridStore2) {
          if (err2)
            return callback(err2);
          gridStore2.read(length, callback);
        });
      } else {
        gridStore.read(length, callback);
      }
    });
  };
  GridStore.readlines = function(db, name, separator, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    separator = args.length ? args.shift() : null;
    options = args.length ? args.shift() : null;
    options = options || {};
    return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options, callback], {skipSessions: true});
  };
  var readlinesStatic = function(db, name, separator, options, callback) {
    var finalSeperator = separator == null ? "\n" : separator;
    new GridStore(db, name, "r", options).open(function(err, gridStore) {
      if (err)
        return callback(err);
      gridStore.readlines(finalSeperator, callback);
    });
  };
  GridStore.unlink = function(db, names, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {
      skipSessions: true
    });
  };
  var unlinkStatic = function(self2, db, names, options, callback) {
    var writeConcern = _getWriteConcern(db, options);
    if (names.constructor === Array) {
      var tc = 0;
      for (var i = 0; i < names.length; i++) {
        ++tc;
        GridStore.unlink(db, names[i], options, function() {
          if (--tc === 0) {
            callback(null, self2);
          }
        });
      }
    } else {
      new GridStore(db, names, "w", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        deleteChunks(gridStore, function(err2) {
          if (err2)
            return callback(err2);
          gridStore.collection(function(err3, collection) {
            if (err3)
              return callback(err3);
            collection.remove({_id: gridStore.fileId}, writeConcern, function(err4) {
              callback(err4, self2);
            });
          });
        });
      });
    }
  };
  var _writeNormal = function(self2, data, close2, options, callback) {
    if (Buffer2.isBuffer(data)) {
      return writeBuffer(self2, data, close2, callback);
    } else {
      return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
    }
  };
  var _setWriteConcernHash = function(options) {
    const baseOptions = Object.assign(options, options.writeConcern);
    var finalOptions = {};
    if (baseOptions.w != null)
      finalOptions.w = baseOptions.w;
    if (baseOptions.journal === true)
      finalOptions.j = baseOptions.journal;
    if (baseOptions.j === true)
      finalOptions.j = baseOptions.j;
    if (baseOptions.fsync === true)
      finalOptions.fsync = baseOptions.fsync;
    if (baseOptions.wtimeout != null)
      finalOptions.wtimeout = baseOptions.wtimeout;
    return finalOptions;
  };
  var _getWriteConcern = function(self2, options) {
    var finalOptions = {w: 1};
    options = options || {};
    if (options.writeConcern != null || options.w != null || typeof options.j === "boolean" || typeof options.journal === "boolean" || typeof options.fsync === "boolean") {
      finalOptions = _setWriteConcernHash(options);
    } else if (options.safe != null && typeof options.safe === "object") {
      finalOptions = _setWriteConcernHash(options.safe);
    } else if (typeof options.safe === "boolean") {
      finalOptions = {w: options.safe ? 1 : 0};
    } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
      finalOptions = _setWriteConcernHash(self2.options);
    } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
      finalOptions = _setWriteConcernHash(self2.safe);
    } else if (typeof self2.safe === "boolean") {
      finalOptions = {w: self2.safe ? 1 : 0};
    }
    if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
      throw MongoError.create({
        message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
        driver: true
      });
    return finalOptions;
  };
  var GridStoreStream = function(gs) {
    Duplex.call(this);
    this.gs = gs;
    this.endCalled = false;
    this.totalBytesToRead = this.gs.length - this.gs.position;
    this.seekPosition = this.gs.position;
  };
  inherits(GridStoreStream, Duplex);
  GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
  GridStoreStream.prototype.pipe = function(destination) {
    var self2 = this;
    if (!self2.gs.isOpen) {
      self2.gs.open(function(err) {
        if (err)
          return self2.emit("error", err);
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      });
    } else {
      self2.totalBytesToRead = self2.gs.length - self2.gs.position;
      self2._pipe.apply(self2, [destination]);
    }
    return destination;
  };
  GridStoreStream.prototype._read = function() {
    var self2 = this;
    var read2 = function() {
      self2.gs.read(length, function(err, buffer) {
        if (err && !self2.endCalled)
          return self2.emit("error", err);
        if (self2.endCalled || buffer == null)
          return self2.push(null);
        if (buffer.length <= self2.totalBytesToRead) {
          self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
          self2.push(buffer);
        } else if (buffer.length > self2.totalBytesToRead) {
          self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
          self2.push(buffer.slice(0, buffer._index));
        }
        if (self2.totalBytesToRead <= 0) {
          self2.endCalled = true;
        }
      });
    };
    var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
    if (!self2.gs.isOpen) {
      self2.gs.open(function(err) {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        if (err)
          return self2.emit("error", err);
        read2();
      });
    } else {
      read2();
    }
  };
  GridStoreStream.prototype.destroy = function() {
    this.pause();
    this.endCalled = true;
    this.gs.close();
    this.emit("end");
  };
  GridStoreStream.prototype.write = function(chunk) {
    var self2 = this;
    if (self2.endCalled)
      return self2.emit("error", MongoError.create({message: "attempting to write to stream after end called", driver: true}));
    if (!self2.gs.isOpen) {
      self2.gs.open(function() {
        self2.gs.isOpen = true;
        self2.gs.write(chunk, function() {
          process.nextTick(function() {
            self2.emit("drain");
          });
        });
      });
      return false;
    } else {
      self2.gs.write(chunk, function() {
        self2.emit("drain");
      });
      return true;
    }
  };
  GridStoreStream.prototype.end = function(chunk, encoding, callback) {
    var self2 = this;
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    chunk = args.length ? args.shift() : null;
    encoding = args.length ? args.shift() : null;
    self2.endCalled = true;
    if (chunk) {
      self2.gs.write(chunk, function() {
        self2.gs.close(function() {
          if (typeof callback === "function")
            callback();
          self2.emit("end");
        });
      });
    }
    self2.gs.close(function() {
      if (typeof callback === "function")
        callback();
      self2.emit("end");
    });
  };
  module2.exports = GridStore;
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require("stream");
  var util = require("util");
  module2.exports = GridFSBucketReadStream;
  function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
    this.s = {
      bytesRead: 0,
      chunks,
      cursor: null,
      expected: 0,
      files,
      filter,
      init: false,
      expectedEnd: 0,
      file: null,
      options,
      readPreference
    };
    stream.Readable.call(this);
  }
  util.inherits(GridFSBucketReadStream, stream.Readable);
  GridFSBucketReadStream.prototype._read = function() {
    var _this = this;
    if (this.destroyed) {
      return;
    }
    waitForFile(_this, function() {
      doRead(_this);
    });
  };
  GridFSBucketReadStream.prototype.start = function(start) {
    throwIfInitialized(this);
    this.s.options.start = start;
    return this;
  };
  GridFSBucketReadStream.prototype.end = function(end) {
    throwIfInitialized(this);
    this.s.options.end = end;
    return this;
  };
  GridFSBucketReadStream.prototype.abort = function(callback) {
    var _this = this;
    this.push(null);
    this.destroyed = true;
    if (this.s.cursor) {
      this.s.cursor.close(function(error) {
        _this.emit("close");
        callback && callback(error);
      });
    } else {
      if (!this.s.init) {
        _this.emit("close");
      }
      callback && callback();
    }
  };
  function throwIfInitialized(self2) {
    if (self2.s.init) {
      throw new Error("You cannot change options after the stream has enteredflowing mode!");
    }
  }
  function doRead(_this) {
    if (_this.destroyed) {
      return;
    }
    _this.s.cursor.next(function(error, doc) {
      if (_this.destroyed) {
        return;
      }
      if (error) {
        return __handleError(_this, error);
      }
      if (!doc) {
        _this.push(null);
        process.nextTick(() => {
          _this.s.cursor.close(function(error2) {
            if (error2) {
              __handleError(_this, error2);
              return;
            }
            _this.emit("close");
          });
        });
        return;
      }
      var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
      var expectedN = _this.s.expected++;
      var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
        return __handleError(_this, new Error(errmsg));
      }
      if (doc.n < expectedN) {
        errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
        return __handleError(_this, new Error(errmsg));
      }
      var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.length !== expectedLength) {
        if (bytesRemaining <= 0) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
          return __handleError(_this, new Error(errmsg));
        }
        errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
        return __handleError(_this, new Error(errmsg));
      }
      _this.s.bytesRead += buf.length;
      if (buf.length === 0) {
        return _this.push(null);
      }
      var sliceStart = null;
      var sliceEnd = null;
      if (_this.s.bytesToSkip != null) {
        sliceStart = _this.s.bytesToSkip;
        _this.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
      const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
      if (atEndOfStream && _this.s.bytesToTrim != null) {
        sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
      } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
      }
      _this.push(buf);
    });
  }
  function init(self2) {
    var findOneOptions = {};
    if (self2.s.readPreference) {
      findOneOptions.readPreference = self2.s.readPreference;
    }
    if (self2.s.options && self2.s.options.sort) {
      findOneOptions.sort = self2.s.options.sort;
    }
    if (self2.s.options && self2.s.options.skip) {
      findOneOptions.skip = self2.s.options.skip;
    }
    self2.s.files.findOne(self2.s.filter, findOneOptions, function(error, doc) {
      if (error) {
        return __handleError(self2, error);
      }
      if (!doc) {
        var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
        var errmsg = "FileNotFound: file " + identifier + " was not found";
        var err = new Error(errmsg);
        err.code = "ENOENT";
        return __handleError(self2, err);
      }
      if (doc.length <= 0) {
        self2.push(null);
        return;
      }
      if (self2.destroyed) {
        self2.emit("close");
        return;
      }
      try {
        self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
      } catch (error2) {
        return __handleError(self2, error2);
      }
      var filter = {files_id: doc._id};
      if (self2.s.options && self2.s.options.start != null) {
        var skip = Math.floor(self2.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = {$gte: skip};
        }
      }
      self2.s.cursor = self2.s.chunks.find(filter).sort({n: 1});
      if (self2.s.readPreference) {
        self2.s.cursor.setReadPreference(self2.s.readPreference);
      }
      self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      self2.s.file = doc;
      try {
        self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
      } catch (error2) {
        return __handleError(self2, error2);
      }
      self2.emit("file", doc);
    });
  }
  function waitForFile(_this, callback) {
    if (_this.s.file) {
      return callback();
    }
    if (!_this.s.init) {
      init(_this);
      _this.s.init = true;
    }
    _this.once("file", function() {
      callback();
    });
  }
  function handleStartOption(stream2, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new Error("Stream start (" + options.start + ") must not be more than the length of the file (" + doc.length + ")");
      }
      if (options.start < 0) {
        throw new Error("Stream start (" + options.start + ") must not be negative");
      }
      if (options.end != null && options.end < options.start) {
        throw new Error("Stream start (" + options.start + ") must not be greater than stream end (" + options.end + ")");
      }
      stream2.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream2.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream2.s.bytesRead;
    }
  }
  function handleEndOption(stream2, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new Error("Stream end (" + options.end + ") must not be more than the length of the file (" + doc.length + ")");
      }
      if (options.start < 0) {
        throw new Error("Stream end (" + options.end + ") must not be negative");
      }
      var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream2.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
  }
  function __handleError(_this, error) {
    _this.emit("error", error);
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS((exports2, module2) => {
  "use strict";
  var core = require_core2();
  var crypto = require("crypto");
  var stream = require("stream");
  var util = require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  var ERROR_NAMESPACE_NOT_FOUND = 26;
  module2.exports = GridFSBucketWriteStream;
  function GridFSBucketWriteStream(bucket, filename, options) {
    options = options || {};
    stream.Writable.call(this, options);
    this.bucket = bucket;
    this.chunks = bucket.s._chunksCollection;
    this.filename = filename;
    this.files = bucket.s._filesCollection;
    this.options = options;
    this.done = false;
    this.id = options.id ? options.id : core.BSON.ObjectId();
    this.chunkSizeBytes = this.options.chunkSizeBytes;
    this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
    this.length = 0;
    this.md5 = !options.disableMD5 && crypto.createHash("md5");
    this.n = 0;
    this.pos = 0;
    this.state = {
      streamEnd: false,
      outstandingRequests: 0,
      errored: false,
      aborted: false,
      promiseLibrary: this.bucket.s.promiseLibrary
    };
    if (!this.bucket.s.calledOpenUploadStream) {
      this.bucket.s.calledOpenUploadStream = true;
      var _this = this;
      checkIndexes(this, function() {
        _this.bucket.s.checkedIndexes = true;
        _this.bucket.emit("index");
      });
    }
  }
  util.inherits(GridFSBucketWriteStream, stream.Writable);
  GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
    var _this = this;
    return waitForIndexes(this, function() {
      return doWrite(_this, chunk, encoding, callback);
    });
  };
  GridFSBucketWriteStream.prototype.abort = function(callback) {
    if (this.state.streamEnd) {
      var error = new Error("Cannot abort a stream that has already completed");
      if (typeof callback === "function") {
        return callback(error);
      }
      return this.state.promiseLibrary.reject(error);
    }
    if (this.state.aborted) {
      error = new Error("Cannot call abort() on a stream twice");
      if (typeof callback === "function") {
        return callback(error);
      }
      return this.state.promiseLibrary.reject(error);
    }
    this.state.aborted = true;
    this.chunks.deleteMany({files_id: this.id}, function(error2) {
      if (typeof callback === "function")
        callback(error2);
    });
  };
  GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
    var _this = this;
    if (typeof chunk === "function") {
      callback = chunk, chunk = null, encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding, encoding = null;
    }
    if (checkAborted(this, callback)) {
      return;
    }
    this.state.streamEnd = true;
    if (callback) {
      this.once("finish", function(result) {
        callback(null, result);
      });
    }
    if (!chunk) {
      waitForIndexes(this, function() {
        writeRemnant(_this);
      });
      return;
    }
    this.write(chunk, encoding, function() {
      writeRemnant(_this);
    });
  };
  function __handleError(_this, error, callback) {
    if (_this.state.errored) {
      return;
    }
    _this.state.errored = true;
    if (callback) {
      return callback(error);
    }
    _this.emit("error", error);
  }
  function createChunkDoc(filesId, n, data) {
    return {
      _id: core.BSON.ObjectId(),
      files_id: filesId,
      n,
      data
    };
  }
  function checkChunksIndex(_this, callback) {
    _this.chunks.listIndexes().toArray(function(error, indexes) {
      if (error) {
        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
          var index = {files_id: 1, n: 1};
          _this.chunks.createIndex(index, {background: false, unique: true}, function(error2) {
            if (error2) {
              return callback(error2);
            }
            callback();
          });
          return;
        }
        return callback(error);
      }
      var hasChunksIndex = false;
      indexes.forEach(function(index2) {
        if (index2.key) {
          var keys = Object.keys(index2.key);
          if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
            hasChunksIndex = true;
          }
        }
      });
      if (hasChunksIndex) {
        callback();
      } else {
        index = {files_id: 1, n: 1};
        var indexOptions = getWriteOptions(_this);
        indexOptions.background = false;
        indexOptions.unique = true;
        _this.chunks.createIndex(index, indexOptions, function(error2) {
          if (error2) {
            return callback(error2);
          }
          callback();
        });
      }
    });
  }
  function checkDone(_this, callback) {
    if (_this.done)
      return true;
    if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
      _this.done = true;
      var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {
        if (error) {
          return __handleError(_this, error, callback);
        }
        _this.emit("finish", filesDoc);
      });
      return true;
    }
    return false;
  }
  function checkIndexes(_this, callback) {
    _this.files.findOne({}, {_id: 1}, function(error, doc) {
      if (error) {
        return callback(error);
      }
      if (doc) {
        return callback();
      }
      _this.files.listIndexes().toArray(function(error2, indexes) {
        if (error2) {
          if (error2.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index = {filename: 1, uploadDate: 1};
            _this.files.createIndex(index, {background: false}, function(error3) {
              if (error3) {
                return callback(error3);
              }
              checkChunksIndex(_this, callback);
            });
            return;
          }
          return callback(error2);
        }
        var hasFileIndex = false;
        indexes.forEach(function(index2) {
          var keys = Object.keys(index2.key);
          if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
            hasFileIndex = true;
          }
        });
        if (hasFileIndex) {
          checkChunksIndex(_this, callback);
        } else {
          index = {filename: 1, uploadDate: 1};
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          _this.files.createIndex(index, indexOptions, function(error3) {
            if (error3) {
              return callback(error3);
            }
            checkChunksIndex(_this, callback);
          });
        }
      });
    });
  }
  function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
    var ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date(),
      filename
    };
    if (md5) {
      ret.md5 = md5;
    }
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  }
  function doWrite(_this, chunk, encoding, callback) {
    if (checkAborted(_this, callback)) {
      return false;
    }
    var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
    _this.length += inputBuf.length;
    if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
      inputBuf.copy(_this.bufToStore, _this.pos);
      _this.pos += inputBuf.length;
      callback && callback();
      return true;
    }
    var inputBufRemaining = inputBuf.length;
    var spaceRemaining = _this.chunkSizeBytes - _this.pos;
    var numToCopy = Math.min(spaceRemaining, inputBuf.length);
    var outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      var inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
      _this.pos += numToCopy;
      spaceRemaining -= numToCopy;
      if (spaceRemaining === 0) {
        if (_this.md5) {
          _this.md5.update(_this.bufToStore);
        }
        var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
        ++_this.state.outstandingRequests;
        ++outstandingRequests;
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
          if (error) {
            return __handleError(_this, error);
          }
          --_this.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            _this.emit("drain", doc);
            callback && callback();
            checkDone(_this);
          }
        });
        spaceRemaining = _this.chunkSizeBytes;
        _this.pos = 0;
        ++_this.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
    return false;
  }
  function getWriteOptions(_this) {
    var obj = {};
    if (_this.options.writeConcern) {
      obj.w = _this.options.writeConcern.w;
      obj.wtimeout = _this.options.writeConcern.wtimeout;
      obj.j = _this.options.writeConcern.j;
    }
    return obj;
  }
  function waitForIndexes(_this, callback) {
    if (_this.bucket.s.checkedIndexes) {
      return callback(false);
    }
    _this.bucket.once("index", function() {
      callback(true);
    });
    return true;
  }
  function writeRemnant(_this, callback) {
    if (_this.pos === 0) {
      return checkDone(_this, callback);
    }
    ++_this.state.outstandingRequests;
    var remnant = Buffer2.alloc(_this.pos);
    _this.bufToStore.copy(remnant, 0, 0, _this.pos);
    if (_this.md5) {
      _this.md5.update(remnant);
    }
    var doc = createChunkDoc(_this.id, _this.n, remnant);
    if (checkAborted(_this, callback)) {
      return false;
    }
    _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
      if (error) {
        return __handleError(_this, error);
      }
      --_this.state.outstandingRequests;
      checkDone(_this);
    });
  }
  function checkAborted(_this, callback) {
    if (_this.state.aborted) {
      if (typeof callback === "function") {
        callback(new Error("this stream has been aborted"));
      }
      return true;
    }
    return false;
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Emitter = require("events").EventEmitter;
  var GridFSBucketReadStream = require_download();
  var GridFSBucketWriteStream = require_upload();
  var shallowClone = require_utils4().shallowClone;
  var toError = require_utils4().toError;
  var util = require("util");
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };
  module2.exports = GridFSBucket;
  function GridFSBucket(db, options) {
    Emitter.apply(this);
    this.setMaxListeners(0);
    if (options && typeof options === "object") {
      options = shallowClone(options);
      var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
      for (var i = 0; i < keys.length; ++i) {
        if (!options[keys[i]]) {
          options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
        }
      }
    } else {
      options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
    }
    this.s = {
      db,
      options,
      _chunksCollection: db.collection(options.bucketName + ".chunks"),
      _filesCollection: db.collection(options.bucketName + ".files"),
      checkedIndexes: false,
      calledOpenUploadStream: false,
      promiseLibrary: db.s.promiseLibrary || Promise
    };
  }
  util.inherits(GridFSBucket, Emitter);
  GridFSBucket.prototype.openUploadStream = function(filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    options.id = id;
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openDownloadStream = function(id, options) {
    var filter = {_id: id};
    options = {
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.delete = function(id, callback) {
    return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
      skipSessions: true
    });
  };
  function _delete(_this, id, callback) {
    _this.s._filesCollection.deleteOne({_id: id}, function(error, res) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.deleteMany({files_id: id}, function(error2) {
        if (error2) {
          return callback(error2);
        }
        if (!res.result.n) {
          var errmsg = "FileNotFound: no file with id " + id + " found";
          return callback(new Error(errmsg));
        }
        callback();
      });
    });
  }
  GridFSBucket.prototype.find = function(filter, options) {
    filter = filter || {};
    options = options || {};
    var cursor = this.s._filesCollection.find(filter);
    if (options.batchSize != null) {
      cursor.batchSize(options.batchSize);
    }
    if (options.limit != null) {
      cursor.limit(options.limit);
    }
    if (options.maxTimeMS != null) {
      cursor.maxTimeMS(options.maxTimeMS);
    }
    if (options.noCursorTimeout != null) {
      cursor.addCursorFlag("noCursorTimeout", options.noCursorTimeout);
    }
    if (options.skip != null) {
      cursor.skip(options.skip);
    }
    if (options.sort != null) {
      cursor.sort(options.sort);
    }
    return cursor;
  };
  GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
    var sort = {uploadDate: -1};
    var skip = null;
    if (options && options.revision != null) {
      if (options.revision >= 0) {
        sort = {uploadDate: 1};
        skip = options.revision;
      } else {
        skip = -options.revision - 1;
      }
    }
    var filter = {filename};
    options = {
      sort,
      skip,
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.rename = function(id, filename, callback) {
    return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
      skipSessions: true
    });
  };
  function _rename(_this, id, filename, callback) {
    var filter = {_id: id};
    var update = {$set: {filename}};
    _this.s._filesCollection.updateOne(filter, update, function(error, res) {
      if (error) {
        return callback(error);
      }
      if (!res.result.n) {
        return callback(toError("File with id " + id + " not found"));
      }
      callback();
    });
  }
  GridFSBucket.prototype.drop = function(callback) {
    return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
      skipSessions: true
    });
  };
  GridFSBucket.prototype.getLogger = function() {
    return this.s.db.s.logger;
  };
  function _drop(_this, callback) {
    _this.s._filesCollection.drop(function(error) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.drop(function(error2) {
        if (error2) {
          return callback(error2);
        }
        return callback();
      });
    });
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS((exports2, module2) => {
  "use strict";
  var core = require_core2();
  var Instrumentation = require_apm2();
  var connect = require_mongo_client().connect;
  connect.MongoError = core.MongoError;
  connect.MongoNetworkError = core.MongoNetworkError;
  connect.MongoTimeoutError = core.MongoTimeoutError;
  connect.MongoServerSelectionError = core.MongoServerSelectionError;
  connect.MongoParseError = core.MongoParseError;
  connect.MongoWriteConcernError = core.MongoWriteConcernError;
  connect.MongoBulkWriteError = require_common3().BulkWriteError;
  connect.BulkWriteError = connect.MongoBulkWriteError;
  connect.Admin = require_admin();
  connect.MongoClient = require_mongo_client();
  connect.Db = require_db2();
  connect.Collection = require_collection();
  connect.Server = require_server3();
  connect.ReplSet = require_replset2();
  connect.Mongos = require_mongos2();
  connect.ReadPreference = core.ReadPreference;
  connect.GridStore = require_grid_store();
  connect.Chunk = require_chunk();
  connect.Logger = core.Logger;
  connect.AggregationCursor = require_aggregation_cursor();
  connect.CommandCursor = require_command_cursor();
  connect.Cursor = require_cursor2();
  connect.GridFSBucket = require_gridfs_stream();
  connect.CoreServer = core.Server;
  connect.CoreConnection = core.Connection;
  connect.Binary = core.BSON.Binary;
  connect.Code = core.BSON.Code;
  connect.Map = core.BSON.Map;
  connect.DBRef = core.BSON.DBRef;
  connect.Double = core.BSON.Double;
  connect.Int32 = core.BSON.Int32;
  connect.Long = core.BSON.Long;
  connect.MinKey = core.BSON.MinKey;
  connect.MaxKey = core.BSON.MaxKey;
  connect.ObjectID = core.BSON.ObjectID;
  connect.ObjectId = core.BSON.ObjectID;
  connect.Symbol = core.BSON.Symbol;
  connect.Timestamp = core.BSON.Timestamp;
  connect.BSONRegExp = core.BSON.BSONRegExp;
  connect.Decimal128 = core.BSON.Decimal128;
  connect.connect = connect;
  connect.instrument = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    const instrumentation = new Instrumentation();
    instrumentation.instrument(connect.MongoClient, callback);
    return instrumentation;
  };
  module2.exports = connect;
});

// node_modules/d3-time/dist/d3-time.js
var require_d3_time = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
  })(exports2, function(exports3) {
    "use strict";
    var t0 = new Date(), t1 = new Date();
    function newInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }
      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };
      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };
      interval.round = function(date) {
        var d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };
      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };
      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0))
          return range;
        do
          range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };
      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date)
            while (floori(date), !test(date))
              date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0)
              while (++step <= 0) {
                while (offseti(date, -1), !test(date)) {
                }
              }
            else
              while (--step >= 0) {
                while (offseti(date, 1), !test(date)) {
                }
              }
          }
        });
      };
      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
            return field(d) % step === 0;
          } : function(d) {
            return interval.count(0, d) % step === 0;
          });
        };
      }
      return interval;
    }
    var millisecond = newInterval(function() {
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0))
        return null;
      if (!(k > 1))
        return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;
    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;
    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;
    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });
    var minutes = minute.range;
    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });
    var hours = hour.range;
    var day = newInterval((date) => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date) => date.getDate() - 1);
    var days = day.range;
    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);
    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;
    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });
    var months = month.range;
    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;
    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;
    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;
    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;
    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }
    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);
    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;
    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;
    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;
    exports3.timeDay = day;
    exports3.timeDays = days;
    exports3.timeFriday = friday;
    exports3.timeFridays = fridays;
    exports3.timeHour = hour;
    exports3.timeHours = hours;
    exports3.timeInterval = newInterval;
    exports3.timeMillisecond = millisecond;
    exports3.timeMilliseconds = milliseconds;
    exports3.timeMinute = minute;
    exports3.timeMinutes = minutes;
    exports3.timeMonday = monday;
    exports3.timeMondays = mondays;
    exports3.timeMonth = month;
    exports3.timeMonths = months;
    exports3.timeSaturday = saturday;
    exports3.timeSaturdays = saturdays;
    exports3.timeSecond = second;
    exports3.timeSeconds = seconds;
    exports3.timeSunday = sunday;
    exports3.timeSundays = sundays;
    exports3.timeThursday = thursday;
    exports3.timeThursdays = thursdays;
    exports3.timeTuesday = tuesday;
    exports3.timeTuesdays = tuesdays;
    exports3.timeWednesday = wednesday;
    exports3.timeWednesdays = wednesdays;
    exports3.timeWeek = sunday;
    exports3.timeWeeks = sundays;
    exports3.timeYear = year;
    exports3.timeYears = years;
    exports3.utcDay = utcDay;
    exports3.utcDays = utcDays;
    exports3.utcFriday = utcFriday;
    exports3.utcFridays = utcFridays;
    exports3.utcHour = utcHour;
    exports3.utcHours = utcHours;
    exports3.utcMillisecond = millisecond;
    exports3.utcMilliseconds = milliseconds;
    exports3.utcMinute = utcMinute;
    exports3.utcMinutes = utcMinutes;
    exports3.utcMonday = utcMonday;
    exports3.utcMondays = utcMondays;
    exports3.utcMonth = utcMonth;
    exports3.utcMonths = utcMonths;
    exports3.utcSaturday = utcSaturday;
    exports3.utcSaturdays = utcSaturdays;
    exports3.utcSecond = second;
    exports3.utcSeconds = seconds;
    exports3.utcSunday = utcSunday;
    exports3.utcSundays = utcSundays;
    exports3.utcThursday = utcThursday;
    exports3.utcThursdays = utcThursdays;
    exports3.utcTuesday = utcTuesday;
    exports3.utcTuesdays = utcTuesdays;
    exports3.utcWednesday = utcWednesday;
    exports3.utcWednesdays = utcWednesdays;
    exports3.utcWeek = utcSunday;
    exports3.utcWeeks = utcSundays;
    exports3.utcYear = utcYear;
    exports3.utcYears = utcYears;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// node_modules/chartjs-node-canvas/dist/freshRequire.js
var require_freshRequire = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.freshRequire = void 0;
  exports2.freshRequire = (file) => {
    const resolvedFile = require.resolve(file);
    const temp = require.cache[resolvedFile];
    delete require.cache[resolvedFile];
    const modified = require(resolvedFile);
    require.cache[resolvedFile] = temp;
    return modified;
  };
});

// node_modules/moment/moment.js
var require_moment = __commonJS((exports2, module2) => {
  //! moment.js
  //! version : 2.29.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
  })(exports2, function() {
    "use strict";
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i;
      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key;
          for (i = 0; i < arguments.length; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(func.apply(this, arguments), token2);
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({unit: u, priority: priorities[u]});
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value = toInt(value);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i;
        for (i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      for (i = 0; i < token2.length; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n, x) {
      return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
          this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }
      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
      this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
      var date;
      if (y < 100 && y >= 0) {
        date = new Date(y + 400, m, d, h, M, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }
      return date;
    }
    function createUTCDate(y) {
      var date, args;
      if (y < 100 && y >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
      week[token2.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
          this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
          this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
      this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("Locale " + key + " not found. Did you forget to load it?");
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
      config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
        week = defaults(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      for (i = 0; i < tokens2.length; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({nullInput: true});
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    });
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = (string || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset2, "m"), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
      if (key === void 0) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }
    function utcStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;
        case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;
        case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
      var era = config._locale.erasParse(input, token2, config._strict);
      if (era) {
        getParsingFlags(config).era = era;
      } else {
        getParsingFlags(config).invalidEra = input;
      }
    });
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length; i < l; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        namePieces.push(regexEscape(eras[i].name));
        abbrPieces.push(regexEscape(eras[i].abbr));
        narrowPieces.push(regexEscape(eras[i].narrow));
        mixedPieces.push(regexEscape(eras[i].name));
        mixedPieces.push(regexEscape(eras[i].abbr));
        mixedPieces.push(regexEscape(eras[i].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
      week[token2.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index, field) {
      if (isNumber(format2)) {
        index = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index != null) {
        return get$1(format2, index, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index != null) {
        return get$1(format2, (index + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index) {
      return listMonthsImpl(format2, index, "months");
    }
    function listMonthsShort(format2, index) {
      return listMonthsImpl(format2, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      w: null,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    };
    return hooks;
  });
});

// node_modules/chart.js/dist/Chart.js
var require_Chart = __commonJS((exports2, module2) => {
  /*!
   * Chart.js v2.9.4
   * https://www.chartjs.org
   * (c) 2020 Chart.js Contributors
   * Released under the MIT License
   */
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory(function() {
      try {
        return require_moment();
      } catch (e) {
      }
    }()) : typeof define === "function" && define.amd ? define(["require"], function(require2) {
      return factory(function() {
        try {
          return require2("moment");
        } catch (e) {
        }
      }());
    }) : (global2 = global2 || self, global2.Chart = factory(global2.moment));
  })(exports2, function(moment) {
    "use strict";
    moment = moment && moment.hasOwnProperty("default") ? moment["default"] : moment;
    function createCommonjsModule(fn, module3) {
      return module3 = {exports: {}}, fn(module3, module3.exports), module3.exports;
    }
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    var colorName = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var conversions = createCommonjsModule(function(module3) {
      var reverseKeywords = {};
      for (var key in colorName) {
        if (colorName.hasOwnProperty(key)) {
          reverseKeywords[colorName[key]] = key;
        }
      }
      var convert2 = module3.exports = {
        rgb: {channels: 3, labels: "rgb"},
        hsl: {channels: 3, labels: "hsl"},
        hsv: {channels: 3, labels: "hsv"},
        hwb: {channels: 3, labels: "hwb"},
        cmyk: {channels: 4, labels: "cmyk"},
        xyz: {channels: 3, labels: "xyz"},
        lab: {channels: 3, labels: "lab"},
        lch: {channels: 3, labels: "lch"},
        hex: {channels: 1, labels: ["hex"]},
        keyword: {channels: 1, labels: ["keyword"]},
        ansi16: {channels: 1, labels: ["ansi16"]},
        ansi256: {channels: 1, labels: ["ansi256"]},
        hcg: {channels: 3, labels: ["h", "c", "g"]},
        apple: {channels: 3, labels: ["r16", "g16", "b16"]},
        gray: {channels: 1, labels: ["gray"]}
      };
      for (var model in convert2) {
        if (convert2.hasOwnProperty(model)) {
          if (!("channels" in convert2[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert2[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert2[model].labels.length !== convert2[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          var channels = convert2[model].channels;
          var labels = convert2[model].labels;
          delete convert2[model].channels;
          delete convert2[model].labels;
          Object.defineProperty(convert2[model], "channels", {value: channels});
          Object.defineProperty(convert2[model], "labels", {value: labels});
        }
      }
      convert2.rgb.hsl = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h;
        var s;
        var l;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h;
        var s;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);
        var diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h = convert2.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k2;
        k2 = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k2) / (1 - k2) || 0;
        m = (1 - g - k2) / (1 - k2) || 0;
        y = (1 - b - k2) / (1 - k2) || 0;
        return [c * 100, m * 100, y * 100, k2 * 100];
      };
      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }
      convert2.rgb.keyword = function(rgb) {
        var reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        var currentClosestDistance = Infinity;
        var currentClosestKeyword;
        for (var keyword2 in colorName) {
          if (colorName.hasOwnProperty(keyword2)) {
            var value = colorName[keyword2];
            var distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword2;
            }
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword2) {
        return colorName[keyword2];
      };
      convert2.rgb.xyz = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        var xyz = convert2.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        var h = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t2;
        var t3;
        var rgb;
        var val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        var h = hsl[0];
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        var h = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h) % 6;
        var f = h - Math.floor(h);
        var p = 255 * v * (1 - s);
        var q = 255 * v * (1 - s * f);
        var t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        var h = hsv[0];
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s) * v;
        lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        var h = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i;
        var v;
        var f;
        var n;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        i = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        n = wh + f * (v - wh);
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k2 = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k2) + k2);
        g = 1 - Math.min(1, m * (1 - k2) + k2);
        b = 1 - Math.min(1, y * (1 - k2) + k2);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h;
        var c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        var l = lch[0];
        var c = lch[1];
        var h = lch[2];
        var a;
        var b;
        var hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        var color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.hex.rgb = function(args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        var colorString2 = match[0];
        if (match[0].length === 3) {
          colorString2 = colorString2.split("").map(function(char) {
            return char + char;
          }).join("");
        }
        var integer = parseInt(colorString2, 16);
        var r = integer >> 16 & 255;
        var g = integer >> 8 & 255;
        var b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;
        if (l < 0.5) {
          c = 2 * s * l;
        } else {
          c = 2 * s * (1 - l);
        }
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s * v;
        var f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        var h = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        var pure = [0, 0, 0];
        var hi = h % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        var f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1 - c) + 0.5 * c;
        var s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = convert2.gray.hsv = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        var val = Math.round(gray[0] / 100 * 255) & 255;
        var integer = (val << 16) + (val << 8) + val;
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.rgb.gray = function(rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    });
    var conversions_1 = conversions.rgb;
    var conversions_2 = conversions.hsl;
    var conversions_3 = conversions.hsv;
    var conversions_4 = conversions.hwb;
    var conversions_5 = conversions.cmyk;
    var conversions_6 = conversions.xyz;
    var conversions_7 = conversions.lab;
    var conversions_8 = conversions.lch;
    var conversions_9 = conversions.hex;
    var conversions_10 = conversions.keyword;
    var conversions_11 = conversions.ansi16;
    var conversions_12 = conversions.ansi256;
    var conversions_13 = conversions.hcg;
    var conversions_14 = conversions.apple;
    var conversions_15 = conversions.gray;
    function buildGraph() {
      var graph = {};
      var models2 = Object.keys(conversions);
      for (var len = models2.length, i = 0; i < len; i++) {
        graph[models2[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models2 = Object.keys(graph);
      for (var len = models2.length, i = 0; i < len; i++) {
        var toModel = models2[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert;
    var colorName$1 = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var colorString = {
      getRgba,
      getHsla,
      getRgb,
      getHsl,
      getHwb,
      getAlpha,
      hexString,
      rgbString,
      rgbaString,
      percentString,
      percentaString,
      hslString,
      hslaString,
      hwbString,
      keyword
    };
    function getRgba(string) {
      if (!string) {
        return;
      }
      var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
      var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
      if (match) {
        match = match[1];
        hexAlpha = match[3];
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }
        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }
        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        a = parseFloat(match[4]);
      } else if (match = string.match(keyword2)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }
        rgb = colorName$1[match[1]];
        if (!rgb) {
          return;
        }
      }
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }
      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }
      rgb[3] = a;
      return rgb;
    }
    function getHsla(string) {
      if (!string) {
        return;
      }
      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }
    function getHwb(string) {
      if (!string) {
        return;
      }
      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }
    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }
    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }
    function getAlpha(string) {
      var vals = getRgba(string);
      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    }
    function hexString(rgba, a) {
      var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }
    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }
      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }
    function rgbaString(rgba, alpha) {
      if (alpha === void 0) {
        alpha = rgba[3] !== void 0 ? rgba[3] : 1;
      }
      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }
    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }
      var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }
    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }
    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }
      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }
    function hslaString(hsla, alpha) {
      if (alpha === void 0) {
        alpha = hsla[3] !== void 0 ? hsla[3] : 1;
      }
      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    }
    function hwbString(hwb, alpha) {
      if (alpha === void 0) {
        alpha = hwb[3] !== void 0 ? hwb[3] : 1;
      }
      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
    }
    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    }
    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
    var reverseNames = {};
    for (var name in colorName$1) {
      reverseNames[colorName$1[name]] = name;
    }
    var Color = function(obj) {
      if (obj instanceof Color) {
        return obj;
      }
      if (!(this instanceof Color)) {
        return new Color(obj);
      }
      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      };
      var vals;
      if (typeof obj === "string") {
        vals = colorString.getRgba(obj);
        if (vals) {
          this.setValues("rgb", vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues("hsl", vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues("hwb", vals);
        }
      } else if (typeof obj === "object") {
        vals = obj;
        if (vals.r !== void 0 || vals.red !== void 0) {
          this.setValues("rgb", vals);
        } else if (vals.l !== void 0 || vals.lightness !== void 0) {
          this.setValues("hsl", vals);
        } else if (vals.v !== void 0 || vals.value !== void 0) {
          this.setValues("hsv", vals);
        } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
          this.setValues("hwb", vals);
        } else if (vals.c !== void 0 || vals.cyan !== void 0) {
          this.setValues("cmyk", vals);
        }
      }
    };
    Color.prototype = {
      isValid: function() {
        return this.valid;
      },
      rgb: function() {
        return this.setSpace("rgb", arguments);
      },
      hsl: function() {
        return this.setSpace("hsl", arguments);
      },
      hsv: function() {
        return this.setSpace("hsv", arguments);
      },
      hwb: function() {
        return this.setSpace("hwb", arguments);
      },
      cmyk: function() {
        return this.setSpace("cmyk", arguments);
      },
      rgbArray: function() {
        return this.values.rgb;
      },
      hslArray: function() {
        return this.values.hsl;
      },
      hsvArray: function() {
        return this.values.hsv;
      },
      hwbArray: function() {
        var values = this.values;
        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }
        return values.hwb;
      },
      cmykArray: function() {
        return this.values.cmyk;
      },
      rgbaArray: function() {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function() {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function(val) {
        if (val === void 0) {
          return this.values.alpha;
        }
        this.setValues("alpha", val);
        return this;
      },
      red: function(val) {
        return this.setChannel("rgb", 0, val);
      },
      green: function(val) {
        return this.setChannel("rgb", 1, val);
      },
      blue: function(val) {
        return this.setChannel("rgb", 2, val);
      },
      hue: function(val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }
        return this.setChannel("hsl", 0, val);
      },
      saturation: function(val) {
        return this.setChannel("hsl", 1, val);
      },
      lightness: function(val) {
        return this.setChannel("hsl", 2, val);
      },
      saturationv: function(val) {
        return this.setChannel("hsv", 1, val);
      },
      whiteness: function(val) {
        return this.setChannel("hwb", 1, val);
      },
      blackness: function(val) {
        return this.setChannel("hwb", 2, val);
      },
      value: function(val) {
        return this.setChannel("hsv", 2, val);
      },
      cyan: function(val) {
        return this.setChannel("cmyk", 0, val);
      },
      magenta: function(val) {
        return this.setChannel("cmyk", 1, val);
      },
      yellow: function(val) {
        return this.setChannel("cmyk", 2, val);
      },
      black: function(val) {
        return this.setChannel("cmyk", 3, val);
      },
      hexString: function() {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function() {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function() {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function() {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function() {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function() {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function() {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function() {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function() {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function() {
        var rgb = this.values.rgb;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      dark: function() {
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      light: function() {
        return !this.dark();
      },
      negate: function() {
        var rgb = [];
        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }
        this.setValues("rgb", rgb);
        return this;
      },
      lighten: function(ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues("hsl", hsl);
        return this;
      },
      darken: function(ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues("hsl", hsl);
        return this;
      },
      saturate: function(ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues("hsl", hsl);
        return this;
      },
      desaturate: function(ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues("hsl", hsl);
        return this;
      },
      whiten: function(ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues("hwb", hwb);
        return this;
      },
      blacken: function(ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues("hwb", hwb);
        return this;
      },
      greyscale: function() {
        var rgb = this.values.rgb;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues("rgb", [val, val, val]);
        return this;
      },
      clearer: function(ratio) {
        var alpha = this.values.alpha;
        this.setValues("alpha", alpha - alpha * ratio);
        return this;
      },
      opaquer: function(ratio) {
        var alpha = this.values.alpha;
        this.setValues("alpha", alpha + alpha * ratio);
        return this;
      },
      rotate: function(degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues("hsl", hsl);
        return this;
      },
      mix: function(mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function() {
        return this.rgb();
      },
      clone: function() {
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);
            if (type === "[object Array]") {
              target[prop] = value.slice(0);
            } else if (type === "[object Number]") {
              target[prop] = value;
            } else {
              console.error("unexpected color value:", value);
            }
          }
        }
        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ["red", "green", "blue"],
      hsl: ["hue", "saturation", "lightness"],
      hsv: ["hue", "saturation", "value"],
      hwb: ["hue", "whiteness", "blackness"],
      cmyk: ["cyan", "magenta", "yellow", "black"]
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };
    Color.prototype.getValues = function(space) {
      var values = this.values;
      var vals = {};
      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }
      if (values.alpha !== 1) {
        vals.a = values.alpha;
      }
      return vals;
    };
    Color.prototype.setValues = function(space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;
      if (space === "alpha") {
        alpha = vals;
      } else if (vals.length) {
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== void 0) {
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }
        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== void 0) {
        var chans = spaces[space];
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }
        alpha = vals.alpha;
      }
      values.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values.alpha : alpha));
      if (space === "alpha") {
        return false;
      }
      var capped;
      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      }
      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }
      return true;
    };
    Color.prototype.setSpace = function(space, args) {
      var vals = args[0];
      if (vals === void 0) {
        return this.getValues(space);
      }
      if (typeof vals === "number") {
        vals = Array.prototype.slice.call(args);
      }
      this.setValues(space, vals);
      return this;
    };
    Color.prototype.setChannel = function(space, index, val) {
      var svalues = this.values[space];
      if (val === void 0) {
        return svalues[index];
      } else if (val === svalues[index]) {
        return this;
      }
      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };
    if (typeof window !== "undefined") {
      window.Color = Color;
    }
    var chartjsColor = Color;
    function isValidKey(key) {
      return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
    }
    var helpers = {
      noop: function() {
      },
      uid: function() {
        var id = 0;
        return function() {
          return id++;
        };
      }(),
      isNullOrUndef: function(value) {
        return value === null || typeof value === "undefined";
      },
      isArray: function(value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }
        var type = Object.prototype.toString.call(value);
        if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
          return true;
        }
        return false;
      },
      isObject: function(value) {
        return value !== null && Object.prototype.toString.call(value) === "[object Object]";
      },
      isFinite: function(value) {
        return (typeof value === "number" || value instanceof Number) && isFinite(value);
      },
      valueOrDefault: function(value, defaultValue) {
        return typeof value === "undefined" ? defaultValue : value;
      },
      valueAtIndexOrDefault: function(value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },
      callback: function(fn, args, thisArg) {
        if (fn && typeof fn.call === "function") {
          return fn.apply(thisArg, args);
        }
      },
      each: function(loopable, fn, thisArg, reverse) {
        var i, len, keys;
        if (helpers.isArray(loopable)) {
          len = loopable.length;
          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },
      arrayEquals: function(a0, a1) {
        var i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];
          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            return false;
          }
        }
        return true;
      },
      clone: function(source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }
        if (helpers.isObject(source)) {
          var target = Object.create(source);
          var keys = Object.keys(source);
          var klen = keys.length;
          var k2 = 0;
          for (; k2 < klen; ++k2) {
            target[keys[k2]] = helpers.clone(source[keys[k2]]);
          }
          return target;
        }
        return source;
      },
      _merger: function(key, target, source, options2) {
        if (!isValidKey(key)) {
          return;
        }
        var tval = target[key];
        var sval = source[key];
        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options2);
        } else {
          target[key] = helpers.clone(sval);
        }
      },
      _mergerIf: function(key, target, source) {
        if (!isValidKey(key)) {
          return;
        }
        var tval = target[key];
        var sval = source[key];
        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },
      merge: function(target, source, options2) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k2;
        if (!helpers.isObject(target)) {
          return target;
        }
        options2 = options2 || {};
        merge = options2.merger || helpers._merger;
        for (i = 0; i < ilen; ++i) {
          source = sources[i];
          if (!helpers.isObject(source)) {
            continue;
          }
          keys = Object.keys(source);
          for (k2 = 0, klen = keys.length; k2 < klen; ++k2) {
            merge(keys[k2], target, source, options2);
          }
        }
        return target;
      },
      mergeIf: function(target, source) {
        return helpers.merge(target, source, {merger: helpers._mergerIf});
      },
      extend: Object.assign || function(target) {
        return helpers.merge(target, [].slice.call(arguments, 1), {
          merger: function(key, dst, src2) {
            dst[key] = src2[key];
          }
        });
      },
      inherits: function(extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
          return me.apply(this, arguments);
        };
        var Surrogate = function() {
          this.constructor = ChartElement;
        };
        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;
        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }
        ChartElement.__super__ = me.prototype;
        return ChartElement;
      },
      _deprecated: function(scope, value, previous, current) {
        if (value !== void 0) {
          console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
        }
      }
    };
    var helpers_core = helpers;
    helpers.callCallback = helpers.callback;
    helpers.indexOf = function(array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    helpers.getValueOrDefault = helpers.valueOrDefault;
    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    var effects = {
      linear: function(t) {
        return t;
      },
      easeInQuad: function(t) {
        return t * t;
      },
      easeOutQuad: function(t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }
        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function(t) {
        return t * t * t;
      },
      easeOutCubic: function(t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }
        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function(t) {
        return t * t * t * t;
      },
      easeOutQuart: function(t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }
        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function(t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function(t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }
        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function(t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function(t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function(t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function(t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function(t) {
        if (t === 0) {
          return 0;
        }
        if (t === 1) {
          return 1;
        }
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }
        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function(t) {
        if (t >= 1) {
          return t;
        }
        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function(t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function(t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t === 0) {
          return 0;
        }
        if (t === 1) {
          return 1;
        }
        if (!p) {
          p = 0.3;
        }
        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t === 0) {
          return 0;
        }
        if (t === 1) {
          return 1;
        }
        if (!p) {
          p = 0.3;
        }
        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }
        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function(t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;
        if (t === 0) {
          return 0;
        }
        if ((t /= 0.5) === 2) {
          return 1;
        }
        if (!p) {
          p = 0.45;
        }
        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }
        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function(t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function(t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function(t) {
        var s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function(t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function(t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }
        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }
        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }
        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function(t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }
        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects
    };
    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    var exports$1 = {
      clear: function(chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },
      roundedRect: function(ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);
          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }
          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function(ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === "object") {
          type = style.toString();
          if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
          }
        }
        if (isNaN(radius) || radius <= 0) {
          return;
        }
        ctx.beginPath();
        switch (style) {
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;
          case "triangle":
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
          case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
          case "rect":
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }
            rad += QUARTER_PI;
          case "rectRot":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;
          case "crossRot":
            rad += QUARTER_PI;
          case "cross":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "star":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "line":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
          case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }
        ctx.fill();
        ctx.stroke();
      },
      _isPointInArea: function(point, area) {
        var epsilon = 1e-6;
        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function(ctx) {
        ctx.restore();
      },
      lineTo: function(ctx, previous, target, flip) {
        var stepped = target.steppedLine;
        if (stepped) {
          if (stepped === "middle") {
            var midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
          return;
        }
        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }
        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1;
    helpers_core.clear = exports$1.clear;
    helpers_core.drawRoundedRectangle = function(ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };
    var defaults = {
      _set: function(scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };
    defaults._set("global", {
      defaultColor: "rgba(0,0,0,0.1)",
      defaultFontColor: "#666",
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: "normal",
      defaultLineHeight: 1.2,
      showLines: true
    });
    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }
      return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
    }
    var helpers_options = {
      toLineHeight: function(value, size) {
        var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        if (!matches || matches[1] === "normal") {
          return size * 1.2;
        }
        value = +matches[2];
        switch (matches[3]) {
          case "px":
            return value;
          case "%":
            value /= 100;
            break;
        }
        return size * value;
      },
      toPadding: function(value) {
        var t, r, b, l;
        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }
        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },
      _parseFont: function(options2) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size),
          size,
          style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ""
        };
        font.string = toFontString(font);
        return font;
      },
      resolve: function(inputs, context, index, info) {
        var cacheable = true;
        var i, ilen, value;
        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];
          if (value === void 0) {
            continue;
          }
          if (context !== void 0 && typeof value === "function") {
            value = value(context);
            cacheable = false;
          }
          if (index !== void 0 && helpers_core.isArray(value)) {
            value = value[index];
            cacheable = false;
          }
          if (value !== void 0) {
            if (info && !cacheable) {
              info.cacheable = false;
            }
            return value;
          }
        }
      }
    };
    var exports$2 = {
      _factorize: function(value) {
        var result = [];
        var sqrt = Math.sqrt(value);
        var i;
        for (i = 1; i < sqrt; i++) {
          if (value % i === 0) {
            result.push(i);
            result.push(value / i);
          }
        }
        if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
        }
        result.sort(function(a, b) {
          return a - b;
        }).pop();
        return result;
      },
      log10: Math.log10 || function(x) {
        var exponent = Math.log(x) * Math.LOG10E;
        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      }
    };
    var helpers_math = exports$2;
    helpers_core.log10 = exports$2.log10;
    var getRtlAdapter = function(rectX, width) {
      return {
        x: function(x) {
          return rectX + rectX + width - x;
        },
        setWidth: function(w) {
          width = w;
        },
        textAlign: function(align) {
          if (align === "center") {
            return align;
          }
          return align === "right" ? "left" : "right";
        },
        xPlus: function(x, value) {
          return x - value;
        },
        leftForLtr: function(x, itemWidth) {
          return x - itemWidth;
        }
      };
    };
    var getLtrAdapter = function() {
      return {
        x: function(x) {
          return x;
        },
        setWidth: function(w) {
        },
        textAlign: function(align) {
          return align;
        },
        xPlus: function(x, value) {
          return x + value;
        },
        leftForLtr: function(x, _itemWidth) {
          return x;
        }
      };
    };
    var getAdapter = function(rtl2, rectX, width) {
      return rtl2 ? getRtlAdapter(rectX, width) : getLtrAdapter();
    };
    var overrideTextDirection = function(ctx, direction) {
      var style, original;
      if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
          style.getPropertyValue("direction"),
          style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
      }
    };
    var restoreTextDirection = function(ctx) {
      var original = ctx.prevTextDirection;
      if (original !== void 0) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
      }
    };
    var helpers_rtl = {
      getRtlAdapter: getAdapter,
      overrideTextDirection,
      restoreTextDirection
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    var math = helpers_math;
    var rtl = helpers_rtl;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;
    helpers$1.math = math;
    helpers$1.rtl = rtl;
    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key];
        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }
        actual = view[key];
        if (actual === target || key[0] === "_") {
          continue;
        }
        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }
        origin = start[key];
        type = typeof target;
        if (type === typeof origin) {
          if (type === "string") {
            c0 = chartjsColor(origin);
            if (c0.valid) {
              c1 = chartjsColor(target);
              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }
        view[key] = target;
      }
    }
    var Element = function(configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };
    helpers$1.extend(Element.prototype, {
      _type: void 0,
      initialize: function() {
        this.hidden = false;
      },
      pivot: function() {
        var me = this;
        if (!me._view) {
          me._view = helpers$1.extend({}, me._model);
        }
        me._start = {};
        return me;
      },
      transition: function(ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view;
        if (!model || ease === 1) {
          me._view = helpers$1.extend({}, model);
          me._start = null;
          return me;
        }
        if (!view) {
          view = me._view = {};
        }
        if (!start) {
          start = me._start = {};
        }
        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function() {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function() {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$3 = core_element.extend({
      chart: null,
      currentStep: 0,
      numSteps: 60,
      easing: "",
      render: null,
      onAnimationProgress: null,
      onAnimationComplete: null
    });
    var core_animation = exports$3;
    Object.defineProperty(exports$3.prototype, "animationObject", {
      get: function() {
        return this;
      }
    });
    Object.defineProperty(exports$3.prototype, "chartInstance", {
      get: function() {
        return this.chart;
      },
      set: function(value) {
        this.chart = value;
      }
    });
    core_defaults._set("global", {
      animation: {
        duration: 1e3,
        easing: "easeOutQuart",
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });
    var core_animations = {
      animations: [],
      request: null,
      addAnimation: function(chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;
        if (!lazy) {
          chart.animating = true;
        }
        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }
        animations.push(animation);
        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function(chart) {
        var index = helpers$1.findIndex(this.animations, function(animation) {
          return animation.chart === chart;
        });
        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function() {
        var me = this;
        if (me.request === null) {
          me.request = helpers$1.requestAnimFrame.call(window, function() {
            me.request = null;
            me.startDigest();
          });
        }
      },
      startDigest: function() {
        var me = this;
        me.advance();
        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },
      advance: function() {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0;
        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps;
          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);
          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
      }
      Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function(key) {
        var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function() {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function(object) {
              if (typeof object[method] === "function") {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;
      if (!stub) {
        return;
      }
      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
      if (listeners.length > 0) {
        return;
      }
      arrayEvents.forEach(function(key) {
        delete array[key];
      });
      delete array._chartjs;
    }
    var DatasetController = function(chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };
    helpers$1.extend(DatasetController.prototype, {
      datasetElementType: null,
      dataElementType: null,
      _datasetElementOptions: [
        "backgroundColor",
        "borderCapStyle",
        "borderColor",
        "borderDash",
        "borderDashOffset",
        "borderJoinStyle",
        "borderWidth"
      ],
      _dataElementOptions: [
        "backgroundColor",
        "borderColor",
        "borderWidth",
        "pointStyle"
      ],
      initialize: function(chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
        me._type = me.getMeta().type;
      },
      updateIndex: function(datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function() {
        var me = this;
        var meta = me.getMeta();
        var chart = me.chart;
        var scales2 = chart.scales;
        var dataset = me.getDataset();
        var scalesOpts = chart.options.scales;
        if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
          meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
        }
        if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
          meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
        }
      },
      getDataset: function() {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function() {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function(scaleID) {
        return this.chart.scales[scaleID];
      },
      _getValueScaleId: function() {
        return this.getMeta().yAxisID;
      },
      _getIndexScaleId: function() {
        return this.getMeta().xAxisID;
      },
      _getValueScale: function() {
        return this.getScaleForId(this._getValueScaleId());
      },
      _getIndexScale: function() {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function() {
        this._update(true);
      },
      destroy: function() {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function() {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function(index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function() {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;
        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }
        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function(index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function() {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []);
        if (me._data !== data) {
          if (me._data) {
            unlistenArrayEvents(me._data, me);
          }
          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }
          me._data = data;
        }
        me.resyncElements();
      },
      _configure: function() {
        var me = this;
        me._config = helpers$1.merge(Object.create(null), [
          me.chart.options.datasets[me._type],
          me.getDataset()
        ], {
          merger: function(key, target, source) {
            if (key !== "_meta" && key !== "data") {
              helpers$1._merger(key, target, source);
            }
          }
        });
      },
      _update: function(reset) {
        var me = this;
        me._configure();
        me._cachedDataOpts = null;
        me.update(reset);
      },
      update: helpers$1.noop,
      transition: function(easingValue) {
        var meta = this.getMeta();
        var elements2 = meta.data || [];
        var ilen = elements2.length;
        var i = 0;
        for (; i < ilen; ++i) {
          elements2[i].transition(easingValue);
        }
        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function() {
        var meta = this.getMeta();
        var elements2 = meta.data || [];
        var ilen = elements2.length;
        var i = 0;
        if (meta.dataset) {
          meta.dataset.draw();
        }
        for (; i < ilen; ++i) {
          elements2[i].draw();
        }
      },
      getStyle: function(index) {
        var me = this;
        var meta = me.getMeta();
        var dataset = meta.dataset;
        var style;
        me._configure();
        if (dataset && index === void 0) {
          style = me._resolveDatasetElementOptions(dataset || {});
        } else {
          index = index || 0;
          style = me._resolveDataElementOptions(meta.data[index] || {}, index);
        }
        if (style.fill === false || style.fill === null) {
          style.backgroundColor = style.borderColor;
        }
        return style;
      },
      _resolveDatasetElementOptions: function(element, hover) {
        var me = this;
        var chart = me.chart;
        var datasetOpts = me._config;
        var custom = element.custom || {};
        var options2 = chart.options.elements[me.datasetElementType.prototype._type] || {};
        var elementOptions = me._datasetElementOptions;
        var values = {};
        var i, ilen, key, readKey;
        var context = {
          chart,
          dataset: me.getDataset(),
          datasetIndex: me.index,
          hover
        };
        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
          key = elementOptions[i];
          readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
          values[key] = resolve([
            custom[readKey],
            datasetOpts[readKey],
            options2[readKey]
          ], context);
        }
        return values;
      },
      _resolveDataElementOptions: function(element, index) {
        var me = this;
        var custom = element && element.custom;
        var cached = me._cachedDataOpts;
        if (cached && !custom) {
          return cached;
        }
        var chart = me.chart;
        var datasetOpts = me._config;
        var options2 = chart.options.elements[me.dataElementType.prototype._type] || {};
        var elementOptions = me._dataElementOptions;
        var values = {};
        var context = {
          chart,
          dataIndex: index,
          dataset: me.getDataset(),
          datasetIndex: me.index
        };
        var info = {cacheable: !custom};
        var keys, i, ilen, key;
        custom = custom || {};
        if (helpers$1.isArray(elementOptions)) {
          for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
            key = elementOptions[i];
            values[key] = resolve([
              custom[key],
              datasetOpts[key],
              options2[key]
            ], context, index, info);
          }
        } else {
          keys = Object.keys(elementOptions);
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            values[key] = resolve([
              custom[key],
              datasetOpts[elementOptions[key]],
              datasetOpts[key],
              options2[key]
            ], context, index, info);
          }
        }
        if (info.cacheable) {
          me._cachedDataOpts = Object.freeze(values);
        }
        return values;
      },
      removeHoverStyle: function(element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function(element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index);
      },
      _removeDatasetHoverStyle: function() {
        var element = this.getMeta().dataset;
        if (element) {
          this.removeHoverStyle(element);
        }
      },
      _setDatasetHoverStyle: function() {
        var element = this.getMeta().dataset;
        var prev = {};
        var i, ilen, key, keys, hoverOptions, model;
        if (!element) {
          return;
        }
        model = element._model;
        hoverOptions = this._resolveDatasetElementOptions(element, true);
        keys = Object.keys(hoverOptions);
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          prev[key] = model[key];
          model[key] = hoverOptions[key];
        }
        element.$previousStyle = prev;
      },
      resyncElements: function() {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;
        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },
      insertElements: function(start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },
      onDataPush: function() {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },
      onDataPop: function() {
        this.getMeta().data.pop();
      },
      onDataShift: function() {
        this.getMeta().data.shift();
      },
      onDataSplice: function(start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },
      onDataUnshift: function() {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;
    var TAU = Math.PI * 2;
    core_defaults._set("global", {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: "#fff",
          borderWidth: 2,
          borderAlign: "center"
        }
      }
    });
    function clipArc(ctx, arc) {
      var startAngle = arc.startAngle;
      var endAngle = arc.endAngle;
      var pixelMargin = arc.pixelMargin;
      var angleMargin = pixelMargin / arc.outerRadius;
      var x = arc.x;
      var y = arc.y;
      ctx.beginPath();
      ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
      if (arc.innerRadius > pixelMargin) {
        angleMargin = pixelMargin / arc.innerRadius;
        ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
      } else {
        ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
      }
      ctx.closePath();
      ctx.clip();
    }
    function drawFullCircleBorders(ctx, vm, arc, inner) {
      var endAngle = arc.endAngle;
      var i;
      if (inner) {
        arc.endAngle = arc.startAngle + TAU;
        clipArc(ctx, arc);
        arc.endAngle = endAngle;
        if (arc.endAngle === arc.startAngle && arc.fullCircles) {
          arc.endAngle += TAU;
          arc.fullCircles--;
        }
      }
      ctx.beginPath();
      ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
      for (i = 0; i < arc.fullCircles; ++i) {
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
      for (i = 0; i < arc.fullCircles; ++i) {
        ctx.stroke();
      }
    }
    function drawBorder(ctx, vm, arc) {
      var inner = vm.borderAlign === "inner";
      if (inner) {
        ctx.lineWidth = vm.borderWidth * 2;
        ctx.lineJoin = "round";
      } else {
        ctx.lineWidth = vm.borderWidth;
        ctx.lineJoin = "bevel";
      }
      if (arc.fullCircles) {
        drawFullCircleBorders(ctx, vm, arc, inner);
      }
      if (inner) {
        clipArc(ctx, arc);
      }
      ctx.beginPath();
      ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
      ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
      ctx.closePath();
      ctx.stroke();
    }
    var element_arc = core_element.extend({
      _type: "arc",
      inLabelRange: function(mouseX) {
        var vm = this._view;
        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }
        return false;
      },
      inRange: function(chartX, chartY) {
        var vm = this._view;
        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance;
          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;
          while (endAngle < startAngle) {
            endAngle += TAU;
          }
          while (angle > endAngle) {
            angle -= TAU;
          }
          while (angle < startAngle) {
            angle += TAU;
          }
          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }
        return false;
      },
      getCenterPoint: function() {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function() {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function() {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function() {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
        var arc = {
          x: vm.x,
          y: vm.y,
          innerRadius: vm.innerRadius,
          outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
          pixelMargin,
          startAngle: vm.startAngle,
          endAngle: vm.endAngle,
          fullCircles: Math.floor(vm.circumference / TAU)
        };
        var i;
        ctx.save();
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        if (arc.fullCircles) {
          arc.endAngle = arc.startAngle + TAU;
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.fill();
          }
          arc.endAngle = arc.startAngle + vm.circumference % TAU;
        }
        ctx.beginPath();
        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
        ctx.closePath();
        ctx.fill();
        if (vm.borderWidth) {
          drawBorder(ctx, vm, arc);
        }
        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;
    core_defaults._set("global", {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          capBezierPoints: true,
          fill: true
        }
      }
    });
    var element_line = core_element.extend({
      _type: "line",
      draw: function() {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;
        var points = me._children.slice();
        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var closePath = me._loop;
        var index, previous, currentVM;
        if (!points.length) {
          return;
        }
        if (me._loop) {
          for (index = 0; index < points.length; ++index) {
            previous = helpers$1.previousItem(points, index);
            if (!points[index]._view.skip && previous._view.skip) {
              points = points.slice(index).concat(points.slice(0, index));
              closePath = spanGaps;
              break;
            }
          }
          if (closePath) {
            points.push(points[0]);
          }
        }
        ctx.save();
        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }
        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
        ctx.beginPath();
        currentVM = points[0]._view;
        if (!currentVM.skip) {
          ctx.moveTo(currentVM.x, currentVM.y);
          lastDrawnIndex = 0;
        }
        for (index = 1; index < points.length; ++index) {
          currentVM = points[index]._view;
          previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];
          if (!currentVM.skip) {
            if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
              ctx.moveTo(currentVM.x, currentVM.y);
            } else {
              helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
            }
            lastDrawnIndex = index;
          }
        }
        if (closePath) {
          ctx.closePath();
        }
        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;
    core_defaults._set("global", {
      elements: {
        point: {
          radius: 3,
          pointStyle: "circle",
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });
    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }
    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }
    var element_point = core_element.extend({
      _type: "point",
      inRange: function(mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function() {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function(chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor2 = globalDefaults.defaultColor;
        if (vm.skip) {
          return;
        }
        if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor2;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor2;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;
    core_defaults._set("global", {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: "bottom",
          borderWidth: 0
        }
      }
    });
    function isVertical(vm) {
      return vm && vm.width !== void 0;
    }
    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;
      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }
      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }
    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }
    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};
      if (!edge) {
        return res;
      }
      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, "left", "right");
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, "bottom", "top");
      }
      res[edge] = true;
      return res;
    }
    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip2 = parseBorderSkipped(vm);
      var t, r, b, l;
      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }
      return {
        t: skip2.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip2.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip2.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }
    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }
    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }
    var element_rectangle = core_element.extend({
      _type: "rectangle",
      draw: function() {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }
        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill("evenodd");
        ctx.restore();
      },
      height: function() {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function(mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function(mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function(mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function(mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function() {
        var vm = this._view;
        var x, y;
        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }
        return {x, y};
      },
      getArea: function() {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function() {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var deprecated = helpers$1._deprecated;
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    core_defaults._set("bar", {
      hover: {
        mode: "label"
      },
      scales: {
        xAxes: [{
          type: "category",
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: "linear"
        }]
      }
    });
    core_defaults._set("global", {
      datasets: {
        bar: {
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }
      }
    });
    function computeMinSampleSize(scale2, pixels) {
      var min = scale2._length;
      var prev, curr, i, ilen;
      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }
      for (i = 0, ilen = scale2.getTicks().length; i < ilen; ++i) {
        curr = scale2.getPixelForTick(i);
        min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
        prev = curr;
      }
      return min;
    }
    function computeFitCategoryTraits(index, ruler, options2) {
      var thickness = options2.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
      var size, ratio;
      if (helpers$1.isNullOrUndef(thickness)) {
        size = min * options2.categoryPercentage;
        ratio = options2.barPercentage;
      } else {
        size = thickness * count;
        ratio = 1;
      }
      return {
        chunk: size / count,
        ratio,
        start: curr - size / 2
      };
    }
    function computeFlexCategoryTraits(index, ruler, options2) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options2.categoryPercentage;
      var start, size;
      if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }
      if (next === null) {
        next = curr + curr - prev;
      }
      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options2.barPercentage,
        start
      };
    }
    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      _dataElementOptions: [
        "backgroundColor",
        "borderColor",
        "borderSkipped",
        "borderWidth",
        "barPercentage",
        "barThickness",
        "categoryPercentage",
        "maxBarThickness",
        "minBarLength"
      ],
      initialize: function() {
        var me = this;
        var meta, scaleOpts;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
        scaleOpts = me._getIndexScale().options;
        deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
        deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
        deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
        deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
        deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
      },
      update: function(reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();
        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function(rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();
        var options2 = me._resolveDataElementOptions(rectangle, index);
        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options2.backgroundColor,
          borderColor: options2.borderColor,
          borderSkipped: options2.borderSkipped,
          borderWidth: options2.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };
        if (helpers$1.isArray(dataset.data[index])) {
          rectangle._model.borderSkipped = null;
        }
        me._updateElementGeometry(rectangle, index, reset, options2);
        rectangle.pivot();
      },
      _updateElementGeometry: function(rectangle, index, reset, options2) {
        var me = this;
        var model = rectangle._model;
        var vscale = me._getValueScale();
        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index, options2);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options2);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : void 0;
        model.width = horizontal ? void 0 : ipixels.size;
      },
      _getStacks: function(last) {
        var me = this;
        var scale2 = me._getIndexScale();
        var metasets = scale2._getMatchingVisibleMetas(me._type);
        var stacked = scale2.options.stacked;
        var ilen = metasets.length;
        var stacks = [];
        var i, meta;
        for (i = 0; i < ilen; ++i) {
          meta = metasets[i];
          if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
            stacks.push(meta.stack);
          }
          if (meta.index === last) {
            break;
          }
        }
        return stacks;
      },
      getStackCount: function() {
        return this._getStacks().length;
      },
      getStackIndex: function(datasetIndex, name2) {
        var stacks = this._getStacks(datasetIndex);
        var index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
        return index === -1 ? stacks.length - 1 : index;
      },
      getRuler: function() {
        var me = this;
        var scale2 = me._getIndexScale();
        var pixels = [];
        var i, ilen;
        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale2.getPixelForValue(null, i, me.index));
        }
        return {
          pixels,
          start: scale2._startPixel,
          end: scale2._endPixel,
          stackCount: me.getStackCount(),
          scale: scale2
        };
      },
      calculateBarValuePixels: function(datasetIndex, index, options2) {
        var me = this;
        var chart = me.chart;
        var scale2 = me._getValueScale();
        var isHorizontal = scale2.isHorizontal();
        var datasets = chart.data.datasets;
        var metasets = scale2._getMatchingVisibleMetas(me._type);
        var value = scale2._parseValue(datasets[datasetIndex].data[index]);
        var minBarLength = options2.minBarLength;
        var stacked = scale2.options.stacked;
        var stack = me.getMeta().stack;
        var start = value.start === void 0 ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
        var length = value.start === void 0 ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
        var ilen = metasets.length;
        var i, imeta, ivalue, base, head, size, stackLength;
        if (stacked || stacked === void 0 && stack !== void 0) {
          for (i = 0; i < ilen; ++i) {
            imeta = metasets[i];
            if (imeta.index === datasetIndex) {
              break;
            }
            if (imeta.stack === stack) {
              stackLength = scale2._parseValue(datasets[imeta.index].data[index]);
              ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
              if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }
        base = scale2.getPixelForValue(start);
        head = scale2.getPixelForValue(start + length);
        size = head - base;
        if (minBarLength !== void 0 && Math.abs(size) < minBarLength) {
          size = minBarLength;
          if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }
        return {
          size,
          base,
          head,
          center: head + size / 2
        };
      },
      calculateBarIndexPixels: function(datasetIndex, index, ruler, options2) {
        var me = this;
        var range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options2) : computeFitCategoryTraits(index, ruler, options2);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(valueOrDefault$3(options2.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center,
          size
        };
      },
      draw: function() {
        var me = this;
        var chart = me.chart;
        var scale2 = me._getValueScale();
        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
        for (; i < ilen; ++i) {
          var val = scale2._parseValue(dataset.data[i]);
          if (!isNaN(val.min) && !isNaN(val.max)) {
            rects[i].draw();
          }
        }
        helpers$1.canvas.unclipArea(chart.ctx);
      },
      _resolveDataElementOptions: function() {
        var me = this;
        var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
        var indexOpts = me._getIndexScale().options;
        var valueOpts = me._getValueScale().options;
        values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
        values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
        values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
        values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
        values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
        return values;
      }
    });
    var valueOrDefault$4 = helpers$1.valueOrDefault;
    var resolve$1 = helpers$1.options.resolve;
    core_defaults._set("bubble", {
      hover: {
        mode: "single"
      },
      scales: {
        xAxes: [{
          type: "linear",
          position: "bottom",
          id: "x-axis-0"
        }],
        yAxes: [{
          type: "linear",
          position: "left",
          id: "y-axis-0"
        }]
      },
      tooltips: {
        callbacks: {
          title: function() {
            return "";
          },
          label: function(item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || "";
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
          }
        }
      }
    });
    var controller_bubble = core_datasetController.extend({
      dataElementType: elements.Point,
      _dataElementOptions: [
        "backgroundColor",
        "borderColor",
        "borderWidth",
        "hoverBackgroundColor",
        "hoverBorderColor",
        "hoverBorderWidth",
        "hoverRadius",
        "hitRadius",
        "pointStyle",
        "rotation"
      ],
      update: function(reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data;
        helpers$1.each(points, function(point, index) {
          me.updateElement(point, index, reset);
        });
      },
      updateElement: function(point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);
        var options2 = me._resolveDataElementOptions(point, index);
        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options2;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options2.backgroundColor,
          borderColor: options2.borderColor,
          borderWidth: options2.borderWidth,
          hitRadius: options2.hitRadius,
          pointStyle: options2.pointStyle,
          rotation: options2.rotation,
          radius: reset ? 0 : options2.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x,
          y
        };
        point.pivot();
      },
      setHoverStyle: function(point) {
        var model = point._model;
        var options2 = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
        model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
        model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
        model.radius = options2.radius + options2.hoverRadius;
      },
      _resolveDataElementOptions: function(point, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = point.custom || {};
        var data = dataset.data[index] || {};
        var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
        var context = {
          chart,
          dataIndex: index,
          dataset,
          datasetIndex: me.index
        };
        if (me._cachedDataOpts === values) {
          values = helpers$1.extend({}, values);
        }
        values.radius = resolve$1([
          custom.radius,
          data.r,
          me._config.radius,
          chart.options.elements.point.radius
        ], context, index);
        return values;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var PI$1 = Math.PI;
    var DOUBLE_PI$1 = PI$1 * 2;
    var HALF_PI$1 = PI$1 / 2;
    core_defaults._set("doughnut", {
      animation: {
        animateRotate: true,
        animateScale: false
      },
      hover: {
        mode: "single"
      },
      legendCallback: function(chart) {
        var list = document.createElement("ul");
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;
        var i, ilen, listItem, listItemSpan;
        list.setAttribute("class", chart.id + "-legend");
        if (datasets.length) {
          for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
            listItem = list.appendChild(document.createElement("li"));
            listItemSpan = listItem.appendChild(document.createElement("span"));
            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
            if (labels[i]) {
              listItem.appendChild(document.createTextNode(labels[i]));
            }
          }
        }
        return list.outerHTML;
      },
      legend: {
        labels: {
          generateLabels: function(chart) {
            var data = chart.data;
            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function(label, i) {
                var meta = chart.getDatasetMeta(0);
                var style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick: function(e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;
          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }
          chart.update();
        }
      },
      cutoutPercentage: 50,
      rotation: -HALF_PI$1,
      circumference: DOUBLE_PI$1,
      tooltips: {
        callbacks: {
          title: function() {
            return "";
          },
          label: function(tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
            if (helpers$1.isArray(dataLabel)) {
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }
            return dataLabel;
          }
        }
      }
    });
    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      _dataElementOptions: [
        "backgroundColor",
        "borderColor",
        "borderWidth",
        "borderAlign",
        "hoverBackgroundColor",
        "hoverBorderColor",
        "hoverBorderWidth"
      ],
      getRingIndex: function(datasetIndex) {
        var ringIndex = 0;
        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }
        return ringIndex;
      },
      update: function(reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var ratioX = 1;
        var ratioY = 1;
        var offsetX = 0;
        var offsetY = 0;
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutout = opts.cutoutPercentage / 100 || 0;
        var circumference = opts.circumference;
        var chartWeight = me._getRingWeight(me.index);
        var maxWidth, maxHeight, i, ilen;
        if (circumference < DOUBLE_PI$1) {
          var startAngle = opts.rotation % DOUBLE_PI$1;
          startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
          var endAngle = startAngle + circumference;
          var startX = Math.cos(startAngle);
          var startY = Math.sin(startAngle);
          var endX = Math.cos(endAngle);
          var endY = Math.sin(endAngle);
          var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
          var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
          var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
          var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
          var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
          var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
          var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
          var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
        }
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
        }
        chart.borderWidth = me.getMaxBorderWidth();
        maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
        maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
        chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offsetX * chart.outerRadius;
        chart.offsetY = offsetY * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function(arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation;
        var endAngle = opts.rotation;
        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options2 = arc._options || {};
        helpers$1.extend(arc, {
          _datasetIndex: me.index,
          _index: index,
          _model: {
            backgroundColor: options2.backgroundColor,
            borderColor: options2.borderColor,
            borderWidth: options2.borderWidth,
            borderAlign: options2.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle,
            endAngle,
            circumference,
            outerRadius,
            innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model;
        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }
          model.endAngle = model.startAngle + model.circumference;
        }
        arc.pivot();
      },
      calculateTotal: function() {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function(element, index) {
          value = dataset.data[index];
          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        return total;
      },
      calculateCircumference: function(value) {
        var total = this.getMeta().total;
        if (total > 0 && !isNaN(value)) {
          return DOUBLE_PI$1 * (Math.abs(value) / total);
        }
        return 0;
      },
      getMaxBorderWidth: function(arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
        if (!arcs) {
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;
              if (i !== me.index) {
                controller = meta.controller;
              }
              break;
            }
          }
        }
        if (!arcs) {
          return 0;
        }
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          if (controller) {
            controller._configure();
            options2 = controller._resolveDataElementOptions(arc, i);
          } else {
            options2 = arc._options;
          }
          if (options2.borderAlign !== "inner") {
            borderWidth = options2.borderWidth;
            hoverWidth = options2.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }
        return max;
      },
      setHoverStyle: function(arc) {
        var model = arc._model;
        var options2 = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
        model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
        model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
      },
      _getRingWeightOffset: function(datasetIndex) {
        var ringWeightOffset = 0;
        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }
        return ringWeightOffset;
      },
      _getRingWeight: function(dataSetIndex) {
        return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },
      _getVisibleDatasetWeightTotal: function() {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });
    core_defaults._set("horizontalBar", {
      hover: {
        mode: "index",
        axis: "y"
      },
      scales: {
        xAxes: [{
          type: "linear",
          position: "bottom"
        }],
        yAxes: [{
          type: "category",
          position: "left",
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: "left"
        }
      },
      tooltips: {
        mode: "index",
        axis: "y"
      }
    });
    core_defaults._set("global", {
      datasets: {
        horizontalBar: {
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }
      }
    });
    var controller_horizontalBar = controller_bar.extend({
      _getValueScaleId: function() {
        return this.getMeta().xAxisID;
      },
      _getIndexScaleId: function() {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;
    core_defaults._set("line", {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: "label"
      },
      scales: {
        xAxes: [{
          type: "category",
          id: "x-axis-0"
        }],
        yAxes: [{
          type: "linear",
          id: "y-axis-0"
        }]
      }
    });
    function scaleClip(scale2, halfBorderWidth) {
      var tickOpts = scale2 && scale2.options.ticks || {};
      var reverse = tickOpts.reverse;
      var min = tickOpts.min === void 0 ? halfBorderWidth : 0;
      var max = tickOpts.max === void 0 ? halfBorderWidth : 0;
      return {
        start: reverse ? max : min,
        end: reverse ? min : max
      };
    }
    function defaultClip(xScale, yScale, borderWidth) {
      var halfBorderWidth = borderWidth / 2;
      var x = scaleClip(xScale, halfBorderWidth);
      var y = scaleClip(yScale, halfBorderWidth);
      return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
      };
    }
    function toClip(value) {
      var t, r, b, l;
      if (helpers$1.isObject(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
      } else {
        t = r = b = l = value;
      }
      return {
        top: t,
        right: r,
        bottom: b,
        left: l
      };
    }
    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      _datasetElementOptions: [
        "backgroundColor",
        "borderCapStyle",
        "borderColor",
        "borderDash",
        "borderDashOffset",
        "borderJoinStyle",
        "borderWidth",
        "cubicInterpolationMode",
        "fill"
      ],
      _dataElementOptions: {
        backgroundColor: "pointBackgroundColor",
        borderColor: "pointBorderColor",
        borderWidth: "pointBorderWidth",
        hitRadius: "pointHitRadius",
        hoverBackgroundColor: "pointHoverBackgroundColor",
        hoverBorderColor: "pointHoverBorderColor",
        hoverBorderWidth: "pointHoverBorderWidth",
        hoverRadius: "pointHoverRadius",
        pointStyle: "pointStyle",
        radius: "pointRadius",
        rotation: "pointRotation"
      },
      update: function(reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var options2 = me.chart.options;
        var config = me._config;
        var showLine = me._showLine = valueOrDefault$6(config.showLine, options2.showLines);
        var i, ilen;
        me._xScale = me.getScaleForId(meta.xAxisID);
        me._yScale = me.getScaleForId(meta.yAxisID);
        if (showLine) {
          if (config.tension !== void 0 && config.lineTension === void 0) {
            config.lineTension = config.tension;
          }
          line._scale = me._yScale;
          line._datasetIndex = me.index;
          line._children = points;
          line._model = me._resolveDatasetElementOptions(line);
          line.pivot();
        }
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }
        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        }
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function(point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var xScale = me._xScale;
        var yScale = me._yScale;
        var lineModel = meta.dataset._model;
        var x, y;
        var options2 = me._resolveDataElementOptions(point, index);
        x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options2;
        point._datasetIndex = datasetIndex;
        point._index = index;
        point._model = {
          x,
          y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          radius: options2.radius,
          pointStyle: options2.pointStyle,
          rotation: options2.rotation,
          backgroundColor: options2.backgroundColor,
          borderColor: options2.borderColor,
          borderWidth: options2.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          hitRadius: options2.hitRadius
        };
      },
      _resolveDatasetElementOptions: function(element) {
        var me = this;
        var config = me._config;
        var custom = element.custom || {};
        var options2 = me.chart.options;
        var lineOptions = options2.elements.line;
        var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
        values.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
        values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
        values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
        values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
        return values;
      },
      calculatePointY: function(value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var yScale = me._yScale;
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
        if (yScale.options.stacked) {
          rightValue = +yScale.getRightValue(value);
          metasets = chart._getSortedVisibleDatasetMetas();
          ilen = metasets.length;
          for (i = 0; i < ilen; ++i) {
            dsMeta = metasets[i];
            if (dsMeta.index === datasetIndex) {
              break;
            }
            ds = chart.data.datasets[dsMeta.index];
            if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
              stackedRightValue = +yScale.getRightValue(ds.data[index]);
              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }
          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }
          return yScale.getPixelForValue(sumPos + rightValue);
        }
        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function() {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;
        if (lineModel.spanGaps) {
          points = points.filter(function(pt) {
            return !pt._model.skip;
          });
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        if (lineModel.cubicInterpolationMode === "monotone") {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }
        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }
              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function() {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var canvas2 = chart.canvas;
        var i = 0;
        var ilen = points.length;
        var clip;
        if (me._showLine) {
          clip = meta.dataset._model.clip;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? canvas2.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? canvas2.height : area.bottom + clip.bottom
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        }
        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },
      setHoverStyle: function(point) {
        var model = point._model;
        var options2 = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
        model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
        model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
        model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    core_defaults._set("polarArea", {
      scale: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function(chart) {
        var list = document.createElement("ul");
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;
        var i, ilen, listItem, listItemSpan;
        list.setAttribute("class", chart.id + "-legend");
        if (datasets.length) {
          for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
            listItem = list.appendChild(document.createElement("li"));
            listItemSpan = listItem.appendChild(document.createElement("span"));
            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
            if (labels[i]) {
              listItem.appendChild(document.createTextNode(labels[i]));
            }
          }
        }
        return list.outerHTML;
      },
      legend: {
        labels: {
          generateLabels: function(chart) {
            var data = chart.data;
            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function(label, i) {
                var meta = chart.getDatasetMeta(0);
                var style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick: function(e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;
          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }
          chart.update();
        }
      },
      tooltips: {
        callbacks: {
          title: function() {
            return "";
          },
          label: function(item, data) {
            return data.labels[item.index] + ": " + item.yLabel;
          }
        }
      }
    });
    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      _dataElementOptions: [
        "backgroundColor",
        "borderColor",
        "borderWidth",
        "borderAlign",
        "hoverBackgroundColor",
        "hoverBorderColor",
        "hoverBorderWidth"
      ],
      _getIndexScaleId: function() {
        return this.chart.scale.id;
      },
      _getValueScaleId: function() {
        return this.chart.scale.id;
      },
      update: function(reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;
        me._updateRadius();
        meta.count = me.countVisibleElements();
        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },
      _updateRadius: function() {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function(arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale2 = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale2.xCenter;
        var centerY = scale2.yCenter;
        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
        var options2 = arc._options || {};
        helpers$1.extend(arc, {
          _datasetIndex: me.index,
          _index: index,
          _scale: scale2,
          _model: {
            backgroundColor: options2.backgroundColor,
            borderColor: options2.borderColor,
            borderWidth: options2.borderWidth,
            borderAlign: options2.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function() {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function(element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },
      setHoverStyle: function(arc) {
        var model = arc._model;
        var options2 = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault2 = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
        model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
        model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
      },
      _computeAngle: function(index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        }
        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset,
          datasetIndex: me.index
        };
        return resolve$3([
          me.chart.options.elements.arc.angle,
          2 * Math.PI / count
        ], context, index);
      }
    });
    core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
    core_defaults._set("pie", {
      cutoutPercentage: 0
    });
    var controller_pie = controller_doughnut;
    var valueOrDefault$7 = helpers$1.valueOrDefault;
    core_defaults._set("radar", {
      spanGaps: false,
      scale: {
        type: "radialLinear"
      },
      elements: {
        line: {
          fill: "start",
          tension: 0
        }
      }
    });
    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      _datasetElementOptions: [
        "backgroundColor",
        "borderWidth",
        "borderColor",
        "borderCapStyle",
        "borderDash",
        "borderDashOffset",
        "borderJoinStyle",
        "fill"
      ],
      _dataElementOptions: {
        backgroundColor: "pointBackgroundColor",
        borderColor: "pointBorderColor",
        borderWidth: "pointBorderWidth",
        hitRadius: "pointHitRadius",
        hoverBackgroundColor: "pointHoverBackgroundColor",
        hoverBorderColor: "pointHoverBorderColor",
        hoverBorderWidth: "pointHoverBorderWidth",
        hoverRadius: "pointHoverRadius",
        pointStyle: "pointStyle",
        radius: "pointRadius",
        rotation: "pointRotation"
      },
      _getIndexScaleId: function() {
        return this.chart.scale.id;
      },
      _getValueScaleId: function() {
        return this.chart.scale.id;
      },
      update: function(reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale2 = me.chart.scale;
        var config = me._config;
        var i, ilen;
        if (config.tension !== void 0 && config.lineTension === void 0) {
          config.lineTension = config.tension;
        }
        line._scale = scale2;
        line._datasetIndex = me.index;
        line._children = points;
        line._loop = true;
        line._model = me._resolveDatasetElementOptions(line);
        line.pivot();
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }
        me.updateBezierControlPoints();
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function(point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale2 = me.chart.scale;
        var pointPosition = scale2.getPointPositionForValue(index, dataset.data[index]);
        var options2 = me._resolveDataElementOptions(point, index);
        var lineModel = me.getMeta().dataset._model;
        var x = reset ? scale2.xCenter : pointPosition.x;
        var y = reset ? scale2.yCenter : pointPosition.y;
        point._scale = scale2;
        point._options = options2;
        point._datasetIndex = me.index;
        point._index = index;
        point._model = {
          x,
          y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          radius: options2.radius,
          pointStyle: options2.pointStyle,
          rotation: options2.rotation,
          backgroundColor: options2.backgroundColor,
          borderColor: options2.borderColor,
          borderWidth: options2.borderWidth,
          tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
          hitRadius: options2.hitRadius
        };
      },
      _resolveDatasetElementOptions: function() {
        var me = this;
        var config = me._config;
        var options2 = me.chart.options;
        var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
        values.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
        values.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
        return values;
      },
      updateBezierControlPoints: function() {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;
        if (meta.dataset._model.spanGaps) {
          points = points.filter(function(pt) {
            return !pt._model.skip;
          });
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);
          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function(point) {
        var model = point._model;
        var options2 = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
        model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
        model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
        model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
      }
    });
    core_defaults._set("scatter", {
      hover: {
        mode: "single"
      },
      scales: {
        xAxes: [{
          id: "x-axis-1",
          type: "linear",
          position: "bottom"
        }],
        yAxes: [{
          id: "y-axis-1",
          type: "linear",
          position: "left"
        }]
      },
      tooltips: {
        callbacks: {
          title: function() {
            return "";
          },
          label: function(item) {
            return "(" + item.xLabel + ", " + item.yLabel + ")";
          }
        }
      }
    });
    core_defaults._set("global", {
      datasets: {
        scatter: {
          showLine: false
        }
      }
    });
    var controller_scatter = controller_line;
    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }
      return helpers$1.getRelativePosition(e, chart);
    }
    function parseVisibleItems(chart, handler) {
      var metasets = chart._getSortedVisibleDatasetMetas();
      var metadata, i, j, ilen, jlen, element;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        metadata = metasets[i].data;
        for (j = 0, jlen = metadata.length; j < jlen; ++j) {
          element = metadata[j];
          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    function getIntersectItems(chart, position) {
      var elements2 = [];
      parseVisibleItems(chart, function(element) {
        if (element.inRange(position.x, position.y)) {
          elements2.push(element);
        }
      });
      return elements2;
    }
    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function(element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }
        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);
        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf("x") !== -1;
      var useY = axis.indexOf("y") !== -1;
      return function(pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }
    function indexMode(chart, e, options2) {
      var position = getRelativePosition(e, chart);
      options2.axis = options2.axis || "x";
      var distanceMetric = getDistanceMetricForAxis(options2.axis);
      var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements2 = [];
      if (!items.length) {
        return [];
      }
      chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
        var element = meta.data[items[0]._index];
        if (element && !element._view.skip) {
          elements2.push(element);
        }
      });
      return elements2;
    }
    var core_interaction = {
      modes: {
        single: function(chart, e) {
          var position = getRelativePosition(e, chart);
          var elements2 = [];
          parseVisibleItems(chart, function(element) {
            if (element.inRange(position.x, position.y)) {
              elements2.push(element);
              return elements2;
            }
          });
          return elements2.slice(0, 1);
        },
        label: indexMode,
        index: indexMode,
        dataset: function(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "xy";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }
          return items;
        },
        "x-axis": function(chart, e) {
          return indexMode(chart, e, {intersect: false});
        },
        point: function(chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },
        nearest: function(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "xy";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          return getNearestItems(chart, position, options2.intersect, distanceMetric);
        },
        x: function(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function(element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }
            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          });
          if (options2.intersect && !intersectsItem) {
            items = [];
          }
          return items;
        },
        y: function(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function(element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }
            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          });
          if (options2.intersect && !intersectsItem) {
            items = [];
          }
          return items;
        }
      }
    };
    var extend = helpers$1.extend;
    function filterByPosition(array, position) {
      return helpers$1.where(array, function(v) {
        return v.pos === position;
      });
    }
    function sortByWeight(array, reverse) {
      return array.sort(function(a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
      });
    }
    function wrapBoxes(boxes) {
      var layoutBoxes = [];
      var i, ilen, box;
      for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
        box = boxes[i];
        layoutBoxes.push({
          index: i,
          box,
          pos: box.position,
          horizontal: box.isHorizontal(),
          weight: box.weight
        });
      }
      return layoutBoxes;
    }
    function setLayoutDims(layouts, params) {
      var i, ilen, layout;
      for (i = 0, ilen = layouts.length; i < ilen; ++i) {
        layout = layouts[i];
        layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
        layout.height = layout.horizontal && params.hBoxMaxHeight;
      }
    }
    function buildLayoutBoxes(boxes) {
      var layoutBoxes = wrapBoxes(boxes);
      var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
      var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
      var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
      var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
      return {
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(bottom),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right),
        horizontal: top.concat(bottom)
      };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
    }
    function updateDims(chartArea, params, layout) {
      var box = layout.box;
      var maxPadding = chartArea.maxPadding;
      var newWidth, newHeight;
      if (layout.size) {
        chartArea[layout.pos] -= layout.size;
      }
      layout.size = layout.horizontal ? box.height : box.width;
      chartArea[layout.pos] += layout.size;
      if (box.getPadding) {
        var boxPadding = box.getPadding();
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
      }
      newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
      newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
      if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
        return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
      }
    }
    function handleMaxPadding(chartArea) {
      var maxPadding = chartArea.maxPadding;
      function updatePos(pos) {
        var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
      }
      chartArea.y += updatePos("top");
      chartArea.x += updatePos("left");
      updatePos("right");
      updatePos("bottom");
    }
    function getMargins(horizontal, chartArea) {
      var maxPadding = chartArea.maxPadding;
      function marginForPositions(positions) {
        var margin = {left: 0, top: 0, right: 0, bottom: 0};
        positions.forEach(function(pos) {
          margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
      }
      return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
    }
    function fitBoxes(boxes, chartArea, params) {
      var refitBoxes = [];
      var i, ilen, layout, box, refit, changed;
      for (i = 0, ilen = boxes.length; i < ilen; ++i) {
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        if (updateDims(chartArea, params, layout)) {
          changed = true;
          if (refitBoxes.length) {
            refit = true;
          }
        }
        if (!box.fullWidth) {
          refitBoxes.push(layout);
        }
      }
      return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
    }
    function placeBoxes(boxes, chartArea, params) {
      var userPadding = params.padding;
      var x = chartArea.x;
      var y = chartArea.y;
      var i, ilen, layout, box;
      for (i = 0, ilen = boxes.length; i < ilen; ++i) {
        layout = boxes[i];
        box = layout.box;
        if (layout.horizontal) {
          box.left = box.fullWidth ? userPadding.left : chartArea.left;
          box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
          box.top = y;
          box.bottom = y + box.height;
          box.width = box.right - box.left;
          y = box.bottom;
        } else {
          box.left = x;
          box.right = x + box.width;
          box.top = chartArea.top;
          box.bottom = chartArea.top + chartArea.h;
          box.height = box.bottom - box.top;
          x = box.right;
        }
      }
      chartArea.x = x;
      chartArea.y = y;
    }
    core_defaults._set("global", {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    var core_layouts = {
      defaults: {},
      addBox: function(chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        }
        item.fullWidth = item.fullWidth || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
          return [{
            z: 0,
            draw: function() {
              item.draw.apply(item, arguments);
            }
          }];
        };
        chart.boxes.push(item);
      },
      removeBox: function(chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },
      configure: function(chart, item, options2) {
        var props = ["fullWidth", "position", "weight"];
        var ilen = props.length;
        var i = 0;
        var prop;
        for (; i < ilen; ++i) {
          prop = props[i];
          if (options2.hasOwnProperty(prop)) {
            item[prop] = options2[prop];
          }
        }
      },
      update: function(chart, width, height) {
        if (!chart) {
          return;
        }
        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var availableWidth = width - padding.width;
        var availableHeight = height - padding.height;
        var boxes = buildLayoutBoxes(chart.boxes);
        var verticalBoxes = boxes.vertical;
        var horizontalBoxes = boxes.horizontal;
        var params = Object.freeze({
          outerWidth: width,
          outerHeight: height,
          padding,
          availableWidth,
          vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
          hBoxMaxHeight: availableHeight / 2
        });
        var chartArea = extend({
          maxPadding: extend({}, padding),
          w: availableWidth,
          h: availableHeight,
          x: padding.left,
          y: padding.top
        }, padding);
        setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(verticalBoxes, chartArea, params);
        if (fitBoxes(horizontalBoxes, chartArea, params)) {
          fitBoxes(verticalBoxes, chartArea, params);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params);
        chart.chartArea = {
          left: chartArea.left,
          top: chartArea.top,
          right: chartArea.left + chartArea.w,
          bottom: chartArea.top + chartArea.h
        };
        helpers$1.each(boxes.chartArea, function(layout) {
          var box = layout.box;
          extend(box, chart.chartArea);
          box.update(chartArea.w, chartArea.h);
        });
      }
    };
    var platform_basic = {
      acquireContext: function(item) {
        if (item && item.canvas) {
          item = item.canvas;
        }
        return item && item.getContext("2d") || null;
      }
    };
    var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
    var platform_dom$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      default: platform_dom
    });
    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = "$chartjs";
    var CSS_PREFIX = "chartjs-";
    var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
    var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
    var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
    var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
    var EVENT_TYPES = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    };
    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : void 0;
    }
    function initCanvas(canvas2, config) {
      var style = canvas2.style;
      var renderHeight = canvas2.getAttribute("height");
      var renderWidth = canvas2.getAttribute("width");
      canvas2[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      };
      style.display = style.display || "block";
      if (renderWidth === null || renderWidth === "") {
        var displayWidth = readUsedSize(canvas2, "width");
        if (displayWidth !== void 0) {
          canvas2.width = displayWidth;
        }
      }
      if (renderHeight === null || renderHeight === "") {
        if (canvas2.style.height === "") {
          canvas2.height = canvas2.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas2, "height");
          if (displayWidth !== void 0) {
            canvas2.height = displayHeight;
          }
        }
      }
      return canvas2;
    }
    var supportsEventListenerOptions = function() {
      var supports = false;
      try {
        var options2 = Object.defineProperty({}, "passive", {
          get: function() {
            supports = true;
          }
        });
        window.addEventListener("e", null, options2);
      } catch (e) {
      }
      return supports;
    }();
    var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }
    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type,
        chart,
        native: nativeEvent || null,
        x: x !== void 0 ? x : null,
        y: y !== void 0 ? y : null
      };
    }
    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }
    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function() {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;
        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function() {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }
    function createDiv(cls) {
      var el = document.createElement("div");
      el.className = cls || "";
      return el;
    }
    function createResizer(handler) {
      var maxSize = 1e6;
      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
      var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);
      resizer._reset = function() {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };
      var onScroll = function() {
        resizer._reset();
        handler();
      };
      addListener(expand, "scroll", onScroll.bind(expand, "expand"));
      addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
      return resizer;
    }
    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
      var proxy = expando.renderProxy = function(e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };
      helpers$1.each(ANIMATION_START_EVENTS, function(type) {
        addListener(node, type, proxy);
      });
      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }
    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;
      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function(type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }
      node.classList.remove(CSS_RENDER_MONITOR);
    }
    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
      var resizer = expando.resizer = createResizer(throttled(function() {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent("resize", chart));
          if (container && container.clientWidth < w && chart.canvas) {
            listener(createEvent("resize", chart));
          }
        }
      }));
      watchForRender(node, function() {
        if (expando.resizer) {
          var container = node.parentNode;
          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          }
          resizer._reset();
        }
      });
    }
    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);
      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }
    function injectCSS(rootNode, css) {
      var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
      if (!expando.containsStyles) {
        expando.containsStyles = true;
        css = "/* Chart.js */\n" + css;
        var style = document.createElement("style");
        style.setAttribute("type", "text/css");
        style.appendChild(document.createTextNode(css));
        rootNode.appendChild(style);
      }
    }
    var platform_dom$2 = {
      disableCSSInjection: false,
      _enabled: typeof window !== "undefined" && typeof document !== "undefined",
      _ensureLoaded: function(canvas2) {
        if (!this.disableCSSInjection) {
          var root = canvas2.getRootNode ? canvas2.getRootNode() : document;
          var targetNode = root.host ? root : document.head;
          injectCSS(targetNode, stylesheet);
        }
      },
      acquireContext: function(item, config) {
        if (typeof item === "string") {
          item = document.getElementById(item);
        } else if (item.length) {
          item = item[0];
        }
        if (item && item.canvas) {
          item = item.canvas;
        }
        var context = item && item.getContext && item.getContext("2d");
        if (context && context.canvas === item) {
          this._ensureLoaded(item);
          initCanvas(item, config);
          return context;
        }
        return null;
      },
      releaseContext: function(context) {
        var canvas2 = context.canvas;
        if (!canvas2[EXPANDO_KEY]) {
          return;
        }
        var initial = canvas2[EXPANDO_KEY].initial;
        ["height", "width"].forEach(function(prop) {
          var value = initial[prop];
          if (helpers$1.isNullOrUndef(value)) {
            canvas2.removeAttribute(prop);
          } else {
            canvas2.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function(value, key) {
          canvas2.style[key] = value;
        });
        canvas2.width = canvas2.width;
        delete canvas2[EXPANDO_KEY];
      },
      addEventListener: function(chart, type, listener) {
        var canvas2 = chart.canvas;
        if (type === "resize") {
          addResizeListener(canvas2, listener, chart);
          return;
        }
        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});
        var proxy = proxies[chart.id + "_" + type] = function(event) {
          listener(fromNativeEvent(event, chart));
        };
        addListener(canvas2, type, proxy);
      },
      removeEventListener: function(chart, type, listener) {
        var canvas2 = chart.canvas;
        if (type === "resize") {
          removeResizeListener(canvas2);
          return;
        }
        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + "_" + type];
        if (!proxy) {
          return;
        }
        removeListener(canvas2, type, proxy);
      }
    };
    helpers$1.addEvent = addListener;
    helpers$1.removeEvent = removeListener;
    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    var platform = helpers$1.extend({
      initialize: function() {
      },
      acquireContext: function() {
      },
      releaseContext: function() {
      },
      addEventListener: function() {
      },
      removeEventListener: function() {
      }
    }, implementation);
    core_defaults._set("global", {
      plugins: {}
    });
    var core_plugins = {
      _plugins: [],
      _cacheId: 0,
      register: function(plugins2) {
        var p = this._plugins;
        [].concat(plugins2).forEach(function(plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },
      unregister: function(plugins2) {
        var p = this._plugins;
        [].concat(plugins2).forEach(function(plugin) {
          var idx = p.indexOf(plugin);
          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },
      clear: function() {
        this._plugins = [];
        this._cacheId++;
      },
      count: function() {
        return this._plugins.length;
      },
      getAll: function() {
        return this._plugins;
      },
      notify: function(chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;
        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];
          if (typeof method === "function") {
            params = [chart].concat(args || []);
            params.push(descriptor.options);
            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }
        return true;
      },
      descriptors: function(chart) {
        var cache = chart.$plugins || (chart.$plugins = {});
        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }
        var plugins2 = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options2 = config.options && config.options.plugins || {};
        this._plugins.concat(config.plugins || []).forEach(function(plugin) {
          var idx = plugins2.indexOf(plugin);
          if (idx !== -1) {
            return;
          }
          var id = plugin.id;
          var opts = options2[id];
          if (opts === false) {
            return;
          }
          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }
          plugins2.push(plugin);
          descriptors.push({
            plugin,
            options: opts || {}
          });
        });
        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },
      _invalidate: function(chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      constructors: {},
      defaults: {},
      registerScaleType: function(type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function(type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
      },
      getScaleDefaults: function(type) {
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function(type, additions) {
        var me = this;
        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function(chart) {
        helpers$1.each(chart.scales, function(scale2) {
          scale2.fullWidth = scale2.options.fullWidth;
          scale2.position = scale2.options.position;
          scale2.weight = scale2.options.weight;
          core_layouts.addBox(chart, scale2);
        });
      }
    };
    var valueOrDefault$8 = helpers$1.valueOrDefault;
    var getRtlHelper = helpers$1.rtl.getRtlAdapter;
    core_defaults._set("global", {
      tooltips: {
        enabled: true,
        custom: null,
        mode: "nearest",
        position: "average",
        intersect: true,
        backgroundColor: "rgba(0,0,0,0.8)",
        titleFontStyle: "bold",
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: "#fff",
        titleAlign: "left",
        bodySpacing: 2,
        bodyFontColor: "#fff",
        bodyAlign: "left",
        footerFontStyle: "bold",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: "#fff",
        footerAlign: "left",
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: "#fff",
        displayColors: true,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        callbacks: {
          beforeTitle: helpers$1.noop,
          title: function(tooltipItems, data) {
            var title2 = "";
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;
            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];
              if (item.label) {
                title2 = item.label;
              } else if (item.xLabel) {
                title2 = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title2 = labels[item.index];
              }
            }
            return title2;
          },
          afterTitle: helpers$1.noop,
          beforeBody: helpers$1.noop,
          beforeLabel: helpers$1.noop,
          label: function(tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || "";
            if (label) {
              label += ": ";
            }
            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }
            return label;
          },
          labelColor: function(tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function() {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          afterBody: helpers$1.noop,
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });
    var positioners = {
      average: function(elements2) {
        if (!elements2.length) {
          return false;
        }
        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;
        for (i = 0, len = elements2.length; i < len; ++i) {
          var el = elements2[i];
          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }
        return {
          x: x / count,
          y: y / count
        };
      },
      nearest: function(elements2, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;
        for (i = 0, len = elements2.length; i < len; ++i) {
          var el = elements2[i];
          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);
            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }
        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }
        return {
          x,
          y
        };
      }
    };
    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }
      return base;
    }
    function splitNewlines(str) {
      if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
        return str.split("\n");
      }
      return str;
    }
    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale;
      var index = element._index;
      var datasetIndex = element._datasetIndex;
      var controller = element._chart.getDatasetMeta(datasetIndex).controller;
      var indexScale = controller._getIndexScale();
      var valueScale = controller._getValueScale();
      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
        label: indexScale ? "" + indexScale.getLabelForIndex(index, datasetIndex) : "",
        value: valueScale ? "" + valueScale.getLabelForIndex(index, datasetIndex) : "",
        index,
        datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        rtl: tooltipOpts.rtl,
        textDirection: tooltipOpts.textDirection,
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2;
      var width = 0;
      var body = model.body;
      var combinedBodyLength = body.reduce(function(count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize;
      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
      height += titleLineCount ? model.titleMarginBottom : 0;
      height += combinedBodyLength * bodyFontSize;
      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
      height += footerLineCount ? model.footerMarginTop : 0;
      height += footerLineCount * footerFontSize;
      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
      var widthPadding = 0;
      var maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth);
      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function(bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth);
      width += 2 * model.xPadding;
      return {
        width,
        height
      };
    }
    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = "center";
      var yAlign = "center";
      if (model.y < size.height) {
        yAlign = "top";
      } else if (model.y > chart.height - size.height) {
        yAlign = "bottom";
      }
      var lf, rf;
      var olf, orf;
      var yf;
      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;
      if (yAlign === "center") {
        lf = function(x) {
          return x <= midX;
        };
        rf = function(x) {
          return x > midX;
        };
      } else {
        lf = function(x) {
          return x <= size.width / 2;
        };
        rf = function(x) {
          return x >= chart.width - size.width / 2;
        };
      }
      olf = function(x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };
      orf = function(x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };
      yf = function(y) {
        return y <= midY ? "top" : "bottom";
      };
      if (lf(model.x)) {
        xAlign = "left";
        if (olf(model.x)) {
          xAlign = "center";
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = "right";
        if (orf(model.x)) {
          xAlign = "center";
          yAlign = yf(model.y);
        }
      }
      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    function getBackgroundPoint(vm, size, alignment, chart) {
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;
      if (xAlign === "right") {
        x -= size.width;
      } else if (xAlign === "center") {
        x -= size.width / 2;
        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }
        if (x < 0) {
          x = 0;
        }
      }
      if (yAlign === "top") {
        y += paddingAndSize;
      } else if (yAlign === "bottom") {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }
      if (yAlign === "center") {
        if (xAlign === "left") {
          x += paddingAndSize;
        } else if (xAlign === "right") {
          x -= paddingAndSize;
        }
      } else if (xAlign === "left") {
        x -= radiusAndPadding;
      } else if (xAlign === "right") {
        x += radiusAndPadding;
      }
      return {
        x,
        y
      };
    }
    function getAlignedX(vm, align) {
      return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }
    var exports$4 = core_element.extend({
      initialize: function() {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      getTitle: function() {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title2 = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title2));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      getBeforeBody: function() {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      getBody: function(tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function(tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      getAfterBody: function() {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      getFooter: function() {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function(changed) {
        var me = this;
        var opts = me._options;
        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data;
        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;
        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];
          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          }
          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function(a) {
              return opts.filter(a, data);
            });
          }
          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function(a, b) {
              return opts.itemSort(a, b, data);
            });
          }
          helpers$1.each(tooltipItems, function(tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          });
          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data);
          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors;
          model.dataPoints = tooltipItems;
          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize);
          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }
        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height;
        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;
        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }
        return me;
      },
      drawCaret: function(tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function(tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;
        if (yAlign === "center") {
          y2 = ptY + height / 2;
          if (xAlign === "left") {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === "left") {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === "right") {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }
          if (yAlign === "top") {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1;
            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }
        return {x1, x2, x3, y1, y2, y3};
      },
      drawTitle: function(pt, vm, ctx) {
        var title2 = vm.title;
        var length = title2.length;
        var titleFontSize, titleSpacing, i;
        if (length) {
          var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
          ctx.textBaseline = "middle";
          titleFontSize = vm.titleFontSize;
          titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          for (i = 0; i < length; ++i) {
            ctx.fillText(title2[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
            pt.y += titleFontSize + titleSpacing;
            if (i + 1 === length) {
              pt.y += vm.titleMarginBottom - titleSpacing;
            }
          }
        }
      },
      drawBody: function(pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
        var fillLineOfText = function(line) {
          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
          pt.y += bodyFontSize + bodySpacing;
        };
        var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
        var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlignForCalculation);
        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
        for (i = 0, ilen = body.length; i < ilen; ++i) {
          bodyItem = body[i];
          textColor = vm.labelTextColors[i];
          labelColors = vm.labelColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          lines = bodyItem.lines;
          for (j = 0, jlen = lines.length; j < jlen; ++j) {
            if (drawColorBoxes) {
              var rtlColorX = rtlHelper.x(colorX);
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }
            fillLineOfText(lines[j]);
          }
          helpers$1.each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
      },
      drawFooter: function(pt, vm, ctx) {
        var footer = vm.footer;
        var length = footer.length;
        var footerFontSize, i;
        if (length) {
          var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
          ctx.textBaseline = "middle";
          footerFontSize = vm.footerFontSize;
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          for (i = 0; i < length; ++i) {
            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
            pt.y += footerFontSize + vm.footerSpacing;
          }
        }
      },
      drawBackground: function(pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        if (yAlign === "top") {
          this.drawCaret(pt, tooltipSize);
        }
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        if (yAlign === "center" && xAlign === "right") {
          this.drawCaret(pt, tooltipSize);
        }
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        if (yAlign === "bottom") {
          this.drawCaret(pt, tooltipSize);
        }
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        if (yAlign === "center" && xAlign === "left") {
          this.drawCaret(pt, tooltipSize);
        }
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function() {
        var ctx = this._chart.ctx;
        var vm = this._view;
        if (vm.opacity === 0) {
          return;
        }
        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        };
        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity;
          this.drawBackground(pt, vm, ctx, tooltipSize);
          pt.y += vm.yPadding;
          helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
          this.drawTitle(pt, vm, ctx);
          this.drawBody(pt, vm, ctx);
          this.drawFooter(pt, vm, ctx);
          helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
          ctx.restore();
        }
      },
      handleEvent: function(e) {
        var me = this;
        var options2 = me._options;
        var changed = false;
        me._lastActive = me._lastActive || [];
        if (e.type === "mouseout") {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options2.mode, options2);
          if (options2.reverse) {
            me._active.reverse();
          }
        }
        changed = !helpers$1.arrayEquals(me._active, me._lastActive);
        if (changed) {
          me._lastActive = me._active;
          if (options2.enabled || options2.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }
        return changed;
      }
    });
    var positioners_1 = positioners;
    var core_tooltip = exports$4;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    core_defaults._set("global", {
      elements: {},
      events: [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ],
      hover: {
        onHover: null,
        mode: "nearest",
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    function mergeScaleConfig() {
      return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
        merger: function(key, target, source, options2) {
          if (key === "xAxes" || key === "yAxes") {
            var slen = source[key].length;
            var i, type, scale2;
            if (!target[key]) {
              target[key] = [];
            }
            for (i = 0; i < slen; ++i) {
              scale2 = source[key][i];
              type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
              if (i >= target[key].length) {
                target[key].push({});
              }
              if (!target[key][i].type || scale2.type && scale2.type !== target[key][i].type) {
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale2]);
              } else {
                helpers$1.merge(target[key][i], scale2);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options2);
          }
        }
      });
    }
    function mergeConfig() {
      return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
        merger: function(key, target, source, options2) {
          var tval = target[key] || Object.create(null);
          var sval = source[key];
          if (key === "scales") {
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === "scale") {
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options2);
          }
        }
      });
    }
    function initConfig(config) {
      config = config || Object.create(null);
      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }
    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function(scale2) {
        core_layouts.removeBox(chart, scale2);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales();
      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }
    function nextAvailableScaleId(axesOpts, prefix, index) {
      var id;
      var hasId = function(obj) {
        return obj.id === id;
      };
      do {
        id = prefix + index++;
      } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
      return id;
    }
    function positionIsHorizontal(position) {
      return position === "top" || position === "bottom";
    }
    function compare2Level(l1, l2) {
      return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
      };
    }
    var Chart = function(item, config) {
      this.construct(item, config);
      return this;
    };
    helpers$1.extend(Chart.prototype, {
      construct: function(item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas2 = context && context.canvas;
        var height = canvas2 && canvas2.height;
        var width = canvas2 && canvas2.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas2;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        me._layers = [];
        me.chart = me;
        me.controller = me;
        Chart.instances[me.id] = me;
        Object.defineProperty(me, "data", {
          get: function() {
            return me.config.data;
          },
          set: function(value) {
            me.config.data = value;
          }
        });
        if (!context || !canvas2) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        me.initialize();
        me.update();
      },
      initialize: function() {
        var me = this;
        core_plugins.notify(me, "beforeInit");
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();
        if (me.options.responsive) {
          me.resize(true);
        }
        me.initToolTip();
        core_plugins.notify(me, "afterInit");
        return me;
      },
      clear: function() {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function() {
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function(silent) {
        var me = this;
        var options2 = me.options;
        var canvas2 = me.canvas;
        var aspectRatio = options2.maintainAspectRatio && me.aspectRatio || null;
        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas2)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas2)));
        if (me.width === newWidth && me.height === newHeight) {
          return;
        }
        canvas2.width = me.width = newWidth;
        canvas2.height = me.height = newHeight;
        canvas2.style.width = newWidth + "px";
        canvas2.style.height = newHeight + "px";
        helpers$1.retinaScale(me, options2.devicePixelRatio);
        if (!silent) {
          var newSize = {width: newWidth, height: newHeight};
          core_plugins.notify(me, "resize", [newSize]);
          if (options2.onResize) {
            options2.onResize(me, newSize);
          }
          me.stop();
          me.update({
            duration: options2.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function() {
        var options2 = this.options;
        var scalesOptions = options2.scales || {};
        var scaleOptions = options2.scale;
        helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {
          if (!xAxisOptions.id) {
            xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index);
          }
        });
        helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {
          if (!yAxisOptions.id) {
            yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index);
          }
        });
        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || "scale";
        }
      },
      buildOrUpdateScales: function() {
        var me = this;
        var options2 = me.options;
        var scales2 = me.scales || {};
        var items = [];
        var updated = Object.keys(scales2).reduce(function(obj, id) {
          obj[id] = false;
          return obj;
        }, {});
        if (options2.scales) {
          items = items.concat((options2.scales.xAxes || []).map(function(xAxisOptions) {
            return {options: xAxisOptions, dtype: "category", dposition: "bottom"};
          }), (options2.scales.yAxes || []).map(function(yAxisOptions) {
            return {options: yAxisOptions, dtype: "linear", dposition: "left"};
          }));
        }
        if (options2.scale) {
          items.push({
            options: options2.scale,
            dtype: "radialLinear",
            isDefault: true,
            dposition: "chartArea"
          });
        }
        helpers$1.each(items, function(item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }
          updated[id] = true;
          var scale2 = null;
          if (id in scales2 && scales2[id].type === scaleType) {
            scale2 = scales2[id];
            scale2.options = scaleOptions;
            scale2.ctx = me.ctx;
            scale2.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);
            if (!scaleClass) {
              return;
            }
            scale2 = new scaleClass({
              id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales2[scale2.id] = scale2;
          }
          scale2.mergeTicksOptions();
          if (item.isDefault) {
            me.scale = scale2;
          }
        });
        helpers$1.each(updated, function(hasUpdated, id) {
          if (!hasUpdated) {
            delete scales2[id];
          }
        });
        me.scales = scales2;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function() {
        var me = this;
        var newControllers = [];
        var datasets = me.data.datasets;
        var i, ilen;
        for (i = 0, ilen = datasets.length; i < ilen; i++) {
          var dataset = datasets[i];
          var meta = me.getDatasetMeta(i);
          var type = dataset.type || me.config.type;
          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(i);
            meta = me.getDatasetMeta(i);
          }
          meta.type = type;
          meta.order = dataset.order || 0;
          meta.index = i;
          if (meta.controller) {
            meta.controller.updateIndex(i);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];
            if (ControllerClass === void 0) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }
            meta.controller = new ControllerClass(me, i);
            newControllers.push(meta.controller);
          }
        }
        return newControllers;
      },
      resetElements: function() {
        var me = this;
        helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },
      reset: function() {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function(config) {
        var me = this;
        var i, ilen;
        if (!config || typeof config !== "object") {
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }
        updateConfig(me);
        core_plugins._invalidate(me);
        if (core_plugins.notify(me, "beforeUpdate") === false) {
          return;
        }
        me.tooltip._data = me.data;
        var newControllers = me.buildOrUpdateControllers();
        for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
          me.getDatasetMeta(i).controller.buildOrUpdateElements();
        }
        me.updateLayout();
        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function(controller) {
            controller.reset();
          });
        }
        me.updateDatasets();
        me.tooltip.initialize();
        me.lastActive = [];
        core_plugins.notify(me, "afterUpdate");
        me._layers.sort(compare2Level("z", "_idx"));
        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },
      updateLayout: function() {
        var me = this;
        if (core_plugins.notify(me, "beforeLayout") === false) {
          return;
        }
        core_layouts.update(this, this.width, this.height);
        me._layers = [];
        helpers$1.each(me.boxes, function(box) {
          if (box._configure) {
            box._configure();
          }
          me._layers.push.apply(me._layers, box._layers());
        }, me);
        me._layers.forEach(function(item, index) {
          item._idx = index;
        });
        core_plugins.notify(me, "afterScaleUpdate");
        core_plugins.notify(me, "afterLayout");
      },
      updateDatasets: function() {
        var me = this;
        if (core_plugins.notify(me, "beforeDatasetsUpdate") === false) {
          return;
        }
        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }
        core_plugins.notify(me, "afterDatasetsUpdate");
      },
      updateDataset: function(index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta,
          index
        };
        if (core_plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
          return;
        }
        meta.controller._update();
        core_plugins.notify(me, "afterDatasetUpdate", [args]);
      },
      render: function(config) {
        var me = this;
        if (!config || typeof config !== "object") {
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }
        var animationOptions = me.options.animation;
        var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;
        if (core_plugins.notify(me, "beforeRender") === false) {
          return;
        }
        var onComplete = function(animation2) {
          core_plugins.notify(me, "afterRender");
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me);
        };
        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            easing: config.easing || animationOptions.easing,
            render: function(chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw();
          onComplete(new core_animation({numSteps: 0, chart: me}));
        }
        return me;
      },
      draw: function(easingValue) {
        var me = this;
        var i, layers;
        me.clear();
        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }
        me.transition(easingValue);
        if (me.width <= 0 || me.height <= 0) {
          return;
        }
        if (core_plugins.notify(me, "beforeDraw", [easingValue]) === false) {
          return;
        }
        layers = me._layers;
        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
          layers[i].draw(me.chartArea);
        }
        me.drawDatasets(easingValue);
        for (; i < layers.length; ++i) {
          layers[i].draw(me.chartArea);
        }
        me._drawTooltip(easingValue);
        core_plugins.notify(me, "afterDraw", [easingValue]);
      },
      transition: function(easingValue) {
        var me = this;
        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }
        me.tooltip.transition(easingValue);
      },
      _getSortedDatasetMetas: function(filterVisible) {
        var me = this;
        var datasets = me.data.datasets || [];
        var result = [];
        var i, ilen;
        for (i = 0, ilen = datasets.length; i < ilen; ++i) {
          if (!filterVisible || me.isDatasetVisible(i)) {
            result.push(me.getDatasetMeta(i));
          }
        }
        result.sort(compare2Level("order", "index"));
        return result;
      },
      _getSortedVisibleDatasetMetas: function() {
        return this._getSortedDatasetMetas(true);
      },
      drawDatasets: function(easingValue) {
        var me = this;
        var metasets, i;
        if (core_plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
          return;
        }
        metasets = me._getSortedVisibleDatasetMetas();
        for (i = metasets.length - 1; i >= 0; --i) {
          me.drawDataset(metasets[i], easingValue);
        }
        core_plugins.notify(me, "afterDatasetsDraw", [easingValue]);
      },
      drawDataset: function(meta, easingValue) {
        var me = this;
        var args = {
          meta,
          index: meta.index,
          easingValue
        };
        if (core_plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
          return;
        }
        meta.controller.draw(easingValue);
        core_plugins.notify(me, "afterDatasetDraw", [args]);
      },
      _drawTooltip: function(easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip,
          easingValue
        };
        if (core_plugins.notify(me, "beforeTooltipDraw", [args]) === false) {
          return;
        }
        tooltip.draw();
        core_plugins.notify(me, "afterTooltipDraw", [args]);
      },
      getElementAtEvent: function(e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function(e) {
        return core_interaction.modes.label(this, e, {intersect: true});
      },
      getElementsAtXAxis: function(e) {
        return core_interaction.modes["x-axis"](this, e, {intersect: true});
      },
      getElementsAtEventForMode: function(e, mode, options2) {
        var method = core_interaction.modes[mode];
        if (typeof method === "function") {
          return method(this, e, options2);
        }
        return [];
      },
      getDatasetAtEvent: function(e) {
        return core_interaction.modes.dataset(this, e, {intersect: true});
      },
      getDatasetMeta: function(datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];
        if (!dataset._meta) {
          dataset._meta = {};
        }
        var meta = dataset._meta[me.id];
        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: dataset.order || 0,
            index: datasetIndex
          };
        }
        return meta;
      },
      getVisibleDatasetCount: function() {
        var count = 0;
        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }
        return count;
      },
      isDatasetVisible: function(datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function() {
        return this.options.legendCallback(this);
      },
      destroyDatasetMeta: function(datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];
        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function() {
        var me = this;
        var canvas2 = me.canvas;
        var i, ilen;
        me.stop();
        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }
        if (canvas2) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }
        core_plugins.notify(me, "destroy");
        delete Chart.instances[me.id];
      },
      toBase64Image: function() {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function() {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },
      bindEvents: function() {
        var me = this;
        var listeners = me._listeners = {};
        var listener = function() {
          me.eventHandler.apply(me, arguments);
        };
        helpers$1.each(me.options.events, function(type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        });
        if (me.options.responsive) {
          listener = function() {
            me.resize();
          };
          platform.addEventListener(me, "resize", listener);
          listeners.resize = listener;
        }
      },
      unbindEvents: function() {
        var me = this;
        var listeners = me._listeners;
        if (!listeners) {
          return;
        }
        delete me._listeners;
        helpers$1.each(listeners, function(listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function(elements2, mode, enabled) {
        var prefix = enabled ? "set" : "remove";
        var element, i, ilen;
        for (i = 0, ilen = elements2.length; i < ilen; ++i) {
          element = elements2[i];
          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
          }
        }
        if (mode === "dataset") {
          this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
        }
      },
      eventHandler: function(e) {
        var me = this;
        var tooltip = me.tooltip;
        if (core_plugins.notify(me, "beforeEvent", [e]) === false) {
          return;
        }
        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e);
        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }
        core_plugins.notify(me, "afterEvent", [e]);
        var bufferedRequest = me._bufferedRequest;
        if (bufferedRequest) {
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          me.stop();
          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }
        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },
      handleEvent: function(e) {
        var me = this;
        var options2 = me.options || {};
        var hoverOptions = options2.hover;
        var changed = false;
        me.lastActive = me.lastActive || [];
        if (e.type === "mouseout") {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        }
        helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me.active], me);
        if (e.type === "mouseup" || e.type === "click") {
          if (options2.onClick) {
            options2.onClick.call(me, e.native, me.active);
          }
        }
        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        }
        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }
        changed = !helpers$1.arrayEquals(me.active, me.lastActive);
        me.lastActive = me.active;
        return changed;
      }
    });
    Chart.instances = {};
    var core_controller = Chart;
    Chart.Controller = Chart;
    Chart.types = {};
    helpers$1.configMerge = mergeConfig;
    helpers$1.scaleMerge = mergeScaleConfig;
    var core_helpers = function() {
      helpers$1.where = function(collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }
        var filtered = [];
        helpers$1.each(collection, function(item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };
      helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function(array, callback, scope) {
        scope = scope === void 0 ? array : scope;
        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }
        return -1;
      };
      helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }
        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];
          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };
      helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }
        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];
          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };
      helpers$1.isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };
      helpers$1.almostEquals = function(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };
      helpers$1.almostWhole = function(x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
      };
      helpers$1.max = function(array) {
        return array.reduce(function(max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }
          return max;
        }, Number.NEGATIVE_INFINITY);
      };
      helpers$1.min = function(array) {
        return array.reduce(function(min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }
          return min;
        }, Number.POSITIVE_INFINITY);
      };
      helpers$1.sign = Math.sign ? function(x) {
        return Math.sign(x);
      } : function(x) {
        x = +x;
        if (x === 0 || isNaN(x)) {
          return x;
        }
        return x > 0 ? 1 : -1;
      };
      helpers$1.toRadians = function(degrees) {
        return degrees * (Math.PI / 180);
      };
      helpers$1.toDegrees = function(radians) {
        return radians * (180 / Math.PI);
      };
      helpers$1._decimalPlaces = function(x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }
        var e = 1;
        var p = 0;
        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }
        return p;
      };
      helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * Math.PI) {
          angle += 2 * Math.PI;
        }
        return {
          angle,
          distance: radialDistanceFromCenter
        };
      };
      helpers$1.distanceBetweenPoints = function(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      helpers$1.aliasPixel = function(pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      helpers$1._alignPixel = function(chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };
      helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01;
        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };
      helpers$1.EPSILON = Number.EPSILON || 1e-14;
      helpers$1.splineCurveMonotone = function(points) {
        var pointsWithTangents = (points || []).map(function(point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        });
        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;
        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];
          if (pointCurrent.model.skip) {
            continue;
          }
          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }
          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        }
        var alphaK, betaK, tauK, squaredMagnitude;
        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];
          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }
          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }
          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
            continue;
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        }
        var deltaX;
        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];
          if (pointCurrent.model.skip) {
            continue;
          }
          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }
          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };
      helpers$1.nextItem = function(collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }
        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };
      helpers$1.previousItem = function(collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }
        return index <= 0 ? collection[0] : collection[index - 1];
      };
      helpers$1.niceNum = function(range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;
        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }
        return niceFraction * Math.pow(10, exponent);
      };
      helpers$1.requestAnimFrame = function() {
        if (typeof window === "undefined") {
          return function(callback) {
            callback();
          };
        }
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
          return window.setTimeout(callback, 1e3 / 60);
        };
      }();
      helpers$1.getRelativePosition = function(evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas2 = evt.target || evt.srcElement;
        var boundingRect = canvas2.getBoundingClientRect();
        var touches = e.touches;
        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }
        var paddingLeft = parseFloat(helpers$1.getStyle(canvas2, "padding-left"));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas2, "padding-top"));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas2, "padding-right"));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas2, "padding-bottom"));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas2.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas2.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      };
      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;
        if (typeof styleValue === "string") {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf("%") !== -1) {
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }
        return valueInPixels;
      }
      function isConstrainedValue(value) {
        return value !== void 0 && value !== null && value !== "none";
      }
      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;
        var parentNode = helpers$1._getParentNode(domNode);
        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;
        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }
        return "none";
      }
      helpers$1.getConstraintWidth = function(domNode) {
        return getConstraintDimension(domNode, "max-width", "clientWidth");
      };
      helpers$1.getConstraintHeight = function(domNode) {
        return getConstraintDimension(domNode, "max-height", "clientHeight");
      };
      helpers$1._calculatePadding = function(container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      helpers$1._getParentNode = function(domNode) {
        var parent = domNode.parentNode;
        if (parent && parent.toString() === "[object ShadowRoot]") {
          parent = parent.host;
        }
        return parent;
      };
      helpers$1.getMaximumWidth = function(domNode) {
        var container = helpers$1._getParentNode(domNode);
        if (!container) {
          return domNode.clientWidth;
        }
        var clientWidth = container.clientWidth;
        var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
        var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };
      helpers$1.getMaximumHeight = function(domNode) {
        var container = helpers$1._getParentNode(domNode);
        if (!container) {
          return domNode.clientHeight;
        }
        var clientHeight = container.clientHeight;
        var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
        var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };
      helpers$1.getStyle = function(el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };
      helpers$1.retinaScale = function(chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
        if (pixelRatio === 1) {
          return;
        }
        var canvas2 = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas2.height = height * pixelRatio;
        canvas2.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio);
        if (!canvas2.style.height && !canvas2.style.width) {
          canvas2.style.height = height + "px";
          canvas2.style.width = width + "px";
        }
      };
      helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
        return fontStyle + " " + pixelSize + "px " + fontFamily;
      };
      helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }
        ctx.font = font;
        var longest = 0;
        var ilen = arrayOfThings.length;
        var i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++) {
          thing = arrayOfThings[i];
          if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            for (j = 0, jlen = thing.length; j < jlen; j++) {
              nestedThing = thing[j];
              if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            }
          }
        }
        var gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
          for (i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
        return longest;
      };
      helpers$1.measureText = function(ctx, data, gc, longest, string) {
        var textWidth = data[string];
        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }
        if (textWidth > longest) {
          longest = textWidth;
        }
        return longest;
      };
      helpers$1.numberOfLabelLines = function(arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function(thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };
      helpers$1.color = !chartjsColor ? function(value) {
        console.error("Color.js not found!");
        return value;
      } : function(value) {
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }
        return chartjsColor(value);
      };
      helpers$1.getHoverColor = function(colorValue) {
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };
    function abstract() {
      throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.");
    }
    function DateAdapter(options2) {
      this.options = options2 || {};
    }
    helpers$1.extend(DateAdapter.prototype, {
      formats: abstract,
      parse: abstract,
      format: abstract,
      add: abstract,
      diff: abstract,
      startOf: abstract,
      endOf: abstract,
      _create: function(value) {
        return value;
      }
    });
    DateAdapter.override = function(members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };
    var _date = DateAdapter;
    var core_adapters = {
      _date
    };
    var core_ticks = {
      formatters: {
        values: function(value) {
          return helpers$1.isArray(value) ? value : "" + value;
        },
        linear: function(tickValue, index, ticks) {
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              delta = tickValue - Math.floor(tickValue);
            }
          }
          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = "";
          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
            if (maxTick < 1e-4) {
              var logTick = helpers$1.log10(Math.abs(tickValue));
              var numExponential = Math.floor(logTick) - Math.floor(logDelta);
              numExponential = Math.max(Math.min(numExponential, 20), 0);
              tickString = tickValue.toExponential(numExponential);
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0);
              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = "0";
          }
          return tickString;
        },
        logarithmic: function(tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
          if (tickValue === 0) {
            return "0";
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }
          return "";
        }
      }
    };
    var isArray = helpers$1.isArray;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
    core_defaults._set("scale", {
      display: true,
      position: "left",
      offset: false,
      gridLines: {
        display: true,
        color: "rgba(0,0,0,0.1)",
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: "rgba(0,0,0,0.25)",
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0
      },
      scaleLabel: {
        display: false,
        labelString: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });
    function sample(arr, numItems) {
      var result = [];
      var increment = arr.length / numItems;
      var i = 0;
      var len = arr.length;
      for (; i < len; i += increment) {
        result.push(arr[Math.floor(i)]);
      }
      return result;
    }
    function getPixelForGridLine(scale2, index, offsetGridLines) {
      var length = scale2.getTicks().length;
      var validIndex = Math.min(index, length - 1);
      var lineValue = scale2.getPixelForTick(validIndex);
      var start = scale2._startPixel;
      var end = scale2._endPixel;
      var epsilon = 1e-6;
      var offset;
      if (offsetGridLines) {
        if (length === 1) {
          offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
          offset = (scale2.getPixelForTick(1) - lineValue) / 2;
        } else {
          offset = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
          return;
        }
      }
      return lineValue;
    }
    function garbageCollect(caches, length) {
      helpers$1.each(caches, function(cache) {
        var gc = cache.gc;
        var gcLen = gc.length / 2;
        var i;
        if (gcLen > length) {
          for (i = 0; i < gcLen; ++i) {
            delete cache.data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
      });
    }
    function computeLabelSizes(ctx, tickFonts, ticks, caches) {
      var length = ticks.length;
      var widths = [];
      var heights = [];
      var offsets = [];
      var widestLabelSize = 0;
      var highestLabelSize = 0;
      var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
      for (i = 0; i < length; ++i) {
        label = ticks[i].label;
        tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        offsets.push(lineHeight / 2);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      widest = widths.indexOf(widestLabelSize);
      highest = heights.indexOf(highestLabelSize);
      function valueAt(idx) {
        return {
          width: widths[idx] || 0,
          height: heights[idx] || 0,
          offset: offsets[idx] || 0
        };
      }
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest)
      };
    }
    function getTickMarkLength(options2) {
      return options2.drawTicks ? options2.tickMarkLength : 0;
    }
    function getScaleLabelHeight(options2) {
      var font, padding;
      if (!options2.display) {
        return 0;
      }
      font = helpers$1.options._parseFont(options2);
      padding = helpers$1.options.toPadding(options2.padding);
      return font.lineHeight + padding.height;
    }
    function parseFontOptions(options2, nestedOpts) {
      return helpers$1.extend(helpers$1.options._parseFont({
        fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
        fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
        fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
        lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
      }), {
        color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
      });
    }
    function parseTickFontOptions(options2) {
      var minor = parseFontOptions(options2, options2.minor);
      var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
      return {minor, major};
    }
    function nonSkipped(ticksToFilter) {
      var filtered = [];
      var item, index, len;
      for (index = 0, len = ticksToFilter.length; index < len; ++index) {
        item = ticksToFilter[index];
        if (typeof item._index !== "undefined") {
          filtered.push(item);
        }
      }
      return filtered;
    }
    function getEvenSpacing(arr) {
      var len = arr.length;
      var i, diff;
      if (len < 2) {
        return false;
      }
      for (diff = arr[0], i = 1; i < len; ++i) {
        if (arr[i] - arr[i - 1] !== diff) {
          return false;
        }
      }
      return diff;
    }
    function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
      var evenMajorSpacing = getEvenSpacing(majorIndices);
      var spacing = (ticks.length - 1) / ticksLimit;
      var factors, factor, i, ilen;
      if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
      }
      factors = helpers$1.math._factorize(evenMajorSpacing);
      for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
        factor = factors[i];
        if (factor > spacing) {
          return factor;
        }
      }
      return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
      var result = [];
      var i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (ticks[i].major) {
          result.push(i);
        }
      }
      return result;
    }
    function skipMajors(ticks, majorIndices, spacing) {
      var count = 0;
      var next = majorIndices[0];
      var i, tick;
      spacing = Math.ceil(spacing);
      for (i = 0; i < ticks.length; i++) {
        tick = ticks[i];
        if (i === next) {
          tick._index = i;
          count++;
          next = majorIndices[count * spacing];
        } else {
          delete tick.label;
        }
      }
    }
    function skip(ticks, spacing, majorStart, majorEnd) {
      var start = valueOrDefault$a(majorStart, 0);
      var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
      var count = 0;
      var length, i, tick, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
      }
      next = start;
      while (next < 0) {
        count++;
        next = Math.round(start + count * spacing);
      }
      for (i = Math.max(start, 0); i < end; i++) {
        tick = ticks[i];
        if (i === next) {
          tick._index = i;
          count++;
          next = Math.round(start + count * spacing);
        } else {
          delete tick.label;
        }
      }
    }
    var Scale = core_element.extend({
      zeroLineIndex: 0,
      getPadding: function() {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },
      getTicks: function() {
        return this._ticks;
      },
      _getLabels: function() {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      },
      mergeTicksOptions: function() {
      },
      beforeUpdate: function() {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function(maxWidth, maxHeight, margins) {
        var me = this;
        var tickOpts = me.options.ticks;
        var sampleSize = tickOpts.sampleSize;
        var i, ilen, labels, ticks, samplingEnabled;
        me.beforeUpdate();
        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._ticks = null;
        me.ticks = null;
        me._labelSizes = null;
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {};
        me._gridLineItems = null;
        me._labelItems = null;
        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions();
        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits();
        me.beforeBuildTicks();
        ticks = me.buildTicks() || [];
        ticks = me.afterBuildTicks(ticks) || ticks;
        if ((!ticks || !ticks.length) && me.ticks) {
          ticks = [];
          for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
            ticks.push({
              value: me.ticks[i],
              major: false
            });
          }
        }
        me._ticks = ticks;
        samplingEnabled = sampleSize < ticks.length;
        labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
        me._configure();
        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation();
        me.beforeFit();
        me.fit();
        me.afterFit();
        me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me._autoSkip(ticks) : ticks;
        if (samplingEnabled) {
          labels = me._convertTicksToLabels(me._ticksToDraw);
        }
        me.ticks = labels;
        me.afterUpdate();
        return me.minSize;
      },
      _configure: function() {
        var me = this;
        var reversePixels = me.options.ticks.reverse;
        var startPixel, endPixel;
        if (me.isHorizontal()) {
          startPixel = me.left;
          endPixel = me.right;
        } else {
          startPixel = me.top;
          endPixel = me.bottom;
          reversePixels = !reversePixels;
        }
        me._startPixel = startPixel;
        me._endPixel = endPixel;
        me._reversePixels = reversePixels;
        me._length = endPixel - startPixel;
      },
      afterUpdate: function() {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      beforeSetDimensions: function() {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function() {
        var me = this;
        if (me.isHorizontal()) {
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight;
          me.top = 0;
          me.bottom = me.height;
        }
        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function() {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      beforeDataLimits: function() {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function() {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      beforeBuildTicks: function() {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function(ticks) {
        var me = this;
        if (isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        }
        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function() {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function() {
        var me = this;
        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function() {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      beforeCalculateTickRotation: function() {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function() {
        var me = this;
        var options2 = me.options;
        var tickOpts = options2.ticks;
        var numTicks = me.getTicks().length;
        var minRotation = tickOpts.minRotation || 0;
        var maxRotation = tickOpts.maxRotation;
        var labelRotation = minRotation;
        var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
        if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
          me.labelRotation = minRotation;
          return;
        }
        labelSizes = me._getLabelSizes();
        maxLabelWidth = labelSizes.widest.width;
        maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
        maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
        tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
          tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
          maxHeight = me.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
          labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function() {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      beforeFit: function() {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function() {
        var me = this;
        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var chart = me.chart;
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;
        var display = me._isVisible();
        var isBottom = opts.position === "bottom";
        var isHorizontal = me.isHorizontal();
        if (isHorizontal) {
          minSize.width = me.maxWidth;
        } else if (display) {
          minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
        }
        if (!isHorizontal) {
          minSize.height = me.maxHeight;
        } else if (display) {
          minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
        }
        if (tickOpts.display && display) {
          var tickFonts = parseTickFontOptions(tickOpts);
          var labelSizes = me._getLabelSizes();
          var firstLabelSize = labelSizes.first;
          var lastLabelSize = labelSizes.last;
          var widestLabelSize = labelSizes.widest;
          var highestLabelSize = labelSizes.highest;
          var lineSpace = tickFonts.minor.lineHeight * 0.4;
          var tickPadding = tickOpts.padding;
          if (isHorizontal) {
            var isRotated = me.labelRotation !== 0;
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians);
            var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
            var paddingLeft, paddingRight;
            if (isRotated) {
              paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
              paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
            } else {
              paddingLeft = firstLabelSize.width / 2;
              paddingRight = lastLabelSize.width / 2;
            }
            me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
            me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
          } else {
            var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
            minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
            me.paddingTop = firstLabelSize.height / 2;
            me.paddingBottom = lastLabelSize.height / 2;
          }
        }
        me.handleMargins();
        if (isHorizontal) {
          me.width = me._length = chart.width - me.margins.left - me.margins.right;
          me.height = minSize.height;
        } else {
          me.width = minSize.width;
          me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
        }
      },
      handleMargins: function() {
        var me = this;
        if (me.margins) {
          me.margins.left = Math.max(me.paddingLeft, me.margins.left);
          me.margins.top = Math.max(me.paddingTop, me.margins.top);
          me.margins.right = Math.max(me.paddingRight, me.margins.right);
          me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
        }
      },
      afterFit: function() {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      isHorizontal: function() {
        var pos = this.options.position;
        return pos === "top" || pos === "bottom";
      },
      isFullWidth: function() {
        return this.options.fullWidth;
      },
      getRightValue: function(rawValue) {
        if (isNullOrUndef(rawValue)) {
          return NaN;
        }
        if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        }
        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== void 0) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== void 0) {
            return this.getRightValue(rawValue.y);
          }
        }
        return rawValue;
      },
      _convertTicksToLabels: function(ticks) {
        var me = this;
        var labels, i, ilen;
        me.ticks = ticks.map(function(tick) {
          return tick.value;
        });
        me.beforeTickToLabelConversion();
        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          ticks[i].label = labels[i];
        }
        return labels;
      },
      _getLabelSizes: function() {
        var me = this;
        var labelSizes = me._labelSizes;
        if (!labelSizes) {
          me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
          me.longestLabelWidth = labelSizes.widest.width;
        }
        return labelSizes;
      },
      _parseValue: function(value) {
        var start, end, min, max;
        if (isArray(value)) {
          start = +this.getRightValue(value[0]);
          end = +this.getRightValue(value[1]);
          min = Math.min(start, end);
          max = Math.max(start, end);
        } else {
          value = +this.getRightValue(value);
          start = void 0;
          end = value;
          min = value;
          max = value;
        }
        return {
          min,
          max,
          start,
          end
        };
      },
      _getScaleLabel: function(rawValue) {
        var v = this._parseValue(rawValue);
        if (v.start !== void 0) {
          return "[" + v.start + ", " + v.end + "]";
        }
        return +this.getRightValue(rawValue);
      },
      getLabelForIndex: helpers$1.noop,
      getPixelForValue: helpers$1.noop,
      getValueForPixel: helpers$1.noop,
      getPixelForTick: function(index) {
        var me = this;
        var offset = me.options.offset;
        var numTicks = me._ticks.length;
        var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
        return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
      },
      getPixelForDecimal: function(decimal) {
        var me = this;
        if (me._reversePixels) {
          decimal = 1 - decimal;
        }
        return me._startPixel + decimal * me._length;
      },
      getDecimalForPixel: function(pixel) {
        var decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
      },
      getBasePixel: function() {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function() {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },
      _autoSkip: function(ticks) {
        var me = this;
        var tickOpts = me.options.ticks;
        var axisLength = me._length;
        var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
        var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        var numMajorIndices = majorIndices.length;
        var first = majorIndices[0];
        var last = majorIndices[numMajorIndices - 1];
        var i, ilen, spacing, avgMajorSpacing;
        if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
          return nonSkipped(ticks);
        }
        spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
        if (numMajorIndices > 0) {
          for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
            skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
          skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return nonSkipped(ticks);
        }
        skip(ticks, spacing);
        return nonSkipped(ticks);
      },
      _tickSize: function() {
        var me = this;
        var optionTicks = me.options.ticks;
        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var labelSizes = me._getLabelSizes();
        var padding = optionTicks.autoSkipPadding || 0;
        var w = labelSizes ? labelSizes.widest.width + padding : 0;
        var h = labelSizes ? labelSizes.highest.height + padding : 0;
        return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },
      _isVisible: function() {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;
        if (display !== "auto") {
          return !!display;
        }
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }
        return false;
      },
      _computeGridLineItems: function(chartArea) {
        var me = this;
        var chart = me.chart;
        var options2 = me.options;
        var gridLines = options2.gridLines;
        var position = options2.position;
        var offsetGridLines = gridLines.offsetGridLines;
        var isHorizontal = me.isHorizontal();
        var ticks = me._ticksToDraw;
        var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
        var tl = getTickMarkLength(gridLines);
        var items = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var axisHalfWidth = axisWidth / 2;
        var alignPixel = helpers$1._alignPixel;
        var alignBorderValue = function(pixel) {
          return alignPixel(chart, pixel, axisWidth);
        };
        var borderValue, i, tick, lineValue, alignedLineValue;
        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
        if (position === "top") {
          borderValue = alignBorderValue(me.bottom);
          ty1 = me.bottom - tl;
          ty2 = borderValue - axisHalfWidth;
          y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
          y2 = chartArea.bottom;
        } else if (position === "bottom") {
          borderValue = alignBorderValue(me.top);
          y1 = chartArea.top;
          y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
          ty1 = borderValue + axisHalfWidth;
          ty2 = me.top + tl;
        } else if (position === "left") {
          borderValue = alignBorderValue(me.right);
          tx1 = me.right - tl;
          tx2 = borderValue - axisHalfWidth;
          x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
          x2 = chartArea.right;
        } else {
          borderValue = alignBorderValue(me.left);
          x1 = chartArea.left;
          x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
          tx1 = borderValue + axisHalfWidth;
          tx2 = me.left + tl;
        }
        for (i = 0; i < ticksLength; ++i) {
          tick = ticks[i] || {};
          if (isNullOrUndef(tick.label) && i < ticks.length) {
            continue;
          }
          if (i === me.zeroLineIndex && options2.offset === offsetGridLines) {
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
            lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0;
          }
          lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);
          if (lineValue === void 0) {
            continue;
          }
          alignedLineValue = alignPixel(chart, lineValue, lineWidth);
          if (isHorizontal) {
            tx1 = tx2 = x1 = x2 = alignedLineValue;
          } else {
            ty1 = ty2 = y1 = y2 = alignedLineValue;
          }
          items.push({
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2,
            width: lineWidth,
            color: lineColor,
            borderDash,
            borderDashOffset
          });
        }
        items.ticksLength = ticksLength;
        items.borderValue = borderValue;
        return items;
      },
      _computeLabelItems: function() {
        var me = this;
        var options2 = me.options;
        var optionTicks = options2.ticks;
        var position = options2.position;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var ticks = me._ticksToDraw;
        var fonts = parseTickFontOptions(optionTicks);
        var tickPadding = optionTicks.padding;
        var tl = getTickMarkLength(options2.gridLines);
        var rotation = -helpers$1.toRadians(me.labelRotation);
        var items = [];
        var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        if (position === "top") {
          y = me.bottom - tl - tickPadding;
          textAlign = !rotation ? "center" : "left";
        } else if (position === "bottom") {
          y = me.top + tl + tickPadding;
          textAlign = !rotation ? "center" : "right";
        } else if (position === "left") {
          x = me.right - (isMirrored ? 0 : tl) - tickPadding;
          textAlign = isMirrored ? "left" : "right";
        } else {
          x = me.left + (isMirrored ? 0 : tl) + tickPadding;
          textAlign = isMirrored ? "right" : "left";
        }
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick = ticks[i];
          label = tick.label;
          if (isNullOrUndef(label)) {
            continue;
          }
          pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
          font = tick.major ? fonts.major : fonts.minor;
          lineHeight = font.lineHeight;
          lineCount = isArray(label) ? label.length : 1;
          if (isHorizontal) {
            x = pixel;
            textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
          } else {
            y = pixel;
            textOffset = (1 - lineCount) * lineHeight / 2;
          }
          items.push({
            x,
            y,
            rotation,
            label,
            font,
            textOffset,
            textAlign
          });
        }
        return items;
      },
      _drawGrid: function(chartArea) {
        var me = this;
        var gridLines = me.options.gridLines;
        if (!gridLines.display) {
          return;
        }
        var ctx = me.ctx;
        var chart = me.chart;
        var alignPixel = helpers$1._alignPixel;
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
        var width, color, i, ilen, item;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];
          width = item.width;
          color = item.color;
          if (width && color) {
            ctx.save();
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            if (ctx.setLineDash) {
              ctx.setLineDash(item.borderDash);
              ctx.lineDashOffset = item.borderDashOffset;
            }
            ctx.beginPath();
            if (gridLines.drawTicks) {
              ctx.moveTo(item.tx1, item.ty1);
              ctx.lineTo(item.tx2, item.ty2);
            }
            if (gridLines.drawOnChartArea) {
              ctx.moveTo(item.x1, item.y1);
              ctx.lineTo(item.x2, item.y2);
            }
            ctx.stroke();
            ctx.restore();
          }
        }
        if (axisWidth) {
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
          var borderValue = items.borderValue;
          var x1, x2, y1, y2;
          if (me.isHorizontal()) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.lineWidth = axisWidth;
          ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      },
      _drawLabels: function() {
        var me = this;
        var optionTicks = me.options.ticks;
        if (!optionTicks.display) {
          return;
        }
        var ctx = me.ctx;
        var items = me._labelItems || (me._labelItems = me._computeLabelItems());
        var i, j, ilen, jlen, item, tickFont, label, y;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];
          tickFont = item.font;
          ctx.save();
          ctx.translate(item.x, item.y);
          ctx.rotate(item.rotation);
          ctx.font = tickFont.string;
          ctx.fillStyle = tickFont.color;
          ctx.textBaseline = "middle";
          ctx.textAlign = item.textAlign;
          label = item.label;
          y = item.textOffset;
          if (isArray(label)) {
            for (j = 0, jlen = label.length; j < jlen; ++j) {
              ctx.fillText("" + label[j], 0, y);
              y += tickFont.lineHeight;
            }
          } else {
            ctx.fillText(label, 0, y);
          }
          ctx.restore();
        }
      },
      _drawTitle: function() {
        var me = this;
        var ctx = me.ctx;
        var options2 = me.options;
        var scaleLabel = options2.scaleLabel;
        if (!scaleLabel.display) {
          return;
        }
        var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
        var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var halfLineHeight = scaleLabelFont.lineHeight / 2;
        var position = options2.position;
        var rotation = 0;
        var scaleLabelX, scaleLabelY;
        if (me.isHorizontal()) {
          scaleLabelX = me.left + me.width / 2;
          scaleLabelY = position === "bottom" ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
        } else {
          var isLeft = position === "left";
          scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
          scaleLabelY = me.top + me.height / 2;
          rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
        }
        ctx.save();
        ctx.translate(scaleLabelX, scaleLabelY);
        ctx.rotate(rotation);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = scaleLabelFontColor;
        ctx.font = scaleLabelFont.string;
        ctx.fillText(scaleLabel.labelString, 0, 0);
        ctx.restore();
      },
      draw: function(chartArea) {
        var me = this;
        if (!me._isVisible()) {
          return;
        }
        me._drawGrid(chartArea);
        me._drawTitle();
        me._drawLabels();
      },
      _layers: function() {
        var me = this;
        var opts = me.options;
        var tz = opts.ticks && opts.ticks.z || 0;
        var gz = opts.gridLines && opts.gridLines.z || 0;
        if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
          return [{
            z: tz,
            draw: function() {
              me.draw.apply(me, arguments);
            }
          }];
        }
        return [{
          z: gz,
          draw: function() {
            me._drawGrid.apply(me, arguments);
            me._drawTitle.apply(me, arguments);
          }
        }, {
          z: tz,
          draw: function() {
            me._drawLabels.apply(me, arguments);
          }
        }];
      },
      _getMatchingVisibleMetas: function(type) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        return me.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
          return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
        });
      }
    });
    Scale.prototype._draw = Scale.prototype.draw;
    var core_scale = Scale;
    var isNullOrUndef$1 = helpers$1.isNullOrUndef;
    var defaultConfig = {
      position: "bottom"
    };
    var scale_category = core_scale.extend({
      determineDataLimits: function() {
        var me = this;
        var labels = me._getLabels();
        var ticksOpts = me.options.ticks;
        var min = ticksOpts.min;
        var max = ticksOpts.max;
        var minIndex = 0;
        var maxIndex = labels.length - 1;
        var findIndex;
        if (min !== void 0) {
          findIndex = labels.indexOf(min);
          if (findIndex >= 0) {
            minIndex = findIndex;
          }
        }
        if (max !== void 0) {
          findIndex = labels.indexOf(max);
          if (findIndex >= 0) {
            maxIndex = findIndex;
          }
        }
        me.minIndex = minIndex;
        me.maxIndex = maxIndex;
        me.min = labels[minIndex];
        me.max = labels[maxIndex];
      },
      buildTicks: function() {
        var me = this;
        var labels = me._getLabels();
        var minIndex = me.minIndex;
        var maxIndex = me.maxIndex;
        me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
      },
      getLabelForIndex: function(index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }
        return me._getLabels()[index];
      },
      _configure: function() {
        var me = this;
        var offset = me.options.offset;
        var ticks = me.ticks;
        core_scale.prototype._configure.call(me);
        if (!me.isHorizontal()) {
          me._reversePixels = !me._reversePixels;
        }
        if (!ticks) {
          return;
        }
        me._startValue = me.minIndex - (offset ? 0.5 : 0);
        me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
      },
      getPixelForValue: function(value, index, datasetIndex) {
        var me = this;
        var valueCategory, labels, idx;
        if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
          value = me.chart.data.datasets[datasetIndex].data[index];
        }
        if (!isNullOrUndef$1(value)) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }
        if (valueCategory !== void 0 || value !== void 0 && isNaN(index)) {
          labels = me._getLabels();
          value = helpers$1.valueOrDefault(valueCategory, value);
          idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
          if (isNaN(index)) {
            index = value;
          }
        }
        return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
      },
      getPixelForTick: function(index) {
        var ticks = this.ticks;
        return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
      },
      getValueForPixel: function(pixel) {
        var me = this;
        var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
        return Math.min(Math.max(value, 0), me.ticks.length - 1);
      },
      getBasePixel: function() {
        return this.bottom;
      }
    });
    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef$2 = helpers$1.isNullOrUndef;
    function generateTicks(generationOptions, dataRange) {
      var ticks = [];
      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
        return [rmin, rmax];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxNumSpaces) {
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }
      if (stepSize || isNullOrUndef$2(precision)) {
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
      if (stepSize) {
        if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1e3)) {
          niceMin = min;
        }
        if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1e3)) {
          niceMax = max;
        }
      }
      numSpaces = (niceMax - niceMin) / spacing;
      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef$2(min) ? niceMin : min);
      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }
      ticks.push(isNullOrUndef$2(max) ? niceMax : max);
      return ticks;
    }
    var scale_linearbase = core_scale.extend({
      getRightValue: function(value) {
        if (typeof value === "string") {
          return +value;
        }
        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function() {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks;
        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);
          if (minSign < 0 && maxSign < 0) {
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            me.min = 0;
          }
        }
        var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
        var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
        if (tickOpts.min !== void 0) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== void 0) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }
        if (tickOpts.max !== void 0) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== void 0) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }
        if (setMin !== setMax) {
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }
        if (me.min === me.max) {
          me.max++;
          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function() {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;
        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
      },
      _computeTickLimit: function() {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function() {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks;
        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges();
        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);
        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function() {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      },
      _configure: function() {
        var me = this;
        var ticks = me.getTicks();
        var start = me.min;
        var end = me.max;
        var offset;
        core_scale.prototype._configure.call(me);
        if (me.options.offset && ticks.length) {
          offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
          start -= offset;
          end += offset;
        }
        me._startValue = start;
        me._endValue = end;
        me._valueRange = end - start;
      }
    });
    var defaultConfig$1 = {
      position: "left",
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var DEFAULT_MIN = 0;
    var DEFAULT_MAX = 1;
    function getOrCreateStack(stacks, stacked, meta) {
      var key = [
        meta.type,
        stacked === void 0 && meta.stack === void 0 ? meta.index : "",
        meta.stack
      ].join(".");
      if (stacks[key] === void 0) {
        stacks[key] = {
          pos: [],
          neg: []
        };
      }
      return stacks[key];
    }
    function stackData(scale2, stacks, meta, data) {
      var opts = scale2.options;
      var stacked = opts.stacked;
      var stack = getOrCreateStack(stacks, stacked, meta);
      var pos = stack.pos;
      var neg = stack.neg;
      var ilen = data.length;
      var i, value;
      for (i = 0; i < ilen; ++i) {
        value = scale2._parseValue(data[i]);
        if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
          continue;
        }
        pos[i] = pos[i] || 0;
        neg[i] = neg[i] || 0;
        if (opts.relativePoints) {
          pos[i] = 100;
        } else if (value.min < 0 || value.max < 0) {
          neg[i] += value.min;
        } else {
          pos[i] += value.max;
        }
      }
    }
    function updateMinMax(scale2, meta, data) {
      var ilen = data.length;
      var i, value;
      for (i = 0; i < ilen; ++i) {
        value = scale2._parseValue(data[i]);
        if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
          continue;
        }
        scale2.min = Math.min(scale2.min, value.min);
        scale2.max = Math.max(scale2.max, value.max);
      }
    }
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function() {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var metasets = me._getMatchingVisibleMetas();
        var hasStacks = opts.stacked;
        var stacks = {};
        var ilen = metasets.length;
        var i, meta, data, values;
        me.min = Number.POSITIVE_INFINITY;
        me.max = Number.NEGATIVE_INFINITY;
        if (hasStacks === void 0) {
          for (i = 0; !hasStacks && i < ilen; ++i) {
            meta = metasets[i];
            hasStacks = meta.stack !== void 0;
          }
        }
        for (i = 0; i < ilen; ++i) {
          meta = metasets[i];
          data = datasets[meta.index].data;
          if (hasStacks) {
            stackData(me, stacks, meta, data);
          } else {
            updateMinMax(me, meta, data);
          }
        }
        helpers$1.each(stacks, function(stackValues) {
          values = stackValues.pos.concat(stackValues.neg);
          me.min = Math.min(me.min, helpers$1.min(values));
          me.max = Math.max(me.max, helpers$1.max(values));
        });
        me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
        me.handleTickRangeOptions();
      },
      _computeTickLimit: function() {
        var me = this;
        var tickFont;
        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }
        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      handleDirectionalChanges: function() {
        if (!this.isHorizontal()) {
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function(index, datasetIndex) {
        return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForValue: function(value) {
        var me = this;
        return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
      },
      getValueForPixel: function(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      },
      getPixelForTick: function(index) {
        var ticks = this.ticksAsNumbers;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index]);
      }
    });
    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var log10 = helpers$1.math.log10;
    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
      var endExp = Math.floor(log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;
      if (tickVal === 0) {
        exp = Math.floor(log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }
      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
      do {
        ticks.push(tickVal);
        ++significand;
        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }
        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);
      var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }
    var defaultConfig$2 = {
      position: "left",
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    };
    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }
    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function() {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var isHorizontal = me.isHorizontal();
        function IDMatches(meta2) {
          return isHorizontal ? meta2.xAxisID === me.id : meta2.yAxisID === me.id;
        }
        var datasetIndex, meta, value, data, i, ilen;
        me.min = Number.POSITIVE_INFINITY;
        me.max = Number.NEGATIVE_INFINITY;
        me.minNotZero = Number.POSITIVE_INFINITY;
        var hasStacks = opts.stacked;
        if (hasStacks === void 0) {
          for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
            meta = chart.getDatasetMeta(datasetIndex);
            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
              hasStacks = true;
              break;
            }
          }
        }
        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
            meta = chart.getDatasetMeta(datasetIndex);
            var key = [
              meta.type,
              opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
              meta.stack
            ].join(".");
            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === void 0) {
                valuesPerStack[key] = [];
              }
              data = datasets[datasetIndex].data;
              for (i = 0, ilen = data.length; i < ilen; i++) {
                var values = valuesPerStack[key];
                value = me._parseValue(data[i]);
                if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                  continue;
                }
                values[i] = values[i] || 0;
                values[i] += value.max;
              }
            }
          }
          helpers$1.each(valuesPerStack, function(valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = Math.min(me.min, minVal);
              me.max = Math.max(me.max, maxVal);
            }
          });
        } else {
          for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
            meta = chart.getDatasetMeta(datasetIndex);
            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              data = datasets[datasetIndex].data;
              for (i = 0, ilen = data.length; i < ilen; i++) {
                value = me._parseValue(data[i]);
                if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                  continue;
                }
                me.min = Math.min(value.min, me.min);
                me.max = Math.max(value.max, me.max);
                if (value.min !== 0) {
                  me.minNotZero = Math.min(value.min, me.minNotZero);
                }
              }
            }
          }
        }
        me.min = helpers$1.isFinite(me.min) ? me.min : null;
        me.max = helpers$1.isFinite(me.max) ? me.max : null;
        me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function() {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN2 = 1;
        var DEFAULT_MAX2 = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);
        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN2;
            me.max = DEFAULT_MAX2;
          }
        }
        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
        }
        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX2;
        }
        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN2;
          }
        }
      },
      buildTicks: function() {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me);
        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);
        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function() {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      getLabelForIndex: function(index, datasetIndex) {
        return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function(index) {
        var ticks = this.tickValues;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index]);
      },
      _getFirstTickValue: function(value) {
        var exp = Math.floor(log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      _configure: function() {
        var me = this;
        var start = me.min;
        var offset = 0;
        core_scale.prototype._configure.call(me);
        if (start === 0) {
          start = me._getFirstTickValue(me.minNotZero);
          offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
        }
        me._startValue = log10(start);
        me._valueOffset = offset;
        me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
      },
      getPixelForValue: function(value) {
        var me = this;
        var decimal = 0;
        value = +me.getRightValue(value);
        if (value > me.min && value > 0) {
          decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
        }
        return me.getPixelForDecimal(decimal);
      },
      getValueForPixel: function(pixel) {
        var me = this;
        var decimal = me.getDecimalForPixel(pixel);
        return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
      }
    });
    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$c = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      animate: true,
      position: "chartArea",
      angleLines: {
        display: true,
        color: "rgba(0,0,0,0.1)",
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0
      },
      gridLines: {
        circular: false
      },
      ticks: {
        showLabelBackdrop: true,
        backdropColor: "rgba(255,255,255,0.75)",
        backdropPaddingY: 2,
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        display: true,
        fontSize: 10,
        callback: function(label) {
          return label;
        }
      }
    };
    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;
      if (tickOpts.display && opts.display) {
        return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }
      return 0;
    }
    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }
      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }
    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }
      return {
        start: pos,
        end: pos + size
      };
    }
    function fitWithPointLabels(scale2) {
      var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
      var furthestLimits = {
        l: 0,
        r: scale2.width,
        t: 0,
        b: scale2.height - scale2.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale2.ctx.font = plFont.string;
      scale2._pointLabelSizes = [];
      var valueCount = scale2.chart.data.labels.length;
      for (i = 0; i < valueCount; i++) {
        pointPosition = scale2.getPointPosition(i, scale2.drawingArea + 5);
        textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i]);
        scale2._pointLabelSizes[i] = textSize;
        var angleRadians = scale2.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }
        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }
        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }
        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }
      scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
    }
    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return "center";
      } else if (angle < 180) {
        return "left";
      }
      return "right";
    }
    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;
      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }
    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }
    function drawPointLabels(scale2) {
      var ctx = scale2.ctx;
      var opts = scale2.options;
      var pointLabelOpts = opts.pointLabels;
      var tickBackdropHeight = getTickBackdropHeight(opts);
      var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
      var plFont = helpers$1.options._parseFont(pointLabelOpts);
      ctx.save();
      ctx.font = plFont.string;
      ctx.textBaseline = "middle";
      for (var i = scale2.chart.data.labels.length - 1; i >= 0; i--) {
        var extra = i === 0 ? tickBackdropHeight / 2 : 0;
        var pointLabelPosition = scale2.getPointPosition(i, outerDistance + extra + 5);
        var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
        ctx.fillStyle = pointLabelFontColor;
        var angleRadians = scale2.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians);
        ctx.textAlign = getTextAlignForAngle(angle);
        adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i], pointLabelPosition);
        fillText(ctx, scale2.pointLabels[i], pointLabelPosition, plFont.lineHeight);
      }
      ctx.restore();
    }
    function drawRadiusLine(scale2, gridLineOpts, radius, index) {
      var ctx = scale2.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = scale2.chart.data.labels.length;
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;
      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }
      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;
      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
      }
      ctx.beginPath();
      if (circular) {
        ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
      } else {
        pointPosition = scale2.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale2.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }
    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function() {
        var me = this;
        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function() {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function(rawValue, index) {
              var value = +me.getRightValue(rawValue);
              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }
              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
        me.handleTickRangeOptions();
      },
      _computeTickLimit: function() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function() {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me);
        me.pointLabels = me.chart.data.labels.map(function() {
          var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
          return label || label === 0 ? label : "";
        });
      },
      getLabelForIndex: function(index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function() {
        var me = this;
        var opts = me.options;
        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },
      setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function(index) {
        var chart = this.chart;
        var angleMultiplier = 360 / chart.data.labels.length;
        var options2 = chart.options || {};
        var startAngle = options2.startAngle || 0;
        var angle = (index * angleMultiplier + startAngle) % 360;
        return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
      },
      getDistanceFromCenterForValue: function(value) {
        var me = this;
        if (helpers$1.isNullOrUndef(value)) {
          return NaN;
        }
        var scalingFactor = me.drawingArea / (me.max - me.min);
        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }
        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function(index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function(index) {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      _drawGrid: function() {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var angleLineOpts = opts.angleLines;
        var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
        var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
        var i, offset, position;
        if (opts.pointLabels.display) {
          drawPointLabels(me);
        }
        if (gridLineOpts.display) {
          helpers$1.each(me.ticks, function(label, index) {
            if (index !== 0) {
              offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
              drawRadiusLine(me, gridLineOpts, offset, index);
            }
          });
        }
        if (angleLineOpts.display && lineWidth && lineColor) {
          ctx.save();
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = lineColor;
          if (ctx.setLineDash) {
            ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
            ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
          }
          for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
            offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
            position = me.getPointPosition(i, offset);
            ctx.beginPath();
            ctx.moveTo(me.xCenter, me.yCenter);
            ctx.lineTo(position.x, position.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      },
      _drawLabels: function() {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;
        var tickOpts = opts.ticks;
        if (!tickOpts.display) {
          return;
        }
        var startAngle = me.getIndexAngle(0);
        var tickFont = helpers$1.options._parseFont(tickOpts);
        var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
        var offset, width;
        ctx.save();
        ctx.font = tickFont.string;
        ctx.translate(me.xCenter, me.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        helpers$1.each(me.ticks, function(label, index) {
          if (index === 0 && !tickOpts.reverse) {
            return;
          }
          offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
          if (tickOpts.showLabelBackdrop) {
            width = ctx.measureText(label).width;
            ctx.fillStyle = tickOpts.backdropColor;
            ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
          }
          ctx.fillStyle = tickFontColor;
          ctx.fillText(label, 0, -offset);
        });
        ctx.restore();
      },
      _drawTitle: helpers$1.noop
    });
    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var deprecated$1 = helpers$1._deprecated;
    var resolve$5 = helpers$1.options.resolve;
    var valueOrDefault$d = helpers$1.valueOrDefault;
    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: 1e3
      },
      second: {
        common: true,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: true,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: true,
        size: 36e5,
        steps: 24
      },
      day: {
        common: true,
        size: 864e5,
        steps: 30
      },
      week: {
        common: false,
        size: 6048e5,
        steps: 4
      },
      month: {
        common: true,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: false,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: true,
        size: 3154e7
      }
    };
    var UNITS = Object.keys(INTERVALS);
    function sorter(a, b) {
      return a - b;
    }
    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }
      return out;
    }
    function getMin(options2) {
      return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
    }
    function getMax(options2) {
      return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
    }
    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === "linear" || !timestamps.length) {
        return [
          {time: min, pos: 0},
          {time: max, pos: 1}
        ];
      }
      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr > min && curr < max) {
          items.push(curr);
        }
      }
      items.push(max);
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
          table.push({time: curr, pos: i / (ilen - 1)});
        }
      }
      return table;
    }
    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;
      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];
        if (!i0) {
          return {lo: null, hi: i1};
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {lo: i0, hi: i1};
        }
      }
      return {lo: i1, hi: null};
    }
    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval);
      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }
    function toTimestamp(scale2, input) {
      var adapter = scale2._adapter;
      var options2 = scale2.options.time;
      var parser = options2.parser;
      var format = parser || options2.format;
      var value = input;
      if (typeof parser === "function") {
        value = parser(value);
      }
      if (!helpers$1.isFinite(value)) {
        value = typeof format === "string" ? adapter.parse(value, format) : adapter.parse(value);
      }
      if (value !== null) {
        return +value;
      }
      if (!parser && typeof format === "function") {
        value = format(input);
        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }
      return value;
    }
    function parse(scale2, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }
      var options2 = scale2.options.time;
      var value = toTimestamp(scale2, scale2.getRightValue(input));
      if (value === null) {
        return value;
      }
      if (options2.round) {
        value = +scale2._adapter.startOf(value, options2.round);
      }
      return value;
    }
    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;
      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps : MAX_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }
      return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale2, numTicks, minUnit, min, max) {
      var i, unit;
      for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];
        if (INTERVALS[unit].common && scale2._adapter.diff(max, min, unit) >= numTicks - 1) {
          return unit;
        }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    function generate(scale2, min, max, capacity) {
      var adapter = scale2._adapter;
      var options2 = scale2.options;
      var timeOpts = options2.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
      var weekday = minor === "week" ? timeOpts.isoWeekday : false;
      var first = min;
      var ticks = [];
      var time;
      if (weekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, weekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor;
      }
      for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(time);
      }
      if (time === max || options2.bounds === "ticks") {
        ticks.push(time);
      }
      return ticks;
    }
    function computeOffsets(table, ticks, min, max, options2) {
      var start = 0;
      var end = 0;
      var first, last;
      if (options2.offset && ticks.length) {
        first = interpolate$1(table, "time", ticks[0], "pos");
        if (ticks.length === 1) {
          start = 1 - first;
        } else {
          start = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
        }
        last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
        if (ticks.length === 1) {
          end = last;
        } else {
          end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
        }
      }
      return {start, end, factor: 1 / (start + 1 + end)};
    }
    function setMajorTicks(scale2, ticks, map, majorUnit) {
      var adapter = scale2._adapter;
      var first = +adapter.startOf(ticks[0].value, majorUnit);
      var last = ticks[ticks.length - 1].value;
      var major, index;
      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index = map[major];
        if (index >= 0) {
          ticks[index].major = true;
        }
      }
      return ticks;
    }
    function ticksFromTimestamps(scale2, values, majorUnit) {
      var ticks = [];
      var map = {};
      var ilen = values.length;
      var i, value;
      for (i = 0; i < ilen; ++i) {
        value = values[i];
        map[value] = i;
        ticks.push({
          value,
          major: false
        });
      }
      return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map, majorUnit);
    }
    var defaultConfig$4 = {
      position: "bottom",
      distribution: "linear",
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        displayFormat: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,
        source: "auto",
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function() {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function() {
        var me = this;
        var options2 = me.options;
        var time = options2.time || (options2.time = {});
        var adapter = me._adapter = new core_adapters._date(options2.adapters.date);
        deprecated$1("time scale", time.format, "time.format", "time.parser");
        deprecated$1("time scale", time.min, "time.min", "ticks.min");
        deprecated$1("time scale", time.max, "time.max", "ticks.max");
        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },
      getRightValue: function(rawValue) {
        if (rawValue && rawValue.t !== void 0) {
          rawValue = rawValue.t;
        }
        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function() {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var options2 = me.options;
        var unit = options2.time.unit || "day";
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp, labelsAdded;
        var dataLabels = me._getLabels();
        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        }
        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data;
            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];
              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              datasets[i] = labels.slice(0);
              if (!labelsAdded) {
                timestamps = timestamps.concat(labels);
                labelsAdded = true;
              }
            }
          } else {
            datasets[i] = [];
          }
        }
        if (labels.length) {
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }
        if (timestamps.length) {
          timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }
        min = parse(me, getMin(options2)) || min;
        max = parse(me, getMax(options2)) || max;
        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;
        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max);
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets,
          labels
        };
      },
      buildTicks: function() {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options2 = me.options;
        var tickOpts = options2.ticks;
        var timeOpts = options2.time;
        var timestamps = me._timestamps;
        var ticks = [];
        var capacity = me.getLabelCapacity(min);
        var source = tickOpts.source;
        var distribution = options2.distribution;
        var i, ilen, timestamp;
        if (source === "data" || source === "auto" && distribution === "series") {
          timestamps = timestamps.data;
        } else if (source === "labels") {
          timestamps = timestamps.labels;
        } else {
          timestamps = generate(me, min, max, capacity);
        }
        if (options2.bounds === "ticks" && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        }
        min = parse(me, getMin(options2)) || min;
        max = parse(me, getMax(options2)) || max;
        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];
          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }
        me.min = min;
        me.max = max;
        me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
        me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options2);
        if (tickOpts.reverse) {
          ticks.reverse();
        }
        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function(index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : "";
        var value = data.datasets[datasetIndex].data[index];
        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }
        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }
        if (typeof label === "string") {
          return label;
        }
        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },
      tickFormatFunction: function(time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options2 = me.options;
        var formats = options2.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var tick = ticks[index];
        var tickOpts = options2.ticks;
        var major = majorUnit && majorFormat && tick && tick.major;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
        var formatter = resolve$5([
          nestedTickOpts.callback,
          nestedTickOpts.userCallback,
          tickOpts.callback,
          tickOpts.userCallback
        ]);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function(ticks) {
        var labels = [];
        var i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }
        return labels;
      },
      getPixelForOffset: function(time) {
        var me = this;
        var offsets = me._offsets;
        var pos = interpolate$1(me._table, "time", time, "pos");
        return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      },
      getPixelForValue: function(value, index, datasetIndex) {
        var me = this;
        var time = null;
        if (index !== void 0 && datasetIndex !== void 0) {
          time = me._timestamps.datasets[datasetIndex][index];
        }
        if (time === null) {
          time = parse(me, value);
        }
        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function(index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function(pixel) {
        var me = this;
        var offsets = me._offsets;
        var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        var time = interpolate$1(me._table, "pos", pos, "time");
        return me._adapter._create(time);
      },
      _getLabelSize: function(label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return {
          w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
          h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
      },
      getLabelWidth: function(label) {
        return this._getLabelSize(label).w;
      },
      getLabelCapacity: function(exampleTime) {
        var me = this;
        var timeOpts = me.options.time;
        var displayFormats = timeOpts.displayFormats;
        var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);
        var size = me._getLabelSize(exampleLabel);
        var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
        if (me.options.offset) {
          capacity--;
        }
        return capacity > 0 ? capacity : 1;
      }
    });
    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: "MMM D, YYYY, h:mm:ss a",
      millisecond: "h:mm:ss.SSS a",
      second: "h:mm:ss a",
      minute: "h:mm a",
      hour: "hA",
      day: "MMM D",
      week: "ll",
      month: "MMM YYYY",
      quarter: "[Q]Q - YYYY",
      year: "YYYY"
    };
    core_adapters._date.override(typeof moment === "function" ? {
      _id: "moment",
      formats: function() {
        return FORMATS;
      },
      parse: function(value, format) {
        if (typeof value === "string" && typeof format === "string") {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }
        return value.isValid() ? value.valueOf() : null;
      },
      format: function(time, format) {
        return moment(time).format(format);
      },
      add: function(time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function(max, min, unit) {
        return moment(max).diff(moment(min), unit);
      },
      startOf: function(time, unit, weekday) {
        time = moment(time);
        if (unit === "isoWeek") {
          return time.isoWeekday(weekday).valueOf();
        }
        return time.startOf(unit).valueOf();
      },
      endOf: function(time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      _create: function(time) {
        return moment(time);
      }
    } : {});
    core_defaults._set("global", {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });
    var mappers = {
      dataset: function(source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function(point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function(source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        if (helpers$1.isArray(boundary)) {
          return function(point, i) {
            return boundary[i];
          };
        }
        return function(point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    };
    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;
      if (fill === void 0) {
        fill = !!model.backgroundColor;
      }
      if (fill === false || fill === null) {
        return false;
      }
      if (fill === true) {
        return "origin";
      }
      target = parseFloat(fill, 10);
      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === "-" || fill[0] === "+") {
          target = index + target;
        }
        if (target === index || target < 0 || target >= count) {
          return false;
        }
        return target;
      }
      switch (fill) {
        case "bottom":
          return "start";
        case "top":
          return "end";
        case "zero":
          return "origin";
        case "origin":
        case "start":
        case "end":
          return fill;
        default:
          return false;
      }
    }
    function computeLinearBoundary(source) {
      var model = source.el._model || {};
      var scale2 = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;
      if (isFinite(fill)) {
        return null;
      }
      if (fill === "start") {
        target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
      } else if (fill === "end") {
        target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
      } else if (model.scaleZero !== void 0) {
        target = model.scaleZero;
      } else if (scale2.getBasePixel) {
        target = scale2.getBasePixel();
      }
      if (target !== void 0 && target !== null) {
        if (target.x !== void 0 && target.y !== void 0) {
          return target;
        }
        if (helpers$1.isFinite(target)) {
          horizontal = scale2.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }
      return null;
    }
    function computeCircularBoundary(source) {
      var scale2 = source.el._scale;
      var options2 = scale2.options;
      var length = scale2.chart.data.labels.length;
      var fill = source.fill;
      var target = [];
      var start, end, center, i, point;
      if (!length) {
        return null;
      }
      start = options2.ticks.reverse ? scale2.max : scale2.min;
      end = options2.ticks.reverse ? scale2.min : scale2.max;
      center = scale2.getPointPositionForValue(0, start);
      for (i = 0; i < length; ++i) {
        point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i, fill === "start" ? start : end) : scale2.getBasePosition(i);
        if (options2.gridLines.circular) {
          point.cx = center.x;
          point.cy = center.y;
          point.angle = scale2.getIndexAngle(i) - Math.PI / 2;
        }
        target.push(point);
      }
      return target;
    }
    function computeBoundary(source) {
      var scale2 = source.el._scale || {};
      if (scale2.getPointPositionForValue) {
        return computeCircularBoundary(source);
      }
      return computeLinearBoundary(source);
    }
    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;
      if (!propagate) {
        return fill;
      }
      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }
        target = sources[fill];
        if (!target) {
          return false;
        }
        if (target.visible) {
          return fill;
        }
        visited.push(fill);
        fill = target.fill;
      }
      return false;
    }
    function createMapper(source) {
      var fill = source.fill;
      var type = "dataset";
      if (fill === false) {
        return null;
      }
      if (!isFinite(fill)) {
        type = "boundary";
      }
      return mappers[type](source);
    }
    function isDrawable(point) {
      return point && !point.skip;
    }
    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i, cx, cy, r;
      if (!len0 || !len1) {
        return;
      }
      ctx.moveTo(curve0[0].x, curve0[0].y);
      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      }
      if (curve1[0].angle !== void 0) {
        cx = curve1[0].cx;
        cy = curve1[0].cy;
        r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
        for (i = len1 - 1; i > 0; --i) {
          ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
        }
        return;
      }
      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }
    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1, loopOffset;
      ctx.beginPath();
      for (i = 0, ilen = count; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);
        if (loop && loopOffset === void 0 && d0) {
          loopOffset = i + 1;
          ilen = count + loopOffset;
        }
        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }
            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }
      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
    var plugin_filler = {
      id: "filler",
      afterDatasetsUpdate: function(chart, options2) {
        var count = (chart.data.datasets || []).length;
        var propagate = options2.propagate;
        var sources = [];
        var meta, i, el, source;
        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;
          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart,
              el
            };
          }
          meta.$filler = source;
          sources.push(source);
        }
        for (i = 0; i < count; ++i) {
          source = sources[i];
          if (!source) {
            continue;
          }
          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetsDraw: function(chart) {
        var metasets = chart._getSortedVisibleDatasetMetas();
        var ctx = chart.ctx;
        var meta, i, el, view, points, mapper, color;
        for (i = metasets.length - 1; i >= 0; --i) {
          meta = metasets[i].$filler;
          if (!meta || !meta.visible) {
            continue;
          }
          el = meta.el;
          view = el._view;
          points = el._children || [];
          mapper = meta.mapper;
          color = view.backgroundColor || core_defaults.global.defaultColor;
          if (mapper && color && points.length) {
            helpers$1.canvas.clipArea(ctx, chart.chartArea);
            doFill(ctx, points, mapper, view, color, el._loop);
            helpers$1.canvas.unclipArea(ctx);
          }
        }
      }
    };
    var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
    var noop$1 = helpers$1.noop;
    var valueOrDefault$e = helpers$1.valueOrDefault;
    core_defaults._set("global", {
      legend: {
        display: true,
        position: "top",
        align: "center",
        fullWidth: true,
        reverse: false,
        weight: 1e3,
        onClick: function(e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index);
          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          generateLabels: function(chart) {
            var datasets = chart.data.datasets;
            var options2 = chart.options.legend || {};
            var usePointStyle = options2.labels && options2.labels.usePointStyle;
            return chart._getSortedDatasetMetas().map(function(meta) {
              var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
              return {
                text: datasets[meta.index].label,
                fillStyle: style.backgroundColor,
                hidden: !chart.isDatasetVisible(meta.index),
                lineCap: style.borderCapStyle,
                lineDash: style.borderDash,
                lineDashOffset: style.borderDashOffset,
                lineJoin: style.borderJoinStyle,
                lineWidth: style.borderWidth,
                strokeStyle: style.borderColor,
                pointStyle: style.pointStyle,
                rotation: style.rotation,
                datasetIndex: meta.index
              };
            }, this);
          }
        }
      },
      legendCallback: function(chart) {
        var list = document.createElement("ul");
        var datasets = chart.data.datasets;
        var i, ilen, listItem, listItemSpan;
        list.setAttribute("class", chart.id + "-legend");
        for (i = 0, ilen = datasets.length; i < ilen; i++) {
          listItem = list.appendChild(document.createElement("li"));
          listItemSpan = listItem.appendChild(document.createElement("span"));
          listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
          if (datasets[i].label) {
            listItem.appendChild(document.createTextNode(datasets[i].label));
          }
        }
        return list.outerHTML;
      }
    });
    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    var Legend = core_element.extend({
      initialize: function(config) {
        var me = this;
        helpers$1.extend(me, config);
        me.legendHitBoxes = [];
        me._hoveredItem = null;
        me.doughnutMode = false;
      },
      beforeUpdate: noop$1,
      update: function(maxWidth, maxHeight, margins) {
        var me = this;
        me.beforeUpdate();
        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins;
        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions();
        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels();
        me.beforeFit();
        me.fit();
        me.afterFit();
        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      beforeSetDimensions: noop$1,
      setDimensions: function() {
        var me = this;
        if (me.isHorizontal()) {
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight;
          me.top = 0;
          me.bottom = me.height;
        }
        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      beforeBuildLabels: noop$1,
      buildLabels: function() {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
        if (labelOpts.filter) {
          legendItems = legendItems.filter(function(item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }
        if (me.options.reverse) {
          legendItems.reverse();
        }
        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      beforeFit: noop$1,
      fit: function() {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;
        var labelFont = helpers$1.options._parseFont(labelOpts);
        var fontSize = labelFont.size;
        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();
        if (isHorizontal) {
          minSize.width = me.maxWidth;
          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight;
        }
        if (!display) {
          me.width = minSize.width = me.height = minSize.height = 0;
          return;
        }
        ctx.font = labelFont.string;
        if (isHorizontal) {
          var lineWidths = me.lineWidths = [0];
          var totalHeight = 0;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          helpers$1.each(me.legendItems, function(legendItem, i) {
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
              totalHeight += fontSize + labelOpts.padding;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
            }
            hitboxes[i] = {
              left: 0,
              top: 0,
              width,
              height: fontSize
            };
            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
          });
          minSize.height += totalHeight;
        } else {
          var vPadding = labelOpts.padding;
          var columnWidths = me.columnWidths = [];
          var columnHeights = me.columnHeights = [];
          var totalWidth = labelOpts.padding;
          var currentColWidth = 0;
          var currentColHeight = 0;
          helpers$1.each(me.legendItems, function(legendItem, i) {
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
              totalWidth += currentColWidth + labelOpts.padding;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              currentColWidth = 0;
              currentColHeight = 0;
            }
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += fontSize + vPadding;
            hitboxes[i] = {
              left: 0,
              top: 0,
              width: itemWidth,
              height: fontSize
            };
          });
          totalWidth += currentColWidth;
          columnWidths.push(currentColWidth);
          columnHeights.push(currentColHeight);
          minSize.width += totalWidth;
        }
        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      isHorizontal: function() {
        return this.options.position === "top" || this.options.position === "bottom";
      },
      draw: function() {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor2 = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendHeight = me.height;
        var columnHeights = me.columnHeights;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;
        if (!opts.display) {
          return;
        }
        var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
        var ctx = me.ctx;
        var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
        var labelFont = helpers$1.options._parseFont(labelOpts);
        var fontSize = labelFont.size;
        var cursor;
        ctx.textAlign = rtlHelper.textAlign("left");
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = fontColor;
        ctx.fillStyle = fontColor;
        ctx.font = labelFont.string;
        var boxWidth = getBoxWidth(labelOpts, fontSize);
        var hitboxes = me.legendHitBoxes;
        var drawLegendBox = function(x, y, legendItem) {
          if (isNaN(boxWidth) || boxWidth <= 0) {
            return;
          }
          ctx.save();
          var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
          ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
          ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
          ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
          ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
          if (ctx.setLineDash) {
            ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
          }
          if (labelOpts && labelOpts.usePointStyle) {
            var radius = boxWidth * Math.SQRT2 / 2;
            var centerX = rtlHelper.xPlus(x, boxWidth / 2);
            var centerY = y + fontSize / 2;
            helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
          } else {
            ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
            if (lineWidth !== 0) {
              ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
            }
          }
          ctx.restore();
        };
        var fillText2 = function(x, y, legendItem, textWidth) {
          var halfFontSize = fontSize / 2;
          var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
          var yMiddle = y + halfFontSize;
          ctx.fillText(legendItem.text, xLeft, yMiddle);
          if (legendItem.hidden) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.moveTo(xLeft, yMiddle);
            ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
            ctx.stroke();
          }
        };
        var alignmentOffset = function(dimension, blockSize) {
          switch (opts.align) {
            case "start":
              return labelOpts.padding;
            case "end":
              return dimension - blockSize;
            default:
              return (dimension - blockSize + labelOpts.padding) / 2;
          }
        };
        var isHorizontal = me.isHorizontal();
        if (isHorizontal) {
          cursor = {
            x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
            y: me.top + labelOpts.padding,
            line: 0
          };
        } else {
          cursor = {
            x: me.left + labelOpts.padding,
            y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
            line: 0
          };
        }
        helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
        var itemHeight = fontSize + labelOpts.padding;
        helpers$1.each(me.legendItems, function(legendItem, i) {
          var textWidth = ctx.measureText(legendItem.text).width;
          var width = boxWidth + fontSize / 2 + textWidth;
          var x = cursor.x;
          var y = cursor.y;
          rtlHelper.setWidth(me.minSize.width);
          if (isHorizontal) {
            if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
              y = cursor.y += itemHeight;
              cursor.line++;
              x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
            }
          } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
            cursor.line++;
            y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
          }
          var realX = rtlHelper.x(x);
          drawLegendBox(realX, y, legendItem);
          hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
          hitboxes[i].top = y;
          fillText2(realX, y, legendItem, textWidth);
          if (isHorizontal) {
            cursor.x += width + labelOpts.padding;
          } else {
            cursor.y += itemHeight;
          }
        });
        helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
      },
      _getLegendItemAt: function(x, y) {
        var me = this;
        var i, hitBox, lh;
        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          lh = me.legendHitBoxes;
          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];
            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              return me.legendItems[i];
            }
          }
        }
        return null;
      },
      handleEvent: function(e) {
        var me = this;
        var opts = me.options;
        var type = e.type === "mouseup" ? "click" : e.type;
        var hoveredItem;
        if (type === "mousemove") {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === "click") {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        }
        hoveredItem = me._getLegendItemAt(e.x, e.y);
        if (type === "click") {
          if (hoveredItem && opts.onClick) {
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }
            me._hoveredItem = hoveredItem;
          }
          if (opts.onHover && hoveredItem) {
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });
    function createNewLegendAndAttach(chart, legendOpts) {
      var legend2 = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart
      });
      core_layouts.configure(chart, legend2, legendOpts);
      core_layouts.addBox(chart, legend2);
      chart.legend = legend2;
    }
    var plugin_legend = {
      id: "legend",
      _element: Legend,
      beforeInit: function(chart) {
        var legendOpts = chart.options.legend;
        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function(chart) {
        var legendOpts = chart.options.legend;
        var legend2 = chart.legend;
        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
          if (legend2) {
            core_layouts.configure(chart, legend2, legendOpts);
            legend2.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend2) {
          core_layouts.removeBox(chart, legend2);
          delete chart.legend;
        }
      },
      afterEvent: function(chart, e) {
        var legend2 = chart.legend;
        if (legend2) {
          legend2.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;
    core_defaults._set("global", {
      title: {
        display: false,
        fontStyle: "bold",
        fullWidth: true,
        padding: 10,
        position: "top",
        text: "",
        weight: 2e3
      }
    });
    var Title = core_element.extend({
      initialize: function(config) {
        var me = this;
        helpers$1.extend(me, config);
        me.legendHitBoxes = [];
      },
      beforeUpdate: noop$2,
      update: function(maxWidth, maxHeight, margins) {
        var me = this;
        me.beforeUpdate();
        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins;
        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions();
        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels();
        me.beforeFit();
        me.fit();
        me.afterFit();
        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      beforeSetDimensions: noop$2,
      setDimensions: function() {
        var me = this;
        if (me.isHorizontal()) {
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight;
          me.top = 0;
          me.bottom = me.height;
        }
        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      beforeFit: noop$2,
      fit: function() {
        var me = this;
        var opts = me.options;
        var minSize = me.minSize = {};
        var isHorizontal = me.isHorizontal();
        var lineCount, textSize;
        if (!opts.display) {
          me.width = minSize.width = me.height = minSize.height = 0;
          return;
        }
        lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
        textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
        me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
        me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
      },
      afterFit: noop$2,
      isHorizontal: function() {
        var pos = this.options.position;
        return pos === "top" || pos === "bottom";
      },
      draw: function() {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;
        if (!opts.display) {
          return;
        }
        var fontOpts = helpers$1.options._parseFont(opts);
        var lineHeight = fontOpts.lineHeight;
        var offset = lineHeight / 2 + opts.padding;
        var rotation = 0;
        var top = me.top;
        var left = me.left;
        var bottom = me.bottom;
        var right = me.right;
        var maxWidth, titleX, titleY;
        ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
        ctx.font = fontOpts.string;
        if (me.isHorizontal()) {
          titleX = left + (right - left) / 2;
          titleY = top + offset;
          maxWidth = right - left;
        } else {
          titleX = opts.position === "left" ? left + offset : right - offset;
          titleY = top + (bottom - top) / 2;
          maxWidth = bottom - top;
          rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
        }
        ctx.save();
        ctx.translate(titleX, titleY);
        ctx.rotate(rotation);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        var text = opts.text;
        if (helpers$1.isArray(text)) {
          var y = 0;
          for (var i = 0; i < text.length; ++i) {
            ctx.fillText(text[i], 0, y, maxWidth);
            y += lineHeight;
          }
        } else {
          ctx.fillText(text, 0, 0, maxWidth);
        }
        ctx.restore();
      }
    });
    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title2 = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
      });
      core_layouts.configure(chart, title2, titleOpts);
      core_layouts.addBox(chart, title2);
      chart.titleBlock = title2;
    }
    var plugin_title = {
      id: "title",
      _element: Title,
      beforeInit: function(chart) {
        var titleOpts = chart.options.title;
        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function(chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;
        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);
          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    core_controller.helpers = helpers$1;
    core_helpers();
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip;
    core_controller.helpers.each(scales, function(scale2, type) {
      core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
    });
    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }
    core_controller.platform.initialize();
    var src = core_controller;
    if (typeof window !== "undefined") {
      window.Chart = core_controller;
    }
    core_controller.Chart = core_controller;
    core_controller.Legend = plugins.legend._element;
    core_controller.Title = plugins.title._element;
    core_controller.pluginService = core_controller.plugins;
    core_controller.PluginBase = core_controller.Element.extend({});
    core_controller.canvasHelpers = core_controller.helpers.canvas;
    core_controller.layoutService = core_controller.layouts;
    core_controller.LinearScaleBase = scale_linearbase;
    core_controller.helpers.each([
      "Bar",
      "Bubble",
      "Doughnut",
      "Line",
      "PolarArea",
      "Radar",
      "Scatter"
    ], function(klass) {
      core_controller[klass] = function(ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

// node_modules/chartjs-node-canvas/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ChartJSNodeCanvas = void 0;
  var freshRequire_1 = require_freshRequire();
  var ChartJSNodeCanvas2 = class {
    constructor(options) {
      if (options === null || typeof options !== "object") {
        throw new Error("An options parameter object is required");
      }
      if (!options.width || typeof options.width !== "number") {
        throw new Error("A width option is required");
      }
      if (!options.height || typeof options.height !== "number") {
        throw new Error("A height option is required");
      }
      this._width = options.width;
      this._height = options.height;
      const canvas = freshRequire_1.freshRequire("canvas");
      this._createCanvas = canvas.createCanvas;
      this._registerFont = canvas.registerFont;
      this._type = options.type && options.type.toLowerCase();
      this._chartJs = this.initialize(options.plugins, options.chartCallback);
    }
    renderToDataURL(configuration, mimeType = "image/png") {
      const chart = this.renderChart(configuration);
      return new Promise((resolve, reject) => {
        if (!chart.canvas) {
          return reject(new Error("Canvas is null"));
        }
        const canvas = chart.canvas;
        canvas.toDataURL(mimeType, (error, png) => {
          chart.destroy();
          if (error) {
            return reject(error);
          }
          return resolve(png);
        });
      });
    }
    renderToDataURLSync(configuration, mimeType = "image/png") {
      const chart = this.renderChart(configuration);
      if (!chart.canvas) {
        throw new Error("Canvas is null");
      }
      const canvas = chart.canvas;
      chart.destroy();
      const dataUrl = canvas.toDataURL(mimeType);
      return dataUrl;
    }
    renderToBuffer(configuration, mimeType = "image/png") {
      const chart = this.renderChart(configuration);
      return new Promise((resolve, reject) => {
        if (!chart.canvas) {
          throw new Error("Canvas is null");
        }
        const canvas = chart.canvas;
        canvas.toBuffer((error, buffer) => {
          chart.destroy();
          if (error) {
            return reject(error);
          }
          return resolve(buffer);
        }, mimeType);
      });
    }
    renderToBufferSync(configuration, mimeType = "image/png") {
      const chart = this.renderChart(configuration);
      if (!chart.canvas) {
        throw new Error("Canvas is null");
      }
      const canvas = chart.canvas;
      const buffer = canvas.toBuffer(mimeType);
      chart.destroy();
      return buffer;
    }
    renderToStream(configuration, mimeType = "image/png") {
      const chart = this.renderChart(configuration);
      if (!chart.canvas) {
        throw new Error("Canvas is null");
      }
      const canvas = chart.canvas;
      setImmediate(() => chart.destroy());
      switch (mimeType) {
        case "image/png":
          return canvas.createPNGStream();
        case "image/jpeg":
          return canvas.createJPEGStream();
        case "application/pdf":
          return canvas.createPDFStream();
        default:
          throw new Error(`Un-handled mimeType: ${mimeType}`);
      }
    }
    registerFont(path, options) {
      this._registerFont(path, options);
    }
    initialize(plugins, chartCallback) {
      const chartJs = require_Chart();
      if (plugins === null || plugins === void 0 ? void 0 : plugins.requireChartJSLegacy) {
        for (const plugin of plugins.requireChartJSLegacy) {
          require(plugin);
          delete require.cache[require.resolve(plugin)];
        }
      }
      if (plugins === null || plugins === void 0 ? void 0 : plugins.globalVariableLegacy) {
        global.Chart = chartJs;
        for (const plugin of plugins.globalVariableLegacy) {
          freshRequire_1.freshRequire(plugin);
        }
        delete global.Chart;
      }
      if (plugins === null || plugins === void 0 ? void 0 : plugins.modern) {
        for (const plugin of plugins.modern) {
          if (typeof plugin === "string") {
            chartJs.plugins.register(freshRequire_1.freshRequire(plugin));
          } else {
            chartJs.plugins.register(plugin);
          }
        }
      }
      if (plugins === null || plugins === void 0 ? void 0 : plugins.requireLegacy) {
        for (const plugin of plugins.requireLegacy) {
          chartJs.plugins.register(freshRequire_1.freshRequire(plugin));
        }
      }
      if (chartCallback) {
        chartCallback(chartJs);
      }
      delete require.cache[require.resolve("chart.js")];
      return chartJs;
    }
    renderChart(configuration) {
      const canvas = this._createCanvas(this._width, this._height, this._type);
      canvas.style = {};
      configuration.options = configuration.options || {};
      configuration.options.responsive = false;
      configuration.options.animation = false;
      const context = canvas.getContext("2d");
      return new this._chartJs(context, configuration);
    }
  };
  exports2.ChartJSNodeCanvas = ChartJSNodeCanvas2;
});

// index.js
var import_dotenv2 = __toModule(require_main());
var import_discord4 = __toModule(require_src2());

// commands/index.js
var import_discord = __toModule(require_src2());

// commands/Command.js
var Command = class {
  constructor(name, alias = [], params = [], description = "") {
    this._name = name;
    if (Array.isArray(alias)) {
      this._alias = alias;
    } else {
      this._alias = [alias];
    }
    if (Array.isArray(params)) {
      this._params = params;
    } else {
      this._params = [params];
    }
    if (Array.isArray(description)) {
      this._description = description;
    } else {
      this._description = [description];
    }
  }
  get name() {
    return this._name;
  }
  get alias() {
    return this._alias;
  }
  get params() {
    return this._params;
  }
  get description() {
    return this._description;
  }
  execute(msg, args) {
    console.error("WARNING: Abstract Command.execute() called");
  }
};
var Command_default = Command;

// commands/scrummy/ping.js
var PingCommand = class extends Command_default {
  constructor() {
    super("!ping", [], [], "Ping the bot, responds with pong");
  }
  execute(msg, args) {
    msg.reply("pong");
  }
};
var ping = new PingCommand();
var ping_default = ping;

// commands/DBCommand.js
var import_debug2 = __toModule(require_src3());

// commands/DBCommandBase.js
var import_mongodb = __toModule(require_mongodb());
var import_dotenv = __toModule(require_main());
var import_debug = __toModule(require_src3());
var debug = import_debug.default("bot:db_command_base");
import_dotenv.default.config();
var DEV_DB_URL = "mongodb://localhost:27017/ScrummyData";
var PROD_DB_URL = `mongodb+srv://${process.env.DB_USER}:${process.env.DB_PW}@profberriercluster.zzyhu.mongodb.net/ScrummyData?retryWrites=true&w=majority`;
var DBCommandBase = class extends Command_default {
  constructor(name, alias, params, description) {
    super(name, alias, params, description);
    this.checkConnection();
  }
  async checkConnection() {
    if (!DBCommandBase.CLIENT_HANDLE && !DBCommandBase.CONNECTING) {
      DBCommandBase.CONNECTING = true;
      try {
        await DBCommandBase.connect();
      } catch (err) {
        console.error("Something went wrong during DB connection");
        console.error(err);
      }
      DBCommandBase.CONNECTING = false;
    }
  }
  static get db() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      throw new Error("Can't retrieve database handle, no connection to Server.");
    }
    return DBCommandBase.CLIENT_HANDLE.db("ScrummyData");
  }
  static connect() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      return new Promise((resolve, reject) => {
        const URL = true ? DEV_DB_URL : PROD_DB_URL;
        debug(`Connecting to MongoDB '${true ? "DEV server" : "PROD server"}'`);
        const connectPromise = import_mongodb.MongoClient.connect(URL, {useUnifiedTopology: true, useNewUrlParser: true});
        connectPromise.then((result) => {
          DBCommandBase.CLIENT_HANDLE = result;
          debug("Connected to database");
        }).catch((err) => {
          console.error("CRITICAL: Database connection failed");
          return reject(err);
        });
      });
    }
    debug("Reusing existing MongoDB connection");
    return Promise.resolve(DBCommandBase.CLIENT_HANDLE);
  }
  static disconnect() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      return Promise.resolve(false);
    }
    return new Promise((resolve, reject) => {
      debug("Closing mongoDB database ...");
      const closePromise = DBCommandBase.CLIENT_HANDLE.close();
      closePromise.then(() => {
        DBCommandBase.CLIENT_HANDLE = null;
        debug("MongoDB connection closed.");
        return resolve(true);
      }).catch((err) => {
        debug("Failed to close MongoDB connection");
        debug(err);
        return reject(err);
      });
    });
  }
};
DBCommandBase.CLIENT_HANDLE = null;
DBCommandBase.CONNECTING = false;
var DBCommandBase_default = DBCommandBase;

// commands/DBCommand.js
var debug2 = import_debug2.default("bot:db_command");
var DBCommand = class extends DBCommandBase_default {
  checkIfUserExists(discordID) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").findOne({discordID}, (err, result) => {
        if (err) {
          debug2("Error checking for user");
          debug2(err);
          return reject(err);
        }
        if (!result) {
          return resolve(false);
        }
        if (result.timeCardVersion === 1) {
          this.upgradeUserTimeCard(result._id).then((result2) => {
            return resolve(result2._id);
          }).catch((err2) => {
            debug2("Error upgrading timecard");
            debug2(err2);
            return reject(err2);
          });
        } else {
          return resolve(result._id);
        }
      });
    });
  }
  createUser(discordID, discordName) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").insertOne({discordID, discordName}, (err, result) => {
        if (err) {
          debug2("Error creating user");
          debug2(err);
          return reject(err);
        }
        return resolve(result.insertedId);
      });
    });
  }
  upgradeUserTimeCard(dbID) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").aggregate([
        {$match: {_id: dbID}},
        {$unwind: {path: "$timeCard"}},
        {$project: {_id: 0, timeCard: 1}}
      ], (err, cursor) => {
        if (err || !cursor) {
          debug2("Error getting user's time card");
          debug2(err);
          return reject(err);
        }
        cursor.toArray((err2, docs) => {
          if (err2) {
            debug2("Error converting time card cursor to array for update");
            debug2(err2);
            return reject(err2);
          }
          const newTimeCard = docs.reduce((accumulate, curVal) => {
            if (!accumulate[curVal.timeCard.serverID]) {
              accumulate[curVal.timeCard.serverID] = [];
            }
            accumulate[curVal.timeCard.serverID].push({
              punch: curVal.timeCard.punch,
              time: curVal.timeCard.time
            });
            return accumulate;
          }, {});
          DBCommandBase_default.db.collection("Users").updateOne({_id: dbID}, {$set: {timeCardVersion: 2, timeCard: newTimeCard}}, (err3, result) => {
            if (err3) {
              debug2("Error updating time card");
              debug2(err3);
              return reject(err3);
            }
            if (result.modifiedCount !== 1) {
              return resolve(false);
            }
            return resolve(true);
          });
        });
      });
    });
  }
  getUsersOnServer(serverID) {
    const fieldMatch = {};
    fieldMatch[`timeCard.${serverID}`] = {$exists: true};
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").aggregate([
        {$match: fieldMatch},
        {$project: {discordName: 1, timeCard: {$last: `$timeCard.${serverID}`}}}
      ], (err, cursor) => {
        if (err) {
          debug2("Error retrieving users on server");
          debug2(err);
          return reject(err);
        }
        cursor.toArray((err2, docs) => {
          if (err2) {
            debug2("Converting users to array");
            debug2(err2);
            return reject(err2);
          }
          if (!docs || !Array.isArray(docs)) {
            return resolve([]);
          }
          return resolve(docs);
        });
      });
    });
  }
  getServerDataInRange(start, end, firstID, secondID) {
    const serverID = secondID || firstID;
    const userID = secondID ? firstID : null;
    const fieldMatch = {};
    fieldMatch[`timeCard.${serverID}`] = {$exists: true};
    if (userID) {
      fieldMatch._id = userID;
    }
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").aggregate([
        {$match: fieldMatch},
        {
          $project: {
            discordName: 1,
            timeCard: {
              $filter: {
                input: `$timeCard.${serverID}`,
                as: "punch",
                cond: {
                  $and: [
                    {$gte: ["$$punch.time", start]},
                    {$lte: ["$$punch.time", end]}
                  ]
                }
              }
            }
          }
        },
        {$unwind: "$timeCard"},
        {
          $replaceRoot: {
            newRoot: {$mergeObjects: ["$$ROOT", "$timeCard"]}
          }
        },
        {$project: {timeCard: 0}}
      ], (err, cursor) => {
        if (err) {
          debug2("Error retrieving range data");
          debug2(err);
          return reject(err);
        }
        cursor.toArray((err2, docs) => {
          if (err2) {
            debug2("Error converting range data to array");
            debug2(err2);
            return reject(err2);
          }
          if (!docs || !Array.isArray(docs)) {
            return resolve([]);
          }
          return resolve(docs);
        });
      });
    });
  }
  getOldUsers() {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").aggregate([
        {$match: {timeCardVersion: 1}},
        {$project: {_id: 1}}
      ], (err, cursor) => {
        if (err) {
          debug2("Error retrieving old users on server");
          debug2(err);
          return reject(err);
        }
        cursor.toArray((err2, docs) => {
          if (err2) {
            debug2("Error converting old users to array");
            debug2(err2);
            return reject(err2);
          }
          if (!docs || !Array.isArray(docs)) {
            return resolve([]);
          }
          return resolve(docs);
        });
      });
    });
  }
  getUserTimeCard(dbID, serverID) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").findOne({_id: dbID}, {projection: {timeCard: `$timeCard.${serverID}`}}, (err, result) => {
        if (err) {
          debug2("Error retrieving timecard");
          debug2(err);
          return reject(err);
        }
        if (!result || !result.timeCard) {
          return resolve([]);
        }
        return resolve(result.timeCard);
      });
    });
  }
  setUserTimecard(dbID, serverID, newTimeCard) {
    const setObj = {};
    setObj[`timeCard.${serverID}`] = newTimeCard;
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").updateOne({_id: dbID}, {$set: setObj}, (err, result) => {
        if (err || !result || result.modifiedCount !== 1) {
          debug2("Error setting/updating timecard");
          debug2(err);
          return reject(err);
        }
        return resolve();
      });
    });
  }
  getLastPunch(dbID, serverID) {
    return new Promise((resolve, reject) => {
      this.getUserTimeCard(dbID, serverID).then((timeCard) => {
        if (timeCard.length > 0) {
          return resolve(timeCard[timeCard.length - 1]);
        }
        return resolve({});
      }).catch((err) => {
        return reject(err);
      });
    });
  }
  punchUserTimeCard(dbID, serverID, punchStr) {
    return new Promise((resolve, reject) => {
      const pushOp = {};
      pushOp[`timeCard.${serverID}`] = {punch: punchStr, time: new Date()};
      DBCommandBase_default.db.collection("Users").updateOne({_id: dbID}, {$push: pushOp}, (err, result) => {
        if (err) {
          debug2("Error punching time card");
          debug2(err);
          return reject(err);
        }
        if (result.modifiedCount !== 1) {
          return reject(new Error("Time Card Punch failed to modify an entry"));
        }
        return resolve(true);
      });
    });
  }
};
var DBCommand_default = DBCommand;

// commands/util.js
var d3 = __toModule(require_d3_time());
var dateFormatter = Intl.DateTimeFormat("en-US", {
  timeZone: "America/Chicago",
  weekday: "short",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric"
});
var DAY_NAMES = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
function formatDate(date) {
  return "`" + dateFormatter.format(date) + "`";
}
function formatDuration(start, end = Date.now()) {
  let minutes = start;
  if (typeof start === "object" && start instanceof Date) {
    minutes = minutesBetween(start, end);
  }
  return `\`${Math.floor(minutes / 60)}h ${minutes % 60}m\``;
}
function minutesBetween(start, end = Date.now()) {
  return d3.timeMinute.range(start, end).length;
}
function daysBetween(dayName, start, end = Date.now()) {
  const dayNameAdj = dayName.substr(0, 1).toUpperCase() + dayName.substr(1).toLowerCase();
  if (DAY_NAMES.indexOf(dayNameAdj) === -1) {
    console.error('Error: Unknown day name"' + dayName + "'");
    return -1;
  }
  return d3[`time${dayNameAdj}`].range(start, end).length;
}
function mondaysBetween(start, end = Date.now()) {
  return daysBetween("Monday", start, end);
}
function sumPunches(punches) {
  let minutes = 0;
  let lastPunchIn = 0;
  punches.forEach((entry) => {
    if (entry.punch === "in") {
      lastPunchIn = entry.time;
    } else {
      if (lastPunchIn instanceof Date) {
        minutes += minutesBetween(lastPunchIn, entry.time);
        lastPunchIn = 0;
      }
    }
  });
  if (lastPunchIn instanceof Date) {
    minutes += minutesBetween(lastPunchIn, Date.now());
  }
  return minutes;
}

// commands/scrummy/clockIn.js
var ClockInCommand = class extends DBCommand_default {
  constructor() {
    super("!clockin", ["!ci"], [], "Clock in and begin tracking your time");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      let dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply(`Creating new ScrummyBot entry for ${msg.author.tag}`);
        dbId = await this.createUser(msg.author.id, msg.author.tag);
      } else {
        const lastPunch = await this.getLastPunch(dbId, msg.guild.id);
        if (lastPunch.punch === "in") {
          msg.reply(`You already clocked in to this server on ${formatDate(lastPunch.time)}. Try !clockout first.`);
          return;
        }
      }
      msg.reply(`Clocking in for ${msg.author.username}`);
      await this.punchUserTimeCard(dbId, msg.guild.id, "in");
    } catch (err) {
      console.error("Error clocking in");
      console.error(err);
    }
  }
};
var clockIn = new ClockInCommand();
var clockIn_default = clockIn;

// commands/scrummy/clockOut.js
var ClockOutCommand = class extends DBCommand_default {
  constructor() {
    super("!clockout", ["!co"], [], "Clock out and stop tracking your time");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      let lastPunch = {};
      let dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply(`Creating new ScrummyBot entry for ${msg.author.tag}`);
        dbId = await this.createUser(msg.author.id, msg.author.tag, msg.guild.id);
      } else {
        lastPunch = await this.getLastPunch(dbId, msg.guild.id);
        if (lastPunch.punch === "out") {
          msg.reply(`You clocked out of this server on ${formatDate(lastPunch.time)}. Try !clockin first.`);
          return;
        }
      }
      msg.reply(`Clocking out for ${msg.author.username}.
You worked for ${formatDuration(lastPunch.time)}`);
      await this.punchUserTimeCard(dbId, msg.guild.id, "out");
    } catch (err) {
      console.error("Error clocking out");
      console.error(err);
    }
  }
};
var clockOut = new ClockOutCommand();
var clockOut_default = clockOut;

// commands/scrummy/status.js
var StatusCommand = class extends DBCommand_default {
  constructor() {
    super("!status", ["!stat", "!st"], [], "Report time tacking status for this server.");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      const timeCard = await this.getUserTimeCard(dbId, msg.guild.id);
      if (!timeCard || timeCard.length === 0) {
        msg.reply("You haven't clocked in on this server yet. Try !clockin first.");
        return;
      }
      let mondayIndex = timeCard.length - 1;
      while (mondayIndex >= 0 && mondaysBetween(timeCard[mondayIndex].time) === 0) {
        mondayIndex--;
      }
      const timeCardWeek = timeCard.slice(mondayIndex + 1);
      let message = "";
      const lastPunch = timeCard[timeCard.length - 1];
      if (lastPunch.punch === "out") {
        message += `You are currently clocked out. You clocked out on ${formatDate(lastPunch.time)}.`;
      } else {
        message += `You are currently clocked in and have been working for ${formatDuration(lastPunch.time)}.`;
      }
      if (timeCardWeek.length === 0) {
        message += "\nYou have not clocked any hours since Monday.";
      } else {
        const minutesWeek = sumPunches(timeCardWeek);
        message += `
Since Monday, you have worked for ${formatDuration(minutesWeek)}`;
      }
      msg.reply(message);
    } catch (err) {
      console.error("Error reporting status");
      console.error(err);
    }
  }
};
var Status = new StatusCommand();
var status_default = Status;

// commands/scrummy/list.js
var ListCommand = class extends DBCommand_default {
  constructor() {
    super("!list", ["!ls"], ["n"], ['List your "n" most recent punches on this', "server (defaults to 4)."]);
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      let timeCard = await this.getUserTimeCard(dbId, msg.guild.id);
      if (!timeCard || timeCard.length === 0) {
        msg.reply("You haven't clocked in on this server yet. Try !clockin first.");
        return;
      }
      const count = args[0] && !isNaN(parseInt(args[0])) ? args[0] : 4;
      if (timeCard.length > count) {
        timeCard = timeCard.slice(timeCard.length - count);
      }
      if (timeCard.length === 0) {
        msg.reply("The list is empty, try again with a higher number.");
      } else {
        const verb = timeCard.length === 1 ? "is" : "are";
        const plural = timeCard.length === 1 ? "punch" : "punches";
        let message = `Here ${verb} your last ${timeCard.length} ${plural}`;
        timeCard.forEach((curPunch, i) => {
          message += `
${i + 1}) Clock ${curPunch.punch}: ${formatDate(curPunch.time)}`;
        });
        msg.reply(message);
      }
    } catch (err) {
      console.error("Error reporting list");
      console.error(err);
    }
  }
};
var List = new ListCommand();
var list_default = List;

// commands/scrummy/summary.js
var SummaryCommand = class extends DBCommand_default {
  constructor() {
    super("!summary", ["!sum"], ["weekday"], ["List times worked (and length) back to", 'indicated day (default weekday: "sunday").']);
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      const timeCard = await this.getUserTimeCard(dbId, msg.guild.id);
      if (!timeCard || timeCard.length === 0) {
        msg.reply("You haven't clocked in on this server yet. Try !clockin first.");
        return;
      }
      const day = args[0] ? args[0] : "sunday";
      let dayIndex = timeCard.length - 1;
      while (dayIndex >= 0 && daysBetween(day, timeCard[dayIndex].time) === 0) {
        dayIndex--;
      }
      const timeCardWeek = timeCard.slice(dayIndex + 1);
      if (timeCardWeek.length === 0) {
        msg.reply("No tracked work found in that range.");
      } else {
        let message = `Here is you summary of work since ${day}:
`;
        for (let i = 0; i < timeCardWeek.length - 1; i += 2) {
          const start = timeCardWeek[i].time;
          const end = timeCardWeek[i + 1].time;
          message += `- from ${formatDate(start)} to ${formatDate(end)} you worked for ${formatDuration(start, end)}
`;
        }
        if (timeCardWeek.length % 2 === 1) {
          const clockIn2 = timeCardWeek[timeCardWeek.length - 1].time;
          message += `- you clocked in on ${formatDate(clockIn2)} and have been working for ${formatDuration(clockIn2)}
`;
        }
        const minutesWeek = sumPunches(timeCardWeek);
        message += `TOTAL since ${day}: ${formatDuration(minutesWeek)}`;
        msg.reply(message);
      }
    } catch (err) {
      console.error("Error reporting summary");
      console.error(err);
    }
  }
};
var Summary = new SummaryCommand();
var summary_default = Summary;

// commands/scrummy/adjust.js
var AdjustCommand = class extends DBCommand_default {
  constructor() {
    super("!adjust", ["!adj"], ["n", "new_time"], ["Adjust a time-card punch to a new time.", "Use !list to get valid n value.", '"new_time" must be parsable by Date.parse().']);
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    if (args.length < 1 || isNaN(args[0])) {
      msg.reply("Punch index is missing or invalid. Run !list first for some valid indexes.");
      return;
    }
    if (args.length < 2 || isNaN(Date.parse(args[1]))) {
      msg.reply("New time missing or invalid.\n```Example: 2021-04-02T13:25:30\n         YYYY-MM-DDTHH:MM:SS```\n(note letter T and 24-hour format)");
      return;
    }
    if (args[1].indexOf("T") === -1) {
      args[1] += "T00:00:00";
    }
    const index = parseInt(args[0]) - 1;
    const newDate = Date.parse(args[1]);
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      const timeCard = await this.getUserTimeCard(dbId, msg.guild.id);
      if (!timeCard || timeCard.length === 0) {
        msg.reply("You haven't clocked in on this server yet. Try !clockin first.");
        return;
      }
      if (index < 0 || index >= timeCard.length) {
        msg.reply("Punch index is invalid. Run !list first for some valid indexes.");
        return;
      }
      msg.reply(`Attempting to adjust entry ${index + 1} to time ${formatDate(newDate)} ...`);
      const newTimeCard = [...timeCard];
      newTimeCard[index].time = new Date(newDate);
      await this.setUserTimecard(dbId, msg.guild.id, newTimeCard);
      msg.reply("Entry updated");
    } catch (err) {
      console.error("Error adjusting entry");
      console.error(err);
    }
  }
};
var Adjust = new AdjustCommand();
var adjust_default = Adjust;

// commands/scrummy/users.js
var UsersCommand = class extends DBCommand_default {
  constructor() {
    super("!users", ["!us"], [], ["List all the users on this server and their", "current status."]);
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      const allUsers = await this.getUsersOnServer(msg.guild.id);
      if (!allUsers || allUsers.length === 0) {
        msg.reply("No users found (that's werid!)");
        return;
      }
      let message = `Scrummy Bot has seen these users on ${msg.guild.name}
\`\`\``;
      allUsers.forEach((user) => {
        message += `- ${user.discordName} is clocked ${user.timeCard.punch}
`;
      });
      message += "```";
      msg.reply(message);
    } catch (err) {
      console.error("Error reporting users");
      console.error(err);
    }
  }
};
var Users = new UsersCommand();
var users_default = Users;

// chartBuilder.js
var import_chartjs_node_canvas = __toModule(require_dist2());
var d32 = __toModule(require_d3_time());
var ChartBuilder = class {
  constructor(width = 1e3, height = 600) {
    const chartCallback = (ChartJS) => {
      ChartJS.defaults.global.elements.rectangle.borderWidth = 2;
      ChartJS.plugins.register({
        beforeDraw: (chart, options) => {
          const ctx = chart.ctx;
          ctx.save();
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }
      });
    };
    this.dateFormatter = Intl.DateTimeFormat("en-US", {
      timeZone: "America/Chicago",
      weekday: "short",
      month: "short",
      day: "numeric"
    });
    this.chartJSNodeCanvas = new import_chartjs_node_canvas.ChartJSNodeCanvas({width, height, chartCallback});
  }
  reBinTimeCardData(rangeStart, rangeEnd, data) {
    const localEnd = new Date(rangeEnd);
    localEnd.setDate(localEnd.getDate() + 1);
    const binnedData = {};
    const days = d32.timeDay.range(rangeStart, localEnd);
    days.forEach((curDay) => {
      binnedData[curDay] = 0;
    });
    for (let i = 0; i < data.length - 1; i++) {
      if (data[i].punch === "out")
        continue;
      const clockIn2 = data[i].time;
      const clockOut2 = data[i + 1].time;
      const dayBin = d32.timeDay(clockIn2);
      if (!binnedData[dayBin]) {
        binnedData[dayBin] = 0;
      }
      binnedData[dayBin] += minutesBetween(clockIn2, clockOut2);
    }
    return binnedData;
  }
  reBinServerTimeCardData(rangeStart, rangeEnd, data) {
    const localEnd = new Date(rangeEnd);
    localEnd.setDate(localEnd.getDate() + 1);
    const bins = {};
    const days = d32.timeDay.range(rangeStart, localEnd);
    days.forEach((curDay) => {
      bins[curDay] = 0;
    });
    const binnedDataSeries = {};
    for (let i = 0; i < data.length - 1; i++) {
      if (data[i].punch === "out")
        continue;
      const clockIn2 = data[i].time;
      const clockOut2 = data[i + 1].time;
      if (!binnedDataSeries[data[i].discordName]) {
        binnedDataSeries[data[i].discordName] = {...bins};
      }
      const curUserBins = binnedDataSeries[data[i].discordName];
      const dayBin = d32.timeDay(clockIn2);
      if (!curUserBins[dayBin]) {
        curUserBins[dayBin] = 0;
      }
      curUserBins[dayBin] += minutesBetween(clockIn2, clockOut2);
    }
    return binnedDataSeries;
  }
  makeUserHoursChart(userName, rangeStart, rangeEnd, data) {
    const binData = this.reBinTimeCardData(rangeStart, rangeEnd, data);
    const chartConfig = {
      type: "bar",
      data: {
        labels: Object.keys(binData).map((label) => {
          return this.dateFormatter.format(new Date(label));
        }),
        datasets: [
          {
            borderColor: "rgb(255,+99,+132)",
            backgroundColor: "rgb(255,+99,+132)",
            data: Object.values(binData)
          }
        ]
      },
      options: {
        legend: {display: false},
        title: {
          display: true,
          text: [
            `Hours Worked for ${userName}`,
            `${this.dateFormatter.format(rangeStart)} to ${this.dateFormatter.format(rangeEnd)}`
          ]
        },
        scales: {
          xAxes: [{scaleLabel: {display: true, labelString: "Day"}}],
          yAxes: [{scaleLabel: {display: true, labelString: "Minutes"}}]
        }
      }
    };
    return this.chartJSNodeCanvas.renderToBuffer(chartConfig, "image/jpeg");
  }
  makeServerHoursChart(serverName, rangeStart, rangeEnd, data) {
    const binSeriesData = this.reBinServerTimeCardData(rangeStart, rangeEnd, data);
    const chartConfig = {
      type: "bar",
      data: {
        labels: Object.keys(Object.values(binSeriesData)[0]).map((label) => {
          return this.dateFormatter.format(new Date(label));
        }),
        datasets: Object.entries(binSeriesData).map(([seriesName, binData], i) => {
          return {
            label: seriesName,
            borderColor: ChartBuilder.BACKGROUND_COLORS[i % ChartBuilder.BACKGROUND_COLORS.length],
            backgroundColor: ChartBuilder.BORDER_COLORS[i % ChartBuilder.BORDER_COLORS.length],
            data: Object.values(binData)
          };
        })
      },
      options: {
        legend: {
          position: "right",
          align: "start"
        },
        title: {
          display: true,
          text: [
            `Hours Worked for users in the '${serverName}' server`,
            `${this.dateFormatter.format(rangeStart)} to ${this.dateFormatter.format(rangeEnd)}`
          ]
        },
        scales: {
          xAxes: [{scaleLabel: {display: true, labelString: "Day"}}],
          yAxes: [{scaleLabel: {display: true, labelString: "Minutes"}}]
        }
      }
    };
    return this.chartJSNodeCanvas.renderToBuffer(chartConfig, "image/jpeg");
  }
};
ChartBuilder.BACKGROUND_COLORS = [
  "rgba(230,  25,  75, 0.2)",
  "rgba( 60, 180,  75, 0.2)",
  "rgba(255, 225,  25, 0.2)",
  "rgba(  0, 130, 200, 0.2)",
  "rgba(245, 130,  48, 0.2)",
  "rgba(145,  30, 180, 0.2)",
  "rgba( 70, 240, 240, 0.2)",
  "rgba(240,  50, 230, 0.2)",
  "rgba(210, 245,  60, 0.2)",
  "rgba(250, 190, 212, 0.2)",
  "rgba(  0, 128, 128, 0.2)",
  "rgba(220, 190, 255, 0.2)",
  "rgba(170, 110,  40, 0.2)",
  "rgba(255, 250, 200, 0.2)",
  "rgba(128,   0,   0, 0.2)",
  "rgba(170, 255, 195, 0.2)",
  "rgba(128, 128,   0, 0.2)",
  "rgba(255, 215, 180, 0.2)",
  "rgba(  0,   0, 128, 0.2)",
  "rgba(128, 128, 128, 0.2)"
];
ChartBuilder.BORDER_COLORS = [
  "rgba(230,  25,  75, 1)",
  "rgba( 60, 180,  75, 1)",
  "rgba(255, 225,  25, 1)",
  "rgba(  0, 130, 200, 1)",
  "rgba(245, 130,  48, 1)",
  "rgba(145,  30, 180, 1)",
  "rgba( 70, 240, 240, 1)",
  "rgba(240,  50, 230, 1)",
  "rgba(210, 245,  60, 1)",
  "rgba(250, 190, 212, 1)",
  "rgba(  0, 128, 128, 1)",
  "rgba(220, 190, 255, 1)",
  "rgba(170, 110,  40, 1)",
  "rgba(255, 250, 200, 1)",
  "rgba(128,   0,   0, 1)",
  "rgba(170, 255, 195, 1)",
  "rgba(128, 128,   0, 1)",
  "rgba(255, 215, 180, 1)",
  "rgba(  0,   0, 128, 1)",
  "rgba(128, 128, 128, 1)"
];
var chartBuilder_default = ChartBuilder;

// commands/scrummy/dataUser.js
var DataUserCommand = class extends DBCommand_default {
  constructor() {
    super("!datauser", ["!du"], ["start", "end"], [
      "List all data in a range for your account.",
      '"start" and "end" must be parsable by Date.parse().',
      '"end" is optional and defaults to now'
    ]);
    this.chartBuilder = new chartBuilder_default();
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    if (args.length < 1 || isNaN(Date.parse(args[0]))) {
      msg.reply("Start time missing or invalid.\n```Example: 2021-04-02T13:25:30\n         YYYY-MM-DDTHH:MM:SS```\n(note letter T and 24-hour format)");
      return;
    }
    if (args.length >= 2 && isNaN(Date.parse(args[1]))) {
      msg.reply("End time is invalid.\n```Example: 2021-04-02T13:25:30\n         YYYY-MM-DDTHH:MM:SS```\n(note letter T and 24-hour format)");
      return;
    }
    if (args[0].indexOf("T") === -1) {
      args[0] += "T00:00:00";
    }
    if (args.length >= 2 && args[1].indexOf("T") === -1) {
      args[1] += "T00:00:00";
    }
    const start = new Date(Date.parse(args[0]));
    const end = args.length >= 2 ? new Date(Date.parse(args[1])) : Date.now();
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      const timeCardInRange = await this.getServerDataInRange(start, end, dbId, msg.guild.id);
      if (!timeCardInRange || timeCardInRange.length === 0) {
        msg.reply("No data returned.");
        return;
      }
      const imageBuffer = await this.chartBuilder.makeUserHoursChart(timeCardInRange[0].discordName, start, end, timeCardInRange);
      msg.channel.send(`${msg.author} Here is your data`, {files: [imageBuffer]});
    } catch (err) {
      console.error("Error reporting user data");
      console.error(err);
    }
  }
};
var DataUser = new DataUserCommand();
var dataUser_default = DataUser;

// commands/scrummy/dataServer.js
var DataServerCommand = class extends DBCommand_default {
  constructor() {
    super("!dataserver", ["!ds"], ["start", "end"], [
      "List all data in a range for this entire server.",
      '"start" and "end" must be parsable by Date.parse().',
      '"end" is optional and defaults to now'
    ]);
    this.chartBuilder = new chartBuilder_default();
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    if (args.length < 1 || isNaN(Date.parse(args[0]))) {
      msg.reply("Start time missing or invalid.\n```Example: 2021-04-02T13:25:30\n         YYYY-MM-DDTHH:MM:SS```\n(note letter T and 24-hour format)");
      return;
    }
    if (args.length >= 2 && isNaN(Date.parse(args[1]))) {
      msg.reply("End time is invalid.\n```Example: 2021-04-02T13:25:30\n         YYYY-MM-DDTHH:MM:SS```\n(note letter T and 24-hour format)");
      return;
    }
    if (args[0].indexOf("T") === -1) {
      args[0] += "T00:00:00";
    }
    if (args.length >= 2 && args[1].indexOf("T") === -1) {
      args[1] += "T00:00:00";
    }
    const start = new Date(Date.parse(args[0]));
    const end = args.length >= 2 ? new Date(Date.parse(args[1])) : Date.now();
    try {
      const timeCardInRange = await this.getServerDataInRange(start, end, msg.guild.id);
      if (!timeCardInRange || timeCardInRange.length === 0) {
        msg.reply("No data returned.");
        return;
      }
      const imageBuffer = await this.chartBuilder.makeServerHoursChart(msg.guild.name, start, end, timeCardInRange);
      msg.channel.send(`${msg.author} Here is your data`, {files: [imageBuffer]});
    } catch (err) {
      console.error("Error reporting user data");
      console.error(err);
    }
  }
};
var DataServer = new DataServerCommand();
var dataServer_default = DataServer;

// commands/index.js
var commands = [ping_default, clockIn_default, clockOut_default, status_default, list_default, summary_default, adjust_default, users_default, dataUser_default, dataServer_default];
function makeHelpString(command) {
  let cmdList = command.name;
  if (command.alias.length > 0) {
    cmdList += ", " + command.alias.join(", ");
  }
  let params = "[n/a]";
  if (command.params.length > 0) {
    params = command.params.join(", ");
  }
  let description = "";
  let first = true;
  command.description.forEach((descLine) => {
    if (first) {
      description += descLine;
    } else {
      description += "\n" + " ".repeat(35) + descLine;
    }
    first = false;
  });
  return cmdList.padEnd(20, " ") + " " + params.padEnd(13, " ") + " " + description + "\n";
}
var helpDescription = "Scrummy bot supports these commands:\n```";
helpDescription += "Command              Params        Description\n";
helpDescription += "==============================================================================\n";
commands.forEach((curCmd) => {
  helpDescription += makeHelpString(curCmd);
});
var Help = class extends Command_default {
  constructor() {
    super("!help", ["!?"], [], "Show this list of commands");
    this.output = helpDescription;
    this.output += makeHelpString(this);
    this.output += "```";
  }
  execute(msg, args) {
    msg.reply(this.output);
  }
};
var help = new Help();
commands.push(help);
var BotCommands = new import_discord.default.Collection();
commands.forEach((cmd) => {
  BotCommands.set(cmd.name, cmd);
  cmd.alias.forEach((aliasName) => {
    BotCommands.set(aliasName, cmd);
  });
});
var commands_default = BotCommands;

// clientMonitor/index.js
var import_debug5 = __toModule(require_src3());

// clientMonitor/GuildMonitor.js
var import_discord2 = __toModule(require_src2());
var import_debug3 = __toModule(require_src3());
var debug3 = import_debug3.default("bot:guild_monitor");
var GuildMonitor = class {
  constructor(djsGuild) {
    this.update(djsGuild);
    debug3(`Monitor installed for server "${this.guild.name}"`);
  }
  update(djsGuild) {
    this.guild = djsGuild;
  }
  guildBanAdd(guild, user) {
    debug3(`${user.tag} was added to the BAN list for "${guild.name}"`);
  }
  guildBanRemove(guild, user) {
    debug3(`${user.tag} was removed from the BAN list for "${guild.name}"`);
  }
  guildIntegrationsUpdate(guild) {
    debug3(`The "${guild.name}" server has updated its integrations.`);
  }
  guildUnavailable(guild) {
    debug3(`The "${guild.name}" server has become unavailable.`);
  }
};
GuildMonitor.DISPATCH_EVENTS = [
  "guildBanAdd",
  "guildBanRemove",
  "guildIntegrationsUpdate",
  "guildUnavailable"
];
var GuildMonitor_default = GuildMonitor;

// clientMonitor/MemberMonitor.js
var import_discord3 = __toModule(require_src2());
var import_debug4 = __toModule(require_src3());
var debug4 = import_debug4.default("bot:member_monitor");
var MemberMonitor = class {
  constructor(djsGuildMember, guildMonitor) {
    this.update(djsGuildMember, guildMonitor);
    debug4(`Monitor installed for guild member "${this.guildMember.nickname}" on "${this.guildMonitor.guild.name}"`);
  }
  update(djsGuildMember, guildMonitor) {
    this.guildMember = djsGuildMember;
    this.guildMonitor = guildMonitor;
  }
  guildMemberAvailable(member) {
    debug4(`${member.nickname} became available`);
  }
  guildMemberSpeaking(member, speaking) {
    if (speaking.has(import_discord3.default.Speaking.FLAGS.SPEAKING | import_discord3.default.Speaking.FLAGS.PRIORITY_SPEAKING)) {
      debug4(`${member.nickname} is speaking on "${member.guild.name}"`);
    } else {
      debug4(`${member.nickname} stopped speaking on "${member.guild.name}"`);
    }
  }
  presenceUpdate(newPres, oldPres) {
    if (oldPres) {
      debug4(`${newPres.member.nickname} was ${oldPres.status} and is now ${newPres.status} on ${newPres.guild.name}`);
    } else {
      debug4(`${newPres.member.nickname} is now ${newPres.status} on ${newPres.guild.name}`);
    }
  }
};
MemberMonitor.DISPATCH_EVENTS = [
  "guildMemberAvailable",
  "guildMemberSpeaking"
];
var MemberMonitor_default = MemberMonitor;

// clientMonitor/index.js
var debug5 = import_debug5.default("bot:client_monitor");
var CURRENT_CLIENT = null;
var GUILD_MONITORS = {};
var MEMBER_MONITORS = {};
function monitorClient(client) {
  CURRENT_CLIENT = client;
  debug5("Installing server monitoring callbacks");
  setupGuildMonitor(client);
  debug5("Installing member monitoring callbacks");
  setupMemberMonitor(client);
}
function setupGuildMonitor(client) {
  client.on("guildCreate", (guild) => {
    debug5(`Joined server "${guild.name}" (${guild.id})!`);
    if (GUILD_MONITORS[guild.id]) {
      debug5(`WARNING: Server monitor already exists for "${guild.name}", updating`);
      GUILD_MONITORS[guild.id].update(guild);
    } else {
      GUILD_MONITORS[guild.id] = new GuildMonitor_default(guild);
    }
  });
  client.on("guildDelete", (guild) => {
    debug5(`Left/kicked from server "${guild.name}" (${guild.id})!`);
    GUILD_MONITORS[guild.id] = void 0;
  });
  client.on("guildUpdate", (oldGuild, newGuild) => {
    debug5(`Update for server "${oldGuild.name}" (${oldGuild.id})!`);
    if (newGuild.id !== oldGuild.id) {
      GUILD_MONITORS[newGuild.id] = GUILD_MONITORS[oldGuild.id];
      GUILD_MONITORS[oldGuild.id] = void 0;
    }
    GUILD_MONITORS[newGuild.id].update(newGuild);
  });
  GuildMonitor_default.DISPATCH_EVENTS.forEach((eventStr) => {
    client.on(eventStr, (...args) => {
      const guildID = args[0].id;
      if (!GUILD_MONITORS[guildID]) {
        debug5(`ERROR: No active guild monitor for ${eventStr} event`);
        return;
      }
      GUILD_MONITORS[guildID][eventStr](...args);
    });
  });
}
function setupMemberMonitor(client) {
  client.on("guildMembersChunk", (members, guild, chunk) => {
    debug5(`${members.size} member(s) added for "${guild.name}"`);
    members.each((member, memberId) => {
      if (MEMBER_MONITORS[memberId]) {
        debug5(`WARNING: Member monitor already exists for "${member.name}", updating`);
        MEMBER_MONITORS[memberId].update(member, GUILD_MONITORS[guild.id]);
      } else {
        MEMBER_MONITORS[memberId] = new MemberMonitor_default(member, GUILD_MONITORS[guild.id]);
      }
    });
  });
  client.on("guildMemberAdd", (member) => {
    debug5(`Member ${member.nickname} added to server "${member.guild.name}"`);
    MEMBER_MONITORS[member.id] = new MemberMonitor_default(member, GUILD_MONITORS[member.guild.id]);
  });
  client.on("guildMemberRemove", (member) => {
    debug5(`Member ${member.nickname} left/kicked from server "${member.guild.name}"`);
    MEMBER_MONITORS[member.id] = void 0;
  });
  client.on("guildMemberUpdate", (oldMember, newMember) => {
    debug5(`Update for server-member "${oldMember.name}" (${oldMember.id})!`);
    if (newMember.id !== oldMember.id) {
      MEMBER_MONITORS[newMember.id] = MEMBER_MONITORS[oldMember.id];
      MEMBER_MONITORS[oldMember.id] = void 0;
    }
    MEMBER_MONITORS[newMember.id].update(newMember, GUILD_MONITORS[newMember.guild.id]);
  });
  MemberMonitor_default.DISPATCH_EVENTS.forEach((eventStr) => {
    client.on(eventStr, (...args) => {
      const memberID = args[0].id;
      if (!MEMBER_MONITORS[memberID]) {
        debug5(`ERROR: No active member monitor for ${eventStr} event`);
        return;
      }
      MEMBER_MONITORS[memberID][eventStr](...args);
    });
  });
  client.on("presenceUpdate", (oldPres, newPres) => {
    debug5("Old:", oldPres);
    debug5("new:", newPres);
  });
}

// index.js
import_dotenv2.default.config();
var TOKEN = true ? process.env.DEV_TOKEN : process.env.TOKEN;
var bot = new import_discord4.default.Client({
  ws: {
    intents: [
      "GUILDS",
      "GUILD_MEMBERS",
      "GUILD_BANS",
      "GUILD_EMOJIS",
      "GUILD_VOICE_STATES",
      "GUILD_PRESENCES",
      "GUILD_MESSAGES",
      "GUILD_MESSAGE_REACTIONS",
      "DIRECT_MESSAGES",
      "DIRECT_MESSAGE_REACTIONS"
    ]
  }
});
bot.commands = commands_default;
monitorClient(bot);
bot.on("ready", () => {
  console.info("Client Ready");
});
bot.on("error", (error) => {
  console.error("CLIENT error message:");
  console.error(error);
});
bot.on("message", (msg) => {
  const args = msg.content.split(/\s+/);
  const command = args.shift().toLowerCase();
  console.info("Message: ", msg);
  if (!bot.commands.has(command))
    return;
  console.info(`Called command: ${command}`);
  try {
    bot.commands.get(command).execute(msg, args);
  } catch (error) {
    console.error(error);
    msg.reply("there was an error trying to execute that command!");
  }
});
process.on("unhandledRejection", (error) => {
  console.error("Unhandled promise rejection:", error);
});
bot.login(TOKEN);
//# sourceMappingURL=scrummybot.js.map
