var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  function log(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse(src, options) {
    const debug3 = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug3) {
        log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug3 = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug3 = true;
      }
    }
    try {
      const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug: debug3});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug3) {
          log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config;
  module2.exports.parse = parse;
});

// node_modules/snekfetch/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  function buildRequest(method, url) {
    return {
      method,
      path: url,
      redirect: this.options.followRedirects ? "follow" : "manual",
      headers: {},
      setHeader(name, value) {
        this.headers[name.toLowerCase()] = value;
      },
      getHeader(name) {
        return this.headers[name.toLowerCase()];
      }
    };
  }
  function finalizeRequest() {
    this._finalizeRequest();
    if (this.data)
      this.request.body = this.data;
    return window.fetch(this.request.path, this.request).then((r) => r.text().then((t) => {
      const headers = {};
      for (const [k, v] of r.headers.entries())
        headers[k.toLowerCase()] = v;
      return {response: r, raw: t, headers};
    }));
  }
  module2.exports = {
    buildRequest,
    finalizeRequest,
    shouldSendRaw: () => false,
    METHODS: ["GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "PATCH"],
    STATUS_CODES: {},
    Extension: Object,
    FormData: window.FormData
  };
});

// node_modules/snekfetch/src/node/mimes.json
var require_mimes = __commonJS((exports2, module2) => {
  module2.exports = {
    "123": "application/vnd.lotus-1-2-3",
    ez: "application/andrew-inset",
    aw: "application/applixware",
    atom: "application/atom+xml",
    atomcat: "application/atomcat+xml",
    atomsvc: "application/atomsvc+xml",
    bdoc: "application/x-bdoc",
    ccxml: "application/ccxml+xml",
    cdmia: "application/cdmi-capability",
    cdmic: "application/cdmi-container",
    cdmid: "application/cdmi-domain",
    cdmio: "application/cdmi-object",
    cdmiq: "application/cdmi-queue",
    cu: "application/cu-seeme",
    mpd: "application/dash+xml",
    davmount: "application/davmount+xml",
    dbk: "application/docbook+xml",
    dssc: "application/dssc+der",
    xdssc: "application/dssc+xml",
    ecma: "application/ecmascript",
    emma: "application/emma+xml",
    epub: "application/epub+zip",
    exi: "application/exi",
    pfr: "application/font-tdpfr",
    woff: "application/font-woff",
    woff2: "application/font-woff2",
    geojson: "application/geo+json",
    gml: "application/gml+xml",
    gpx: "application/gpx+xml",
    gxf: "application/gxf",
    stk: "application/hyperstudio",
    ink: "application/inkml+xml",
    inkml: "application/inkml+xml",
    ipfix: "application/ipfix",
    jar: "application/java-archive",
    war: "application/java-archive",
    ear: "application/java-archive",
    ser: "application/java-serialized-object",
    class: "application/java-vm",
    js: "application/javascript",
    json: "application/json",
    map: "application/json",
    json5: "application/json5",
    jsonml: "application/jsonml+json",
    jsonld: "application/ld+json",
    lostxml: "application/lost+xml",
    hqx: "application/mac-binhex40",
    cpt: "application/mac-compactpro",
    mads: "application/mads+xml",
    webmanifest: "application/manifest+json",
    mrc: "application/marc",
    mrcx: "application/marcxml+xml",
    ma: "application/mathematica",
    nb: "application/mathematica",
    mb: "application/mathematica",
    mathml: "application/mathml+xml",
    mbox: "application/mbox",
    mscml: "application/mediaservercontrol+xml",
    metalink: "application/metalink+xml",
    meta4: "application/metalink4+xml",
    mets: "application/mets+xml",
    mods: "application/mods+xml",
    m21: "application/mp21",
    mp21: "application/mp21",
    mp4s: "application/mp4",
    m4p: "application/mp4",
    doc: "application/msword",
    dot: "application/msword",
    mxf: "application/mxf",
    bin: "application/octet-stream",
    dms: "application/octet-stream",
    lrf: "application/octet-stream",
    mar: "application/octet-stream",
    so: "application/octet-stream",
    dist: "application/octet-stream",
    distz: "application/octet-stream",
    pkg: "application/octet-stream",
    bpk: "application/octet-stream",
    dump: "application/octet-stream",
    elc: "application/octet-stream",
    deploy: "application/octet-stream",
    exe: "application/x-msdownload",
    dll: "application/x-msdownload",
    deb: "application/x-debian-package",
    dmg: "application/x-apple-diskimage",
    iso: "application/x-iso9660-image",
    img: "application/octet-stream",
    msi: "application/x-msdownload",
    msp: "application/octet-stream",
    msm: "application/octet-stream",
    buffer: "application/octet-stream",
    oda: "application/oda",
    opf: "application/oebps-package+xml",
    ogx: "application/ogg",
    omdoc: "application/omdoc+xml",
    onetoc: "application/onenote",
    onetoc2: "application/onenote",
    onetmp: "application/onenote",
    onepkg: "application/onenote",
    oxps: "application/oxps",
    xer: "application/patch-ops-error+xml",
    pdf: "application/pdf",
    pgp: "application/pgp-encrypted",
    asc: "application/pgp-signature",
    sig: "application/pgp-signature",
    prf: "application/pics-rules",
    p10: "application/pkcs10",
    p7m: "application/pkcs7-mime",
    p7c: "application/pkcs7-mime",
    p7s: "application/pkcs7-signature",
    p8: "application/pkcs8",
    ac: "application/pkix-attr-cert",
    cer: "application/pkix-cert",
    crl: "application/pkix-crl",
    pkipath: "application/pkix-pkipath",
    pki: "application/pkixcmp",
    pls: "application/pls+xml",
    ai: "application/postscript",
    eps: "application/postscript",
    ps: "application/postscript",
    cww: "application/prs.cww",
    pskcxml: "application/pskc+xml",
    rdf: "application/rdf+xml",
    rif: "application/reginfo+xml",
    rnc: "application/relax-ng-compact-syntax",
    rl: "application/resource-lists+xml",
    rld: "application/resource-lists-diff+xml",
    rs: "application/rls-services+xml",
    gbr: "application/rpki-ghostbusters",
    mft: "application/rpki-manifest",
    roa: "application/rpki-roa",
    rsd: "application/rsd+xml",
    rss: "application/rss+xml",
    rtf: "text/rtf",
    sbml: "application/sbml+xml",
    scq: "application/scvp-cv-request",
    scs: "application/scvp-cv-response",
    spq: "application/scvp-vp-request",
    spp: "application/scvp-vp-response",
    sdp: "application/sdp",
    setpay: "application/set-payment-initiation",
    setreg: "application/set-registration-initiation",
    shf: "application/shf+xml",
    smi: "application/smil+xml",
    smil: "application/smil+xml",
    rq: "application/sparql-query",
    srx: "application/sparql-results+xml",
    gram: "application/srgs",
    grxml: "application/srgs+xml",
    sru: "application/sru+xml",
    ssdl: "application/ssdl+xml",
    ssml: "application/ssml+xml",
    tei: "application/tei+xml",
    teicorpus: "application/tei+xml",
    tfi: "application/thraud+xml",
    tsd: "application/timestamped-data",
    plb: "application/vnd.3gpp.pic-bw-large",
    psb: "application/vnd.3gpp.pic-bw-small",
    pvb: "application/vnd.3gpp.pic-bw-var",
    tcap: "application/vnd.3gpp2.tcap",
    pwn: "application/vnd.3m.post-it-notes",
    aso: "application/vnd.accpac.simply.aso",
    imp: "application/vnd.accpac.simply.imp",
    acu: "application/vnd.acucobol",
    atc: "application/vnd.acucorp",
    acutc: "application/vnd.acucorp",
    air: "application/vnd.adobe.air-application-installer-package+zip",
    fcdt: "application/vnd.adobe.formscentral.fcdt",
    fxp: "application/vnd.adobe.fxp",
    fxpl: "application/vnd.adobe.fxp",
    xdp: "application/vnd.adobe.xdp+xml",
    xfdf: "application/vnd.adobe.xfdf",
    ahead: "application/vnd.ahead.space",
    azf: "application/vnd.airzip.filesecure.azf",
    azs: "application/vnd.airzip.filesecure.azs",
    azw: "application/vnd.amazon.ebook",
    acc: "application/vnd.americandynamics.acc",
    ami: "application/vnd.amiga.ami",
    apk: "application/vnd.android.package-archive",
    cii: "application/vnd.anser-web-certificate-issue-initiation",
    fti: "application/vnd.anser-web-funds-transfer-initiation",
    atx: "application/vnd.antix.game-component",
    mpkg: "application/vnd.apple.installer+xml",
    m3u8: "application/vnd.apple.mpegurl",
    pkpass: "application/vnd.apple.pkpass",
    swi: "application/vnd.aristanetworks.swi",
    iota: "application/vnd.astraea-software.iota",
    aep: "application/vnd.audiograph",
    mpm: "application/vnd.blueice.multipass",
    bmi: "application/vnd.bmi",
    rep: "application/vnd.businessobjects",
    cdxml: "application/vnd.chemdraw+xml",
    mmd: "application/vnd.chipnuts.karaoke-mmd",
    cdy: "application/vnd.cinderella",
    cla: "application/vnd.claymore",
    rp9: "application/vnd.cloanto.rp9",
    c4g: "application/vnd.clonk.c4group",
    c4d: "application/vnd.clonk.c4group",
    c4f: "application/vnd.clonk.c4group",
    c4p: "application/vnd.clonk.c4group",
    c4u: "application/vnd.clonk.c4group",
    c11amc: "application/vnd.cluetrust.cartomobile-config",
    c11amz: "application/vnd.cluetrust.cartomobile-config-pkg",
    csp: "application/vnd.commonspace",
    cdbcmsg: "application/vnd.contact.cmsg",
    cmc: "application/vnd.cosmocaller",
    clkx: "application/vnd.crick.clicker",
    clkk: "application/vnd.crick.clicker.keyboard",
    clkp: "application/vnd.crick.clicker.palette",
    clkt: "application/vnd.crick.clicker.template",
    clkw: "application/vnd.crick.clicker.wordbank",
    wbs: "application/vnd.criticaltools.wbs+xml",
    pml: "application/vnd.ctc-posml",
    ppd: "application/vnd.cups-ppd",
    car: "application/vnd.curl.car",
    pcurl: "application/vnd.curl.pcurl",
    dart: "application/vnd.dart",
    rdz: "application/vnd.data-vision.rdz",
    uvf: "application/vnd.dece.data",
    uvvf: "application/vnd.dece.data",
    uvd: "application/vnd.dece.data",
    uvvd: "application/vnd.dece.data",
    uvt: "application/vnd.dece.ttml+xml",
    uvvt: "application/vnd.dece.ttml+xml",
    uvx: "application/vnd.dece.unspecified",
    uvvx: "application/vnd.dece.unspecified",
    uvz: "application/vnd.dece.zip",
    uvvz: "application/vnd.dece.zip",
    fe_launch: "application/vnd.denovo.fcselayout-link",
    dna: "application/vnd.dna",
    mlp: "application/vnd.dolby.mlp",
    dpg: "application/vnd.dpgraph",
    dfac: "application/vnd.dreamfactory",
    kpxx: "application/vnd.ds-keypoint",
    ait: "application/vnd.dvb.ait",
    svc: "application/vnd.dvb.service",
    geo: "application/vnd.dynageo",
    mag: "application/vnd.ecowin.chart",
    nml: "application/vnd.enliven",
    esf: "application/vnd.epson.esf",
    msf: "application/vnd.epson.msf",
    qam: "application/vnd.epson.quickanime",
    slt: "application/vnd.epson.salt",
    ssf: "application/vnd.epson.ssf",
    es3: "application/vnd.eszigno3+xml",
    et3: "application/vnd.eszigno3+xml",
    ez2: "application/vnd.ezpix-album",
    ez3: "application/vnd.ezpix-package",
    fdf: "application/vnd.fdf",
    mseed: "application/vnd.fdsn.mseed",
    seed: "application/vnd.fdsn.seed",
    dataless: "application/vnd.fdsn.seed",
    gph: "application/vnd.flographit",
    ftc: "application/vnd.fluxtime.clip",
    fm: "application/vnd.framemaker",
    frame: "application/vnd.framemaker",
    maker: "application/vnd.framemaker",
    book: "application/vnd.framemaker",
    fnc: "application/vnd.frogans.fnc",
    ltf: "application/vnd.frogans.ltf",
    fsc: "application/vnd.fsc.weblaunch",
    oas: "application/vnd.fujitsu.oasys",
    oa2: "application/vnd.fujitsu.oasys2",
    oa3: "application/vnd.fujitsu.oasys3",
    fg5: "application/vnd.fujitsu.oasysgp",
    bh2: "application/vnd.fujitsu.oasysprs",
    ddd: "application/vnd.fujixerox.ddd",
    xdw: "application/vnd.fujixerox.docuworks",
    xbd: "application/vnd.fujixerox.docuworks.binder",
    fzs: "application/vnd.fuzzysheet",
    txd: "application/vnd.genomatix.tuxedo",
    ggb: "application/vnd.geogebra.file",
    ggt: "application/vnd.geogebra.tool",
    gex: "application/vnd.geometry-explorer",
    gre: "application/vnd.geometry-explorer",
    gxt: "application/vnd.geonext",
    g2w: "application/vnd.geoplan",
    g3w: "application/vnd.geospace",
    gmx: "application/vnd.gmx",
    gdoc: "application/vnd.google-apps.document",
    gslides: "application/vnd.google-apps.presentation",
    gsheet: "application/vnd.google-apps.spreadsheet",
    kml: "application/vnd.google-earth.kml+xml",
    kmz: "application/vnd.google-earth.kmz",
    gqf: "application/vnd.grafeq",
    gqs: "application/vnd.grafeq",
    gac: "application/vnd.groove-account",
    ghf: "application/vnd.groove-help",
    gim: "application/vnd.groove-identity-message",
    grv: "application/vnd.groove-injector",
    gtm: "application/vnd.groove-tool-message",
    tpl: "application/vnd.groove-tool-template",
    vcg: "application/vnd.groove-vcard",
    hal: "application/vnd.hal+xml",
    zmm: "application/vnd.handheld-entertainment+xml",
    hbci: "application/vnd.hbci",
    les: "application/vnd.hhe.lesson-player",
    hpgl: "application/vnd.hp-hpgl",
    hpid: "application/vnd.hp-hpid",
    hps: "application/vnd.hp-hps",
    jlt: "application/vnd.hp-jlyt",
    pcl: "application/vnd.hp-pcl",
    pclxl: "application/vnd.hp-pclxl",
    "sfd-hdstx": "application/vnd.hydrostatix.sof-data",
    mpy: "application/vnd.ibm.minipay",
    afp: "application/vnd.ibm.modcap",
    listafp: "application/vnd.ibm.modcap",
    list3820: "application/vnd.ibm.modcap",
    irm: "application/vnd.ibm.rights-management",
    sc: "application/vnd.ibm.secure-container",
    icc: "application/vnd.iccprofile",
    icm: "application/vnd.iccprofile",
    igl: "application/vnd.igloader",
    ivp: "application/vnd.immervision-ivp",
    ivu: "application/vnd.immervision-ivu",
    igm: "application/vnd.insors.igm",
    xpw: "application/vnd.intercon.formnet",
    xpx: "application/vnd.intercon.formnet",
    i2g: "application/vnd.intergeo",
    qbo: "application/vnd.intu.qbo",
    qfx: "application/vnd.intu.qfx",
    rcprofile: "application/vnd.ipunplugged.rcprofile",
    irp: "application/vnd.irepository.package+xml",
    xpr: "application/vnd.is-xpr",
    fcs: "application/vnd.isac.fcs",
    jam: "application/vnd.jam",
    rms: "application/vnd.jcp.javame.midlet-rms",
    jisp: "application/vnd.jisp",
    joda: "application/vnd.joost.joda-archive",
    ktz: "application/vnd.kahootz",
    ktr: "application/vnd.kahootz",
    karbon: "application/vnd.kde.karbon",
    chrt: "application/vnd.kde.kchart",
    kfo: "application/vnd.kde.kformula",
    flw: "application/vnd.kde.kivio",
    kon: "application/vnd.kde.kontour",
    kpr: "application/vnd.kde.kpresenter",
    kpt: "application/vnd.kde.kpresenter",
    ksp: "application/vnd.kde.kspread",
    kwd: "application/vnd.kde.kword",
    kwt: "application/vnd.kde.kword",
    htke: "application/vnd.kenameaapp",
    kia: "application/vnd.kidspiration",
    kne: "application/vnd.kinar",
    knp: "application/vnd.kinar",
    skp: "application/vnd.koan",
    skd: "application/vnd.koan",
    skt: "application/vnd.koan",
    skm: "application/vnd.koan",
    sse: "application/vnd.kodak-descriptor",
    lasxml: "application/vnd.las.las+xml",
    lbd: "application/vnd.llamagraphics.life-balance.desktop",
    lbe: "application/vnd.llamagraphics.life-balance.exchange+xml",
    apr: "application/vnd.lotus-approach",
    pre: "application/vnd.lotus-freelance",
    nsf: "application/vnd.lotus-notes",
    org: "application/vnd.lotus-organizer",
    scm: "application/vnd.lotus-screencam",
    lwp: "application/vnd.lotus-wordpro",
    portpkg: "application/vnd.macports.portpkg",
    mcd: "application/vnd.mcd",
    mc1: "application/vnd.medcalcdata",
    cdkey: "application/vnd.mediastation.cdkey",
    mwf: "application/vnd.mfer",
    mfm: "application/vnd.mfmp",
    flo: "application/vnd.micrografx.flo",
    igx: "application/vnd.micrografx.igx",
    mif: "application/vnd.mif",
    daf: "application/vnd.mobius.daf",
    dis: "application/vnd.mobius.dis",
    mbk: "application/vnd.mobius.mbk",
    mqy: "application/vnd.mobius.mqy",
    msl: "application/vnd.mobius.msl",
    plc: "application/vnd.mobius.plc",
    txf: "application/vnd.mobius.txf",
    mpn: "application/vnd.mophun.application",
    mpc: "application/vnd.mophun.certificate",
    xul: "application/vnd.mozilla.xul+xml",
    cil: "application/vnd.ms-artgalry",
    cab: "application/vnd.ms-cab-compressed",
    xls: "application/vnd.ms-excel",
    xlm: "application/vnd.ms-excel",
    xla: "application/vnd.ms-excel",
    xlc: "application/vnd.ms-excel",
    xlt: "application/vnd.ms-excel",
    xlw: "application/vnd.ms-excel",
    xlam: "application/vnd.ms-excel.addin.macroenabled.12",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
    xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
    xltm: "application/vnd.ms-excel.template.macroenabled.12",
    eot: "application/vnd.ms-fontobject",
    chm: "application/vnd.ms-htmlhelp",
    ims: "application/vnd.ms-ims",
    lrm: "application/vnd.ms-lrm",
    thmx: "application/vnd.ms-officetheme",
    cat: "application/vnd.ms-pki.seccat",
    stl: "application/vnd.ms-pki.stl",
    ppt: "application/vnd.ms-powerpoint",
    pps: "application/vnd.ms-powerpoint",
    pot: "application/vnd.ms-powerpoint",
    ppam: "application/vnd.ms-powerpoint.addin.macroenabled.12",
    pptm: "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    sldm: "application/vnd.ms-powerpoint.slide.macroenabled.12",
    ppsm: "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    potm: "application/vnd.ms-powerpoint.template.macroenabled.12",
    mpp: "application/vnd.ms-project",
    mpt: "application/vnd.ms-project",
    docm: "application/vnd.ms-word.document.macroenabled.12",
    dotm: "application/vnd.ms-word.template.macroenabled.12",
    wps: "application/vnd.ms-works",
    wks: "application/vnd.ms-works",
    wcm: "application/vnd.ms-works",
    wdb: "application/vnd.ms-works",
    wpl: "application/vnd.ms-wpl",
    xps: "application/vnd.ms-xpsdocument",
    mseq: "application/vnd.mseq",
    mus: "application/vnd.musician",
    msty: "application/vnd.muvee.style",
    taglet: "application/vnd.mynfc",
    nlu: "application/vnd.neurolanguage.nlu",
    ntf: "application/vnd.nitf",
    nitf: "application/vnd.nitf",
    nnd: "application/vnd.noblenet-directory",
    nns: "application/vnd.noblenet-sealer",
    nnw: "application/vnd.noblenet-web",
    ngdat: "application/vnd.nokia.n-gage.data",
    "n-gage": "application/vnd.nokia.n-gage.symbian.install",
    rpst: "application/vnd.nokia.radio-preset",
    rpss: "application/vnd.nokia.radio-presets",
    edm: "application/vnd.novadigm.edm",
    edx: "application/vnd.novadigm.edx",
    ext: "application/vnd.novadigm.ext",
    odc: "application/vnd.oasis.opendocument.chart",
    otc: "application/vnd.oasis.opendocument.chart-template",
    odb: "application/vnd.oasis.opendocument.database",
    odf: "application/vnd.oasis.opendocument.formula",
    odft: "application/vnd.oasis.opendocument.formula-template",
    odg: "application/vnd.oasis.opendocument.graphics",
    otg: "application/vnd.oasis.opendocument.graphics-template",
    odi: "application/vnd.oasis.opendocument.image",
    oti: "application/vnd.oasis.opendocument.image-template",
    odp: "application/vnd.oasis.opendocument.presentation",
    otp: "application/vnd.oasis.opendocument.presentation-template",
    ods: "application/vnd.oasis.opendocument.spreadsheet",
    ots: "application/vnd.oasis.opendocument.spreadsheet-template",
    odt: "application/vnd.oasis.opendocument.text",
    odm: "application/vnd.oasis.opendocument.text-master",
    ott: "application/vnd.oasis.opendocument.text-template",
    oth: "application/vnd.oasis.opendocument.text-web",
    xo: "application/vnd.olpc-sugar",
    dd2: "application/vnd.oma.dd2+xml",
    oxt: "application/vnd.openofficeorg.extension",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    sldx: "application/vnd.openxmlformats-officedocument.presentationml.slide",
    ppsx: "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    potx: "application/vnd.openxmlformats-officedocument.presentationml.template",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    mgp: "application/vnd.osgeo.mapguide.package",
    dp: "application/vnd.osgi.dp",
    esa: "application/vnd.osgi.subsystem",
    pdb: "application/x-pilot",
    pqa: "application/vnd.palm",
    oprc: "application/vnd.palm",
    paw: "application/vnd.pawaafile",
    str: "application/vnd.pg.format",
    ei6: "application/vnd.pg.osasli",
    efif: "application/vnd.picsel",
    wg: "application/vnd.pmi.widget",
    plf: "application/vnd.pocketlearn",
    pbd: "application/vnd.powerbuilder6",
    box: "application/vnd.previewsystems.box",
    mgz: "application/vnd.proteus.magazine",
    qps: "application/vnd.publishare-delta-tree",
    ptid: "application/vnd.pvi.ptid1",
    qxd: "application/vnd.quark.quarkxpress",
    qxt: "application/vnd.quark.quarkxpress",
    qwd: "application/vnd.quark.quarkxpress",
    qwt: "application/vnd.quark.quarkxpress",
    qxl: "application/vnd.quark.quarkxpress",
    qxb: "application/vnd.quark.quarkxpress",
    bed: "application/vnd.realvnc.bed",
    mxl: "application/vnd.recordare.musicxml",
    musicxml: "application/vnd.recordare.musicxml+xml",
    cryptonote: "application/vnd.rig.cryptonote",
    cod: "application/vnd.rim.cod",
    rm: "application/vnd.rn-realmedia",
    rmvb: "application/vnd.rn-realmedia-vbr",
    link66: "application/vnd.route66.link66+xml",
    st: "application/vnd.sailingtracker.track",
    see: "application/vnd.seemail",
    sema: "application/vnd.sema",
    semd: "application/vnd.semd",
    semf: "application/vnd.semf",
    ifm: "application/vnd.shana.informed.formdata",
    itp: "application/vnd.shana.informed.formtemplate",
    iif: "application/vnd.shana.informed.interchange",
    ipk: "application/vnd.shana.informed.package",
    twd: "application/vnd.simtech-mindmapper",
    twds: "application/vnd.simtech-mindmapper",
    mmf: "application/vnd.smaf",
    teacher: "application/vnd.smart.teacher",
    sdkm: "application/vnd.solent.sdkm+xml",
    sdkd: "application/vnd.solent.sdkm+xml",
    dxp: "application/vnd.spotfire.dxp",
    sfs: "application/vnd.spotfire.sfs",
    sdc: "application/vnd.stardivision.calc",
    sda: "application/vnd.stardivision.draw",
    sdd: "application/vnd.stardivision.impress",
    smf: "application/vnd.stardivision.math",
    sdw: "application/vnd.stardivision.writer",
    vor: "application/vnd.stardivision.writer",
    sgl: "application/vnd.stardivision.writer-global",
    smzip: "application/vnd.stepmania.package",
    sm: "application/vnd.stepmania.stepchart",
    sxc: "application/vnd.sun.xml.calc",
    stc: "application/vnd.sun.xml.calc.template",
    sxd: "application/vnd.sun.xml.draw",
    std: "application/vnd.sun.xml.draw.template",
    sxi: "application/vnd.sun.xml.impress",
    sti: "application/vnd.sun.xml.impress.template",
    sxm: "application/vnd.sun.xml.math",
    sxw: "application/vnd.sun.xml.writer",
    sxg: "application/vnd.sun.xml.writer.global",
    stw: "application/vnd.sun.xml.writer.template",
    sus: "application/vnd.sus-calendar",
    susp: "application/vnd.sus-calendar",
    svd: "application/vnd.svd",
    sis: "application/vnd.symbian.install",
    sisx: "application/vnd.symbian.install",
    xsm: "application/vnd.syncml+xml",
    bdm: "application/vnd.syncml.dm+wbxml",
    xdm: "application/vnd.syncml.dm+xml",
    tao: "application/vnd.tao.intent-module-archive",
    pcap: "application/vnd.tcpdump.pcap",
    cap: "application/vnd.tcpdump.pcap",
    dmp: "application/vnd.tcpdump.pcap",
    tmo: "application/vnd.tmobile-livetv",
    tpt: "application/vnd.trid.tpt",
    mxs: "application/vnd.triscape.mxs",
    tra: "application/vnd.trueapp",
    ufd: "application/vnd.ufdl",
    ufdl: "application/vnd.ufdl",
    utz: "application/vnd.uiq.theme",
    umj: "application/vnd.umajin",
    unityweb: "application/vnd.unity",
    uoml: "application/vnd.uoml+xml",
    vcx: "application/vnd.vcx",
    vsd: "application/vnd.visio",
    vst: "application/vnd.visio",
    vss: "application/vnd.visio",
    vsw: "application/vnd.visio",
    vis: "application/vnd.visionary",
    vsf: "application/vnd.vsf",
    wbxml: "application/vnd.wap.wbxml",
    wmlc: "application/vnd.wap.wmlc",
    wmlsc: "application/vnd.wap.wmlscriptc",
    wtb: "application/vnd.webturbo",
    nbp: "application/vnd.wolfram.player",
    wpd: "application/vnd.wordperfect",
    wqd: "application/vnd.wqd",
    stf: "application/vnd.wt.stf",
    xar: "application/vnd.xara",
    xfdl: "application/vnd.xfdl",
    hvd: "application/vnd.yamaha.hv-dic",
    hvs: "application/vnd.yamaha.hv-script",
    hvp: "application/vnd.yamaha.hv-voice",
    osf: "application/vnd.yamaha.openscoreformat",
    osfpvg: "application/vnd.yamaha.openscoreformat.osfpvg+xml",
    saf: "application/vnd.yamaha.smaf-audio",
    spf: "application/vnd.yamaha.smaf-phrase",
    cmp: "application/vnd.yellowriver-custom-menu",
    zir: "application/vnd.zul",
    zirz: "application/vnd.zul",
    zaz: "application/vnd.zzazz.deck+xml",
    vxml: "application/voicexml+xml",
    wgt: "application/widget",
    hlp: "application/winhlp",
    wsdl: "application/wsdl+xml",
    wspolicy: "application/wspolicy+xml",
    "7z": "application/x-7z-compressed",
    abw: "application/x-abiword",
    ace: "application/x-ace-compressed",
    aab: "application/x-authorware-bin",
    x32: "application/x-authorware-bin",
    u32: "application/x-authorware-bin",
    vox: "application/x-authorware-bin",
    aam: "application/x-authorware-map",
    aas: "application/x-authorware-seg",
    bcpio: "application/x-bcpio",
    torrent: "application/x-bittorrent",
    blb: "application/x-blorb",
    blorb: "application/x-blorb",
    bz: "application/x-bzip",
    bz2: "application/x-bzip2",
    boz: "application/x-bzip2",
    cbr: "application/x-cbr",
    cba: "application/x-cbr",
    cbt: "application/x-cbr",
    cbz: "application/x-cbr",
    cb7: "application/x-cbr",
    vcd: "application/x-cdlink",
    cfs: "application/x-cfs-compressed",
    chat: "application/x-chat",
    pgn: "application/x-chess-pgn",
    crx: "application/x-chrome-extension",
    cco: "application/x-cocoa",
    nsc: "application/x-conference",
    cpio: "application/x-cpio",
    csh: "application/x-csh",
    udeb: "application/x-debian-package",
    dgc: "application/x-dgc-compressed",
    dir: "application/x-director",
    dcr: "application/x-director",
    dxr: "application/x-director",
    cst: "application/x-director",
    cct: "application/x-director",
    cxt: "application/x-director",
    w3d: "application/x-director",
    fgd: "application/x-director",
    swa: "application/x-director",
    wad: "application/x-doom",
    ncx: "application/x-dtbncx+xml",
    dtb: "application/x-dtbook+xml",
    res: "application/x-dtbresource+xml",
    dvi: "application/x-dvi",
    evy: "application/x-envoy",
    eva: "application/x-eva",
    bdf: "application/x-font-bdf",
    gsf: "application/x-font-ghostscript",
    psf: "application/x-font-linux-psf",
    otf: "font/opentype",
    pcf: "application/x-font-pcf",
    snf: "application/x-font-snf",
    ttf: "application/x-font-ttf",
    ttc: "application/x-font-ttf",
    pfa: "application/x-font-type1",
    pfb: "application/x-font-type1",
    pfm: "application/x-font-type1",
    afm: "application/x-font-type1",
    arc: "application/x-freearc",
    spl: "application/x-futuresplash",
    gca: "application/x-gca-compressed",
    ulx: "application/x-glulx",
    gnumeric: "application/x-gnumeric",
    gramps: "application/x-gramps-xml",
    gtar: "application/x-gtar",
    hdf: "application/x-hdf",
    php: "application/x-httpd-php",
    install: "application/x-install-instructions",
    jardiff: "application/x-java-archive-diff",
    jnlp: "application/x-java-jnlp-file",
    latex: "application/x-latex",
    luac: "application/x-lua-bytecode",
    lzh: "application/x-lzh-compressed",
    lha: "application/x-lzh-compressed",
    run: "application/x-makeself",
    mie: "application/x-mie",
    prc: "application/x-pilot",
    mobi: "application/x-mobipocket-ebook",
    application: "application/x-ms-application",
    lnk: "application/x-ms-shortcut",
    wmd: "application/x-ms-wmd",
    wmz: "application/x-msmetafile",
    xbap: "application/x-ms-xbap",
    mdb: "application/x-msaccess",
    obd: "application/x-msbinder",
    crd: "application/x-mscardfile",
    clp: "application/x-msclip",
    com: "application/x-msdownload",
    bat: "application/x-msdownload",
    mvb: "application/x-msmediaview",
    m13: "application/x-msmediaview",
    m14: "application/x-msmediaview",
    wmf: "application/x-msmetafile",
    emf: "application/x-msmetafile",
    emz: "application/x-msmetafile",
    mny: "application/x-msmoney",
    pub: "application/x-mspublisher",
    scd: "application/x-msschedule",
    trm: "application/x-msterminal",
    wri: "application/x-mswrite",
    nc: "application/x-netcdf",
    cdf: "application/x-netcdf",
    pac: "application/x-ns-proxy-autoconfig",
    nzb: "application/x-nzb",
    pl: "application/x-perl",
    pm: "application/x-perl",
    p12: "application/x-pkcs12",
    pfx: "application/x-pkcs12",
    p7b: "application/x-pkcs7-certificates",
    spc: "application/x-pkcs7-certificates",
    p7r: "application/x-pkcs7-certreqresp",
    rar: "application/x-rar-compressed",
    rpm: "application/x-redhat-package-manager",
    ris: "application/x-research-info-systems",
    sea: "application/x-sea",
    sh: "application/x-sh",
    shar: "application/x-shar",
    swf: "application/x-shockwave-flash",
    xap: "application/x-silverlight-app",
    sql: "application/x-sql",
    sit: "application/x-stuffit",
    sitx: "application/x-stuffitx",
    srt: "application/x-subrip",
    sv4cpio: "application/x-sv4cpio",
    sv4crc: "application/x-sv4crc",
    t3: "application/x-t3vm-image",
    gam: "application/x-tads",
    tar: "application/x-tar",
    tcl: "application/x-tcl",
    tk: "application/x-tcl",
    tex: "application/x-tex",
    tfm: "application/x-tex-tfm",
    texinfo: "application/x-texinfo",
    texi: "application/x-texinfo",
    obj: "application/x-tgif",
    ustar: "application/x-ustar",
    src: "application/x-wais-source",
    webapp: "application/x-web-app-manifest+json",
    der: "application/x-x509-ca-cert",
    crt: "application/x-x509-ca-cert",
    pem: "application/x-x509-ca-cert",
    fig: "application/x-xfig",
    xlf: "application/x-xliff+xml",
    xpi: "application/x-xpinstall",
    xz: "application/x-xz",
    z1: "application/x-zmachine",
    z2: "application/x-zmachine",
    z3: "application/x-zmachine",
    z4: "application/x-zmachine",
    z5: "application/x-zmachine",
    z6: "application/x-zmachine",
    z7: "application/x-zmachine",
    z8: "application/x-zmachine",
    xaml: "application/xaml+xml",
    xdf: "application/xcap-diff+xml",
    xenc: "application/xenc+xml",
    xhtml: "application/xhtml+xml",
    xht: "application/xhtml+xml",
    xml: "text/xml",
    xsl: "application/xml",
    xsd: "application/xml",
    rng: "application/xml",
    dtd: "application/xml-dtd",
    xop: "application/xop+xml",
    xpl: "application/xproc+xml",
    xslt: "application/xslt+xml",
    xspf: "application/xspf+xml",
    mxml: "application/xv+xml",
    xhvml: "application/xv+xml",
    xvml: "application/xv+xml",
    xvm: "application/xv+xml",
    yang: "application/yang",
    yin: "application/yin+xml",
    zip: "application/zip",
    "3gpp": "video/3gpp",
    adp: "audio/adpcm",
    au: "audio/basic",
    snd: "audio/basic",
    mid: "audio/midi",
    midi: "audio/midi",
    kar: "audio/midi",
    rmi: "audio/midi",
    mp3: "audio/mpeg",
    m4a: "audio/x-m4a",
    mp4a: "audio/mp4",
    mpga: "audio/mpeg",
    mp2: "audio/mpeg",
    mp2a: "audio/mpeg",
    m2a: "audio/mpeg",
    m3a: "audio/mpeg",
    oga: "audio/ogg",
    ogg: "audio/ogg",
    spx: "audio/ogg",
    s3m: "audio/s3m",
    sil: "audio/silk",
    uva: "audio/vnd.dece.audio",
    uvva: "audio/vnd.dece.audio",
    eol: "audio/vnd.digital-winds",
    dra: "audio/vnd.dra",
    dts: "audio/vnd.dts",
    dtshd: "audio/vnd.dts.hd",
    lvp: "audio/vnd.lucent.voice",
    pya: "audio/vnd.ms-playready.media.pya",
    ecelp4800: "audio/vnd.nuera.ecelp4800",
    ecelp7470: "audio/vnd.nuera.ecelp7470",
    ecelp9600: "audio/vnd.nuera.ecelp9600",
    rip: "audio/vnd.rip",
    wav: "audio/x-wav",
    weba: "audio/webm",
    aac: "audio/x-aac",
    aif: "audio/x-aiff",
    aiff: "audio/x-aiff",
    aifc: "audio/x-aiff",
    caf: "audio/x-caf",
    flac: "audio/x-flac",
    mka: "audio/x-matroska",
    m3u: "audio/x-mpegurl",
    wax: "audio/x-ms-wax",
    wma: "audio/x-ms-wma",
    ram: "audio/x-pn-realaudio",
    ra: "audio/x-realaudio",
    rmp: "audio/x-pn-realaudio-plugin",
    xm: "audio/xm",
    cdx: "chemical/x-cdx",
    cif: "chemical/x-cif",
    cmdf: "chemical/x-cmdf",
    cml: "chemical/x-cml",
    csml: "chemical/x-csml",
    xyz: "chemical/x-xyz",
    bmp: "image/x-ms-bmp",
    cgm: "image/cgm",
    g3: "image/g3fax",
    gif: "image/gif",
    ief: "image/ief",
    jpeg: "image/jpeg",
    jpg: "image/jpeg",
    jpe: "image/jpeg",
    ktx: "image/ktx",
    png: "image/png",
    btif: "image/prs.btif",
    sgi: "image/sgi",
    svg: "image/svg+xml",
    svgz: "image/svg+xml",
    tiff: "image/tiff",
    tif: "image/tiff",
    psd: "image/vnd.adobe.photoshop",
    uvi: "image/vnd.dece.graphic",
    uvvi: "image/vnd.dece.graphic",
    uvg: "image/vnd.dece.graphic",
    uvvg: "image/vnd.dece.graphic",
    djvu: "image/vnd.djvu",
    djv: "image/vnd.djvu",
    sub: "text/vnd.dvb.subtitle",
    dwg: "image/vnd.dwg",
    dxf: "image/vnd.dxf",
    fbs: "image/vnd.fastbidsheet",
    fpx: "image/vnd.fpx",
    fst: "image/vnd.fst",
    mmr: "image/vnd.fujixerox.edmics-mmr",
    rlc: "image/vnd.fujixerox.edmics-rlc",
    mdi: "image/vnd.ms-modi",
    wdp: "image/vnd.ms-photo",
    npx: "image/vnd.net-fpx",
    wbmp: "image/vnd.wap.wbmp",
    xif: "image/vnd.xiff",
    webp: "image/webp",
    "3ds": "image/x-3ds",
    ras: "image/x-cmu-raster",
    cmx: "image/x-cmx",
    fh: "image/x-freehand",
    fhc: "image/x-freehand",
    fh4: "image/x-freehand",
    fh5: "image/x-freehand",
    fh7: "image/x-freehand",
    ico: "image/x-icon",
    jng: "image/x-jng",
    sid: "image/x-mrsid-image",
    pcx: "image/x-pcx",
    pic: "image/x-pict",
    pct: "image/x-pict",
    pnm: "image/x-portable-anymap",
    pbm: "image/x-portable-bitmap",
    pgm: "image/x-portable-graymap",
    ppm: "image/x-portable-pixmap",
    rgb: "image/x-rgb",
    tga: "image/x-tga",
    xbm: "image/x-xbitmap",
    xpm: "image/x-xpixmap",
    xwd: "image/x-xwindowdump",
    eml: "message/rfc822",
    mime: "message/rfc822",
    igs: "model/iges",
    iges: "model/iges",
    msh: "model/mesh",
    mesh: "model/mesh",
    silo: "model/mesh",
    dae: "model/vnd.collada+xml",
    dwf: "model/vnd.dwf",
    gdl: "model/vnd.gdl",
    gtw: "model/vnd.gtw",
    mts: "model/vnd.mts",
    vtu: "model/vnd.vtu",
    wrl: "model/vrml",
    vrml: "model/vrml",
    x3db: "model/x3d+binary",
    x3dbz: "model/x3d+binary",
    x3dv: "model/x3d+vrml",
    x3dvz: "model/x3d+vrml",
    x3d: "model/x3d+xml",
    x3dz: "model/x3d+xml",
    appcache: "text/cache-manifest",
    manifest: "text/cache-manifest",
    ics: "text/calendar",
    ifb: "text/calendar",
    coffee: "text/coffeescript",
    litcoffee: "text/coffeescript",
    css: "text/css",
    csv: "text/csv",
    hjson: "text/hjson",
    html: "text/html",
    htm: "text/html",
    shtml: "text/html",
    jade: "text/jade",
    jsx: "text/jsx",
    less: "text/less",
    mml: "text/mathml",
    n3: "text/n3",
    txt: "text/plain",
    text: "text/plain",
    conf: "text/plain",
    def: "text/plain",
    list: "text/plain",
    log: "text/plain",
    in: "text/plain",
    ini: "text/plain",
    dsc: "text/prs.lines.tag",
    rtx: "text/richtext",
    sgml: "text/sgml",
    sgm: "text/sgml",
    slim: "text/slim",
    slm: "text/slim",
    stylus: "text/stylus",
    styl: "text/stylus",
    tsv: "text/tab-separated-values",
    t: "text/troff",
    tr: "text/troff",
    roff: "text/troff",
    man: "text/troff",
    me: "text/troff",
    ms: "text/troff",
    ttl: "text/turtle",
    uri: "text/uri-list",
    uris: "text/uri-list",
    urls: "text/uri-list",
    vcard: "text/vcard",
    curl: "text/vnd.curl",
    dcurl: "text/vnd.curl.dcurl",
    mcurl: "text/vnd.curl.mcurl",
    scurl: "text/vnd.curl.scurl",
    fly: "text/vnd.fly",
    flx: "text/vnd.fmi.flexstor",
    gv: "text/vnd.graphviz",
    "3dml": "text/vnd.in3d.3dml",
    spot: "text/vnd.in3d.spot",
    jad: "text/vnd.sun.j2me.app-descriptor",
    wml: "text/vnd.wap.wml",
    wmls: "text/vnd.wap.wmlscript",
    vtt: "text/vtt",
    s: "text/x-asm",
    asm: "text/x-asm",
    c: "text/x-c",
    cc: "text/x-c",
    cxx: "text/x-c",
    cpp: "text/x-c",
    h: "text/x-c",
    hh: "text/x-c",
    dic: "text/x-c",
    htc: "text/x-component",
    f: "text/x-fortran",
    for: "text/x-fortran",
    f77: "text/x-fortran",
    f90: "text/x-fortran",
    hbs: "text/x-handlebars-template",
    java: "text/x-java-source",
    lua: "text/x-lua",
    markdown: "text/x-markdown",
    md: "text/x-markdown",
    mkd: "text/x-markdown",
    nfo: "text/x-nfo",
    opml: "text/x-opml",
    p: "text/x-pascal",
    pas: "text/x-pascal",
    pde: "text/x-processing",
    sass: "text/x-sass",
    scss: "text/x-scss",
    etx: "text/x-setext",
    sfv: "text/x-sfv",
    ymp: "text/x-suse-ymp",
    uu: "text/x-uuencode",
    vcs: "text/x-vcalendar",
    vcf: "text/x-vcard",
    yaml: "text/yaml",
    yml: "text/yaml",
    "3gp": "video/3gpp",
    "3g2": "video/3gpp2",
    h261: "video/h261",
    h263: "video/h263",
    h264: "video/h264",
    jpgv: "video/jpeg",
    jpm: "video/jpm",
    jpgm: "video/jpm",
    mj2: "video/mj2",
    mjp2: "video/mj2",
    ts: "video/mp2t",
    mp4: "video/mp4",
    mp4v: "video/mp4",
    mpg4: "video/mp4",
    mpeg: "video/mpeg",
    mpg: "video/mpeg",
    mpe: "video/mpeg",
    m1v: "video/mpeg",
    m2v: "video/mpeg",
    ogv: "video/ogg",
    qt: "video/quicktime",
    mov: "video/quicktime",
    uvh: "video/vnd.dece.hd",
    uvvh: "video/vnd.dece.hd",
    uvm: "video/vnd.dece.mobile",
    uvvm: "video/vnd.dece.mobile",
    uvp: "video/vnd.dece.pd",
    uvvp: "video/vnd.dece.pd",
    uvs: "video/vnd.dece.sd",
    uvvs: "video/vnd.dece.sd",
    uvv: "video/vnd.dece.video",
    uvvv: "video/vnd.dece.video",
    dvb: "video/vnd.dvb.file",
    fvt: "video/vnd.fvt",
    mxu: "video/vnd.mpegurl",
    m4u: "video/vnd.mpegurl",
    pyv: "video/vnd.ms-playready.media.pyv",
    uvu: "video/vnd.uvvu.mp4",
    uvvu: "video/vnd.uvvu.mp4",
    viv: "video/vnd.vivo",
    webm: "video/webm",
    f4v: "video/x-f4v",
    fli: "video/x-fli",
    flv: "video/x-flv",
    m4v: "video/x-m4v",
    mkv: "video/x-matroska",
    mk3d: "video/x-matroska",
    mks: "video/x-matroska",
    mng: "video/x-mng",
    asf: "video/x-ms-asf",
    asx: "video/x-ms-asf",
    vob: "video/x-ms-vob",
    wm: "video/x-ms-wm",
    wmv: "video/x-ms-wmv",
    wmx: "video/x-ms-wmx",
    wvx: "video/x-ms-wvx",
    avi: "video/x-msvideo",
    movie: "video/x-sgi-movie",
    smv: "video/x-smv",
    ice: "x-conference/x-cooltalk"
  };
});

// node_modules/snekfetch/src/node/mimeOfBuffer.js
var require_mimeOfBuffer = __commonJS((exports2, module2) => {
  function mimeOfBuffer(input) {
    const buf = new Uint8Array(input);
    if (!(buf && buf.length > 1))
      return null;
    if (buf[0] === 255 && buf[1] === 216 && buf[2] === 255) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (buf[0] === 137 && buf[1] === 80 && buf[2] === 78 && buf[3] === 71) {
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (buf[0] === 71 && buf[1] === 73 && buf[2] === 70) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (buf[8] === 87 && buf[9] === 69 && buf[10] === 66 && buf[11] === 80) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (buf[0] === 70 && buf[1] === 76 && buf[2] === 73 && buf[3] === 70) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if ((buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) && buf[8] === 67 && buf[9] === 82) {
      return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
      };
    }
    if (buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (buf[0] === 66 && buf[1] === 77) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (buf[0] === 73 && buf[1] === 73 && buf[2] === 188) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (buf[0] === 56 && buf[1] === 66 && buf[2] === 80 && buf[3] === 83) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 109 && buf[31] === 105 && buf[32] === 109 && buf[33] === 101 && buf[34] === 116 && buf[35] === 121 && buf[36] === 112 && buf[37] === 101 && buf[38] === 97 && buf[39] === 112 && buf[40] === 112 && buf[41] === 108 && buf[42] === 105 && buf[43] === 99 && buf[44] === 97 && buf[45] === 116 && buf[46] === 105 && buf[47] === 111 && buf[48] === 110 && buf[49] === 47 && buf[50] === 101 && buf[51] === 112 && buf[52] === 117 && buf[53] === 98 && buf[54] === 43 && buf[55] === 122 && buf[56] === 105 && buf[57] === 112) {
      return {
        ext: "epub",
        mime: "application/epub+zip"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 77 && buf[31] === 69 && buf[32] === 84 && buf[33] === 65 && buf[34] === 45 && buf[35] === 73 && buf[36] === 78 && buf[37] === 70 && buf[38] === 47 && buf[39] === 109 && buf[40] === 111 && buf[41] === 122 && buf[42] === 105 && buf[43] === 108 && buf[44] === 108 && buf[45] === 97 && buf[46] === 46 && buf[47] === 114 && buf[48] === 115 && buf[49] === 97) {
      return {
        ext: "xpi",
        mime: "application/x-xpinstall"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (buf[257] === 117 && buf[258] === 115 && buf[259] === 116 && buf[260] === 97 && buf[261] === 114) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (buf[0] === 82 && buf[1] === 97 && buf[2] === 114 && buf[3] === 33 && buf[4] === 26 && buf[5] === 7 && (buf[6] === 0 || buf[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (buf[0] === 31 && buf[1] === 139 && buf[2] === 8) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (buf[0] === 66 && buf[1] === 90 && buf[2] === 104) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (buf[0] === 55 && buf[1] === 122 && buf[2] === 188 && buf[3] === 175 && buf[4] === 39 && buf[5] === 28) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (buf[0] === 120 && buf[1] === 1) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && (buf[3] === 24 || buf[3] === 32) && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 || buf[0] === 51 && buf[1] === 103 && buf[2] === 112 && buf[3] === 53 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[16] === 109 && buf[17] === 112 && buf[18] === 52 && buf[19] === 49 && buf[20] === 109 && buf[21] === 112 && buf[22] === 52 && buf[23] === 50 && buf[24] === 105 && buf[25] === 115 && buf[26] === 111 && buf[27] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 105 && buf[9] === 115 && buf[10] === 111 && buf[11] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[12] === 0 && buf[13] === 0 && buf[14] === 0 && buf[15] === 0) {
      return {
        ext: "mp4",
        mime: "video/mp4"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 86) {
      return {
        ext: "m4v",
        mime: "video/x-m4v"
      };
    }
    if (buf[0] === 77 && buf[1] === 84 && buf[2] === 104 && buf[3] === 100) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (buf[0] === 26 && buf[1] === 69 && buf[2] === 223 && buf[3] === 163) {
      const sliced = buf.subarray(4, 4 + 4096);
      const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
      if (idPos >= 0) {
        const docTypePos = idPos + 3;
        const findDocType = (type) => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
        if (findDocType("matroska")) {
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        }
        if (findDocType("webm")) {
          return {
            ext: "webm",
            mime: "video/webm"
          };
        }
      }
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 20 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 65 && buf[9] === 86 && buf[10] === 73) {
      return {
        ext: "avi",
        mime: "video/x-msvideo"
      };
    }
    if (buf[0] === 48 && buf[1] === 38 && buf[2] === 178 && buf[3] === 117 && buf[4] === 142 && buf[5] === 102 && buf[6] === 207 && buf[7] === 17 && buf[8] === 166 && buf[9] === 217) {
      return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3].toString(16)[0] === "b") {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (buf[0] === 73 && buf[1] === 68 && buf[2] === 51 || buf[0] === 255 && buf[1] === 251) {
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    }
    if (buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 65 || buf[0] === 77 && buf[1] === 52 && buf[2] === 65 && buf[3] === 32) {
      return {
        ext: "m4a",
        mime: "audio/m4a"
      };
    }
    if (buf[28] === 79 && buf[29] === 112 && buf[30] === 117 && buf[31] === 115 && buf[32] === 72 && buf[33] === 101 && buf[34] === 97 && buf[35] === 100) {
      return {
        ext: "opus",
        mime: "audio/opus"
      };
    }
    if (buf[0] === 79 && buf[1] === 103 && buf[2] === 103 && buf[3] === 83) {
      return {
        ext: "ogg",
        mime: "audio/ogg"
      };
    }
    if (buf[0] === 102 && buf[1] === 76 && buf[2] === 97 && buf[3] === 67) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 87 && buf[9] === 65 && buf[10] === 86 && buf[11] === 69) {
      return {
        ext: "wav",
        mime: "audio/x-wav"
      };
    }
    if (buf[0] === 35 && buf[1] === 33 && buf[2] === 65 && buf[3] === 77 && buf[4] === 82 && buf[5] === 10) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (buf[0] === 37 && buf[1] === 80 && buf[2] === 68 && buf[3] === 70) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (buf[0] === 77 && buf[1] === 90) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if ((buf[0] === 67 || buf[0] === 70) && buf[1] === 87 && buf[2] === 83) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (buf[0] === 123 && buf[1] === 92 && buf[2] === 114 && buf[3] === 116 && buf[4] === 102) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 70 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
      return {
        ext: "woff",
        mime: "application/font-woff"
      };
    }
    if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 50 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
      return {
        ext: "woff2",
        mime: "application/font-woff"
      };
    }
    if (buf[34] === 76 && buf[35] === 80 && (buf[8] === 0 && buf[9] === 0 && buf[10] === 1 || buf[8] === 1 && buf[9] === 0 && buf[10] === 2 || buf[8] === 2 && buf[9] === 0 && buf[10] === 2)) {
      return {
        ext: "eot",
        mime: "application/octet-stream"
      };
    }
    if (buf[0] === 0 && buf[1] === 1 && buf[2] === 0 && buf[3] === 0 && buf[4] === 0) {
      return {
        ext: "ttf",
        mime: "application/font-sfnt"
      };
    }
    if (buf[0] === 79 && buf[1] === 84 && buf[2] === 84 && buf[3] === 79 && buf[4] === 0) {
      return {
        ext: "otf",
        mime: "application/font-sfnt"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3] === 0) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (buf[0] === 70 && buf[1] === 76 && buf[2] === 86 && buf[3] === 1) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (buf[0] === 37 && buf[1] === 33) {
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (buf[0] === 253 && buf[1] === 55 && buf[2] === 122 && buf[3] === 88 && buf[4] === 90 && buf[5] === 0) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (buf[0] === 83 && buf[1] === 81 && buf[2] === 76 && buf[3] === 105) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (buf[0] === 78 && buf[1] === 69 && buf[2] === 83 && buf[3] === 26) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (buf[0] === 67 && buf[1] === 114 && buf[2] === 50 && buf[3] === 52) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (buf[0] === 77 && buf[1] === 83 && buf[2] === 67 && buf[3] === 70 || buf[0] === 73 && buf[1] === 83 && buf[2] === 99 && buf[3] === 40) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62 && buf[7] === 10 && buf[8] === 100 && buf[9] === 101 && buf[10] === 98 && buf[11] === 105 && buf[12] === 97 && buf[13] === 110 && buf[14] === 45 && buf[15] === 98 && buf[16] === 105 && buf[17] === 110 && buf[18] === 97 && buf[19] === 114 && buf[20] === 121) {
      return {
        ext: "deb",
        mime: "application/x-deb"
      };
    }
    if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62) {
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (buf[0] === 237 && buf[1] === 171 && buf[2] === 238 && buf[3] === 219) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (buf[0] === 31 && buf[1] === 160 || buf[0] === 31 && buf[1] === 157) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (buf[0] === 76 && buf[1] === 90 && buf[2] === 73 && buf[3] === 80) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (buf[0] === 208 && buf[1] === 207 && buf[2] === 17 && buf[3] === 224 && buf[4] === 161 && buf[5] === 177 && buf[6] === 26 && buf[7] === 225) {
      return {
        ext: "msi",
        mime: "application/x-msi"
      };
    }
    if (buf[0] === 6 && buf[1] === 14 && buf[2] === 43 && buf[3] === 52 && buf[4] === 2 && buf[5] === 5 && buf[6] === 1 && buf[7] === 1 && buf[8] === 13 && buf[9] === 1 && buf[10] === 2 && buf[11] === 1 && buf[12] === 1 && buf[13] === 2) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    return null;
  }
  module2.exports = mimeOfBuffer;
});

// node_modules/snekfetch/src/node/mime.js
var require_mime = __commonJS((exports2, module2) => {
  var mimes = require_mimes();
  var mimeOfBuffer = require_mimeOfBuffer();
  function lookupMime(ext) {
    return mimes[ext.replace(/^\./, "")] || mimes.bin;
  }
  function lookupBuffer(buffer) {
    const ret = mimeOfBuffer(buffer);
    return ret ? ret.mime : mimes.bin;
  }
  module2.exports = {
    buffer: lookupBuffer,
    lookup: lookupMime
  };
});

// node_modules/snekfetch/src/node/FormData.js
var require_FormData = __commonJS((exports2, module2) => {
  var path = require("path");
  var mime = require_mime();
  var FormData = class {
    constructor() {
      this.boundary = `--snekfetch--${Math.random().toString().slice(2, 7)}`;
      this.buffers = [];
    }
    append(name, data, filename) {
      if (typeof data === "undefined")
        return;
      let str = `\r
--${this.boundary}\r
Content-Disposition: form-data; name="${name}"`;
      let mimetype = null;
      if (filename) {
        str += `; filename="${filename}"`;
        mimetype = "application/octet-stream";
        const extname = path.extname(filename).slice(1);
        if (extname)
          mimetype = mime.lookup(extname);
      }
      if (data instanceof Buffer) {
        mimetype = mime.buffer(data);
      } else if (typeof data === "object") {
        mimetype = "application/json";
        data = Buffer.from(JSON.stringify(data));
      } else {
        data = Buffer.from(String(data));
      }
      if (mimetype)
        str += `\r
Content-Type: ${mimetype}`;
      this.buffers.push(Buffer.from(`${str}\r
\r
`));
      this.buffers.push(data);
    }
    getBoundary() {
      return this.boundary;
    }
    end() {
      return Buffer.concat([...this.buffers, Buffer.from(`\r
--${this.boundary}--`)]);
    }
    get length() {
      return this.buffers.reduce((sum, b) => sum + Buffer.byteLength(b), 0);
    }
  };
  module2.exports = FormData;
});

// node_modules/snekfetch/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "snekfetch@3.6.4",
        "D:\\Programming-School\\scrummy-bot"
      ]
    ],
    _from: "snekfetch@3.6.4",
    _id: "snekfetch@3.6.4",
    _inBundle: false,
    _integrity: "sha512-NjxjITIj04Ffqid5lqr7XdgwM7X61c/Dns073Ly170bPQHLm6jkmelye/eglS++1nfTWktpP6Y2bFXjdPlQqdw==",
    _location: "/snekfetch",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "snekfetch@3.6.4",
      name: "snekfetch",
      escapedName: "snekfetch",
      rawSpec: "3.6.4",
      saveSpec: null,
      fetchSpec: "3.6.4"
    },
    _requiredBy: [
      "/discord.js"
    ],
    _resolved: "https://registry.npmjs.org/snekfetch/-/snekfetch-3.6.4.tgz",
    _spec: "3.6.4",
    _where: "D:\\Programming-School\\scrummy-bot",
    author: {
      name: "Gus Caplan",
      email: "me@gus.host"
    },
    browser: {
      "./src/node/index.js": false,
      "./src/meta.js": false
    },
    bugs: {
      url: "https://github.com/devsnek/snekfetch/issues"
    },
    dependencies: {},
    description: "Just do http requests without all that weird nastiness from other libs",
    devDependencies: {
      "@snek/syncify": "0.0.6",
      coveralls: "^3.0.0",
      docma: "^1.5.1",
      eslint: "^4.8.0",
      jest: "^21.2.1",
      "jsdoc-dynamic": "^1.0.4",
      "json-filter-loader": "^1.0.0",
      "node-fetch": "github:bitinn/node-fetch",
      "uglifyjs-webpack-plugin": "^1.0.0-beta.2",
      webpack: "^3.8.1"
    },
    homepage: "https://snekfetch.js.org/",
    jest: {
      collectCoverage: true,
      collectCoverageFrom: [
        "src/**/*.js",
        "!src/qs_mock.js",
        "!src/node/mimeOfBuffer.js",
        "!src/node/transports/http2.js"
      ],
      verbose: true
    },
    jsdelivr: "browser.js",
    license: "MIT",
    main: "index.js",
    module: "esm.mjs",
    name: "snekfetch",
    repository: {
      type: "git",
      url: "git+https://github.com/devsnek/snekfetch.git"
    },
    scripts: {
      "build:browser": "webpack",
      docs: "node docs.js",
      lint: "eslint **/*.js",
      prepublishOnly: "npm run build:browser",
      test: "node ./node_modules/.bin/jest",
      "test:coveralls": "cat ./coverage/lcov.info | coveralls"
    },
    unpkg: "browser.js",
    version: "3.6.4"
  };
});

// node_modules/snekfetch/src/node/transports/ResponseStream.js
var require_ResponseStream = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  var ResponseStream = class extends Stream.Readable {
    constructor() {
      super();
      this.statusCode = 200;
      this.status = "OK";
    }
    error(code, message) {
      this.statusCode = code;
      this.status = message;
      return this;
    }
    on(event, handler) {
      if (["end", "open"].includes(event))
        handler();
    }
    _read() {
    }
  };
  module2.exports = ResponseStream;
});

// node_modules/snekfetch/src/node/transports/file.js
var require_file = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  var mime = require_mime();
  var EventEmitter2 = require("events");
  var ResponseStream = require_ResponseStream();
  var methods = {
    GET: (filename, req) => {
      req.end = () => {
        const stream = should404(filename) ? new ResponseStream().error(404, `ENOENT: no such file or directory, open '${filename}'`) : fs.createReadStream(filename);
        req.res = stream;
        stream.headers = {
          "content-length": 0,
          "content-type": mime.lookup(path.extname(filename))
        };
        stream.on("open", () => {
          req.emit("response", stream);
        });
        if (stream instanceof ResponseStream)
          return;
        stream.statusCode = 200;
        stream.on("end", () => {
          stream.headers["content-length"] = stream.bytesRead;
        });
        stream.on("error", (err) => {
          stream.statusCode = 400;
          stream.status = err.message;
        });
      };
    },
    POST: (filename, req) => {
      const chunks = [];
      req.write = (data) => {
        chunks.push(data);
      };
      req.end = (data) => {
        chunks.push(data);
        const stream = fs.createWriteStream(filename);
        const standin = new ResponseStream();
        req.res = standin;
        standin.headers = {
          "content-length": 0,
          "content-type": mime.lookup(path.extname(filename))
        };
        stream.on("finish", () => {
          req.emit("response", standin);
        });
        stream.on("open", () => {
          (function write() {
            const chunk = chunks.shift();
            if (!chunk)
              return;
            if (!stream.write(chunk))
              stream.once("drain", write);
            else
              write();
          })();
          stream.end();
        });
      };
    },
    DELETE: (filename, req) => {
      req.end = () => {
        const stream = new ResponseStream();
        req.res = stream;
        stream.headers = {
          "content-length": 0,
          "content-type": mime.lookup(path.extname(filename))
        };
        fs.unlink(filename, (err) => {
          req.emit("response", err ? stream.error(400, err.message) : stream);
        });
      };
    }
  };
  var Req = class extends EventEmitter2 {
    constructor() {
      super();
      this._headers = {};
    }
    setHeader() {
    }
    getHeader() {
    }
  };
  function request(options) {
    const method = methods[options.method];
    if (!method)
      throw new Error(`Invalid request method for file: "${options.method}"`);
    const filename = options.href.replace("file://", "");
    const req = new Req();
    method(filename, req, options);
    return req;
  }
  function should404(p) {
    try {
      return fs.lstatSync(p).isDirectory();
    } catch (err) {
      return true;
    }
  }
  module2.exports = {
    request
  };
});

// node_modules/snekfetch/src/node/index.js
var require_node = __commonJS((exports2, module2) => {
  var zlib = require("zlib");
  var http = require("http");
  var https = require("https");
  var URL = require("url");
  var Stream = require("stream");
  var FormData = require_FormData();
  var Package = require_package();
  var transports = {
    "http:": http,
    "https:": https,
    "file:": require_file()
  };
  function buildRequest(method, url) {
    this._read = () => {
      this.resume();
      if (this._response)
        return;
      this.catch((err) => this.emit("error", err));
    };
    this.options.lastBuiltUrl = url;
    const options = URL.parse(url);
    options.encoding = "utf8";
    if (!options.protocol)
      throw new Error("URL must have a valid protocol");
    const transport = transports[options.protocol];
    options.method = method.toUpperCase();
    if (this.options.headers)
      options.headers = this.options.headers;
    if (this.options.agent)
      options.agent = this.options.agent;
    else if (transport.Agent && this.options.followRedirects !== false)
      options.agent = new transport.Agent({keepAlive: true});
    if (options.port)
      options.port = parseInt(options.port);
    this.options._req = options;
    const request = transport.request(options);
    if (request.setNoDelay)
      request.setNoDelay(true);
    return request;
  }
  function finalizeRequest() {
    return new Promise((resolve, reject) => {
      const request = this.request;
      let socket;
      const handleError = (err) => {
        if (!err)
          err = new Error("Unknown error occured");
        err.request = request;
        reject(err);
        if (socket)
          socket.removeListener("error", handleError);
      };
      request.once("abort", handleError);
      request.once("error", handleError);
      request.once("socket", (s) => {
        socket = s;
        s.once("error", handleError);
      });
      request.once("response", (response) => {
        if (socket)
          socket.removeListener("error", handleError);
        let stream = response;
        if (shouldUnzip(response)) {
          stream = response.pipe(zlib.createUnzip({
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          }));
        }
        if (this.options.followRedirects !== false && [301, 302, 303, 307, 308].includes(response.statusCode)) {
          resolve({
            response,
            redirect: URL.resolve(this.options.lastBuiltUrl, response.headers.location)
          });
          response.destroy();
        } else {
          const body = [];
          stream.on("data", (chunk) => {
            if (!this.push(chunk))
              this.pause();
            body.push(chunk);
          });
          stream.once("end", () => {
            this.push(null);
            const raw = Buffer.concat(body);
            resolve({response, raw, redirect: false});
          });
        }
      });
      if (!this.request.getHeader("user-agent"))
        this.set("User-Agent", `snekfetch/${Package.version} (${Package.homepage})`);
      this._finalizeRequest();
      let data = this.data;
      if (data && data.end)
        data = data.end();
      if (Array.isArray(data)) {
        for (const chunk of data)
          request.write(chunk);
        request.end();
      } else if (data instanceof Stream) {
        data.pipe(request);
      } else if (data instanceof Buffer) {
        request.end(data);
      } else if (data) {
        request.end(data);
      } else {
        request.end();
      }
    });
  }
  function shouldSendRaw(data) {
    return data instanceof Buffer || data instanceof Stream;
  }
  function shouldUnzip(res) {
    if (res.statusCode === 204 || res.statusCode === 304)
      return false;
    if (res.headers["content-length"] === "0")
      return false;
    return /^\s*(?:deflate|gzip)\s*$/.test(res.headers["content-encoding"]);
  }
  module2.exports = {
    buildRequest,
    finalizeRequest,
    shouldSendRaw,
    METHODS: http.METHODS,
    STATUS_CODES: http.STATUS_CODES,
    FormData,
    Extension: Stream.Readable
  };
});

// node_modules/snekfetch/src/index.js
var require_src = __commonJS((exports2, module2) => {
  var browser = typeof window !== "undefined";
  var querystring = require("querystring");
  var transport = browser ? require_browser() : require_node();
  var Snekfetch = class extends transport.Extension {
    constructor(method, url, opts = {}) {
      super();
      this.options = Object.assign({version: 1, qs: querystring, followRedirects: true}, opts);
      this.request = transport.buildRequest.call(this, method, url, opts);
      if (opts.headers)
        this.set(opts.headers);
      if (opts.query)
        this.query(opts.query);
      if (opts.data)
        this.send(opts.data);
    }
    query(name, value) {
      if (!this.request.query)
        this.request.query = {};
      if (name !== null && typeof name === "object") {
        for (const [k, v] of Object.entries(name))
          this.query(k, v);
      } else {
        this.request.query[name] = value;
      }
      return this;
    }
    set(name, value) {
      if (name !== null && typeof name === "object") {
        for (const key of Object.keys(name))
          this.set(key, name[key]);
      } else {
        this.request.setHeader(name, value);
      }
      return this;
    }
    attach(...args) {
      const form = this.data instanceof transport.FormData ? this.data : this.data = new transport.FormData();
      if (typeof args[0] === "object") {
        for (const [k, v] of Object.entries(args[0]))
          this.attach(k, v);
      } else {
        form.append(...args);
      }
      return this;
    }
    send(data) {
      if (data instanceof transport.FormData || transport.shouldSendRaw(data)) {
        this.data = data;
      } else if (data !== null && typeof data === "object") {
        const header = this.request.getHeader("content-type");
        let serialize;
        if (header) {
          if (header.includes("json"))
            serialize = JSON.stringify;
          else if (header.includes("urlencoded"))
            serialize = this.options.qs.stringify;
        } else {
          this.set("Content-Type", "application/json");
          serialize = JSON.stringify;
        }
        this.data = serialize(data);
      } else {
        this.data = data;
      }
      return this;
    }
    then(resolver, rejector) {
      if (this._response)
        return this._response.then(resolver, rejector);
      return this._response = transport.finalizeRequest.call(this).then(({response, raw, redirect, headers}) => {
        if (redirect) {
          let method = this.request.method;
          if ([301, 302].includes(response.statusCode)) {
            if (method !== "HEAD")
              method = "GET";
            this.data = null;
          } else if (response.statusCode === 303) {
            method = "GET";
          }
          const redirectHeaders = this.request.getHeaders();
          delete redirectHeaders.host;
          return new Snekfetch(method, redirect, {
            data: this.data,
            headers: redirectHeaders,
            version: this.options.version
          });
        }
        const statusCode = response.statusCode || response.status;
        const self2 = this;
        const res = {
          request: this.request,
          get body() {
            delete res.body;
            const type = this.headers["content-type"];
            if (type && type.includes("application/json")) {
              try {
                res.body = JSON.parse(res.text);
              } catch (err) {
                res.body = res.text;
              }
            } else if (type && type.includes("application/x-www-form-urlencoded")) {
              res.body = self2.options.qs.parse(res.text);
            } else {
              res.body = raw;
            }
            return res.body;
          },
          text: raw.toString(),
          ok: statusCode >= 200 && statusCode < 400,
          headers: headers || response.headers,
          status: statusCode,
          statusText: response.statusText || transport.STATUS_CODES[response.statusCode]
        };
        if (res.ok) {
          return res;
        } else {
          const err = new Error(`${res.status} ${res.statusText}`.trim());
          Object.assign(err, res);
          return Promise.reject(err);
        }
      }).then(resolver, rejector);
    }
    catch(rejector) {
      return this.then(null, rejector);
    }
    end(cb) {
      return this.then((res) => cb ? cb(null, res) : res, (err) => cb ? cb(err, err.status ? err : null) : Promise.reject(err));
    }
    _finalizeRequest() {
      if (!this.request)
        return;
      if (this.request.method !== "HEAD")
        this.set("Accept-Encoding", "gzip, deflate");
      if (this.data && this.data.getBoundary)
        this.set("Content-Type", `multipart/form-data; boundary=${this.data.getBoundary()}`);
      if (this.request.query) {
        const [path, query] = this.request.path.split("?");
        this.request.path = `${path}?${this.options.qs.stringify(this.request.query)}${query ? `&${query}` : ""}`;
      }
    }
  };
  Snekfetch.METHODS = transport.METHODS.concat("BREW").filter((m) => m !== "M-SEARCH");
  for (const method of Snekfetch.METHODS) {
    Snekfetch[method.toLowerCase()] = function runMethod(url, opts) {
      const Constructor = this.prototype instanceof Snekfetch ? this : Snekfetch;
      return new Constructor(method, url, opts);
    };
  }
  module2.exports = Snekfetch;
});

// node_modules/snekfetch/index.js
var require_snekfetch = __commonJS((exports2, module2) => {
  module2.exports = require_src();
});

// node_modules/discord.js/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "discord.js@11.5.1",
        "D:\\Programming-School\\scrummy-bot"
      ]
    ],
    _from: "discord.js@11.5.1",
    _id: "discord.js@11.5.1",
    _inBundle: false,
    _integrity: "sha512-tGhV5xaZXE3Z+4uXJb3hYM6gQ1NmnSxp9PClcsSAYFVRzH6AJH74040mO3afPDMWEAlj8XsoPXXTJHTxesqcGw==",
    _location: "/discord.js",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "discord.js@11.5.1",
      name: "discord.js",
      escapedName: "discord.js",
      rawSpec: "11.5.1",
      saveSpec: null,
      fetchSpec: "11.5.1"
    },
    _requiredBy: [
      "/"
    ],
    _resolved: "https://registry.npmjs.org/discord.js/-/discord.js-11.5.1.tgz",
    _spec: "11.5.1",
    _where: "D:\\Programming-School\\scrummy-bot",
    author: {
      name: "Amish Shah",
      email: "amishshah.2k@gmail.com"
    },
    browser: {
      ws: false,
      uws: false,
      "@discordjs/uws": false,
      erlpack: false,
      "prism-media": false,
      opusscript: false,
      "node-opus": false,
      tweetnacl: false,
      sodium: false,
      "src/sharding/Shard.js": false,
      "src/sharding/ShardClientUtil.js": false,
      "src/sharding/ShardingManager.js": false,
      "src/client/voice/dispatcher/StreamDispatcher.js": false,
      "src/client/voice/opus/BaseOpusEngine.js": false,
      "src/client/voice/opus/NodeOpusEngine.js": false,
      "src/client/voice/opus/OpusEngineList.js": false,
      "src/client/voice/opus/OpusScriptEngine.js": false,
      "src/client/voice/pcm/ConverterEngine.js": false,
      "src/client/voice/pcm/ConverterEngineList.js": false,
      "src/client/voice/pcm/FfmpegConverterEngine.js": false,
      "src/client/voice/player/AudioPlayer.js": false,
      "src/client/voice/receiver/VoiceReadable.js": false,
      "src/client/voice/receiver/VoiceReceiver.js": false,
      "src/client/voice/util/Secretbox.js": false,
      "src/client/voice/util/SecretKey.js": false,
      "src/client/voice/util/VolumeInterface.js": false,
      "src/client/voice/ClientVoiceManager.js": false,
      "src/client/voice/VoiceBroadcast.js": false,
      "src/client/voice/VoiceConnection.js": false,
      "src/client/voice/VoiceUDPClient.js": false,
      "src/client/voice/VoiceWebSocket.js": false
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    dependencies: {
      long: "^4.0.0",
      "prism-media": "^0.0.3",
      snekfetch: "^3.6.4",
      tweetnacl: "^1.0.0",
      ws: "^6.0.0"
    },
    description: "A powerful library for interacting with the Discord API",
    devDependencies: {
      "@types/node": "^9.4.6",
      "discord.js-docgen": "github:discordjs/docgen",
      eslint: "^5.4.0",
      "parallel-webpack": "^2.3.0",
      tslint: "^3.15.1",
      "tslint-config-typings": "^0.2.4",
      typescript: "^3.0.1",
      "uglifyjs-webpack-plugin": "^1.3.0",
      webpack: "^4.17.0"
    },
    engines: {
      node: ">=6.0.0"
    },
    homepage: "https://github.com/discordjs/discord.js#readme",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    license: "Apache-2.0",
    main: "./src/index",
    name: "discord.js",
    peerDependencies: {
      "@discordjs/uws": "^10.149.0",
      bufferutil: "^4.0.0",
      erlpack: "discordapp/erlpack",
      "libsodium-wrappers": "^0.7.3",
      "node-opus": "^0.2.7",
      opusscript: "^0.0.6",
      sodium: "^2.0.3"
    },
    peerDependenciesMeta: {
      bufferutil: {
        optional: true
      },
      erlpack: {
        optional: true
      },
      "node-opus": {
        optional: true
      },
      opusscript: {
        optional: true
      },
      sodium: {
        optional: true
      },
      "libsodium-wrappers": {
        optional: true
      },
      uws: {
        optional: true
      }
    },
    repository: {
      type: "git",
      url: "git+https://github.com/discordjs/discord.js.git"
    },
    runkitExampleFilename: "./docs/examples/ping.js",
    scripts: {
      docs: "docgen --source src --custom docs/index.yml --output docs/docs.json",
      "docs:test": "docgen --source src --custom docs/index.yml",
      lint: "eslint src",
      "lint:fix": "eslint --fix src",
      "lint:typings": "tslint typings/index.d.ts typings/discord.js-test.ts",
      test: "npm run lint && npm run docs:test",
      webpack: "parallel-webpack"
    },
    types: "./typings/index.d.ts",
    version: "11.5.1"
  };
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports2) => {
  exports2.Package = require_package2();
  exports2.DefaultOptions = {
    apiRequestMethod: "sequential",
    shardId: 0,
    shardCount: 0,
    messageCacheMaxSize: 200,
    messageCacheLifetime: 0,
    messageSweepInterval: 0,
    fetchAllMembers: false,
    disableEveryone: false,
    sync: false,
    restWsBridgeTimeout: 5e3,
    retryLimit: Infinity,
    disabledEvents: [],
    restTimeOffset: 500,
    ws: {
      large_threshold: 250,
      compress: require("os").platform() !== "browser",
      properties: {
        $os: process ? process.platform : "discord.js",
        $browser: "discord.js",
        $device: "discord.js",
        $referrer: "",
        $referring_domain: ""
      },
      version: 6
    },
    http: {
      version: 7,
      host: "https://discordapp.com",
      cdn: "https://cdn.discordapp.com"
    }
  };
  exports2.WSCodes = {
    1e3: "Connection gracefully closed",
    4004: "Tried to identify with an invalid token",
    4010: "Sharding data provided was invalid",
    4011: "Shard would be on too many guilds if connected"
  };
  exports2.Errors = {
    NO_TOKEN: "Request to use token, but token was unavailable to the client.",
    NO_BOT_ACCOUNT: "Only bot accounts are able to make use of this feature.",
    NO_USER_ACCOUNT: "Only user accounts are able to make use of this feature.",
    BAD_WS_MESSAGE: "A bad message was received from the websocket; either bad compression, or not JSON.",
    TOOK_TOO_LONG: "Something took too long to do.",
    NOT_A_PERMISSION: "Invalid permission string or number.",
    INVALID_RATE_LIMIT_METHOD: "Unknown rate limiting method.",
    BAD_LOGIN: "Incorrect login details were provided.",
    INVALID_SHARD: "Invalid shard settings were provided.",
    SHARDING_REQUIRED: "This session would have handled too many guilds - Sharding is required.",
    INVALID_TOKEN: "An invalid token was provided."
  };
  var Endpoints = exports2.Endpoints = {
    User: (userID) => {
      if (userID.id)
        userID = userID.id;
      const base = `/users/${userID}`;
      return {
        toString: () => base,
        channels: `${base}/channels`,
        profile: `${base}/profile`,
        relationships: `${base}/relationships`,
        settings: `${base}/settings`,
        Relationship: (uID) => `${base}/relationships/${uID}`,
        Guild: (guildID) => ({
          toString: () => `${base}/guilds/${guildID}`,
          settings: `${base}/guilds/${guildID}/settings`
        }),
        Note: (id) => `${base}/notes/${id}`,
        Mentions: (limit, roles, everyone, guildID) => `${base}/mentions?limit=${limit}&roles=${roles}&everyone=${everyone}${guildID ? `&guild_id=${guildID}` : ""}`,
        Avatar: (root, hash) => {
          if (userID === "1")
            return hash;
          return Endpoints.CDN(root).Avatar(userID, hash);
        }
      };
    },
    guilds: "/guilds",
    Guild: (guildID) => {
      if (guildID.id)
        guildID = guildID.id;
      const base = `/guilds/${guildID}`;
      return {
        toString: () => base,
        prune: `${base}/prune`,
        embed: `${base}/embed`,
        bans: `${base}/bans`,
        integrations: `${base}/integrations`,
        members: `${base}/members`,
        channels: `${base}/channels`,
        invites: `${base}/invites`,
        roles: `${base}/roles`,
        emojis: `${base}/emojis`,
        search: `${base}/messages/search`,
        vanityURL: `${base}/vanity-url`,
        voiceRegions: `${base}/regions`,
        webhooks: `${base}/webhooks`,
        ack: `${base}/ack`,
        settings: `${base}/settings`,
        auditLogs: `${base}/audit-logs`,
        Emoji: (emojiID) => `${base}/emojis/${emojiID}`,
        Icon: (root, hash) => Endpoints.CDN(root).Icon(guildID, hash),
        Splash: (root, hash) => Endpoints.CDN(root).Splash(guildID, hash),
        Role: (roleID) => `${base}/roles/${roleID}`,
        Member: (memberID) => {
          if (memberID.id)
            memberID = memberID.id;
          const mbase = `${base}/members/${memberID}`;
          return {
            toString: () => mbase,
            Role: (roleID) => `${mbase}/roles/${roleID}`,
            nickname: `${base}/members/@me/nick`
          };
        }
      };
    },
    channels: "/channels",
    Channel: (channelID) => {
      if (channelID.id)
        channelID = channelID.id;
      const base = `/channels/${channelID}`;
      return {
        toString: () => base,
        messages: {
          toString: () => `${base}/messages`,
          bulkDelete: `${base}/messages/bulk-delete`
        },
        invites: `${base}/invites`,
        typing: `${base}/typing`,
        permissions: `${base}/permissions`,
        webhooks: `${base}/webhooks`,
        search: `${base}/messages/search`,
        pins: `${base}/pins`,
        Icon: (root, hash) => Endpoints.CDN(root).GDMIcon(channelID, hash),
        Pin: (messageID) => `${base}/pins/${messageID}`,
        Recipient: (recipientID) => `${base}/recipients/${recipientID}`,
        Message: (messageID) => {
          if (messageID.id)
            messageID = messageID.id;
          const mbase = `${base}/messages/${messageID}`;
          return {
            toString: () => mbase,
            reactions: `${mbase}/reactions`,
            ack: `${mbase}/ack`,
            Reaction: (emoji) => {
              const rbase = `${mbase}/reactions/${emoji}`;
              return {
                toString: () => rbase,
                User: (userID) => `${rbase}/${userID}`
              };
            }
          };
        }
      };
    },
    Message: (m) => exports2.Endpoints.Channel(m.channel).Message(m),
    Member: (m) => exports2.Endpoints.Guild(m.guild).Member(m),
    CDN(root) {
      return {
        Emoji: (emojiID, format = "png") => `${root}/emojis/${emojiID}.${format}`,
        Asset: (name) => `${root}/assets/${name}`,
        Avatar: (userID, hash) => `${root}/avatars/${userID}/${hash}.${hash.startsWith("a_") ? "gif" : "png?size=2048"}`,
        Icon: (guildID, hash) => `${root}/icons/${guildID}/${hash}.jpg`,
        AppIcon: (clientID, hash) => `${root}/app-icons/${clientID}/${hash}.png`,
        AppAsset: (clientID, hash) => `${root}/app-assets/${clientID}/${hash}.png`,
        GDMIcon: (channelID, hash) => `${root}/channel-icons/${channelID}/${hash}.jpg?size=2048`,
        Splash: (guildID, hash) => `${root}/splashes/${guildID}/${hash}.jpg`
      };
    },
    OAUTH2: {
      Application: (appID) => {
        const base = `/oauth2/applications/${appID}`;
        return {
          toString: () => base,
          resetSecret: `${base}/reset`,
          resetToken: `${base}/bot/reset`
        };
      },
      App: (appID) => `/oauth2/authorize?client_id=${appID}`
    },
    login: "/auth/login",
    logout: "/auth/logout",
    voiceRegions: "/voice/regions",
    gateway: {
      toString: () => "/gateway",
      bot: "/gateway/bot"
    },
    Invite: (inviteID) => `/invite/${inviteID}?with_counts=true`,
    inviteLink: (id) => `https://discord.gg/${id}`,
    Webhook: (webhookID, token) => `/webhooks/${webhookID}${token ? `/${token}` : ""}`
  };
  exports2.Status = {
    READY: 0,
    CONNECTING: 1,
    RECONNECTING: 2,
    IDLE: 3,
    NEARLY: 4,
    DISCONNECTED: 5
  };
  exports2.VoiceStatus = {
    CONNECTED: 0,
    CONNECTING: 1,
    AUTHENTICATING: 2,
    RECONNECTING: 3,
    DISCONNECTED: 4
  };
  exports2.ChannelTypes = {
    TEXT: 0,
    DM: 1,
    VOICE: 2,
    GROUP_DM: 3,
    CATEGORY: 4,
    NEWS: 5,
    STORE: 6
  };
  exports2.OPCodes = {
    DISPATCH: 0,
    HEARTBEAT: 1,
    IDENTIFY: 2,
    STATUS_UPDATE: 3,
    VOICE_STATE_UPDATE: 4,
    VOICE_GUILD_PING: 5,
    RESUME: 6,
    RECONNECT: 7,
    REQUEST_GUILD_MEMBERS: 8,
    INVALID_SESSION: 9,
    HELLO: 10,
    HEARTBEAT_ACK: 11
  };
  exports2.VoiceOPCodes = {
    IDENTIFY: 0,
    SELECT_PROTOCOL: 1,
    READY: 2,
    HEARTBEAT: 3,
    SESSION_DESCRIPTION: 4,
    SPEAKING: 5
  };
  exports2.Events = {
    RATE_LIMIT: "rateLimit",
    READY: "ready",
    RESUME: "resume",
    GUILD_CREATE: "guildCreate",
    GUILD_DELETE: "guildDelete",
    GUILD_UPDATE: "guildUpdate",
    GUILD_UNAVAILABLE: "guildUnavailable",
    GUILD_AVAILABLE: "guildAvailable",
    GUILD_MEMBER_ADD: "guildMemberAdd",
    GUILD_MEMBER_REMOVE: "guildMemberRemove",
    GUILD_MEMBER_UPDATE: "guildMemberUpdate",
    GUILD_MEMBER_AVAILABLE: "guildMemberAvailable",
    GUILD_MEMBER_SPEAKING: "guildMemberSpeaking",
    GUILD_MEMBERS_CHUNK: "guildMembersChunk",
    GUILD_INTEGRATIONS_UPDATE: "guildIntegrationsUpdate",
    GUILD_ROLE_CREATE: "roleCreate",
    GUILD_ROLE_DELETE: "roleDelete",
    GUILD_ROLE_UPDATE: "roleUpdate",
    GUILD_EMOJI_CREATE: "emojiCreate",
    GUILD_EMOJI_DELETE: "emojiDelete",
    GUILD_EMOJI_UPDATE: "emojiUpdate",
    GUILD_BAN_ADD: "guildBanAdd",
    GUILD_BAN_REMOVE: "guildBanRemove",
    CHANNEL_CREATE: "channelCreate",
    CHANNEL_DELETE: "channelDelete",
    CHANNEL_UPDATE: "channelUpdate",
    CHANNEL_PINS_UPDATE: "channelPinsUpdate",
    MESSAGE_CREATE: "message",
    MESSAGE_DELETE: "messageDelete",
    MESSAGE_UPDATE: "messageUpdate",
    MESSAGE_BULK_DELETE: "messageDeleteBulk",
    MESSAGE_REACTION_ADD: "messageReactionAdd",
    MESSAGE_REACTION_REMOVE: "messageReactionRemove",
    MESSAGE_REACTION_REMOVE_ALL: "messageReactionRemoveAll",
    USER_UPDATE: "userUpdate",
    USER_NOTE_UPDATE: "userNoteUpdate",
    USER_SETTINGS_UPDATE: "clientUserSettingsUpdate",
    USER_GUILD_SETTINGS_UPDATE: "clientUserGuildSettingsUpdate",
    PRESENCE_UPDATE: "presenceUpdate",
    VOICE_STATE_UPDATE: "voiceStateUpdate",
    TYPING_START: "typingStart",
    TYPING_STOP: "typingStop",
    WEBHOOKS_UPDATE: "webhookUpdate",
    DISCONNECT: "disconnect",
    RECONNECTING: "reconnecting",
    ERROR: "error",
    WARN: "warn",
    DEBUG: "debug"
  };
  exports2.ActivityTypes = [
    "PLAYING",
    "STREAMING",
    "LISTENING",
    "WATCHING"
  ];
  exports2.ActivityFlags = {
    INSTANCE: 1 << 0,
    JOIN: 1 << 1,
    SPECTATE: 1 << 2,
    JOIN_REQUEST: 1 << 3,
    SYNC: 1 << 4,
    PLAY: 1 << 5
  };
  exports2.WSEvents = {
    READY: "READY",
    RESUMED: "RESUMED",
    GUILD_SYNC: "GUILD_SYNC",
    GUILD_CREATE: "GUILD_CREATE",
    GUILD_DELETE: "GUILD_DELETE",
    GUILD_UPDATE: "GUILD_UPDATE",
    GUILD_MEMBER_ADD: "GUILD_MEMBER_ADD",
    GUILD_MEMBER_REMOVE: "GUILD_MEMBER_REMOVE",
    GUILD_MEMBER_UPDATE: "GUILD_MEMBER_UPDATE",
    GUILD_MEMBERS_CHUNK: "GUILD_MEMBERS_CHUNK",
    GUILD_INTEGRATIONS_UPDATE: "GUILD_INTEGRATIONS_UPDATE",
    GUILD_ROLE_CREATE: "GUILD_ROLE_CREATE",
    GUILD_ROLE_DELETE: "GUILD_ROLE_DELETE",
    GUILD_ROLE_UPDATE: "GUILD_ROLE_UPDATE",
    GUILD_BAN_ADD: "GUILD_BAN_ADD",
    GUILD_BAN_REMOVE: "GUILD_BAN_REMOVE",
    GUILD_EMOJIS_UPDATE: "GUILD_EMOJIS_UPDATE",
    CHANNEL_CREATE: "CHANNEL_CREATE",
    CHANNEL_DELETE: "CHANNEL_DELETE",
    CHANNEL_UPDATE: "CHANNEL_UPDATE",
    CHANNEL_PINS_UPDATE: "CHANNEL_PINS_UPDATE",
    MESSAGE_CREATE: "MESSAGE_CREATE",
    MESSAGE_DELETE: "MESSAGE_DELETE",
    MESSAGE_UPDATE: "MESSAGE_UPDATE",
    MESSAGE_DELETE_BULK: "MESSAGE_DELETE_BULK",
    MESSAGE_REACTION_ADD: "MESSAGE_REACTION_ADD",
    MESSAGE_REACTION_REMOVE: "MESSAGE_REACTION_REMOVE",
    MESSAGE_REACTION_REMOVE_ALL: "MESSAGE_REACTION_REMOVE_ALL",
    USER_UPDATE: "USER_UPDATE",
    USER_NOTE_UPDATE: "USER_NOTE_UPDATE",
    USER_SETTINGS_UPDATE: "USER_SETTINGS_UPDATE",
    USER_GUILD_SETTINGS_UPDATE: "USER_GUILD_SETTINGS_UPDATE",
    PRESENCE_UPDATE: "PRESENCE_UPDATE",
    VOICE_STATE_UPDATE: "VOICE_STATE_UPDATE",
    TYPING_START: "TYPING_START",
    VOICE_SERVER_UPDATE: "VOICE_SERVER_UPDATE",
    RELATIONSHIP_ADD: "RELATIONSHIP_ADD",
    RELATIONSHIP_REMOVE: "RELATIONSHIP_REMOVE",
    WEBHOOKS_UPDATE: "WEBHOOKS_UPDATE"
  };
  exports2.MessageTypes = [
    "DEFAULT",
    "RECIPIENT_ADD",
    "RECIPIENT_REMOVE",
    "CALL",
    "CHANNEL_NAME_CHANGE",
    "CHANNEL_ICON_CHANGE",
    "PINS_ADD",
    "GUILD_MEMBER_JOIN"
  ];
  exports2.MessageNotificationTypes = [
    "EVERYTHING",
    "MENTIONS",
    "NOTHING",
    "INHERIT"
  ];
  exports2.DefaultAvatars = {
    BLURPLE: "6debd47ed13483642cf09e832ed0bc1b",
    GREY: "322c936a8c8be1b803cd94861bdfa868",
    GREEN: "dd4dbc0016779df1378e7812eabaa04d",
    ORANGE: "0e291f67c9274a1abdddeb3fd919cbaa",
    RED: "1cbd08c76f8af6dddce02c5138971129"
  };
  exports2.ExplicitContentFilterTypes = [
    "DISABLED",
    "NON_FRIENDS",
    "FRIENDS_AND_NON_FRIENDS"
  ];
  exports2.UserSettingsMap = {
    convert_emoticons: "convertEmoticons",
    default_guilds_restricted: "defaultGuildsRestricted",
    detect_platform_accounts: "detectPlatformAccounts",
    developer_mode: "developerMode",
    enable_tts_command: "enableTTSCommand",
    theme: "theme",
    status: "status",
    show_current_game: "showCurrentGame",
    inline_attachment_media: "inlineAttachmentMedia",
    inline_embed_media: "inlineEmbedMedia",
    locale: "locale",
    message_display_compact: "messageDisplayCompact",
    render_reactions: "renderReactions",
    guild_positions: "guildPositions",
    restricted_guilds: "restrictedGuilds",
    explicit_content_filter: function explicitContentFilter(type) {
      return exports2.ExplicitContentFilterTypes[type];
    },
    friend_source_flags: function friendSources(flags) {
      return {
        all: flags.all || false,
        mutualGuilds: flags.all ? true : flags.mutual_guilds || false,
        mutualFriends: flags.all ? true : flags.mutualFriends || false
      };
    }
  };
  exports2.UserGuildSettingsMap = {
    message_notifications: function messageNotifications(type) {
      return exports2.MessageNotificationTypes[type];
    },
    mobile_push: "mobilePush",
    muted: "muted",
    suppress_everyone: "suppressEveryone",
    channel_overrides: "channelOverrides"
  };
  exports2.UserChannelOverrideMap = {
    message_notifications: function messageNotifications(type) {
      return exports2.MessageNotificationTypes[type];
    },
    muted: "muted"
  };
  exports2.Colors = {
    DEFAULT: 0,
    WHITE: 16777215,
    AQUA: 1752220,
    GREEN: 3066993,
    BLUE: 3447003,
    PURPLE: 10181046,
    LUMINOUS_VIVID_PINK: 15277667,
    GOLD: 15844367,
    ORANGE: 15105570,
    RED: 15158332,
    GREY: 9807270,
    NAVY: 3426654,
    DARK_AQUA: 1146986,
    DARK_GREEN: 2067276,
    DARK_BLUE: 2123412,
    DARK_PURPLE: 7419530,
    DARK_VIVID_PINK: 11342935,
    DARK_GOLD: 12745742,
    DARK_ORANGE: 11027200,
    DARK_RED: 10038562,
    DARK_GREY: 9936031,
    DARKER_GREY: 8359053,
    LIGHT_GREY: 12370112,
    DARK_NAVY: 2899536,
    BLURPLE: 7506394,
    GREYPLE: 10070709,
    DARK_BUT_NOT_BLACK: 2895667,
    NOT_QUITE_BLACK: 2303786
  };
  exports2.APIErrors = {
    UNKNOWN_ACCOUNT: 10001,
    UNKNOWN_APPLICATION: 10002,
    UNKNOWN_CHANNEL: 10003,
    UNKNOWN_GUILD: 10004,
    UNKNOWN_INTEGRATION: 10005,
    UNKNOWN_INVITE: 10006,
    UNKNOWN_MEMBER: 10007,
    UNKNOWN_MESSAGE: 10008,
    UNKNOWN_OVERWRITE: 10009,
    UNKNOWN_PROVIDER: 10010,
    UNKNOWN_ROLE: 10011,
    UNKNOWN_TOKEN: 10012,
    UNKNOWN_USER: 10013,
    UNKNOWN_EMOJI: 10014,
    UNKNOWN_WEBHOOK: 10015,
    BOT_PROHIBITED_ENDPOINT: 20001,
    BOT_ONLY_ENDPOINT: 20002,
    MAXIMUM_GUILDS: 30001,
    MAXIMUM_FRIENDS: 30002,
    MAXIMUM_PINS: 30003,
    MAXIMUM_ROLES: 30005,
    MAXIMUM_REACTIONS: 30010,
    UNAUTHORIZED: 40001,
    MISSING_ACCESS: 50001,
    INVALID_ACCOUNT_TYPE: 50002,
    CANNOT_EXECUTE_ON_DM: 50003,
    EMBED_DISABLED: 50004,
    CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,
    CANNOT_SEND_EMPTY_MESSAGE: 50006,
    CANNOT_MESSAGE_USER: 50007,
    CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,
    CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,
    OAUTH2_APPLICATION_BOT_ABSENT: 50010,
    MAXIMUM_OAUTH2_APPLICATIONS: 50011,
    INVALID_OAUTH_STATE: 50012,
    MISSING_PERMISSIONS: 50013,
    INVALID_AUTHENTICATION_TOKEN: 50014,
    NOTE_TOO_LONG: 50015,
    INVALID_BULK_DELETE_QUANTITY: 50016,
    CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,
    INVALID_OR_TAKEN_INVITE_CODE: 50020,
    CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,
    BULK_DELETE_MESSAGE_TOO_OLD: 50034,
    INVITE_ACCEPTED_TO_GUILD_NOT_CONTANING_BOT: 50036,
    REACTION_BLOCKED: 90001
  };
  exports2.DefaultMessageNotifications = [
    "ALL",
    "MENTIONS"
  ];
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports2, module2) => {
  var snekfetch = require_snekfetch();
  var Constants2 = require_Constants();
  var ConstantsHttp = Constants2.DefaultOptions.http;
  var Util2 = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static splitMessage(text, {maxLength = 1950, char = "\n", prepend = "", append = ""} = {}) {
      if (text.length <= maxLength)
        return text;
      const splitText = text.split(char);
      if (splitText.some((chunk) => chunk.length > maxLength)) {
        throw new Error("Message exceeds the max length and contains no split characters.");
      }
      const messages = [""];
      let msg = 0;
      for (let i = 0; i < splitText.length; i++) {
        if (messages[msg].length + splitText[i].length + 1 > maxLength) {
          messages[msg] += append;
          messages.push(prepend);
          msg++;
        }
        messages[msg] += (messages[msg].length > 0 && messages[msg] !== prepend ? char : "") + splitText[i];
      }
      return messages;
    }
    static escapeMarkdown(text, onlyCodeBlock = false, onlyInlineCode = false) {
      if (onlyCodeBlock)
        return text.replace(/```/g, "`\u200B``");
      if (onlyInlineCode)
        return text.replace(/\\(`|\\)/g, "$1").replace(/(`|\\)/g, "\\$1");
      return text.replace(/\\(\*|_|`|~|\\)/g, "$1").replace(/(\*|_|`|~|\\)/g, "\\$1");
    }
    static fetchRecommendedShards(token, guildsPerShard = 1e3) {
      return new Promise((resolve, reject) => {
        if (!token)
          throw new Error("A token must be provided.");
        snekfetch.get(`${ConstantsHttp.host}/api/v${ConstantsHttp.version}${Constants2.Endpoints.gateway.bot}`).set("Authorization", `Bot ${token.replace(/^Bot\s*/i, "")}`).end((err, res) => {
          if (err)
            reject(err);
          resolve(res.body.shards * (1e3 / guildsPerShard));
        });
      });
    }
    static parseEmoji(text) {
      if (text.includes("%"))
        text = decodeURIComponent(text);
      if (!text.includes(":"))
        return {animated: false, name: text, id: null};
      const m = text.match(/<?(a:)?(\w{2,32}):(\d{17,19})>?/);
      if (!m)
        return null;
      return {animated: Boolean(m[1]), name: m[2], id: m[3]};
    }
    static arraysEqual(a, b) {
      if (a === b)
        return true;
      if (a.length !== b.length)
        return false;
      for (const item of a) {
        const ind = b.indexOf(item);
        if (ind !== -1)
          b.splice(ind, 1);
      }
      return b.length === 0;
    }
    static cloneObject(obj) {
      return Object.assign(Object.create(obj), obj);
    }
    static mergeDefault(def, given) {
      if (!given)
        return def;
      for (const key in def) {
        if (!{}.hasOwnProperty.call(given, key)) {
          given[key] = def[key];
        } else if (given[key] === Object(given[key])) {
          given[key] = this.mergeDefault(def[key], given[key]);
        }
      }
      return given;
    }
    static convertToBuffer(ab) {
      if (typeof ab === "string")
        ab = this.str2ab(ab);
      return Buffer.from(ab);
    }
    static str2ab(str) {
      const buffer = new ArrayBuffer(str.length * 2);
      const view = new Uint16Array(buffer);
      for (var i = 0, strLen = str.length; i < strLen; i++)
        view[i] = str.charCodeAt(i);
      return buffer;
    }
    static makeError(obj) {
      const err = new Error(obj.message);
      err.name = obj.name;
      err.stack = obj.stack;
      return err;
    }
    static makePlainError(err) {
      const obj = {};
      obj.name = err.name;
      obj.message = err.message;
      obj.stack = err.stack;
      return obj;
    }
    static moveElementInArray(array, element, newIndex, offset = false) {
      const index = array.indexOf(element);
      newIndex = (offset ? index : 0) + newIndex;
      if (newIndex > -1 && newIndex < array.length) {
        const removedElement = array.splice(index, 1)[0];
        array.splice(newIndex, 0, removedElement);
      }
      return array.indexOf(element);
    }
    static delayFor(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
  };
  module2.exports = Util2;
});

// node_modules/discord.js/src/util/Permissions.js
var require_Permissions = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var util = require("util");
  var Permissions2 = class {
    constructor(member, permissions) {
      permissions = typeof member === "object" && !(member instanceof Array) ? permissions : member;
      this._member = typeof member === "object" ? member : null;
      this.bitfield = typeof permissions === "number" ? permissions : this.constructor.resolve(permissions);
    }
    get member() {
      return this._member;
    }
    set member(value) {
      this._member = value;
    }
    get raw() {
      return this.bitfield;
    }
    set raw(raw) {
      this.bitfield = raw;
    }
    has(permission, checkAdmin = true) {
      if (permission instanceof Array)
        return permission.every((p) => this.has(p, checkAdmin));
      permission = this.constructor.resolve(permission);
      if (checkAdmin && (this.bitfield & this.constructor.FLAGS.ADMINISTRATOR) > 0)
        return true;
      return (this.bitfield & permission) === permission;
    }
    missing(permissions, checkAdmin = true) {
      if (!(permissions instanceof Array))
        permissions = [permissions];
      return permissions.filter((p) => !this.has(p, checkAdmin));
    }
    add(...permissions) {
      let total = 0;
      for (let p = permissions.length - 1; p >= 0; p--) {
        const perm = this.constructor.resolve(permissions[p]);
        total |= perm;
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...permissions) {
      let total = 0;
      for (let p = permissions.length - 1; p >= 0; p--) {
        const perm = this.constructor.resolve(permissions[p]);
        total |= perm;
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(checkAdmin = true) {
      const serialized = {};
      for (const perm in this.constructor.FLAGS)
        serialized[perm] = this.has(perm, checkAdmin);
      return serialized;
    }
    hasPermission(permission, explicit = false) {
      return this.has(permission, !explicit);
    }
    hasPermissions(permissions, explicit = false) {
      return this.has(permissions, !explicit);
    }
    missingPermissions(permissions, explicit = false) {
      return this.missing(permissions, !explicit);
    }
    toArray(checkAdmin = true) {
      return Object.keys(this.constructor.FLAGS).filter((perm) => this.has(perm, checkAdmin));
    }
    freeze() {
      return Object.freeze(this);
    }
    valueOf() {
      return this.bitfield;
    }
    static resolve(permission) {
      if (permission instanceof Array)
        return permission.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, 0);
      if (permission instanceof Permissions2)
        return permission.bitfield;
      if (typeof permission === "string")
        permission = this.FLAGS[permission];
      if (typeof permission !== "number" || permission < 0)
        throw new RangeError(Constants2.Errors.NOT_A_PERMISSION);
      return permission;
    }
  };
  Permissions2.FLAGS = {
    CREATE_INSTANT_INVITE: 1 << 0,
    KICK_MEMBERS: 1 << 1,
    BAN_MEMBERS: 1 << 2,
    ADMINISTRATOR: 1 << 3,
    MANAGE_CHANNELS: 1 << 4,
    MANAGE_GUILD: 1 << 5,
    ADD_REACTIONS: 1 << 6,
    VIEW_AUDIT_LOG: 1 << 7,
    PRIORITY_SPEAKER: 1 << 8,
    VIEW_CHANNEL: 1 << 10,
    READ_MESSAGES: 1 << 10,
    SEND_MESSAGES: 1 << 11,
    SEND_TTS_MESSAGES: 1 << 12,
    MANAGE_MESSAGES: 1 << 13,
    EMBED_LINKS: 1 << 14,
    ATTACH_FILES: 1 << 15,
    READ_MESSAGE_HISTORY: 1 << 16,
    MENTION_EVERYONE: 1 << 17,
    EXTERNAL_EMOJIS: 1 << 18,
    USE_EXTERNAL_EMOJIS: 1 << 18,
    CONNECT: 1 << 20,
    SPEAK: 1 << 21,
    MUTE_MEMBERS: 1 << 22,
    DEAFEN_MEMBERS: 1 << 23,
    MOVE_MEMBERS: 1 << 24,
    USE_VAD: 1 << 25,
    CHANGE_NICKNAME: 1 << 26,
    MANAGE_NICKNAMES: 1 << 27,
    MANAGE_ROLES: 1 << 28,
    MANAGE_ROLES_OR_PERMISSIONS: 1 << 28,
    MANAGE_WEBHOOKS: 1 << 29,
    MANAGE_EMOJIS: 1 << 30
  };
  Permissions2.ALL = Object.keys(Permissions2.FLAGS).reduce((all, p) => all | Permissions2.FLAGS[p], 0);
  Permissions2.DEFAULT = 104324097;
  Permissions2.prototype.hasPermission = util.deprecate(Permissions2.prototype.hasPermission, "EvaluatedPermissions#hasPermission is deprecated, use Permissions#has instead");
  Permissions2.prototype.hasPermissions = util.deprecate(Permissions2.prototype.hasPermissions, "EvaluatedPermissions#hasPermissions is deprecated, use Permissions#has instead");
  Permissions2.prototype.missingPermissions = util.deprecate(Permissions2.prototype.missingPermissions, "EvaluatedPermissions#missingPermissions is deprecated, use Permissions#missing instead");
  Object.defineProperty(Permissions2.prototype, "member", {
    get: util.deprecate(Object.getOwnPropertyDescriptor(Permissions2.prototype, "member").get, "EvaluatedPermissions#member is deprecated")
  });
  module2.exports = Permissions2;
});

// node_modules/discord.js/src/client/rest/UserAgentManager.js
var require_UserAgentManager = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var UserAgentManager = class {
    constructor() {
      this.build(this.constructor.DEFAULT);
    }
    set({url, version} = {}) {
      this.build({
        url: url || this.constructor.DFEAULT.url,
        version: version || this.constructor.DEFAULT.version
      });
    }
    build(ua) {
      this.userAgent = `DiscordBot (${ua.url}, ${ua.version}) Node.js/${process.version}`;
    }
  };
  UserAgentManager.DEFAULT = {
    url: Constants2.Package.homepage.split("#")[0],
    version: Constants2.Package.version
  };
  module2.exports = UserAgentManager;
});

// node_modules/long/src/long.js
var require_long = __commonJS((exports2, module2) => {
  module2.exports = Long2;
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  function Long2(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long2.prototype.__isLong__;
  Object.defineProperty(Long2.prototype, "__isLong__", {value: true});
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  Long2.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long2.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long2.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long2(lowBits, highBits, unsigned);
  }
  Long2.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return ZERO;
    if (typeof unsigned === "number") {
      radix = unsigned, unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long2.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long2.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long2.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long2.UZERO = UZERO;
  var ONE = fromInt(1);
  Long2.ONE = ONE;
  var UONE = fromInt(1, true);
  Long2.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long2.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long2.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long2.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long2.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(other);
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(other) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(other) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return ZERO;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      var high = this.high;
      if (numBits < 32) {
        var low = this.low;
        return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return fromBits(high, 0, this.unsigned);
      else
        return fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
  };
  Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
});

// node_modules/discord.js/src/util/Collection.js
var require_Collection = __commonJS((exports2, module2) => {
  var util = require("util");
  var Collection2 = class extends Map {
    constructor(iterable) {
      super(iterable);
      Object.defineProperty(this, "_array", {value: null, writable: true, configurable: true});
      Object.defineProperty(this, "_keyArray", {value: null, writable: true, configurable: true});
    }
    set(key, val) {
      this._array = null;
      this._keyArray = null;
      return super.set(key, val);
    }
    delete(key) {
      this._array = null;
      this._keyArray = null;
      return super.delete(key);
    }
    array() {
      if (!this._array || this._array.length !== this.size)
        this._array = [...this.values()];
      return this._array;
    }
    keyArray() {
      if (!this._keyArray || this._keyArray.length !== this.size)
        this._keyArray = [...this.keys()];
      return this._keyArray;
    }
    first(count) {
      if (count === void 0)
        return this.values().next().value;
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      count = Math.min(this.size, count);
      const arr = new Array(count);
      const iter = this.values();
      for (let i = 0; i < count; i++)
        arr[i] = iter.next().value;
      return arr;
    }
    firstKey(count) {
      if (count === void 0)
        return this.keys().next().value;
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      count = Math.min(this.size, count);
      const arr = new Array(count);
      const iter = this.keys();
      for (let i = 0; i < count; i++)
        arr[i] = iter.next().value;
      return arr;
    }
    last(count) {
      const arr = this.array();
      if (count === void 0)
        return arr[arr.length - 1];
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      return arr.slice(-count);
    }
    lastKey(count) {
      const arr = this.keyArray();
      if (count === void 0)
        return arr[arr.length - 1];
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      return arr.slice(-count);
    }
    random(count) {
      let arr = this.array();
      if (count === void 0)
        return arr[Math.floor(Math.random() * arr.length)];
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      if (arr.length === 0)
        return [];
      const rand = new Array(count);
      arr = arr.slice();
      for (let i = 0; i < count; i++)
        rand[i] = arr.splice(Math.floor(Math.random() * arr.length), 1)[0];
      return rand;
    }
    randomKey(count) {
      let arr = this.keyArray();
      if (count === void 0)
        return arr[Math.floor(Math.random() * arr.length)];
      if (typeof count !== "number")
        throw new TypeError("The count must be a number.");
      if (!Number.isInteger(count) || count < 1)
        throw new RangeError("The count must be an integer greater than 0.");
      if (arr.length === 0)
        return [];
      const rand = new Array(count);
      arr = arr.slice();
      for (let i = 0; i < count; i++)
        rand[i] = arr.splice(Math.floor(Math.random() * arr.length), 1)[0];
      return rand;
    }
    findAll(prop, value) {
      if (typeof prop !== "string")
        throw new TypeError("Key must be a string.");
      if (typeof value === "undefined")
        throw new Error("Value must be specified.");
      const results = [];
      for (const item of this.values()) {
        if (item[prop] === value)
          results.push(item);
      }
      return results;
    }
    find(propOrFn, value) {
      if (typeof propOrFn === "string") {
        if (typeof value === "undefined")
          throw new Error("Value must be specified.");
        for (const item of this.values()) {
          if (item[propOrFn] === value)
            return item;
        }
        return null;
      } else if (typeof propOrFn === "function") {
        for (const [key, val] of this) {
          if (propOrFn(val, key, this))
            return val;
        }
        return null;
      } else {
        throw new Error("First argument must be a property string or a function.");
      }
    }
    findKey(propOrFn, value) {
      if (typeof propOrFn === "string") {
        if (typeof value === "undefined")
          throw new Error("Value must be specified.");
        for (const [key, val] of this) {
          if (val[propOrFn] === value)
            return key;
        }
        return null;
      } else if (typeof propOrFn === "function") {
        for (const [key, val] of this) {
          if (propOrFn(val, key, this))
            return key;
        }
        return null;
      } else {
        throw new Error("First argument must be a property string or a function.");
      }
    }
    exists(prop, value) {
      return Boolean(this.find(prop, value));
    }
    sweep(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      const results = new Collection2();
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    filterArray(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      const results = [];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.push(val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof thisArg !== "undefined")
        fn = fn.bind(thisArg);
      const results = [new Collection2(), new Collection2()];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    map(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      const arr = new Array(this.size);
      let i = 0;
      for (const [key, val] of this)
        arr[i++] = fn(val, key, this);
      return arr;
    }
    some(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (thisArg)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      let accumulator;
      if (typeof initialValue !== "undefined") {
        accumulator = initialValue;
        for (const [key, val] of this)
          accumulator = fn(accumulator, val, key, this);
      } else {
        let first = true;
        for (const [key, val] of this) {
          if (first) {
            accumulator = val;
            first = false;
            continue;
          }
          accumulator = fn(accumulator, val, key, this);
        }
      }
      return accumulator;
    }
    tap(fn, thisArg) {
      this.forEach(fn, thisArg);
      return this;
    }
    clone() {
      return new this.constructor(this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    deleteAll() {
      const returns = [];
      for (const item of this.values()) {
        if (item.delete)
          returns.push(item.delete());
      }
      return returns;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      return !this.find((value, key) => {
        const testVal = collection.get(key);
        return testVal !== value || testVal === void 0 && !collection.has(key);
      });
    }
    sort(compareFunction = (x, y) => +(x > y) || +(x === y) - 1) {
      return new Collection2([...this.entries()].sort((a, b) => compareFunction(a[1], b[1], a[0], b[0])));
    }
  };
  Collection2.prototype.findAll = util.deprecate(Collection2.prototype.findAll, "Collection#findAll: use Collection#filter instead");
  Collection2.prototype.filterArray = util.deprecate(Collection2.prototype.filterArray, "Collection#filterArray: use Collection#filter instead");
  Collection2.prototype.exists = util.deprecate(Collection2.prototype.exists, "Collection#exists: use Collection#some instead");
  Collection2.prototype.find = function find(propOrFn, value) {
    if (typeof propOrFn === "string") {
      process.emitWarning("Collection#find: pass a function instead", "DeprecationWarning");
      if (typeof value === "undefined")
        throw new Error("Value must be specified.");
      for (const item of this.values()) {
        if (item[propOrFn] === value)
          return item;
      }
      return null;
    } else if (typeof propOrFn === "function") {
      for (const [key, val] of this) {
        if (propOrFn(val, key, this))
          return val;
      }
      return null;
    } else {
      throw new Error("First argument must be a property string or a function.");
    }
  };
  Collection2.prototype.findKey = function findKey(propOrFn, value) {
    if (typeof propOrFn === "string") {
      process.emitWarning("Collection#findKey: pass a function instead", "DeprecationWarning");
      if (typeof value === "undefined")
        throw new Error("Value must be specified.");
      for (const [key, val] of this) {
        if (val[propOrFn] === value)
          return key;
      }
      return null;
    } else if (typeof propOrFn === "function") {
      for (const [key, val] of this) {
        if (propOrFn(val, key, this))
          return key;
      }
      return null;
    } else {
      throw new Error("First argument must be a property string or a function.");
    }
  };
  module2.exports = Collection2;
});

// node_modules/discord.js/src/structures/shared/resolvePermissions.js
var require_resolvePermissions = __commonJS((exports2, module2) => {
  var Permissions2 = require_Permissions();
  var Collection2 = require_Collection();
  module2.exports = function resolvePermissions(overwrites, guild) {
    if (overwrites instanceof Collection2 || overwrites instanceof Array) {
      overwrites = overwrites.map((overwrite) => {
        const role = this.client.resolver.resolveRole(guild, overwrite.id);
        if (role) {
          overwrite.id = role.id;
          overwrite.type = "role";
        } else {
          overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
          overwrite.type = "member";
        }
        return {
          allow: Permissions2.resolve(overwrite.allow || overwrite.allowed || 0),
          deny: Permissions2.resolve(overwrite.deny || overwrite.denied || 0),
          type: overwrite.type,
          id: overwrite.id
        };
      });
    }
    return overwrites;
  };
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports2, module2) => {
  var Attachment = class {
    constructor(file, name) {
      this.file = null;
      if (name)
        this.setAttachment(file, name);
      else
        this._attach(file);
    }
    get name() {
      return this.file.name;
    }
    get attachment() {
      return this.file.attachment;
    }
    setAttachment(file, name) {
      this.file = {attachment: file, name};
      return this;
    }
    setFile(attachment) {
      this.file = {attachment};
      return this;
    }
    setName(name) {
      this.file.name = name;
      return this;
    }
    _attach(file, name) {
      if (typeof file === "string")
        this.file = file;
      else
        this.setAttachment(file, name);
    }
  };
  module2.exports = Attachment;
});

// node_modules/discord.js/src/structures/MessageEmbed.js
var require_MessageEmbed = __commonJS((exports2, module2) => {
  var MessageEmbed = class {
    constructor(message, data) {
      Object.defineProperty(this, "client", {value: message.client});
      this.message = message;
      this.setup(data);
    }
    setup(data) {
      this.type = data.type;
      this.title = data.title;
      this.description = data.description;
      this.url = data.url;
      this.color = data.color;
      this.fields = [];
      if (data.fields)
        for (const field of data.fields)
          this.fields.push(new MessageEmbedField(this, field));
      this.timestamp = data.timestamp;
      this.thumbnail = data.thumbnail ? new MessageEmbedThumbnail(this, data.thumbnail) : null;
      this.image = data.image ? new MessageEmbedImage(this, data.image) : null;
      this.video = data.video ? new MessageEmbedVideo(this, data.video) : null;
      this.author = data.author ? new MessageEmbedAuthor(this, data.author) : null;
      this.provider = data.provider ? new MessageEmbedProvider(this, data.provider) : null;
      this.footer = data.footer ? new MessageEmbedFooter(this, data.footer) : null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      if (!this.color)
        return null;
      let col = this.color.toString(16);
      while (col.length < 6)
        col = `0${col}`;
      return `#${col}`;
    }
  };
  var MessageEmbedThumbnail = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.url = data.url;
      this.proxyURL = data.proxy_url;
      this.height = data.height;
      this.width = data.width;
    }
  };
  var MessageEmbedImage = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.url = data.url;
      this.proxyURL = data.proxy_url;
      this.height = data.height;
      this.width = data.width;
    }
  };
  var MessageEmbedVideo = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.url = data.url;
      this.height = data.height;
      this.width = data.width;
    }
  };
  var MessageEmbedProvider = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.name = data.name;
      this.url = data.url;
    }
  };
  var MessageEmbedAuthor = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.name = data.name;
      this.url = data.url;
      this.iconURL = data.icon_url;
    }
  };
  var MessageEmbedField = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.name = data.name;
      this.value = data.value;
      this.inline = data.inline;
    }
  };
  var MessageEmbedFooter = class {
    constructor(embed, data) {
      this.embed = embed;
      this.setup(data);
    }
    setup(data) {
      this.text = data.text;
      this.iconURL = data.icon_url;
      this.proxyIconUrl = data.proxy_icon_url;
    }
  };
  MessageEmbed.Thumbnail = MessageEmbedThumbnail;
  MessageEmbed.Image = MessageEmbedImage;
  MessageEmbed.Video = MessageEmbedVideo;
  MessageEmbed.Provider = MessageEmbedProvider;
  MessageEmbed.Author = MessageEmbedAuthor;
  MessageEmbed.Field = MessageEmbedField;
  MessageEmbed.Footer = MessageEmbedFooter;
  module2.exports = MessageEmbed;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var MessageMentions = class {
    constructor(message, users, roles, everyone) {
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection2) {
          this.users = new Collection2(users);
        } else {
          this.users = new Collection2();
          for (const mention of users) {
            let user = message.client.users.get(mention.id);
            if (!user)
              user = message.client.dataManager.newUser(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection2();
      }
      if (roles) {
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else {
          this.roles = new Collection2();
          for (const mention of roles) {
            const role = message.channel.guild.roles.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection2();
      }
      this._content = message.content;
      this._client = message.client;
      this._guild = message.channel.guild;
      this._members = null;
      this._channels = null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this._guild)
        return null;
      this._members = new Collection2();
      this.users.forEach((user) => {
        const member = this._guild.member(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection2();
      let matches;
      while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {
        const chan = this._client.channels.get(matches[1]);
        if (chan)
          this._channels.set(chan.id, chan);
      }
      return this._channels;
    }
  };
  MessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;
  MessageMentions.USERS_PATTERN = /<@!?[0-9]+>/g;
  MessageMentions.ROLES_PATTERN = /<@&[0-9]+>/g;
  MessageMentions.CHANNELS_PATTERN = /<#([0-9]+)>/g;
  module2.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/MessageAttachment.js
var require_MessageAttachment = __commonJS((exports2, module2) => {
  var MessageAttachment = class {
    constructor(message, data) {
      Object.defineProperty(this, "client", {value: message.client});
      this.message = message;
      this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.filename = data.filename;
      this.filesize = data.size;
      this.url = data.url;
      this.proxyURL = data.proxy_url;
      this.height = data.height;
      this.width = data.width;
    }
  };
  module2.exports = MessageAttachment;
});

// node_modules/discord.js/src/util/Snowflake.js
var require_Snowflake = __commonJS((exports2, module2) => {
  var Long2 = require_long();
  var EPOCH = 14200704e5;
  var INCREMENT = 0;
  var SnowflakeUtil = class {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static generate(timestamp = Date.now()) {
      if (timestamp instanceof Date)
        timestamp = timestamp.getTime();
      if (typeof timestamp !== "number" || isNaN(timestamp)) {
        throw new TypeError(`"timestamp" argument must be a number (received ${isNaN(timestamp) ? "NaN" : typeof timestamp})`);
      }
      if (INCREMENT >= 4095)
        INCREMENT = 0;
      const BINARY = `${pad((timestamp - EPOCH).toString(2), 42)}0000100000${pad((INCREMENT++).toString(2), 12)}`;
      return Long2.fromString(BINARY, 2).toString();
    }
    static deconstruct(snowflake) {
      const BINARY = pad(Long2.fromString(snowflake).toString(2), 64);
      const res = {
        timestamp: parseInt(BINARY.substring(0, 42), 2) + EPOCH,
        workerID: parseInt(BINARY.substring(42, 47), 2),
        processID: parseInt(BINARY.substring(47, 52), 2),
        increment: parseInt(BINARY.substring(52, 64), 2),
        binary: BINARY
      };
      Object.defineProperty(res, "date", {
        get: function get() {
          return new Date(this.timestamp);
        },
        enumerable: true
      });
      return res;
    }
  };
  function pad(v, n, c = "0") {
    return String(v).length >= n ? String(v) : (String(c).repeat(n) + v).slice(-n);
  }
  module2.exports = SnowflakeUtil;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var Collection2 = require_Collection();
  var Permissions2 = require_Permissions();
  var Snowflake = require_Snowflake();
  var Emoji = class {
    constructor(guild, data) {
      Object.defineProperty(this, "client", {value: guild.client});
      this.guild = guild;
      this.deleted = false;
      this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.name = data.name;
      this.requiresColons = data.require_colons;
      this.managed = data.managed;
      this.animated = data.animated;
      this._roles = data.roles;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get deletable() {
      return !this.managed && this.guild.me.hasPermission(Permissions2.FLAGS.MANAGE_EMOJIS);
    }
    get roles() {
      const roles = new Collection2();
      for (const role of this._roles) {
        if (this.guild.roles.has(role))
          roles.set(role, this.guild.roles.get(role));
      }
      return roles;
    }
    get url() {
      return Constants2.Endpoints.CDN(this.client.options.http.cdn).Emoji(this.id, this.animated ? "gif" : "png");
    }
    get identifier() {
      if (this.id)
        return `${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    edit(data, reason) {
      return this.client.rest.methods.updateEmoji(this, data, reason);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    fetchAuthor() {
      if (this.managed)
        return Promise.reject(new Error("Emoji is managed and has no Author."));
      if (!this.guild.me.permissions.has(Permissions2.FLAGS.MANAGE_EMOJIS)) {
        return Promise.reject(new Error(`Client must have Manage Emoji permission in guild ${this.guild} to see emoji authors.`));
      }
      return this.client.rest.makeRequest("get", Constants2.Endpoints.Guild(this.guild).Emoji(this.id), true).then((emoji) => this.client.dataManager.newUser(emoji.user));
    }
    addRestrictedRole(role) {
      return this.addRestrictedRoles([role]);
    }
    addRestrictedRoles(roles) {
      const newRoles = new Collection2(this.roles);
      for (const role of roles) {
        if (this.guild.roles.has(role.id))
          newRoles.set(role.id, role);
      }
      return this.edit({roles: newRoles});
    }
    removeRestrictedRole(role) {
      return this.removeRestrictedRoles([role]);
    }
    removeRestrictedRoles(roles) {
      const newRoles = new Collection2(this.roles);
      for (const role of roles) {
        if (newRoles.has(role.id))
          newRoles.delete(role.id);
      }
      return this.edit({roles: newRoles});
    }
    toString() {
      if (!this.id || !this.requiresColons) {
        return this.name;
      }
      return `<${this.animated ? "a" : ""}:${this.name}:${this.id}>`;
    }
    equals(other) {
      if (other instanceof Emoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons;
      } else {
        return other.id === this.id && other.name === this.name;
      }
    }
  };
  module2.exports = Emoji;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports2, module2) => {
  var ReactionEmoji = class {
    constructor(reaction, name, id) {
      this.reaction = reaction;
      this.name = name;
      this.id = id;
    }
    get identifier() {
      if (this.id)
        return `${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    toString() {
      return this.id ? `<:${this.name}:${this.id}>` : this.name;
    }
  };
  module2.exports = ReactionEmoji;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var Emoji = require_Emoji();
  var ReactionEmoji = require_ReactionEmoji();
  var MessageReaction = class {
    constructor(message, emoji, count, me) {
      this.message = message;
      this.me = me;
      this.count = count || 0;
      this.users = new Collection2();
      this._emoji = new ReactionEmoji(this, emoji.name, emoji.id);
    }
    get emoji() {
      if (this._emoji instanceof Emoji)
        return this._emoji;
      if (this._emoji.id) {
        const emojis = this.message.client.emojis;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    remove(user = this.message.client.user) {
      const message = this.message;
      const userID = this.message.client.resolver.resolveUserID(user);
      if (!userID)
        return Promise.reject(new Error("Couldn't resolve the user ID to remove from the reaction."));
      return message.client.rest.methods.removeMessageReaction(message, this.emoji.identifier, userID);
    }
    fetchUsers(limit = 100, {after, before} = {}) {
      const message = this.message;
      return message.client.rest.methods.getMessageReactionUsers(message, this.emoji.identifier, {after, before, limit}).then((data) => {
        const users = new Collection2();
        for (const rawUser of data) {
          const user = this.message.client.dataManager.newUser(rawUser);
          this.users.set(user.id, user);
          users.set(user.id, user);
        }
        return users;
      });
    }
  };
  module2.exports = MessageReaction;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var EventEmitter2 = require("events").EventEmitter;
  var Collector = class extends EventEmitter2 {
    constructor(client, filter, options = {}) {
      super();
      Object.defineProperty(this, "client", {value: client});
      this.filter = filter;
      this.options = options;
      this.collected = new Collection2();
      this.ended = false;
      this._timeout = null;
      this.listener = this._handle.bind(this);
      if (options.time)
        this._timeout = this.client.setTimeout(() => this.stop("time"), options.time);
    }
    _handle(...args) {
      const collect = this.handle(...args);
      if (!collect || !this.filter(...args, this.collected))
        return;
      this.collected.set(collect.key, collect.value);
      this.emit("collect", collect.value, this);
      const post = this.postCheck(...args);
      if (post)
        this.stop(post);
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout)
        this.client.clearTimeout(this._timeout);
      this.ended = true;
      this.cleanup();
      this.emit("end", this.collected, reason);
    }
    handle() {
    }
    postCheck() {
    }
    cleanup() {
    }
  };
  module2.exports = Collector;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports2, module2) => {
  var Collector = require_Collector();
  var Collection2 = require_Collection();
  var ReactionCollector = class extends Collector {
    constructor(message, filter, options = {}) {
      super(message.client, filter, options);
      this.message = message;
      this.users = new Collection2();
      this.total = 0;
      this.client.setMaxListeners(this.client.getMaxListeners() + 1);
      this.client.on("messageReactionAdd", this.listener);
    }
    handle(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return {
        key: reaction.emoji.id || reaction.emoji.name,
        value: reaction
      };
    }
    postCheck(reaction, user) {
      this.users.set(user.id, user);
      if (this.options.max && ++this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return null;
    }
    cleanup() {
      this.client.removeListener("messageReactionAdd", this.listener);
      this.client.setMaxListeners(this.client.getMaxListeners() - 1);
    }
  };
  module2.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports2, module2) => {
  var Snowflake = require_Snowflake();
  var Permissions2 = require_Permissions();
  var util = require("util");
  var Role = class {
    constructor(guild, data) {
      Object.defineProperty(this, "client", {value: guild.client});
      this.guild = guild;
      this.deleted = false;
      if (data)
        this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.name = data.name;
      this.color = data.color;
      this.hoist = data.hoist;
      this.position = data.position;
      this.permissions = data.permissions;
      this.managed = data.managed;
      this.mentionable = data.mentionable;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      let col = this.color.toString(16);
      while (col.length < 6)
        col = `0${col}`;
      return `#${col}`;
    }
    get members() {
      return this.guild.members.filter((m) => m.roles.has(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.member(this.client.user);
      if (!clientMember.permissions.has(Permissions2.FLAGS.MANAGE_ROLES_OR_PERMISSIONS))
        return false;
      return clientMember.highestRole.comparePositionTo(this) > 0;
    }
    get calculatedPosition() {
      const sorted = this.guild._sortedRoles;
      return sorted.array().indexOf(sorted.get(this.id));
    }
    serialize() {
      return new Permissions2(this.permissions).serialize();
    }
    hasPermission(permission, explicit = false, checkAdmin) {
      return new Permissions2(this.permissions).has(permission, typeof checkAdmin !== "undefined" ? checkAdmin : !explicit);
    }
    hasPermissions(permissions, explicit = false) {
      return new Permissions2(this.permissions).has(permissions, !explicit);
    }
    comparePositionTo(role) {
      return this.constructor.comparePositions(this, role);
    }
    edit(data, reason) {
      return this.client.rest.methods.updateGuildRole(this, data, reason);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setColor(color, reason) {
      return this.edit({color}, reason);
    }
    setHoist(hoist, reason) {
      return this.edit({hoist}, reason);
    }
    setPosition(position, relative) {
      return this.guild.setRolePosition(this, position, relative).then(() => this);
    }
    setPermissions(permissions, reason) {
      return this.edit({permissions}, reason);
    }
    setMentionable(mentionable, reason) {
      return this.edit({mentionable}, reason);
    }
    delete(reason) {
      return this.client.rest.methods.deleteGuildRole(this, reason);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions === role.permissions && this.managed === role.managed;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return `<@&${this.id}>`;
    }
    static comparePositions(role1, role2) {
      if (role1.position === role2.position)
        return role2.id - role1.id;
      return role1.position - role2.position;
    }
  };
  Role.prototype.hasPermissions = util.deprecate(Role.prototype.hasPermissions, "Role#hasPermissions is deprecated - use Role#hasPermission instead, it now takes an array");
  module2.exports = Role;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports2) => {
  var {ActivityFlags, Endpoints} = require_Constants();
  var Presence2 = class {
    constructor(data = {}, client) {
      Object.defineProperty(this, "client", {value: client});
      this.status = data.status || "offline";
      this.game = data.game ? new Game(data.game, this) : null;
      this.clientStatus = data.client_status || null;
    }
    update(data) {
      this.status = data.status || this.status;
      this.game = data.game ? new Game(data.game, this) : null;
      this.clientStatus = data.client_status || null;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && (this.game ? this.game.equals(presence.game) : !presence.game) && this.clientStatus.web === presence.clientStatus.web && this.clientStatus.mobile === presence.clientStatus.mobile && this.clientStatus.desktop === presence.clientStatus.desktop;
    }
  };
  var Game = class {
    constructor(data, presence) {
      Object.defineProperty(this, "presence", {value: presence});
      this.name = data.name;
      this.type = data.type;
      this.url = data.url || null;
      this.details = data.details || null;
      this.state = data.state || null;
      this.applicationID = data.application_id || null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party || null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.syncID = data.sync_id;
      this._flags = data.flags;
    }
    get flags() {
      const flags = [];
      for (const [name, flag] of Object.entries(ActivityFlags)) {
        if ((this._flags & flag) === flag)
          flags.push(name);
      }
      return flags;
    }
    get streaming() {
      return this.type === 1;
    }
    toString() {
      return this.name;
    }
    equals(game) {
      return this === game || game && this.name === game.name && this.type === game.type && this.url === game.url;
    }
  };
  var RichPresenceAssets = class {
    constructor(game, assets) {
      Object.defineProperty(this, "game", {value: game});
      this.largeText = assets.large_text || null;
      this.smallText = assets.small_text || null;
      this.largeImage = assets.large_image || null;
      this.smallImage = assets.small_image || null;
    }
    get smallImageURL() {
      if (!this.smallImage)
        return null;
      return Endpoints.CDN(this.game.presence.client.options.http.cdn).AppAsset(this.game.applicationID, this.smallImage);
    }
    get largeImageURL() {
      if (!this.largeImage)
        return null;
      if (/^spotify:/.test(this.largeImage)) {
        return `https://i.scdn.co/image/${this.largeImage.slice(8)}`;
      }
      return Endpoints.CDN(this.game.presence.client.options.http.cdn).AppAsset(this.game.applicationID, this.largeImage);
    }
  };
  exports2.Presence = Presence2;
  exports2.Game = Game;
  exports2.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports2, module2) => {
  var TextBasedChannel = require_TextBasedChannel();
  var Role = require_Role();
  var Permissions2 = require_Permissions();
  var Collection2 = require_Collection();
  var {Presence: Presence2} = require_Presence();
  var util = require("util");
  var GuildMember = class {
    constructor(guild, data) {
      Object.defineProperty(this, "client", {value: guild.client});
      this.guild = guild;
      this.user = {};
      this.joinedTimestamp = null;
      this._roles = [];
      if (data)
        this.setup(data);
      this.lastMessageID = null;
      this.lastMessage = null;
      this.deleted = false;
    }
    setup(data) {
      this.serverDeaf = data.deaf;
      this.serverMute = data.mute;
      this.selfMute = data.self_mute;
      this.selfDeaf = data.self_deaf;
      this.voiceSessionID = data.session_id;
      this.voiceChannelID = data.channel_id;
      this.speaking = false;
      this.nickname = data.nick || null;
      if (data.joined_at)
        this.joinedTimestamp = new Date(data.joined_at).getTime();
      this.user = data.user;
      this._roles = data.roles;
    }
    get joinedAt() {
      return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;
    }
    get presence() {
      return this.frozenPresence || this.guild.presences.get(this.id) || new Presence2(void 0, this.client);
    }
    get roles() {
      const list = new Collection2();
      const everyoneRole = this.guild.roles.get(this.guild.id);
      if (everyoneRole)
        list.set(everyoneRole.id, everyoneRole);
      for (const roleID of this._roles) {
        const role = this.guild.roles.get(roleID);
        if (role)
          list.set(role.id, role);
      }
      return list;
    }
    get highestRole() {
      return this.roles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get colorRole() {
      const coloredRoles = this.roles.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get displayColor() {
      const role = this.colorRole;
      return role && role.color || 0;
    }
    get displayHexColor() {
      const role = this.colorRole;
      return role && role.hexColor || "#000000";
    }
    get hoistRole() {
      const hoistedRoles = this.roles.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get mute() {
      return this.selfMute || this.serverMute;
    }
    get deaf() {
      return this.selfDeaf || this.serverDeaf;
    }
    get voiceChannel() {
      return this.guild.channels.get(this.voiceChannelID);
    }
    get id() {
      return this.user.id;
    }
    get displayName() {
      return this.nickname || this.user.username;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerID)
        return new Permissions2(this, Permissions2.ALL);
      let permissions = 0;
      const roles = this.roles;
      for (const role of roles.values())
        permissions |= role.permissions;
      return new Permissions2(this, permissions);
    }
    get manageable() {
      if (this.user.id === this.guild.ownerID)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      return this.guild.me.highestRole.comparePositionTo(this.highestRole) > 0;
    }
    get kickable() {
      return this.manageable && this.guild.me.permissions.has(Permissions2.FLAGS.KICK_MEMBERS);
    }
    get bannable() {
      return this.manageable && this.guild.me.permissions.has(Permissions2.FLAGS.BAN_MEMBERS);
    }
    permissionsIn(channel) {
      channel = this.client.resolver.resolveChannel(channel);
      if (!channel || !channel.guild)
        throw new Error("Could not resolve channel to a guild channel.");
      return channel.permissionsFor(this);
    }
    hasPermission(permission, explicit = false, checkAdmin, checkOwner) {
      if (typeof checkAdmin === "undefined")
        checkAdmin = !explicit;
      if (typeof checkOwner === "undefined")
        checkOwner = !explicit;
      if (checkOwner && this.user.id === this.guild.ownerID)
        return true;
      return this.roles.some((r) => r.hasPermission(permission, void 0, checkAdmin));
    }
    hasPermissions(permissions, explicit = false) {
      if (!explicit && this.user.id === this.guild.ownerID)
        return true;
      return this.hasPermission(permissions, explicit);
    }
    missingPermissions(permissions, explicit = false) {
      if (!(permissions instanceof Array))
        permissions = [permissions];
      return this.permissions.missing(permissions, explicit);
    }
    edit(data, reason) {
      return this.client.rest.methods.updateGuildMember(this, data, reason);
    }
    setMute(mute, reason) {
      return this.edit({mute}, reason);
    }
    setDeaf(deaf, reason) {
      return this.edit({deaf}, reason);
    }
    setVoiceChannel(channel) {
      return this.edit({channel});
    }
    setRoles(roles, reason) {
      return this.edit({roles}, reason);
    }
    addRole(role, reason) {
      if (!(role instanceof Role))
        role = this.guild.roles.get(role);
      if (!role)
        return Promise.reject(new TypeError("Supplied parameter was neither a Role nor a Snowflake."));
      return this.client.rest.methods.addMemberRole(this, role, reason);
    }
    addRoles(roles, reason) {
      let allRoles;
      if (roles instanceof Collection2) {
        allRoles = this._roles.slice();
        for (const role of roles.values())
          allRoles.push(role.id);
      } else {
        allRoles = this._roles.concat(roles);
      }
      return this.edit({roles: allRoles}, reason);
    }
    removeRole(role, reason) {
      if (!(role instanceof Role))
        role = this.guild.roles.get(role);
      if (!role)
        return Promise.reject(new TypeError("Supplied parameter was neither a Role nor a Snowflake."));
      return this.client.rest.methods.removeMemberRole(this, role, reason);
    }
    removeRoles(roles, reason) {
      const allRoles = this._roles.slice();
      if (roles instanceof Collection2) {
        for (const role of roles.values()) {
          const index = allRoles.indexOf(role.id);
          if (index >= 0)
            allRoles.splice(index, 1);
        }
      } else {
        for (const role of roles) {
          const index = allRoles.indexOf(role instanceof Role ? role.id : role);
          if (index >= 0)
            allRoles.splice(index, 1);
        }
      }
      return this.edit({roles: allRoles}, reason);
    }
    setNickname(nick, reason) {
      return this.edit({nick}, reason);
    }
    createDM() {
      return this.user.createDM();
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.client.rest.methods.kickGuildMember(this.guild, this, reason);
    }
    ban(options) {
      return this.guild.ban(this, options);
    }
    toString() {
      return `<@${this.nickname ? "!" : ""}${this.user.id}>`;
    }
    send() {
    }
    sendMessage() {
    }
    sendEmbed() {
    }
    sendFile() {
    }
    sendCode() {
    }
  };
  TextBasedChannel.applyToClass(GuildMember);
  GuildMember.prototype.hasPermissions = util.deprecate(GuildMember.prototype.hasPermissions, "GuildMember#hasPermissions is deprecated - use GuildMember#hasPermission, it now takes an array");
  GuildMember.prototype.missingPermissions = util.deprecate(GuildMember.prototype.missingPermissions, "GuildMember#missingPermissions is deprecated - use GuildMember#permissions.missing, it now takes an array");
  module2.exports = GuildMember;
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports2, module2) => {
  var Mentions = require_MessageMentions();
  var Attachment = require_MessageAttachment();
  var Embed = require_MessageEmbed();
  var RichEmbed = require_RichEmbed();
  var MessageReaction = require_MessageReaction();
  var ReactionCollector = require_ReactionCollector();
  var Util2 = require_Util();
  var Collection2 = require_Collection();
  var Constants2 = require_Constants();
  var Permissions2 = require_Permissions();
  var GuildMember;
  var Message = class {
    constructor(channel, data, client) {
      Object.defineProperty(this, "client", {value: client});
      this.channel = channel;
      this.deleted = false;
      if (data)
        this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.type = Constants2.MessageTypes[data.type];
      this.content = data.content;
      this.author = this.client.dataManager.newUser(data.author, !data.webhook_id);
      this.member = this.guild ? this.guild.member(this.author) || null : null;
      this.pinned = data.pinned;
      this.tts = data.tts;
      this.nonce = data.nonce;
      this.system = data.type === 6;
      this.embeds = data.embeds.map((e) => new Embed(this, e));
      this.attachments = new Collection2();
      for (const attachment of data.attachments)
        this.attachments.set(attachment.id, new Attachment(this, attachment));
      this.createdTimestamp = new Date(data.timestamp).getTime();
      this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;
      this.reactions = new Collection2();
      if (data.reactions && data.reactions.length > 0) {
        for (const reaction of data.reactions) {
          const id = reaction.emoji.id ? `${reaction.emoji.name}:${reaction.emoji.id}` : reaction.emoji.name;
          this.reactions.set(id, new MessageReaction(this, reaction.emoji, reaction.count, reaction.me));
        }
      }
      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone);
      this.webhookID = data.webhook_id || null;
      this.hit = typeof data.hit === "boolean" ? data.hit : null;
      this._edits = [];
    }
    patch(data) {
      const clone = Util2.cloneObject(this);
      this._edits.unshift(clone);
      if ("edited_timestamp" in data)
        this.editedTimestamp = new Date(data.edited_timestamp).getTime();
      if ("content" in data)
        this.content = data.content;
      if ("pinned" in data)
        this.pinned = data.pinned;
      if ("tts" in data)
        this.tts = data.tts;
      if ("embeds" in data)
        this.embeds = data.embeds.map((e) => new Embed(this, e));
      else
        this.embeds = this.embeds.slice();
      if ("attachments" in data) {
        this.attachments = new Collection2();
        for (const attachment of data.attachments)
          this.attachments.set(attachment.id, new Attachment(this, attachment));
      } else {
        this.attachments = new Collection2(this.attachments);
      }
      this.mentions = new Mentions(this, "mentions" in data ? data.mentions : this.mentions.users, "mentions_roles" in data ? data.mentions_roles : this.mentions.roles, "mention_everyone" in data ? data.mention_everyone : this.mentions.everyone);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
    }
    get guild() {
      return this.channel.guild || null;
    }
    get url() {
      return `https://discordapp.com/channels/${this.guild ? this.guild.id : "@me"}/${this.channel.id}/${this.id}`;
    }
    get cleanContent() {
      return this.content.replace(/@(everyone|here)/g, "@\u200B$1").replace(/<@!?[0-9]+>/g, (input) => {
        const id = input.replace(/<|!|>|@/g, "");
        if (this.channel.type === "dm" || this.channel.type === "group") {
          return this.client.users.has(id) ? `@${this.client.users.get(id).username}` : input;
        }
        const member = this.channel.guild.members.get(id);
        if (member) {
          if (member.nickname)
            return `@${member.nickname}`;
          return `@${member.user.username}`;
        } else {
          const user = this.client.users.get(id);
          if (user)
            return `@${user.username}`;
          return input;
        }
      }).replace(/<#[0-9]+>/g, (input) => {
        const channel = this.client.channels.get(input.replace(/<|#|>/g, ""));
        if (channel)
          return `#${channel.name}`;
        return input;
      }).replace(/<@&[0-9]+>/g, (input) => {
        if (this.channel.type === "dm" || this.channel.type === "group")
          return input;
        const role = this.guild.roles.get(input.replace(/<|@|>|&/g, ""));
        if (role)
          return `@${role.name}`;
        return input;
      });
    }
    createReactionCollector(filter, options = {}) {
      return new ReactionCollector(this, filter, options);
    }
    awaitReactions(filter, options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(filter, options);
        collector.once("end", (reactions, reason) => {
          if (options.errors && options.errors.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    get edits() {
      const copy = this._edits.slice();
      copy.unshift(this);
      return copy;
    }
    get editable() {
      return this.author.id === this.client.user.id;
    }
    get deletable() {
      return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_MESSAGES));
    }
    get pinnable() {
      return this.type === "DEFAULT" && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_MESSAGES));
    }
    isMentioned(data) {
      data = data && data.id ? data.id : data;
      return this.mentions.users.has(data) || this.mentions.channels.has(data) || this.mentions.roles.has(data);
    }
    isMemberMentioned(member) {
      if (!GuildMember)
        GuildMember = require_GuildMember();
      if (this.mentions.everyone)
        return true;
      if (this.mentions.users.has(member.id))
        return true;
      if (member instanceof GuildMember && member.roles.some((r) => this.mentions.roles.has(r.id)))
        return true;
      return false;
    }
    edit(content, options) {
      if (!options && typeof content === "object" && !(content instanceof Array)) {
        options = content;
        content = "";
      } else if (!options) {
        options = {};
      }
      if (options instanceof RichEmbed)
        options = {embed: options};
      return this.client.rest.methods.updateMessage(this, content, options);
    }
    editCode(lang, content) {
      content = Util2.escapeMarkdown(this.client.resolver.resolveString(content), true);
      return this.edit(`\`\`\`${lang || ""}
${content}
\`\`\``);
    }
    pin() {
      return this.client.rest.methods.pinMessage(this);
    }
    unpin() {
      return this.client.rest.methods.unpinMessage(this);
    }
    react(emoji) {
      emoji = this.client.resolver.resolveEmojiIdentifier(emoji);
      if (!emoji)
        throw new TypeError("Emoji must be a string or Emoji/ReactionEmoji");
      return this.client.rest.methods.addMessageReaction(this, emoji);
    }
    clearReactions() {
      return this.client.rest.methods.removeMessageReactions(this);
    }
    delete(timeout = 0) {
      if (timeout <= 0) {
        return this.client.rest.methods.deleteMessage(this);
      } else {
        return new Promise((resolve) => {
          this.client.setTimeout(() => {
            resolve(this.delete());
          }, timeout);
        });
      }
    }
    reply(content, options) {
      if (!options && typeof content === "object" && !(content instanceof Array)) {
        options = content;
        content = "";
      } else if (!options) {
        options = {};
      }
      return this.channel.send(content, Object.assign(options, {reply: this.member || this.author}));
    }
    acknowledge() {
      return this.client.rest.methods.ackMessage(this);
    }
    fetchWebhook() {
      if (!this.webhookID)
        return Promise.reject(new Error("The message was not sent by a webhook."));
      return this.client.fetchWebhook(this.webhookID);
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();
      }
      return equal;
    }
    toString() {
      return this.content;
    }
    _addReaction(emoji, user) {
      const emojiID = emoji.id ? `${emoji.name}:${emoji.id}` : emoji.name;
      let reaction;
      if (this.reactions.has(emojiID)) {
        reaction = this.reactions.get(emojiID);
        if (!reaction.me)
          reaction.me = user.id === this.client.user.id;
      } else {
        reaction = new MessageReaction(this, emoji, 0, user.id === this.client.user.id);
        this.reactions.set(emojiID, reaction);
      }
      if (!reaction.users.has(user.id)) {
        reaction.users.set(user.id, user);
        reaction.count++;
      }
      return reaction;
    }
    _removeReaction(emoji, user) {
      const emojiID = emoji.id ? `${emoji.name}:${emoji.id}` : emoji.name;
      if (this.reactions.has(emojiID)) {
        const reaction = this.reactions.get(emojiID);
        if (reaction.users.has(user.id)) {
          reaction.users.delete(user.id);
          reaction.count--;
          if (user.id === this.client.user.id)
            reaction.me = false;
          if (reaction.count <= 0)
            this.reactions.delete(emojiID);
          return reaction;
        }
      }
      return null;
    }
    _clearReactions() {
      this.reactions.clear();
    }
  };
  module2.exports = Message;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports2, module2) => {
  var Collector = require_Collector();
  var util = require("util");
  var MessageCollector = class extends Collector {
    constructor(channel, filter, options = {}) {
      super(channel.client, filter, options);
      this.channel = channel;
      this.received = 0;
      this.client.setMaxListeners(this.client.getMaxListeners() + 1);
      this.client.on("message", this.listener);
      if (this.options.max)
        this.options.maxProcessed = this.options.max;
      if (this.options.maxMatches)
        this.options.max = this.options.maxMatches;
      this._reEmitter = (message) => {
        this.emit("message", message);
      };
      this.on("collect", this._reEmitter);
    }
    on(eventName, listener) {
      if (eventName === "message") {
        listener = util.deprecate(listener, 'MessageCollector will soon no longer emit "message", use "collect" instead');
      }
      super.on(eventName, listener);
    }
    handle(message) {
      if (message.channel.id !== this.channel.id)
        return null;
      this.received++;
      return {
        key: message.id,
        value: message
      };
    }
    postCheck() {
      if (this.options.maxMatches && this.collected.size >= this.options.max)
        return "matchesLimit";
      if (this.options.max && this.received >= this.options.maxProcessed)
        return "limit";
      return null;
    }
    cleanup() {
      this.removeListener("collect", this._reEmitter);
      this.client.removeListener("message", this.listener);
      this.client.setMaxListeners(this.client.getMaxListeners() - 1);
    }
  };
  module2.exports = MessageCollector;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports2) => {
  var path = require("path");
  var Message = require_Message();
  var MessageCollector = require_MessageCollector();
  var Collection2 = require_Collection();
  var Attachment = require_Attachment();
  var RichEmbed = require_RichEmbed();
  var Snowflake = require_Snowflake();
  var util = require("util");
  var TextBasedChannel = class {
    constructor() {
      this.messages = new Collection2();
      this.lastMessageID = null;
      this.lastMessage = null;
      this.lastPinTimestamp = null;
    }
    send(content, options) {
      if (!options && typeof content === "object" && !(content instanceof Array)) {
        options = content;
        content = "";
      } else if (!options) {
        options = {};
      }
      const {reply} = options;
      if (options instanceof Attachment)
        options = {files: [options.file]};
      if (options instanceof RichEmbed) {
        if (options.reply)
          options.reply = void 0;
        options = {embed: options};
      }
      options.reply = reply;
      if (options.embed) {
        if (options.embed.file) {
          if (options.files)
            options.files.push(options.embed.file);
          else
            options.files = [options.embed.file];
        }
        if (options.embed.files) {
          if (options.files)
            options.files = options.files.concat(options.embed.files);
          else
            options.files = options.embed.files;
        }
      }
      if (options.file) {
        if (options.files)
          options.files.push(options.file);
        else
          options.files = [options.file];
      }
      if (options.embed)
        options.embed = new RichEmbed(options.embed)._apiTransform();
      if (options.files) {
        for (let i = 0; i < options.files.length; i++) {
          let file = options.files[i];
          if (!file || typeof file === "string" || Buffer.isBuffer(file))
            file = {attachment: file};
          if (!file.name) {
            if (typeof file.attachment === "string") {
              file.name = path.basename(file.attachment);
            } else if (file.attachment && file.attachment.path) {
              file.name = path.basename(file.attachment.path);
            } else if (file instanceof Attachment) {
              file = {attachment: file.file, name: path.basename(file.file) || "file.jpg"};
            } else {
              file.name = "file.jpg";
            }
          } else if (file instanceof Attachment) {
            file = file.file;
          }
          options.files[i] = file;
        }
        return Promise.all(options.files.map((file) => this.client.resolver.resolveFile(file.attachment).then((resource) => {
          file.file = resource;
          return file;
        }))).then((files) => this.client.rest.methods.sendMessage(this, content, options, files));
      }
      return this.client.rest.methods.sendMessage(this, content, options);
    }
    fetchMessage(messageID) {
      if (!this.client.user.bot) {
        return this.fetchMessages({limit: 1, around: messageID}).then((messages) => {
          const msg = messages.get(messageID);
          if (!msg)
            throw new Error("Message not found.");
          return msg;
        });
      }
      return this.client.rest.methods.getChannelMessage(this, messageID).then((data) => {
        const msg = data instanceof Message ? data : new Message(this, data, this.client);
        this._cacheMessage(msg);
        return msg;
      });
    }
    fetchMessages(options = {}) {
      return this.client.rest.methods.getChannelMessages(this, options).then((data) => {
        const messages = new Collection2();
        for (const message of data) {
          const msg = new Message(this, message, this.client);
          messages.set(message.id, msg);
          this._cacheMessage(msg);
        }
        return messages;
      });
    }
    fetchPinnedMessages() {
      return this.client.rest.methods.getChannelPinnedMessages(this).then((data) => {
        const messages = new Collection2();
        for (const message of data) {
          const msg = new Message(this, message, this.client);
          messages.set(message.id, msg);
          this._cacheMessage(msg);
        }
        return messages;
      });
    }
    search(options = {}) {
      return this.client.rest.methods.search(this, options);
    }
    startTyping(count) {
      if (typeof count !== "undefined" && count < 1)
        throw new RangeError("Count must be at least 1.");
      if (this.client.user._typing.has(this.id)) {
        const entry2 = this.client.user._typing.get(this.id);
        entry2.count = count || entry2.count + 1;
        return;
      }
      const entry = {
        count: count || 1,
        interval: this.client.setInterval(() => {
          this.client.rest.methods.sendTyping(this.id).catch(() => {
            this.client.clearInterval(entry.interval);
            this.client.user._typing.delete(this.id);
          });
        }, 9e3)
      };
      this.client.rest.methods.sendTyping(this.id).catch(() => {
        this.client.clearInterval(entry.interval);
        this.client.user._typing.delete(this.id);
      });
      this.client.user._typing.set(this.id, entry);
    }
    stopTyping(force = false) {
      if (this.client.user._typing.has(this.id)) {
        const entry = this.client.user._typing.get(this.id);
        entry.count--;
        if (entry.count <= 0 || force) {
          this.client.clearInterval(entry.interval);
          this.client.user._typing.delete(this.id);
        }
      }
    }
    get typing() {
      return this.client.user._typing.has(this.id);
    }
    get typingCount() {
      if (this.client.user._typing.has(this.id))
        return this.client.user._typing.get(this.id).count;
      return 0;
    }
    get lastMessage() {
      return this.messages.get(this.lastMessageID) || null;
    }
    get lastPinAt() {
      return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;
    }
    createCollector(filter, options) {
      return this.createMessageCollector(filter, options);
    }
    createMessageCollector(filter, options = {}) {
      return new MessageCollector(this, filter, options);
    }
    awaitMessages(filter, options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createCollector(filter, options);
        collector.once("end", (collection, reason) => {
          if (options.errors && options.errors.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    bulkDelete(messages, filterOld = false) {
      if (messages instanceof Array || messages instanceof Collection2) {
        let messageIDs = messages instanceof Collection2 ? messages.keyArray() : messages.map((m) => m.id || m);
        if (filterOld) {
          messageIDs = messageIDs.filter((id) => Date.now() - Snowflake.deconstruct(id).date.getTime() < 12096e5);
        }
        if (messageIDs.length === 0)
          return Promise.resolve(new Collection2());
        if (messageIDs.length === 1) {
          return this.fetchMessage(messageIDs[0]).then((m) => m.delete()).then((m) => new Collection2([[m.id, m]]));
        }
        return this.client.rest.methods.bulkDeleteMessages(this, messageIDs);
      }
      if (!isNaN(messages))
        return this.fetchMessages({limit: messages}).then((msgs) => this.bulkDelete(msgs, filterOld));
      throw new TypeError("The messages must be an Array, Collection, or number.");
    }
    acknowledge() {
      if (!this.lastMessageID)
        return Promise.resolve(this);
      return this.client.rest.methods.ackTextChannel(this);
    }
    _cacheMessage(message) {
      const maxSize = this.client.options.messageCacheMaxSize;
      if (maxSize === 0)
        return null;
      if (this.messages.size >= maxSize && maxSize > 0)
        this.messages.delete(this.messages.firstKey());
      this.messages.set(message.id, message);
      return message;
    }
  };
  var Deprecated = {
    sendMessage(content, options) {
      return this.send(content, options);
    },
    sendEmbed(embed, content, options) {
      if (!options && typeof content === "object" && !(content instanceof Array)) {
        options = content;
        content = "";
      } else if (!options) {
        options = {};
      }
      return this.send(content, Object.assign(options, {embed}));
    },
    sendFiles(files, content, options = {}) {
      return this.send(content, Object.assign(options, {files}));
    },
    sendFile(attachment, name, content, options = {}) {
      return this.send({files: [{attachment, name}], content, options});
    },
    sendCode(lang, content, options = {}) {
      return this.send(content, Object.assign(options, {code: lang}));
    }
  };
  for (const key of Object.keys(Deprecated)) {
    TextBasedChannel.prototype[key] = util.deprecate(Deprecated[key], `TextChannel#${key}: use TextChannel#send instead`);
  }
  exports2.applyToClass = (structure, full = false, ignore = []) => {
    const props = ["send", "sendMessage", "sendEmbed", "sendFile", "sendFiles", "sendCode"];
    if (full) {
      props.push("_cacheMessage", "acknowledge", "fetchMessages", "fetchMessage", "search", "lastMessage", "lastPinAt", "bulkDelete", "startTyping", "stopTyping", "typing", "typingCount", "fetchPinnedMessages", "createCollector", "createMessageCollector", "awaitMessages");
    }
    for (const prop of props) {
      if (ignore.includes(prop))
        continue;
      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
    }
  };
  TextBasedChannel.prototype.acknowledge = util.deprecate(TextBasedChannel.prototype.acknowledge, "TextBasedChannel#acknowledge: userbot methods will be removed");
  TextBasedChannel.prototype.search = util.deprecate(TextBasedChannel.prototype.search, "TextBasedChannel#search: userbot methods will be removed");
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports2, module2) => {
  var TextBasedChannel = require_TextBasedChannel();
  var Constants2 = require_Constants();
  var Presence2 = require_Presence().Presence;
  var Snowflake = require_Snowflake();
  var util = require("util");
  var User = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      if (data)
        this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.bot = Boolean(data.bot);
      this.lastMessageID = null;
      this.lastMessage = null;
    }
    patch(data) {
      for (const prop of ["id", "username", "discriminator", "avatar", "bot"]) {
        if (typeof data[prop] !== "undefined")
          this[prop] = data[prop];
      }
      if (data.token)
        this.client.token = data.token;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get presence() {
      if (this.client.presences.has(this.id))
        return this.client.presences.get(this.id);
      for (const guild of this.client.guilds.values()) {
        if (guild.presences.has(this.id))
          return guild.presences.get(this.id);
      }
      return new Presence2(void 0, this.client);
    }
    get avatarURL() {
      if (!this.avatar)
        return null;
      return Constants2.Endpoints.User(this).Avatar(this.client.options.http.cdn, this.avatar);
    }
    get defaultAvatarURL() {
      const avatars = Object.keys(Constants2.DefaultAvatars);
      const avatar = avatars[this.discriminator % avatars.length];
      return Constants2.Endpoints.CDN(this.client.options.http.host).Asset(`${Constants2.DefaultAvatars[avatar]}.png`);
    }
    get displayAvatarURL() {
      return this.avatarURL || this.defaultAvatarURL;
    }
    get tag() {
      return `${this.username}#${this.discriminator}`;
    }
    get note() {
      return this.client.user.notes.get(this.id) || null;
    }
    typingIn(channel) {
      channel = this.client.resolver.resolveChannel(channel);
      return channel._typing.has(this.id);
    }
    typingSinceIn(channel) {
      channel = this.client.resolver.resolveChannel(channel);
      return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;
    }
    typingDurationIn(channel) {
      channel = this.client.resolver.resolveChannel(channel);
      return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;
    }
    get dmChannel() {
      return this.client.channels.find((c) => c.type === "dm" && c.recipient.id === this.id);
    }
    createDM() {
      return this.client.rest.methods.createDM(this);
    }
    deleteDM() {
      return this.client.rest.methods.deleteChannel(this);
    }
    addFriend() {
      return this.client.rest.methods.addFriend(this);
    }
    removeFriend() {
      return this.client.rest.methods.removeFriend(this);
    }
    block() {
      return this.client.rest.methods.blockUser(this);
    }
    unblock() {
      return this.client.rest.methods.unblockUser(this);
    }
    fetchProfile() {
      return this.client.rest.methods.fetchUserProfile(this);
    }
    setNote(note) {
      return this.client.rest.methods.setNote(this, note);
    }
    equals(user) {
      let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && this.bot === Boolean(user.bot);
      return equal;
    }
    toString() {
      return `<@${this.id}>`;
    }
    send() {
    }
    sendMessage() {
    }
    sendEmbed() {
    }
    sendFile() {
    }
    sendCode() {
    }
  };
  TextBasedChannel.applyToClass(User);
  User.prototype.block = util.deprecate(User.prototype.block, "User#block: userbot methods will be removed");
  User.prototype.unblock = util.deprecate(User.prototype.unblock, "User#unblock: userbot methods will be removed");
  User.prototype.addFriend = util.deprecate(User.prototype.addFriend, "User#addFriend: userbot methods will be removed");
  User.prototype.removeFriend = util.deprecate(User.prototype.removeFriend, "User#removeFriend: userbot methods will be removed");
  User.prototype.setNote = util.deprecate(User.prototype.setNote, "User#setNote, userbot methods will be removed");
  User.prototype.fetchProfile = util.deprecate(User.prototype.fetchProfile, "User#fetchProfile: userbot methods will be removed");
  module2.exports = User;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports2, module2) => {
  var util = require("util");
  var Long2 = require_long();
  var User = require_User();
  var Role = require_Role();
  var Emoji = require_Emoji();
  var Presence2 = require_Presence().Presence;
  var GuildMember = require_GuildMember();
  var Constants2 = require_Constants();
  var Collection2 = require_Collection();
  var Util2 = require_Util();
  var Snowflake = require_Snowflake();
  var Guild = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.members = new Collection2();
      this.channels = new Collection2();
      this.roles = new Collection2();
      this.presences = new Collection2();
      this.deleted = false;
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
        this.id = data.id;
      } else {
        this.setup(data);
        if (!data.channels)
          this.available = false;
      }
    }
    setup(data) {
      this.name = data.name;
      this.icon = data.icon;
      this.splash = data.splash;
      this.region = data.region;
      this.memberCount = data.member_count || this.memberCount;
      this.large = Boolean("large" in data ? data.large : this.large);
      this.features = data.features;
      this.applicationID = data.application_id;
      this.afkTimeout = data.afk_timeout;
      this.afkChannelID = data.afk_channel_id;
      this.systemChannelID = data.system_channel_id;
      this.embedEnabled = data.embed_enabled;
      this.verificationLevel = data.verification_level;
      this.explicitContentFilter = data.explicit_content_filter;
      this.mfaLevel = data.mfa_level;
      this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;
      this.defaultMessageNotifications = Constants2.DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;
      this.id = data.id;
      this.available = !data.unavailable;
      this.features = data.features || this.features || [];
      if (data.members) {
        this.members.clear();
        for (const guildUser of data.members)
          this._addMember(guildUser, false);
      }
      if (data.owner_id) {
        this.ownerID = data.owner_id;
      }
      if (data.channels) {
        this.channels.clear();
        for (const channel of data.channels)
          this.client.dataManager.newChannel(channel, this);
      }
      if (data.roles) {
        this.roles.clear();
        for (const role of data.roles) {
          const newRole = new Role(this, role);
          this.roles.set(newRole.id, newRole);
        }
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this._setPresence(presence.user.id, presence);
        }
      }
      this._rawVoiceStates = new Collection2();
      if (data.voice_states) {
        for (const voiceState of data.voice_states) {
          this._rawVoiceStates.set(voiceState.user_id, voiceState);
          const member = this.members.get(voiceState.user_id);
          const voiceChannel = this.channels.get(voiceState.channel_id);
          if (member && voiceChannel) {
            member.serverMute = voiceState.mute;
            member.serverDeaf = voiceState.deaf;
            member.selfMute = voiceState.self_mute;
            member.selfDeaf = voiceState.self_deaf;
            member.voiceSessionID = voiceState.session_id;
            member.voiceChannelID = voiceState.channel_id;
            voiceChannel.members.set(member.user.id, member);
          }
        }
      }
      if (!this.emojis) {
        this.emojis = new Collection2();
        for (const emoji of data.emojis)
          this.emojis.set(emoji.id, new Emoji(this, emoji));
      } else {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    get verified() {
      return this.features.includes("VERIFIED");
    }
    get iconURL() {
      if (!this.icon)
        return null;
      return Constants2.Endpoints.Guild(this).Icon(this.client.options.http.cdn, this.icon);
    }
    get nameAcronym() {
      return this.name.replace(/\w+/g, (name) => name[0]).replace(/\s/g, "");
    }
    get splashURL() {
      if (!this.splash)
        return null;
      return Constants2.Endpoints.Guild(this).Splash(this.client.options.http.cdn, this.splash);
    }
    get owner() {
      return this.members.get(this.ownerID);
    }
    get afkChannel() {
      return this.client.channels.get(this.afkChannelID) || null;
    }
    get systemChannel() {
      return this.client.channels.get(this.systemChannelID) || null;
    }
    get voiceConnection() {
      if (this.client.browser)
        return null;
      return this.client.voice.connections.get(this.id) || null;
    }
    get position() {
      if (this.client.user.bot)
        return null;
      if (!this.client.user.settings.guildPositions)
        return null;
      return this.client.user.settings.guildPositions.indexOf(this.id);
    }
    get muted() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.id).muted;
      } catch (err) {
        return false;
      }
    }
    get messageNotifications() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.id).messageNotifications;
      } catch (err) {
        return null;
      }
    }
    get mobilePush() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.id).mobilePush;
      } catch (err) {
        return false;
      }
    }
    get suppressEveryone() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.id).suppressEveryone;
      } catch (err) {
        return null;
      }
    }
    get defaultRole() {
      return this.roles.get(this.id);
    }
    get me() {
      return this.members.get(this.client.user.id);
    }
    get _sortedRoles() {
      return this._sortPositionWithID(this.roles);
    }
    member(user) {
      return this.client.resolver.resolveGuildMember(this, user);
    }
    fetchBan(user) {
      return this.client.rest.methods.getGuildBan(this, user);
    }
    fetchBans(withReasons = false) {
      if (withReasons)
        return this.client.rest.methods.getGuildBans(this);
      return this.client.rest.methods.getGuildBans(this).then((bans) => {
        const users = new Collection2();
        for (const ban of bans.values())
          users.set(ban.user.id, ban.user);
        return users;
      });
    }
    fetchInvites() {
      return this.client.rest.methods.getGuildInvites(this);
    }
    fetchVanityCode() {
      if (!this.features.includes("VANITY_URL")) {
        return Promise.reject(new Error("This guild does not have the VANITY_URL feature enabled."));
      }
      return this.client.rest.methods.getGuildVanityCode(this);
    }
    fetchWebhooks() {
      return this.client.rest.methods.getGuildWebhooks(this);
    }
    fetchVoiceRegions() {
      return this.client.rest.methods.fetchVoiceRegions(this.id);
    }
    fetchEmbed() {
      return this.client.rest.methods.fetchEmbed(this.id);
    }
    fetchAuditLogs(options) {
      return this.client.rest.methods.getGuildAuditLogs(this, options);
    }
    addMember(user, options) {
      user = this.client.resolver.resolveUserID(user);
      if (this.members.has(user))
        return Promise.resolve(this.members.get(user));
      return this.client.rest.methods.putGuildMember(this, user, options);
    }
    fetchMember(user, cache = true) {
      user = this.client.resolver.resolveUser(user);
      if (!user)
        return Promise.reject(new Error("Invalid or uncached id provided."));
      const member = this.members.get(user.id);
      if (member && member.joinedTimestamp)
        return Promise.resolve(member);
      return this.client.rest.methods.getGuildMember(this, user, cache);
    }
    fetchMembers(query = "", limit = 0) {
      return new Promise((resolve, reject) => {
        if (this.memberCount === this.members.size) {
          resolve(this);
          return;
        }
        this.client.ws.send({
          op: Constants2.OPCodes.REQUEST_GUILD_MEMBERS,
          d: {
            guild_id: this.id,
            query,
            limit
          }
        });
        const handler = (members, guild) => {
          if (guild.id !== this.id)
            return;
          if (this.memberCount === this.members.size || members.length < 1e3) {
            this.client.removeListener(Constants2.Events.GUILD_MEMBERS_CHUNK, handler);
            resolve(this);
          }
        };
        this.client.on(Constants2.Events.GUILD_MEMBERS_CHUNK, handler);
        this.client.setTimeout(() => reject(new Error("Members didn't arrive in time.")), 120 * 1e3);
      });
    }
    search(options = {}) {
      return this.client.rest.methods.search(this, options);
    }
    edit(data, reason) {
      const _data = {};
      if (data.name)
        _data.name = data.name;
      if (data.region)
        _data.region = data.region;
      if (typeof data.verificationLevel !== "undefined")
        _data.verification_level = Number(data.verificationLevel);
      if (typeof data.afkChannel !== "undefined") {
        _data.afk_channel_id = this.client.resolver.resolveChannelID(data.afkChannel);
      }
      if (typeof data.systemChannel !== "undefined") {
        _data.system_channel_id = this.client.resolver.resolveChannelID(data.systemChannel);
      }
      if (data.afkTimeout)
        _data.afk_timeout = Number(data.afkTimeout);
      if (typeof data.icon !== "undefined")
        _data.icon = data.icon;
      if (data.owner)
        _data.owner_id = this.client.resolver.resolveUser(data.owner).id;
      if (typeof data.splash !== "undefined")
        _data.splash = data.splash;
      if (typeof data.explicitContentFilter !== "undefined") {
        _data.explicit_content_filter = Number(data.explicitContentFilter);
      }
      if (typeof data.defaultMessageNotifications !== "undefined") {
        _data.default_message_notifications = typeof data.defaultMessageNotifications === "string" ? Constants2.DefaultMessageNotifications.indexOf(data.defaultMessageNotifications) : Number(data.defaultMessageNotifications);
      }
      return this.client.rest.methods.updateGuild(this, _data, reason);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({explicitContentFilter}, reason);
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({defaultMessageNotifications}, reason);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setRegion(region, reason) {
      return this.edit({region}, reason);
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({verificationLevel}, reason);
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({afkChannel}, reason);
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({systemChannel}, reason);
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({afkTimeout}, reason);
    }
    setIcon(icon, reason) {
      return this.client.resolver.resolveImage(icon).then((data) => this.edit({icon: data, reason}));
    }
    setOwner(owner, reason) {
      return this.edit({owner}, reason);
    }
    setSplash(splash) {
      return this.client.resolver.resolveImage(splash).then((data) => this.edit({splash: data}));
    }
    setPosition(position, relative) {
      if (this.client.user.bot) {
        return Promise.reject(new Error("Setting guild position is only available for user accounts"));
      }
      return this.client.user.settings.setGuildPosition(this, position, relative);
    }
    acknowledge() {
      return this.client.rest.methods.ackGuild(this);
    }
    allowDMs(allow) {
      const settings = this.client.user.settings;
      if (allow)
        return settings.removeRestrictedGuild(this);
      else
        return settings.addRestrictedGuild(this);
    }
    ban(user, options = {}) {
      if (typeof options === "number") {
        options = {reason: null, "delete-message-days": options};
      } else if (typeof options === "string") {
        options = {reason: options, "delete-message-days": 0};
      }
      if (options.days)
        options["delete-message-days"] = options.days;
      return this.client.rest.methods.banGuildMember(this, user, options);
    }
    unban(user, reason) {
      return this.client.rest.methods.unbanGuildMember(this, user, reason);
    }
    pruneMembers(days, dry = false, reason) {
      if (typeof days !== "number")
        throw new TypeError("Days must be a number.");
      return this.client.rest.methods.pruneGuildMembers(this, days, dry, reason);
    }
    sync() {
      if (!this.client.user.bot)
        this.client.syncGuilds([this]);
    }
    createChannel(name, typeOrOptions, permissionOverwrites, reason) {
      if (!typeOrOptions || typeof typeOrOptions === "string") {
        if (typeOrOptions) {
          process.emitWarning("Guild#createChannel: Create channels with an options object instead of separate parameters", "DeprecationWarning");
        }
        typeOrOptions = {
          type: typeOrOptions,
          permissionOverwrites,
          reason
        };
      }
      return this.client.rest.methods.createChannel(this, name, typeOrOptions);
    }
    setChannelPositions(channelPositions) {
      return this.client.rest.methods.updateChannelPositions(this.id, channelPositions);
    }
    setEmbed(embed, reason) {
      return this.client.rest.methods.updateEmbed(this.id, embed, reason).then(() => this);
    }
    createRole(data = {}, reason) {
      return this.client.rest.methods.createGuildRole(this, data, reason);
    }
    createEmoji(attachment, name, roles, reason) {
      if (typeof attachment === "string" && attachment.startsWith("data:")) {
        return this.client.rest.methods.createEmoji(this, attachment, name, roles, reason);
      } else {
        return this.client.resolver.resolveImage(attachment).then((data) => this.client.rest.methods.createEmoji(this, data, name, roles, reason));
      }
    }
    deleteEmoji(emoji, reason) {
      if (typeof emoji === "string")
        emoji = this.emojis.get(emoji);
      if (!(emoji instanceof Emoji))
        throw new TypeError("Emoji must be either an instance of Emoji or an ID");
      return this.client.rest.methods.deleteEmoji(emoji, reason);
    }
    leave() {
      return this.client.rest.methods.leaveGuild(this);
    }
    delete() {
      return this.client.rest.methods.deleteGuild(this);
    }
    equals(guild) {
      let equal = guild && this.id === guild.id && this.available === !guild.unavailable && this.splash === guild.splash && this.region === guild.region && this.name === guild.name && this.memberCount === guild.member_count && this.large === guild.large && this.icon === guild.icon && Util2.arraysEqual(this.features, guild.features) && this.ownerID === guild.owner_id && this.verificationLevel === guild.verification_level && this.embedEnabled === guild.embed_enabled;
      if (equal) {
        if (this.embedChannel) {
          if (this.embedChannel.id !== guild.embed_channel_id)
            equal = false;
        } else if (guild.embed_channel_id) {
          equal = false;
        }
      }
      return equal;
    }
    toString() {
      return this.name;
    }
    _addMember(guildUser, emitEvent = true) {
      const existing = this.members.has(guildUser.user.id);
      if (!(guildUser.user instanceof User))
        guildUser.user = this.client.dataManager.newUser(guildUser.user);
      guildUser.joined_at = guildUser.joined_at || 0;
      const member = new GuildMember(this, guildUser);
      this.members.set(member.id, member);
      if (this._rawVoiceStates && this._rawVoiceStates.has(member.user.id)) {
        const voiceState = this._rawVoiceStates.get(member.user.id);
        member.serverMute = voiceState.mute;
        member.serverDeaf = voiceState.deaf;
        member.selfMute = voiceState.self_mute;
        member.selfDeaf = voiceState.self_deaf;
        member.voiceSessionID = voiceState.session_id;
        member.voiceChannelID = voiceState.channel_id;
        if (this.client.channels.has(voiceState.channel_id)) {
          this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member);
        } else {
          this.client.emit("warn", `Member ${member.id} added in guild ${this.id} with an uncached voice channel`);
        }
      }
      if (this.client.ws.connection.status === Constants2.Status.READY && emitEvent && !existing) {
        this.client.emit(Constants2.Events.GUILD_MEMBER_ADD, member);
      }
      return member;
    }
    _updateMember(member, data) {
      const oldMember = Util2.cloneObject(member);
      if (data.roles)
        member._roles = data.roles;
      if (typeof data.nick !== "undefined")
        member.nickname = data.nick;
      const notSame = member.nickname !== oldMember.nickname || !Util2.arraysEqual(member._roles, oldMember._roles);
      if (this.client.ws.connection.status === Constants2.Status.READY && notSame) {
        this.client.emit(Constants2.Events.GUILD_MEMBER_UPDATE, oldMember, member);
      }
      return {
        old: oldMember,
        mem: member
      };
    }
    _removeMember(guildMember) {
      if (guildMember.voiceChannel)
        guildMember.voiceChannel.members.delete(guildMember.id);
      this.members.delete(guildMember.id);
    }
    _memberSpeakUpdate(user, speaking) {
      const member = this.members.get(user);
      if (member && member.speaking !== speaking) {
        member.speaking = speaking;
        this.client.emit(Constants2.Events.GUILD_MEMBER_SPEAKING, member, speaking);
      }
    }
    _setPresence(id, presence) {
      if (this.presences.get(id)) {
        this.presences.get(id).update(presence);
        return;
      }
      this.presences.set(id, new Presence2(presence, this.client));
    }
    setRolePosition(role, position, relative = false) {
      if (typeof role === "string") {
        role = this.roles.get(role);
        if (!role)
          return Promise.reject(new Error("Supplied role is not a role or snowflake."));
      }
      position = Number(position);
      if (isNaN(position))
        return Promise.reject(new Error("Supplied position is not a number."));
      let updatedRoles = this._sortedRoles.array();
      Util2.moveElementInArray(updatedRoles, role, position, relative);
      updatedRoles = updatedRoles.map((r, i) => ({id: r.id, position: i}));
      return this.client.rest.methods.setRolePositions(this.id, updatedRoles);
    }
    setChannelPosition(channel, position, relative = false) {
      if (typeof channel === "string") {
        channel = this.channels.get(channel);
        if (!channel)
          return Promise.reject(new Error("Supplied channel is not a channel or snowflake."));
      }
      position = Number(position);
      if (isNaN(position))
        return Promise.reject(new Error("Supplied position is not a number."));
      let updatedChannels = this._sortedChannels(channel.type).array();
      Util2.moveElementInArray(updatedChannels, channel, position, relative);
      updatedChannels = updatedChannels.map((r, i) => ({id: r.id, position: i}));
      return this.client.rest.methods.setChannelPositions(this.id, updatedChannels);
    }
    _sortedChannels(type) {
      return this._sortPositionWithID(this.channels.filter((c) => {
        if (type === "voice" && c.type === "voice")
          return true;
        else if (type !== "voice" && c.type !== "voice")
          return true;
        else
          return type === c.type;
      }));
    }
    _sortPositionWithID(collection) {
      return collection.sort((a, b) => a.position !== b.position ? a.position - b.position : Long2.fromString(b.id).sub(Long2.fromString(a.id)).toNumber());
    }
  };
  Object.defineProperty(Guild.prototype, "defaultChannel", {
    get: util.deprecate(function defaultChannel() {
      return this.channels.get(this.id);
    }, "Guild#defaultChannel: This property is obsolete, will be removed in v12.0.0, and may not function as expected.")
  });
  Guild.prototype.allowDMs = util.deprecate(Guild.prototype.allowDMs, "Guild#allowDMs: userbot methods will be removed");
  Guild.prototype.acknowledge = util.deprecate(Guild.prototype.acknowledge, "Guild#acknowledge: userbot methods will be removed");
  Guild.prototype.setPosition = util.deprecate(Guild.prototype.setPosition, "Guild#setPosition: userbot methods will be removed");
  Guild.prototype.search = util.deprecate(Guild.prototype.search, "Guild#search: userbot methods will be removed");
  Guild.prototype.sync = util.deprecate(Guild.prototype.sync, "Guild#sync:, userbot methods will be removed");
  module2.exports = Guild;
});

// node_modules/discord.js/src/structures/Channel.js
var require_Channel = __commonJS((exports2, module2) => {
  var Snowflake = require_Snowflake();
  var Channel = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.type = null;
      this.deleted = false;
      if (data)
        this.setup(data);
    }
    setup(data) {
      this.id = data.id;
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    delete() {
      return this.client.rest.methods.deleteChannel(this);
    }
  };
  module2.exports = Channel;
});

// node_modules/discord.js/src/client/ClientDataResolver.js
var require_ClientDataResolver = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  var snekfetch = require_snekfetch();
  var Constants2 = require_Constants();
  var convertToBuffer = require_Util().convertToBuffer;
  var User = require_User();
  var Message = require_Message();
  var Guild = require_Guild();
  var Channel = require_Channel();
  var GuildMember = require_GuildMember();
  var Emoji = require_Emoji();
  var ReactionEmoji = require_ReactionEmoji();
  var Role = require_Role();
  var ClientDataResolver2 = class {
    constructor(client) {
      this.client = client;
    }
    resolveUser(user) {
      if (user instanceof User)
        return user;
      if (typeof user === "string")
        return this.client.users.get(user) || null;
      if (user instanceof GuildMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      if (user instanceof Guild)
        return user.owner;
      return null;
    }
    resolveUserID(user) {
      if (user instanceof User || user instanceof GuildMember)
        return user.id;
      if (typeof user === "string")
        return user || null;
      if (user instanceof Message)
        return user.author.id;
      if (user instanceof Guild)
        return user.ownerID;
      return null;
    }
    resolveGuild(guild) {
      if (guild instanceof Guild)
        return guild;
      if (typeof guild === "string")
        return this.client.guilds.get(guild) || null;
      return null;
    }
    resolveGuildMember(guild, user) {
      if (user instanceof GuildMember)
        return user;
      guild = this.resolveGuild(guild);
      user = this.resolveUser(user);
      if (!guild || !user)
        return null;
      return guild.members.get(user.id) || null;
    }
    resolveRole(guild, role) {
      if (role instanceof Role)
        return role;
      guild = this.resolveGuild(guild);
      if (!guild)
        return null;
      if (typeof role === "string")
        return guild.roles.get(role);
      return null;
    }
    resolveChannel(channel) {
      if (channel instanceof Channel)
        return channel;
      if (typeof channel === "string")
        return this.client.channels.get(channel) || null;
      if (channel instanceof Message)
        return channel.channel;
      if (channel instanceof Guild)
        return channel.channels.get(channel.id) || null;
      return null;
    }
    resolveChannelID(channel) {
      if (channel instanceof Channel)
        return channel.id;
      if (typeof channel === "string")
        return channel;
      if (channel instanceof Message)
        return channel.channel.id;
      if (channel instanceof Guild)
        return channel.defaultChannel.id;
      return null;
    }
    resolveInviteCode(data) {
      const inviteRegex = /discord(?:app\.com\/invite|\.gg(?:\/invite)?)\/([\w-]{2,255})/i;
      const match = inviteRegex.exec(data);
      if (match && match[1])
        return match[1];
      return data;
    }
    resolveString(data) {
      if (typeof data === "string")
        return data;
      if (data instanceof Array)
        return data.join("\n");
      return String(data);
    }
    resolveImage(image) {
      if (!image)
        return Promise.resolve(null);
      if (typeof image === "string" && image.startsWith("data:")) {
        return Promise.resolve(image);
      }
      return this.resolveFile(image).then(this.resolveBase64);
    }
    resolveBase64(data) {
      if (data instanceof Buffer)
        return `data:image/jpg;base64,${data.toString("base64")}`;
      return data;
    }
    resolveFile(resource) {
      if (resource instanceof Buffer)
        return Promise.resolve(resource);
      if (this.client.browser && resource instanceof ArrayBuffer)
        return Promise.resolve(convertToBuffer(resource));
      if (typeof resource === "string") {
        if (/^https?:\/\//.test(resource)) {
          return snekfetch.get(resource).then((res) => res.body instanceof Buffer ? res.body : Buffer.from(res.text));
        }
        return new Promise((resolve, reject) => {
          const file = path.resolve(resource);
          fs.stat(file, (err, stats) => {
            if (err)
              return reject(err);
            if (!stats || !stats.isFile())
              return reject(new Error(`The file could not be found: ${file}`));
            fs.readFile(file, (err2, data) => {
              if (err2)
                reject(err2);
              else
                resolve(data);
            });
            return null;
          });
        });
      } else if (resource && resource.pipe && typeof resource.pipe === "function") {
        return new Promise((resolve, reject) => {
          const buffers = [];
          resource.once("error", reject);
          resource.on("data", (data) => buffers.push(data));
          resource.once("end", () => resolve(Buffer.concat(buffers)));
        });
      }
      return Promise.reject(new TypeError("The resource must be a string or Buffer."));
    }
    resolveEmojiIdentifier(emoji) {
      if (emoji instanceof Emoji || emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        if (this.client.emojis.has(emoji))
          return this.client.emojis.get(emoji).identifier;
        else if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        else
          return emoji;
      }
      return null;
    }
    static resolveColor(color) {
      if (typeof color === "string") {
        if (color === "RANDOM")
          return Math.floor(Math.random() * (16777215 + 1));
        if (color === "DEFAULT")
          return 0;
        color = Constants2.Colors[color] || parseInt(color.replace("#", ""), 16);
      } else if (color instanceof Array) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
      }
      if (color < 0 || color > 16777215) {
        throw new RangeError("Color must be within the range 0 - 16777215 (0xFFFFFF).");
      } else if (color && isNaN(color)) {
        throw new TypeError("Unable to convert color to a number.");
      }
      return color;
    }
    resolveColor(color) {
      return this.constructor.resolveColor(color);
    }
  };
  module2.exports = ClientDataResolver2;
});

// node_modules/discord.js/src/structures/RichEmbed.js
var require_RichEmbed = __commonJS((exports2, module2) => {
  var Attachment = require_Attachment();
  var MessageEmbed = require_MessageEmbed();
  var ClientDataResolver2;
  var RichEmbed = class {
    constructor(data = {}) {
      this.title = data.title;
      this.description = data.description;
      this.url = data.url;
      this.color = data.color;
      this.author = data.author;
      this.timestamp = data.timestamp;
      this.fields = data.fields || [];
      this.thumbnail = data.thumbnail;
      this.image = data.image;
      this.footer = data.footer;
      this.file = data.file;
      this.files = [];
    }
    setTitle(title) {
      title = resolveString(title);
      if (title.length > 256)
        throw new RangeError("RichEmbed titles may not exceed 256 characters.");
      this.title = title;
      return this;
    }
    setDescription(description) {
      description = resolveString(description);
      if (description.length > 2048)
        throw new RangeError("RichEmbed descriptions may not exceed 2048 characters.");
      this.description = description;
      return this;
    }
    setURL(url) {
      this.url = url;
      return this;
    }
    setColor(color) {
      if (!ClientDataResolver2)
        ClientDataResolver2 = require_ClientDataResolver();
      this.color = ClientDataResolver2.resolveColor(color);
      return this;
    }
    setAuthor(name, icon, url) {
      this.author = {name: resolveString(name), icon_url: icon, url};
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      if (timestamp instanceof Date)
        timestamp = timestamp.getTime();
      this.timestamp = timestamp;
      return this;
    }
    addField(name, value, inline = false) {
      if (this.fields.length >= 25)
        throw new RangeError("RichEmbeds may not exceed 25 fields.");
      name = resolveString(name);
      if (name.length > 256)
        throw new RangeError("RichEmbed field names may not exceed 256 characters.");
      if (!/\S/.test(name))
        throw new RangeError("RichEmbed field names may not be empty.");
      value = resolveString(value);
      if (value.length > 1024)
        throw new RangeError("RichEmbed field values may not exceed 1024 characters.");
      if (!/\S/.test(value))
        throw new RangeError("RichEmbed field values may not be empty.");
      this.fields.push({name, value, inline});
      return this;
    }
    addBlankField(inline = false) {
      return this.addField("\u200B", "\u200B", inline);
    }
    setThumbnail(url) {
      this.thumbnail = {url};
      return this;
    }
    setImage(url) {
      this.image = {url};
      return this;
    }
    setFooter(text, icon) {
      text = resolveString(text);
      if (text.length > 2048)
        throw new RangeError("RichEmbed footer text may not exceed 2048 characters.");
      this.footer = {text, icon_url: icon};
      return this;
    }
    attachFile(file) {
      if (this.file)
        throw new RangeError("You may not upload more than one file at once.");
      if (file instanceof Attachment)
        file = file.file;
      this.file = file;
      return this;
    }
    attachFiles(files) {
      files = files.map((file) => file instanceof Attachment ? file.file : file);
      this.files = this.files.concat(files);
      return this;
    }
    get length() {
      return (this.title ? this.title.length : 0) + (this.description ? this.description.length : 0) + (this.fields.length >= 1 ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) : 0) + (this.footer ? this.footer.text.length : 0) + (this.author ? this.author.name.length : 0);
    }
    _apiTransform() {
      return {
        title: this.title,
        type: "rich",
        description: this.description,
        url: this.url,
        timestamp: this.timestamp ? new Date(this.timestamp) : null,
        color: this.color,
        fields: this.fields ? this.fields.map((field) => ({name: field.name, value: field.value, inline: field.inline})) : null,
        thumbnail: this.thumbnail ? {
          url: this.thumbnail.url
        } : null,
        image: this.image ? {
          url: this.image.url
        } : null,
        author: this.author ? {
          name: this.author.name,
          url: this.author.url,
          icon_url: this.author instanceof MessageEmbed.Author ? this.author.iconURL : this.author.icon_url
        } : null,
        footer: this.footer ? {
          text: this.footer.text,
          icon_url: this.footer instanceof MessageEmbed.Footer ? this.footer.iconURL : this.footer.icon_url
        } : null
      };
    }
  };
  module2.exports = RichEmbed;
  function resolveString(data) {
    if (typeof data === "string")
      return data;
    if (data instanceof Array)
      return data.join("\n");
    return String(data);
  }
});

// node_modules/discord.js/src/structures/PartialGuild.js
var require_PartialGuild = __commonJS((exports2, module2) => {
  var PartialGuild = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.splash = data.splash;
    }
  };
  module2.exports = PartialGuild;
});

// node_modules/discord.js/src/structures/PartialGuildChannel.js
var require_PartialGuildChannel = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var PartialGuildChannel = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.name = data.name;
      this.type = Constants2.ChannelTypes.TEXT === data.type ? "text" : "voice";
    }
  };
  module2.exports = PartialGuildChannel;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports2, module2) => {
  var PartialGuild = require_PartialGuild();
  var PartialGuildChannel = require_PartialGuildChannel();
  var Constants2 = require_Constants();
  var Invite = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.setup(data);
    }
    setup(data) {
      this.guild = this.client.guilds.get(data.guild.id) || new PartialGuild(this.client, data.guild);
      this.code = data.code;
      this.presenceCount = data.approximate_presence_count;
      this.memberCount = data.approximate_member_count;
      this.textChannelCount = data.guild.text_channel_count;
      this.voiceChannelCount = data.guild.voice_channel_count;
      this.temporary = data.temporary;
      this.maxAge = data.max_age;
      this.uses = data.uses;
      this.maxUses = data.max_uses;
      if (data.inviter) {
        this.inviter = this.client.dataManager.newUser(data.inviter);
      }
      this.channel = this.client.channels.get(data.channel.id) || new PartialGuildChannel(this.client, data.channel);
      this.createdTimestamp = new Date(data.created_at).getTime();
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get expiresTimestamp() {
      return this.createdTimestamp + this.maxAge * 1e3;
    }
    get expiresAt() {
      return new Date(this.expiresTimestamp);
    }
    get url() {
      return Constants2.Endpoints.inviteLink(this.code);
    }
    delete(reason) {
      return this.client.rest.methods.deleteInvite(this, reason);
    }
    toString() {
      return this.url;
    }
  };
  module2.exports = Invite;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events");
  var path = require("path");
  var Util2 = require_Util();
  var Attachment = require_Attachment();
  var RichEmbed = require_RichEmbed();
  var Webhook = class extends EventEmitter2 {
    constructor(client, dataOrID, token) {
      super();
      if (client) {
        Object.defineProperty(this, "client", {value: client});
        if (dataOrID)
          this.setup(dataOrID);
      } else {
        this.id = dataOrID;
        this.token = token;
        Object.defineProperty(this, "client", {value: this});
      }
    }
    setup(data) {
      this.name = data.name;
      Object.defineProperty(this, "token", {value: data.token, writable: true, configurable: true});
      this.avatar = data.avatar;
      this.id = data.id;
      this.guildID = data.guild_id;
      this.channelID = data.channel_id;
      if (data.user) {
        this.owner = this.client.users ? this.client.users.get(data.user.id) : data.user;
      } else {
        this.owner = null;
      }
    }
    send(content, options) {
      if (!options && typeof content === "object" && !(content instanceof Array)) {
        options = content;
        content = "";
      } else if (!options) {
        options = {};
      }
      if (options instanceof Attachment)
        options = {files: [options]};
      if (options instanceof RichEmbed)
        options = {embeds: [options]};
      if (content) {
        content = this.client.resolver.resolveString(content);
        let {split, code, disableEveryone} = options;
        if (split && typeof split !== "object")
          split = {};
        if (typeof code !== "undefined" && (typeof code !== "boolean" || code === true)) {
          content = Util2.escapeMarkdown(content, true);
          content = `\`\`\`${typeof code !== "boolean" ? code || "" : ""}
${content}
\`\`\``;
          if (split) {
            split.prepend = `\`\`\`${typeof code !== "boolean" ? code || "" : ""}
`;
            split.append = "\n```";
          }
        }
        if (disableEveryone || typeof disableEveryone === "undefined" && this.client.options.disableEveryone) {
          content = content.replace(/@(everyone|here)/g, "@\u200B$1");
        }
        if (split)
          content = Util2.splitMessage(content, split);
      }
      if (options.file) {
        if (options.files)
          options.files.push(options.file);
        else
          options.files = [options.file];
      }
      if (options.embeds) {
        const files = [];
        for (const embed of options.embeds) {
          if (embed.file)
            files.push(embed.file);
        }
        if (options.files)
          options.files.push(...files);
        else
          options.files = files;
      }
      if (options.embeds)
        options.embeds = options.embeds.map((e) => new RichEmbed(e)._apiTransform());
      if (options.files) {
        for (let i = 0; i < options.files.length; i++) {
          let file = options.files[i];
          if (typeof file === "string" || Buffer.isBuffer(file))
            file = {attachment: file};
          if (!file.name) {
            if (typeof file.attachment === "string") {
              file.name = path.basename(file.attachment);
            } else if (file.attachment && file.attachment.path) {
              file.name = path.basename(file.attachment.path);
            } else if (file instanceof Attachment) {
              file = {attachment: file.file, name: path.basename(file.file) || "file.jpg"};
            } else {
              file.name = "file.jpg";
            }
          } else if (file instanceof Attachment) {
            file = file.file;
          }
          options.files[i] = file;
        }
        return Promise.all(options.files.map((file) => this.client.resolver.resolveFile(file.attachment).then((resource) => {
          file.file = resource;
          return file;
        }))).then((files) => this.client.rest.methods.sendWebhookMessage(this, content, options, files));
      }
      return this.client.rest.methods.sendWebhookMessage(this, content, options);
    }
    sendMessage(content, options = {}) {
      return this.send(content, options);
    }
    sendFile(attachment, name, content, options = {}) {
      return this.send(content, Object.assign(options, {file: {attachment, name}}));
    }
    sendCode(lang, content, options = {}) {
      return this.send(content, Object.assign(options, {code: lang}));
    }
    sendSlackMessage(body) {
      return this.client.rest.methods.sendSlackWebhookMessage(this, body);
    }
    edit(name = this.name, avatar) {
      if (avatar) {
        return this.client.resolver.resolveImage(avatar).then((data) => this.client.rest.methods.editWebhook(this, name, data));
      }
      return this.client.rest.methods.editWebhook(this, name);
    }
    delete(reason) {
      return this.client.rest.methods.deleteWebhook(this, reason);
    }
  };
  module2.exports = Webhook;
});

// node_modules/discord.js/src/structures/UserConnection.js
var require_UserConnection = __commonJS((exports2, module2) => {
  var UserConnection = class {
    constructor(user, data) {
      this.user = user;
      this.setup(data);
    }
    setup(data) {
      this.type = data.type;
      this.name = data.name;
      this.id = data.id;
      this.revoked = data.revoked;
      this.integrations = data.integrations;
    }
  };
  module2.exports = UserConnection;
});

// node_modules/discord.js/src/structures/UserProfile.js
var require_UserProfile = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var UserConnection = require_UserConnection();
  var UserProfile = class {
    constructor(user, data) {
      this.user = user;
      Object.defineProperty(this, "client", {value: user.client});
      this.mutualGuilds = new Collection2();
      this.connections = new Collection2();
      this.setup(data);
    }
    setup(data) {
      this.premium = data.premium;
      this.premiumSince = data.premium_since ? new Date(data.premium_since) : null;
      for (const guild of data.mutual_guilds) {
        if (this.client.guilds.has(guild.id)) {
          this.mutualGuilds.set(guild.id, this.client.guilds.get(guild.id));
        }
      }
      for (const connection of data.connected_accounts) {
        this.connections.set(connection.id, new UserConnection(this.user, connection));
      }
    }
  };
  module2.exports = UserProfile;
});

// node_modules/discord.js/src/structures/OAuth2Application.js
var require_OAuth2Application = __commonJS((exports2, module2) => {
  var Snowflake = require_Snowflake();
  var util = require("util");
  var OAuth2Application = class {
    constructor(client, data) {
      Object.defineProperty(this, "client", {value: client});
      this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.name = data.name;
      this.description = data.description;
      this.icon = data.icon;
      this.iconURL = `https://cdn.discordapp.com/app-icons/${this.id}/${this.icon}.jpg`;
      this.rpcOrigins = data.rpc_origins;
      this.redirectURIs = data.redirect_uris;
      this.botRequireCodeGrant = data.bot_require_code_grant;
      this.botPublic = data.bot_public;
      this.rpcApplicationState = data.rpc_application_state;
      this.bot = data.bot;
      this.flags = data.flags;
      this.secret = data.secret;
      if (data.owner) {
        this.owner = this.client.dataManager.newUser(data.owner);
      }
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    reset() {
      return this.client.rest.methods.resetApplication(this.id);
    }
    toString() {
      return this.name;
    }
  };
  OAuth2Application.prototype.reset = util.deprecate(OAuth2Application.prototype.reset, "OAuth2Application#reset: userbot methods will be removed");
  module2.exports = OAuth2Application;
});

// node_modules/discord.js/src/structures/GroupDMChannel.js
var require_GroupDMChannel = __commonJS((exports2, module2) => {
  var Channel = require_Channel();
  var TextBasedChannel = require_TextBasedChannel();
  var Collection2 = require_Collection();
  var Constants2 = require_Constants();
  var GroupDMChannel = class extends Channel {
    constructor(client, data) {
      super(client, data);
      this.type = "group";
      this.messages = new Collection2();
      this._typing = new Map();
    }
    setup(data) {
      super.setup(data);
      this.name = data.name;
      this.icon = data.icon;
      this.ownerID = data.owner_id;
      this.managed = data.managed;
      this.applicationID = data.application_id;
      if (data.nicks) {
        this.nicks = new Collection2(data.nicks.map((n) => [n.id, n.nick]));
      }
      if (!this.recipients) {
        this.recipients = new Collection2();
      }
      if (data.recipients) {
        for (const recipient of data.recipients) {
          const user = this.client.dataManager.newUser(recipient);
          this.recipients.set(user.id, user);
        }
      }
      this.lastMessageID = data.last_message_id;
      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
    }
    get owner() {
      return this.client.users.get(this.ownerID);
    }
    get iconURL() {
      if (!this.icon)
        return null;
      return Constants2.Endpoints.Channel(this).Icon(this.client.options.http.cdn, this.icon);
    }
    edit(data) {
      const _data = {};
      if (data.name)
        _data.name = data.name;
      if (typeof data.icon !== "undefined")
        _data.icon = data.icon;
      return this.client.rest.methods.updateGroupDMChannel(this, _data);
    }
    equals(channel) {
      const equal = channel && this.id === channel.id && this.name === channel.name && this.icon === channel.icon && this.ownerID === channel.ownerID;
      if (equal) {
        return this.recipients.equals(channel.recipients);
      }
      return equal;
    }
    addUser(accessTokenOrID, nick) {
      return this.client.rest.methods.addUserToGroupDM(this, {
        nick,
        id: this.client.resolver.resolveUserID(accessTokenOrID),
        accessToken: accessTokenOrID
      });
    }
    setIcon(icon) {
      return this.client.resolver.resolveImage(icon).then((data) => this.edit({icon: data}));
    }
    setName(name) {
      return this.edit({name});
    }
    removeUser(user) {
      const id = this.client.resolver.resolveUserID(user);
      return this.client.rest.methods.removeUserFromGroupDM(this, id);
    }
    toString() {
      return this.name;
    }
    get lastPinAt() {
    }
    send() {
    }
    sendMessage() {
    }
    sendEmbed() {
    }
    sendFile() {
    }
    sendFiles() {
    }
    sendCode() {
    }
    fetchMessage() {
    }
    fetchMessages() {
    }
    fetchPinnedMessages() {
    }
    search() {
    }
    startTyping() {
    }
    stopTyping() {
    }
    get typing() {
    }
    get typingCount() {
    }
    createCollector() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    acknowledge() {
    }
    _cacheMessage() {
    }
  };
  TextBasedChannel.applyToClass(GroupDMChannel, true, ["bulkDelete"]);
  module2.exports = GroupDMChannel;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports2, module2) => {
  var VoiceRegion = class {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.vip = data.vip;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
      this.sampleHostname = data.sample_hostname;
    }
  };
  module2.exports = VoiceRegion;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var Snowflake = require_Snowflake();
  var Webhook = require_Webhook();
  var Invite = require_Invite();
  var Targets = {
    ALL: "ALL",
    GUILD: "GUILD",
    CHANNEL: "CHANNEL",
    USER: "USER",
    ROLE: "ROLE",
    INVITE: "INVITE",
    WEBHOOK: "WEBHOOK",
    EMOJI: "EMOJI",
    MESSAGE: "MESSAGE"
  };
  var Actions = {
    ALL: null,
    GUILD_UPDATE: 1,
    CHANNEL_CREATE: 10,
    CHANNEL_UPDATE: 11,
    CHANNEL_DELETE: 12,
    CHANNEL_OVERWRITE_CREATE: 13,
    CHANNEL_OVERWRITE_UPDATE: 14,
    CHANNEL_OVERWRITE_DELETE: 15,
    MEMBER_KICK: 20,
    MEMBER_PRUNE: 21,
    MEMBER_BAN_ADD: 22,
    MEMBER_BAN_REMOVE: 23,
    MEMBER_UPDATE: 24,
    MEMBER_ROLE_UPDATE: 25,
    ROLE_CREATE: 30,
    ROLE_UPDATE: 31,
    ROLE_DELETE: 32,
    INVITE_CREATE: 40,
    INVITE_UPDATE: 41,
    INVITE_DELETE: 42,
    WEBHOOK_CREATE: 50,
    WEBHOOK_UPDATE: 51,
    WEBHOOK_DELETE: 52,
    EMOJI_CREATE: 60,
    EMOJI_UPDATE: 61,
    EMOJI_DELETE: 62,
    MESSAGE_DELETE: 72
  };
  var GuildAuditLogs = class {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.dataManager.newUser(user);
      this.webhooks = new Collection2();
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.entries = new Collection2();
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(this, guild, item);
        this.entries.set(entry.id, entry);
      }
    }
    static build(...args) {
      const logs = new GuildAuditLogs(...args);
      return Promise.all(logs.entries.map((e) => e.target)).then(() => logs);
    }
    static targetType(target) {
      if (target < 10)
        return Targets.GUILD;
      if (target < 20)
        return Targets.CHANNEL;
      if (target < 30)
        return Targets.USER;
      if (target < 40)
        return Targets.ROLE;
      if (target < 50)
        return Targets.INVITE;
      if (target < 60)
        return Targets.WEBHOOK;
      if (target < 70)
        return Targets.EMOJI;
      if (target < 80)
        return Targets.MESSAGE;
      return null;
    }
    static actionType(action) {
      if ([
        Actions.CHANNEL_CREATE,
        Actions.CHANNEL_OVERWRITE_CREATE,
        Actions.MEMBER_BAN_REMOVE,
        Actions.ROLE_CREATE,
        Actions.INVITE_CREATE,
        Actions.WEBHOOK_CREATE,
        Actions.EMOJI_CREATE
      ].includes(action))
        return "CREATE";
      if ([
        Actions.CHANNEL_DELETE,
        Actions.CHANNEL_OVERWRITE_DELETE,
        Actions.MEMBER_KICK,
        Actions.MEMBER_PRUNE,
        Actions.MEMBER_BAN_ADD,
        Actions.ROLE_DELETE,
        Actions.INVITE_DELETE,
        Actions.WEBHOOK_DELETE,
        Actions.EMOJI_DELETE,
        Actions.MESSAGE_DELETE
      ].includes(action))
        return "DELETE";
      if ([
        Actions.GUILD_UPDATE,
        Actions.CHANNEL_UPDATE,
        Actions.CHANNEL_OVERWRITE_UPDATE,
        Actions.MEMBER_UPDATE,
        Actions.MEMBER_ROLE_UPDATE,
        Actions.ROLE_UPDATE,
        Actions.INVITE_UPDATE,
        Actions.WEBHOOK_UPDATE,
        Actions.EMOJI_UPDATE
      ].includes(action))
        return "UPDATE";
      return "ALL";
    }
  };
  var GuildAuditLogsEntry = class {
    constructor(logs, guild, data) {
      const targetType = GuildAuditLogs.targetType(data.action_type);
      this.targetType = targetType;
      this.actionType = GuildAuditLogs.actionType(data.action_type);
      this.action = Object.keys(Actions).find((k) => Actions[k] === data.action_type);
      this.reason = data.reason || null;
      this.executor = guild.client.users.get(data.user_id);
      this.changes = data.changes ? data.changes.map((c) => ({key: c.key, old: c.old_value, new: c.new_value})) : null;
      this.id = data.id;
      this.extra = null;
      if (data.options) {
        if (data.action_type === Actions.MEMBER_PRUNE) {
          this.extra = {
            removed: data.options.members_removed,
            days: data.options.delete_member_days
          };
        } else if (data.action_type === Actions.MESSAGE_DELETE) {
          this.extra = {
            count: data.options.count,
            channel: guild.channels.get(data.options.channel_id)
          };
        } else {
          switch (data.options.type) {
            case "member":
              this.extra = guild.members.get(data.options.id);
              if (!this.extra)
                this.extra = {id: data.options.id};
              break;
            case "role":
              this.extra = guild.roles.get(data.options.id);
              if (!this.extra)
                this.extra = {id: data.options.id, name: data.options.role_name};
              break;
            default:
              break;
          }
        }
      }
      if ([Targets.USER, Targets.GUILD].includes(targetType)) {
        this.target = guild.client[`${targetType.toLowerCase()}s`].get(data.target_id);
      } else if (targetType === Targets.WEBHOOK) {
        this.target = logs.webhooks.get(data.target_id) || new Webhook(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new || c.old;
          return o;
        }, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.INVITE) {
        const changes = this.changes.reduce((o, c) => {
          o[c.key] = c.new || c.old;
          return o;
        }, {
          id: data.target_id,
          guild
        });
        changes.channel = {id: changes.channel_id};
        this.target = new Invite(guild.client, changes);
      } else if (targetType === Targets.MESSAGE) {
        this.target = guild.client.users.get(data.target_id);
      } else {
        this.target = guild[`${targetType.toLowerCase()}s`].get(data.target_id);
      }
    }
    get createdTimestamp() {
      return Snowflake.deconstruct(this.id).timestamp;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  };
  GuildAuditLogs.Actions = Actions;
  GuildAuditLogs.Targets = Targets;
  GuildAuditLogs.Entry = GuildAuditLogsEntry;
  module2.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/client/rest/RESTMethods.js
var require_RESTMethods = __commonJS((exports2, module2) => {
  var querystring = require("querystring");
  var long = require_long();
  var Permissions2 = require_Permissions();
  var Constants2 = require_Constants();
  var Endpoints = Constants2.Endpoints;
  var Collection2 = require_Collection();
  var Util2 = require_Util();
  var resolvePermissions = require_resolvePermissions();
  var RichEmbed = require_RichEmbed();
  var User = require_User();
  var GuildMember = require_GuildMember();
  var Message = require_Message();
  var Role = require_Role();
  var Invite = require_Invite();
  var Webhook = require_Webhook();
  var UserProfile = require_UserProfile();
  var OAuth2Application = require_OAuth2Application();
  var Channel = require_Channel();
  var GroupDMChannel = require_GroupDMChannel();
  var Guild = require_Guild();
  var VoiceRegion = require_VoiceRegion();
  var GuildAuditLogs = require_GuildAuditLogs();
  var RESTMethods = class {
    constructor(restManager) {
      this.rest = restManager;
      this.client = restManager.client;
      this._ackToken = null;
    }
    login(token = this.client.token) {
      return new Promise((resolve, reject) => {
        if (!token || typeof token !== "string")
          throw new Error(Constants2.Errors.INVALID_TOKEN);
        token = token.replace(/^Bot\s*/i, "");
        this.client.manager.connectToWebSocket(token, resolve, reject);
      }).catch((e) => {
        this.client.destroy();
        return Promise.reject(e);
      });
    }
    logout() {
      return this.rest.makeRequest("post", Endpoints.logout, true, {});
    }
    getGateway(bot2 = false) {
      return this.rest.makeRequest("get", bot2 ? Endpoints.gateway.bot : Endpoints.gateway, true);
    }
    fetchVoiceRegions(guildID) {
      let endpoint;
      if (guildID)
        endpoint = Endpoints.Guild(guildID).voiceRegions;
      else
        endpoint = Endpoints.voiceRegions;
      return this.rest.makeRequest("get", endpoint, true).then((res) => {
        const regions = new Collection2();
        for (const region of res)
          regions.set(region.id, new VoiceRegion(region));
        return regions;
      });
    }
    fetchEmbed(guildID) {
      return this.rest.makeRequest("get", Endpoints.Guild(guildID).embed, true).then((data) => ({
        enabled: data.enabled,
        channel: data.channel_id ? this.client.channels.get(data.channel_id) : null
      }));
    }
    sendMessage(channel, content, {tts, nonce, embed, disableEveryone, split, code, reply} = {}, files = null) {
      return new Promise((resolve, reject) => {
        if (typeof content !== "undefined")
          content = this.client.resolver.resolveString(content);
        if (typeof nonce !== "undefined") {
          nonce = parseInt(nonce);
          if (isNaN(nonce) || nonce < 0)
            throw new RangeError("Message nonce must fit in an unsigned 64-bit integer.");
        }
        if (content) {
          if (split && typeof split !== "object")
            split = {};
          if (typeof code !== "undefined" && (typeof code !== "boolean" || code === true)) {
            content = Util2.escapeMarkdown(this.client.resolver.resolveString(content), true);
            content = `\`\`\`${typeof code !== "boolean" ? code || "" : ""}
${content}
\`\`\``;
            if (split) {
              split.prepend = `\`\`\`${typeof code !== "boolean" ? code || "" : ""}
`;
              split.append = "\n```";
            }
          }
          if (disableEveryone || typeof disableEveryone === "undefined" && this.client.options.disableEveryone) {
            content = content.replace(/@(everyone|here)/g, "@\u200B$1");
          }
          if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== "dm") {
            const id = this.client.resolver.resolveUserID(reply);
            const mention = `<@${reply instanceof GuildMember && reply.nickname ? "!" : ""}${id}>`;
            content = `${mention}${content ? `, ${content}` : ""}`;
            if (split)
              split.prepend = `${mention}, ${split.prepend || ""}`;
          }
          if (split)
            content = Util2.splitMessage(content, split);
        } else if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== "dm") {
          const id = this.client.resolver.resolveUserID(reply);
          content = `<@${reply instanceof GuildMember && reply.nickname ? "!" : ""}${id}>`;
        }
        const send = (chan) => {
          if (content instanceof Array) {
            const messages = [];
            (function sendChunk(list, index) {
              const options = index === list.length - 1 ? {tts, embed, files} : {tts};
              chan.send(list[index], options).then((message) => {
                messages.push(message);
                if (index >= list.length - 1)
                  return resolve(messages);
                return sendChunk(list, ++index);
              }).catch(reject);
            })(content, 0);
          } else {
            this.rest.makeRequest("post", Endpoints.Channel(chan).messages, true, {
              content,
              tts,
              nonce,
              embed
            }, files).then((data) => resolve(this.client.actions.MessageCreate.handle(data).message), reject);
          }
        };
        if (channel instanceof User || channel instanceof GuildMember)
          this.createDM(channel).then(send, reject);
        else
          send(channel);
      });
    }
    updateMessage(message, content, {embed, code, reply} = {}) {
      if (typeof content !== "undefined")
        content = this.client.resolver.resolveString(content);
      if (typeof code !== "undefined" && (typeof code !== "boolean" || code === true)) {
        content = Util2.escapeMarkdown(this.client.resolver.resolveString(content), true);
        content = `\`\`\`${typeof code !== "boolean" ? code || "" : ""}
${content}
\`\`\``;
      }
      if (reply && message.channel.type !== "dm") {
        const id = this.client.resolver.resolveUserID(reply);
        const mention = `<@${reply instanceof GuildMember && reply.nickname ? "!" : ""}${id}>`;
        content = `${mention}${content ? `, ${content}` : ""}`;
      }
      if (embed instanceof RichEmbed)
        embed = embed._apiTransform();
      return this.rest.makeRequest("patch", Endpoints.Message(message), true, {
        content,
        embed
      }).then((data) => this.client.actions.MessageUpdate.handle(data).updated);
    }
    deleteMessage(message) {
      return this.rest.makeRequest("delete", Endpoints.Message(message), true).then(() => this.client.actions.MessageDelete.handle({
        id: message.id,
        channel_id: message.channel.id
      }).message);
    }
    ackMessage(message) {
      return this.rest.makeRequest("post", Endpoints.Message(message).ack, true, {token: this._ackToken}).then((res) => {
        if (res.token)
          this._ackToken = res.token;
        return message;
      });
    }
    ackTextChannel(channel) {
      return this.rest.makeRequest("post", Endpoints.Channel(channel).Message(channel.lastMessageID).ack, true, {
        token: this._ackToken
      }).then((res) => {
        if (res.token)
          this._ackToken = res.token;
        return channel;
      });
    }
    ackGuild(guild) {
      return this.rest.makeRequest("post", Endpoints.Guild(guild).ack, true).then(() => guild);
    }
    bulkDeleteMessages(channel, messages) {
      return this.rest.makeRequest("post", Endpoints.Channel(channel).messages.bulkDelete, true, {
        messages
      }).then(() => this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages
      }).messages);
    }
    search(target, options) {
      if (typeof options === "string")
        options = {content: options};
      if (options.before) {
        if (!(options.before instanceof Date))
          options.before = new Date(options.before);
        options.maxID = long.fromNumber(options.before.getTime() - 14200704e5).shiftLeft(22).toString();
      }
      if (options.after) {
        if (!(options.after instanceof Date))
          options.after = new Date(options.after);
        options.minID = long.fromNumber(options.after.getTime() - 14200704e5).shiftLeft(22).toString();
      }
      if (options.during) {
        if (!(options.during instanceof Date))
          options.during = new Date(options.during);
        const t = options.during.getTime() - 14200704e5;
        options.minID = long.fromNumber(t).shiftLeft(22).toString();
        options.maxID = long.fromNumber(t + 864e5).shiftLeft(22).toString();
      }
      if (options.channel)
        options.channel = this.client.resolver.resolveChannelID(options.channel);
      if (options.author)
        options.author = this.client.resolver.resolveUserID(options.author);
      if (options.mentions)
        options.mentions = this.client.resolver.resolveUserID(options.options.mentions);
      options = {
        content: options.content,
        max_id: options.maxID,
        min_id: options.minID,
        has: options.has,
        channel_id: options.channel,
        author_id: options.author,
        author_type: options.authorType,
        context_size: options.contextSize,
        sort_by: options.sortBy,
        sort_order: options.sortOrder,
        limit: options.limit,
        offset: options.offset,
        mentions: options.mentions,
        mentions_everyone: options.mentionsEveryone,
        link_hostname: options.linkHostname,
        embed_provider: options.embedProvider,
        embed_type: options.embedType,
        attachment_filename: options.attachmentFilename,
        attachment_extension: options.attachmentExtension,
        include_nsfw: options.nsfw
      };
      for (const key in options)
        if (options[key] === void 0)
          delete options[key];
      const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join("&");
      let endpoint;
      if (target instanceof Channel) {
        endpoint = Endpoints.Channel(target).search;
      } else if (target instanceof Guild) {
        endpoint = Endpoints.Guild(target).search;
      } else {
        throw new TypeError("Target must be a TextChannel, DMChannel, GroupDMChannel, or Guild.");
      }
      return this.rest.makeRequest("get", `${endpoint}?${queryString}`, true).then((body) => {
        const messages = body.messages.map((x) => x.map((m) => new Message(this.client.channels.get(m.channel_id), m, this.client)));
        return {
          totalResults: body.total_results,
          messages
        };
      });
    }
    createChannel(guild, name, options) {
      const {
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        reason
      } = options;
      return this.rest.makeRequest("post", Endpoints.Guild(guild).channels, true, {
        name,
        topic,
        type: type ? Constants2.ChannelTypes[type.toUpperCase()] : "text",
        nsfw,
        bitrate,
        user_limit: userLimit,
        parent_id: parent instanceof Channel ? parent.id : parent,
        permission_overwrites: resolvePermissions.call(this, permissionOverwrites, guild),
        position,
        rate_limit_per_user: rateLimitPerUser
      }, void 0, reason).then((data) => this.client.actions.ChannelCreate.handle(data).channel);
    }
    createDM(recipient) {
      const dmChannel = this.getExistingDM(recipient);
      if (dmChannel)
        return Promise.resolve(dmChannel);
      return this.rest.makeRequest("post", Endpoints.User(this.client.user).channels, true, {
        recipient_id: recipient.id
      }).then((data) => this.client.actions.ChannelCreate.handle(data).channel);
    }
    createGroupDM(options) {
      const data = this.client.user.bot ? {access_tokens: options.accessTokens, nicks: options.nicks} : {recipients: options.recipients};
      return this.rest.makeRequest("post", Endpoints.User("@me").channels, true, data).then((res) => new GroupDMChannel(this.client, res));
    }
    addUserToGroupDM(channel, options) {
      const data = this.client.user.bot ? {nick: options.nick, access_token: options.accessToken} : {recipient: options.id};
      return this.rest.makeRequest("put", Endpoints.Channel(channel).Recipient(options.id), true, data).then(() => channel);
    }
    removeUserFromGroupDM(channel, userId) {
      return this.rest.makeRequest("delete", Endpoints.Channel(channel).Recipient(userId), true).then(() => channel);
    }
    updateGroupDMChannel(channel, _data) {
      const data = {};
      data.name = _data.name;
      data.icon = _data.icon;
      return this.rest.makeRequest("patch", Endpoints.Channel(channel), true, data).then(() => channel);
    }
    getExistingDM(recipient) {
      return this.client.channels.find((channel) => channel.recipient && channel.recipient.id === recipient.id);
    }
    deleteChannel(channel, reason) {
      if (channel instanceof User || channel instanceof GuildMember)
        channel = this.getExistingDM(channel);
      if (!channel)
        return Promise.reject(new Error("No channel to delete."));
      return this.rest.makeRequest("delete", Endpoints.Channel(channel), true, void 0, void 0, reason).then((data) => {
        data.id = channel.id;
        return this.client.actions.ChannelDelete.handle(data).channel;
      });
    }
    updateChannel(channel, _data, reason) {
      const data = {};
      data.name = (_data.name || channel.name).trim();
      data.topic = typeof _data.topic === "undefined" ? channel.topic : _data.topic;
      data.nsfw = typeof _data.nsfw === "undefined" ? channel.nsfw : _data.nsfw;
      data.position = _data.position || channel.position;
      data.bitrate = _data.bitrate || (channel.bitrate ? channel.bitrate * 1e3 : void 0);
      data.user_limit = typeof _data.userLimit !== "undefined" ? _data.userLimit : channel.userLimit;
      data.parent_id = _data.parent instanceof Channel ? _data.parent.id : _data.parent;
      data.permission_overwrites = _data.permissionOverwrites ? resolvePermissions.call(this, _data.permissionOverwrites, channel.guild) : void 0;
      data.rate_limit_per_user = typeof _data.rateLimitPerUser !== "undefined" ? _data.rateLimitPerUser : channel.rateLimitPerUser;
      return this.rest.makeRequest("patch", Endpoints.Channel(channel), true, data, void 0, reason).then((newData) => this.client.actions.ChannelUpdate.handle(newData).updated);
    }
    leaveGuild(guild) {
      if (guild.ownerID === this.client.user.id)
        return Promise.reject(new Error("Guild is owned by the client."));
      return this.rest.makeRequest("delete", Endpoints.User("@me").Guild(guild.id), true).then(() => this.client.actions.GuildDelete.handle({id: guild.id}).guild);
    }
    createGuild(options) {
      options.icon = this.client.resolver.resolveBase64(options.icon) || null;
      options.region = options.region || "us-central";
      return new Promise((resolve, reject) => {
        this.rest.makeRequest("post", Endpoints.guilds, true, options).then((data) => {
          if (this.client.guilds.has(data.id))
            return resolve(this.client.guilds.get(data.id));
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              this.client.removeListener(Constants2.Events.GUILD_CREATE, handleGuild);
              this.client.clearTimeout(timeout);
              resolve(guild);
            }
          };
          this.client.on(Constants2.Events.GUILD_CREATE, handleGuild);
          const timeout = this.client.setTimeout(() => {
            this.client.removeListener(Constants2.Events.GUILD_CREATE, handleGuild);
            reject(new Error("Took too long to receive guild data."));
          }, 1e4);
          return void 0;
        }, reject);
      });
    }
    deleteGuild(guild) {
      return this.rest.makeRequest("delete", Endpoints.Guild(guild), true).then(() => this.client.actions.GuildDelete.handle({id: guild.id}).guild);
    }
    getUser(userID, cache) {
      return this.rest.makeRequest("get", Endpoints.User(userID), true).then((data) => {
        if (cache)
          return this.client.actions.UserGet.handle(data).user;
        else
          return new User(this.client, data);
      });
    }
    updateCurrentUser(_data, password) {
      const user = this.client.user;
      const data = {};
      data.username = _data.username || user.username;
      data.avatar = typeof _data.avatar === "undefined" ? user.avatar : this.client.resolver.resolveBase64(_data.avatar);
      if (!user.bot) {
        data.email = _data.email || user.email;
        data.password = password;
        if (_data.new_password)
          data.new_password = _data.newPassword;
      }
      return this.rest.makeRequest("patch", Endpoints.User("@me"), true, data).then((newData) => this.client.actions.UserUpdate.handle(newData).updated);
    }
    updateGuild(guild, data, reason) {
      return this.rest.makeRequest("patch", Endpoints.Guild(guild), true, data, void 0, reason).then((newData) => this.client.actions.GuildUpdate.handle(newData).updated);
    }
    kickGuildMember(guild, member, reason) {
      return this.rest.makeRequest("delete", Endpoints.Guild(guild).Member(member), true, void 0, void 0, reason).then(() => member);
    }
    createGuildRole(guild, data, reason) {
      if (data.color)
        data.color = this.client.resolver.resolveColor(data.color);
      if (data.permissions)
        data.permissions = Permissions2.resolve(data.permissions);
      return this.rest.makeRequest("post", Endpoints.Guild(guild).roles, true, data, void 0, reason).then((r) => {
        const {role} = this.client.actions.GuildRoleCreate.handle({
          guild_id: guild.id,
          role: r
        });
        if (data.position)
          return role.setPosition(data.position, reason);
        return role;
      });
    }
    deleteGuildRole(role, reason) {
      return this.rest.makeRequest("delete", Endpoints.Guild(role.guild).Role(role.id), true, void 0, void 0, reason).then(() => this.client.actions.GuildRoleDelete.handle({
        guild_id: role.guild.id,
        role_id: role.id
      }).role);
    }
    setChannelOverwrite(channel, payload) {
      return this.rest.makeRequest("put", `${Endpoints.Channel(channel).permissions}/${payload.id}`, true, payload);
    }
    deletePermissionOverwrites(overwrite, reason) {
      return this.rest.makeRequest("delete", `${Endpoints.Channel(overwrite.channel).permissions}/${overwrite.id}`, true, void 0, void 0, reason).then(() => overwrite);
    }
    getChannelMessages(channel, payload = {}) {
      const params = [];
      if (payload.limit)
        params.push(`limit=${payload.limit}`);
      if (payload.around)
        params.push(`around=${payload.around}`);
      else if (payload.before)
        params.push(`before=${payload.before}`);
      else if (payload.after)
        params.push(`after=${payload.after}`);
      let endpoint = Endpoints.Channel(channel).messages;
      if (params.length > 0)
        endpoint += `?${params.join("&")}`;
      return this.rest.makeRequest("get", endpoint, true);
    }
    getChannelMessage(channel, messageID) {
      const msg = channel.messages.get(messageID);
      if (msg)
        return Promise.resolve(msg);
      return this.rest.makeRequest("get", Endpoints.Channel(channel).Message(messageID), true);
    }
    putGuildMember(guild, userID, options) {
      options.access_token = options.accessToken;
      if (options.roles) {
        const roles = options.roles;
        if (roles instanceof Collection2 || roles instanceof Array && roles[0] instanceof Role) {
          options.roles = roles.map((role) => role.id);
        }
      }
      return this.rest.makeRequest("put", Endpoints.Guild(guild).Member(userID), true, options).then((data) => this.client.actions.GuildMemberGet.handle(guild, data).member);
    }
    getGuildMember(guild, user, cache) {
      return this.rest.makeRequest("get", Endpoints.Guild(guild).Member(user.id), true).then((data) => {
        if (cache)
          return this.client.actions.GuildMemberGet.handle(guild, data).member;
        else
          return new GuildMember(guild, data);
      });
    }
    updateGuildMember(member, data, reason) {
      if (data.channel) {
        const channel = this.client.resolver.resolveChannel(data.channel);
        if (!channel || channel.guild.id !== member.guild.id || channel.type !== "voice") {
          return Promise.reject(new Error("Could not resolve channel to a guild voice channel."));
        }
        data.channel_id = channel.id;
        data.channel = void 0;
      } else if (data.channel === null) {
        data.channel_id = null;
        data.channel = void 0;
      }
      if (data.roles)
        data.roles = data.roles.map((role) => role instanceof Role ? role.id : role);
      let endpoint = Endpoints.Member(member);
      if (member.id === this.client.user.id) {
        const keys = Object.keys(data);
        if (keys.length === 1 && keys[0] === "nick") {
          endpoint = Endpoints.Member(member).nickname;
        }
      }
      return this.rest.makeRequest("patch", endpoint, true, data, void 0, reason).then((newData) => member.guild._updateMember(member, newData).mem);
    }
    addMemberRole(member, role, reason) {
      return new Promise((resolve, reject) => {
        if (member._roles.includes(role.id))
          return resolve(member);
        const listener = (oldMember, newMember) => {
          if (newMember.id === member.id && !oldMember._roles.includes(role.id) && newMember._roles.includes(role.id)) {
            this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
            resolve(newMember);
          }
        };
        this.client.on(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
          reject(new Error("Adding the role timed out."));
        }, 1e4);
        return this.rest.makeRequest("put", Endpoints.Member(member).Role(role.id), true, void 0, void 0, reason).catch((err) => {
          this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        });
      });
    }
    removeMemberRole(member, role, reason) {
      return new Promise((resolve, reject) => {
        if (!member._roles.includes(role.id))
          return resolve(member);
        const listener = (oldMember, newMember) => {
          if (newMember.id === member.id && oldMember._roles.includes(role.id) && !newMember._roles.includes(role.id)) {
            this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
            resolve(newMember);
          }
        };
        this.client.on(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
          reject(new Error("Removing the role timed out."));
        }, 1e4);
        return this.rest.makeRequest("delete", Endpoints.Member(member).Role(role.id), true, void 0, void 0, reason).catch((err) => {
          this.client.removeListener(Constants2.Events.GUILD_MEMBER_UPDATE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        });
      });
    }
    sendTyping(channelID) {
      return this.rest.makeRequest("post", Endpoints.Channel(channelID).typing, true);
    }
    banGuildMember(guild, member, options) {
      const id = this.client.resolver.resolveUserID(member);
      if (!id)
        return Promise.reject(new Error("Couldn't resolve the user ID to ban."));
      const url = `${Endpoints.Guild(guild).bans}/${id}?${querystring.stringify(options)}`;
      return this.rest.makeRequest("put", url, true).then(() => {
        if (member instanceof GuildMember)
          return member;
        const user = this.client.resolver.resolveUser(id);
        if (user) {
          member = this.client.resolver.resolveGuildMember(guild, user);
          return member || user;
        }
        return id;
      });
    }
    unbanGuildMember(guild, member, reason) {
      return new Promise((resolve, reject) => {
        const id = this.client.resolver.resolveUserID(member);
        if (!id)
          throw new Error("Couldn't resolve the user ID to unban.");
        const listener = (eGuild, eUser) => {
          if (eGuild.id === guild.id && eUser.id === id) {
            this.client.removeListener(Constants2.Events.GUILD_BAN_REMOVE, listener);
            this.client.clearTimeout(timeout);
            resolve(eUser);
          }
        };
        this.client.on(Constants2.Events.GUILD_BAN_REMOVE, listener);
        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants2.Events.GUILD_BAN_REMOVE, listener);
          reject(new Error("Took too long to receive the ban remove event."));
        }, 1e4);
        this.rest.makeRequest("delete", `${Endpoints.Guild(guild).bans}/${id}`, true, void 0, void 0, reason).catch((err) => {
          this.client.removeListener(Constants2.Events.GUILD_BAN_REMOVE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        });
      });
    }
    getGuildBan(guild, user) {
      const id = this.client.resolver.resolveUserID(user);
      return this.rest.makeRequest("get", `${Endpoints.Guild(guild).bans}/${id}`, true).then((ban) => ({
        reason: ban.reason,
        user: this.client.dataManager.newUser(ban.user)
      }));
    }
    getGuildBans(guild) {
      return this.rest.makeRequest("get", Endpoints.Guild(guild).bans, true).then((bans) => bans.reduce((collection, ban) => {
        collection.set(ban.user.id, {
          reason: ban.reason,
          user: this.client.dataManager.newUser(ban.user)
        });
        return collection;
      }, new Collection2()));
    }
    updateGuildRole(role, _data, reason) {
      const data = {};
      data.name = _data.name || role.name;
      data.position = typeof _data.position !== "undefined" ? _data.position : role.position;
      data.color = _data.color === null ? null : this.client.resolver.resolveColor(_data.color || role.color);
      data.hoist = typeof _data.hoist !== "undefined" ? _data.hoist : role.hoist;
      data.mentionable = typeof _data.mentionable !== "undefined" ? _data.mentionable : role.mentionable;
      if (typeof _data.permissions !== "undefined")
        data.permissions = Permissions2.resolve(_data.permissions);
      else
        data.permissions = role.permissions;
      return this.rest.makeRequest("patch", Endpoints.Guild(role.guild).Role(role.id), true, data, void 0, reason).then((_role) => this.client.actions.GuildRoleUpdate.handle({
        role: _role,
        guild_id: role.guild.id
      }).updated);
    }
    pinMessage(message) {
      return this.rest.makeRequest("put", Endpoints.Channel(message.channel).Pin(message.id), true).then(() => message);
    }
    unpinMessage(message) {
      return this.rest.makeRequest("delete", Endpoints.Channel(message.channel).Pin(message.id), true).then(() => message);
    }
    getChannelPinnedMessages(channel) {
      return this.rest.makeRequest("get", Endpoints.Channel(channel).pins, true);
    }
    createChannelInvite(channel, options, reason) {
      const payload = {};
      payload.temporary = options.temporary;
      payload.max_age = options.maxAge;
      payload.max_uses = options.maxUses;
      payload.unique = options.unique;
      return this.rest.makeRequest("post", Endpoints.Channel(channel).invites, true, payload, void 0, reason).then((invite) => new Invite(this.client, invite));
    }
    deleteInvite(invite, reason) {
      return this.rest.makeRequest("delete", Endpoints.Invite(invite.code), true, void 0, void 0, reason).then(() => invite);
    }
    getInvite(code) {
      return this.rest.makeRequest("get", Endpoints.Invite(code), true).then((invite) => new Invite(this.client, invite));
    }
    getGuildInvites(guild) {
      return this.rest.makeRequest("get", Endpoints.Guild(guild).invites, true).then((inviteItems) => {
        const invites = new Collection2();
        for (const inviteItem of inviteItems) {
          const invite = new Invite(this.client, inviteItem);
          invites.set(invite.code, invite);
        }
        return invites;
      });
    }
    getGuildVanityCode(guild) {
      return this.rest.makeRequest("get", Endpoints.Guild(guild).vanityURL, true).then((res) => res.code);
    }
    pruneGuildMembers(guild, days, dry, reason) {
      return this.rest.makeRequest(dry ? "get" : "post", `${Endpoints.Guild(guild).prune}?days=${days}`, true, void 0, void 0, reason).then((data) => data.pruned);
    }
    createEmoji(guild, image, name, roles, reason) {
      const data = {image, name};
      if (roles)
        data.roles = roles.map((r) => r.id ? r.id : r);
      return this.rest.makeRequest("post", Endpoints.Guild(guild).emojis, true, data, void 0, reason).then((emoji) => this.client.actions.GuildEmojiCreate.handle(guild, emoji).emoji);
    }
    updateEmoji(emoji, _data, reason) {
      const data = {};
      if (_data.name)
        data.name = _data.name;
      if (_data.roles)
        data.roles = _data.roles.map((r) => r.id ? r.id : r);
      return this.rest.makeRequest("patch", Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, data, void 0, reason).then((newEmoji) => this.client.actions.GuildEmojiUpdate.handle(emoji, newEmoji).emoji);
    }
    deleteEmoji(emoji, reason) {
      return this.rest.makeRequest("delete", Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, void 0, reason).then(() => this.client.actions.GuildEmojiDelete.handle(emoji).data);
    }
    getGuildAuditLogs(guild, options = {}) {
      if (options.before && options.before instanceof GuildAuditLogs.Entry)
        options.before = options.before.id;
      if (options.after && options.after instanceof GuildAuditLogs.Entry)
        options.after = options.after.id;
      if (typeof options.type === "string")
        options.type = GuildAuditLogs.Actions[options.type];
      const queryString = (querystring.stringify({
        before: options.before,
        after: options.after,
        limit: options.limit,
        user_id: this.client.resolver.resolveUserID(options.user),
        action_type: options.type
      }).match(/[^=&?]+=[^=&?]+/g) || []).join("&");
      return this.rest.makeRequest("get", `${Endpoints.Guild(guild).auditLogs}?${queryString}`, true).then((data) => GuildAuditLogs.build(guild, data));
    }
    getWebhook(id, token) {
      return this.rest.makeRequest("get", Endpoints.Webhook(id, token), !token).then((data) => new Webhook(this.client, data));
    }
    getGuildWebhooks(guild) {
      return this.rest.makeRequest("get", Endpoints.Guild(guild).webhooks, true).then((data) => {
        const hooks = new Collection2();
        for (const hook of data)
          hooks.set(hook.id, new Webhook(this.client, hook));
        return hooks;
      });
    }
    getChannelWebhooks(channel) {
      return this.rest.makeRequest("get", Endpoints.Channel(channel).webhooks, true).then((data) => {
        const hooks = new Collection2();
        for (const hook of data)
          hooks.set(hook.id, new Webhook(this.client, hook));
        return hooks;
      });
    }
    createWebhook(channel, name, avatar, reason) {
      return this.rest.makeRequest("post", Endpoints.Channel(channel).webhooks, true, {name, avatar}, void 0, reason).then((data) => new Webhook(this.client, data));
    }
    editWebhook(webhook, name, avatar) {
      return this.rest.makeRequest("patch", Endpoints.Webhook(webhook.id, webhook.token), false, {
        name,
        avatar
      }).then((data) => {
        webhook.name = data.name;
        webhook.avatar = data.avatar;
        return webhook;
      });
    }
    deleteWebhook(webhook, reason) {
      return this.rest.makeRequest("delete", Endpoints.Webhook(webhook.id, webhook.token), false, void 0, void 0, reason);
    }
    sendWebhookMessage(webhook, content, {avatarURL, tts, embeds, username} = {}, files = null) {
      return new Promise((resolve, reject) => {
        username = username || webhook.name;
        if (content instanceof Array) {
          const messages = [];
          (function sendChunk(list, index) {
            const options = index === list.length - 1 ? {tts, embeds, files} : {tts};
            webhook.send(list[index], options).then((message) => {
              messages.push(message);
              if (index >= list.length - 1)
                return resolve(messages);
              return sendChunk(list, ++index);
            }).catch(reject);
          })(content, 0);
        } else {
          this.rest.makeRequest("post", `${Endpoints.Webhook(webhook.id, webhook.token)}?wait=true`, false, {
            username,
            avatar_url: avatarURL,
            content,
            tts,
            embeds
          }, files).then((data) => {
            if (!this.client.channels)
              resolve(data);
            else
              resolve(this.client.actions.MessageCreate.handle(data).message);
          }, reject);
        }
      });
    }
    sendSlackWebhookMessage(webhook, body) {
      return this.rest.makeRequest("post", `${Endpoints.Webhook(webhook.id, webhook.token)}/slack?wait=true`, false, body);
    }
    fetchUserProfile(user) {
      return this.rest.makeRequest("get", Endpoints.User(user).profile, true).then((data) => new UserProfile(user, data));
    }
    fetchMentions(options) {
      if (options.guild instanceof Guild)
        options.guild = options.guild.id;
      Util2.mergeDefault({limit: 25, roles: true, everyone: true, guild: null}, options);
      return this.rest.makeRequest("get", Endpoints.User("@me").Mentions(options.limit, options.roles, options.everyone, options.guild), true).then((data) => data.map((m) => new Message(this.client.channels.get(m.channel_id), m, this.client)));
    }
    addFriend(user) {
      return this.rest.makeRequest("post", Endpoints.User("@me"), true, {
        username: user.username,
        discriminator: user.discriminator
      }).then(() => user);
    }
    removeFriend(user) {
      return this.rest.makeRequest("delete", Endpoints.User("@me").Relationship(user.id), true).then(() => user);
    }
    blockUser(user) {
      return this.rest.makeRequest("put", Endpoints.User("@me").Relationship(user.id), true, {type: 2}).then(() => user);
    }
    unblockUser(user) {
      return this.rest.makeRequest("delete", Endpoints.User("@me").Relationship(user.id), true).then(() => user);
    }
    updateChannelPositions(guildID, channels) {
      const data = new Array(channels.length);
      for (let i = 0; i < channels.length; i++) {
        data[i] = {
          id: this.client.resolver.resolveChannelID(channels[i].channel),
          position: channels[i].position
        };
      }
      return this.rest.makeRequest("patch", Endpoints.Guild(guildID).channels, true, data).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: guildID,
        channels
      }).guild);
    }
    updateEmbed(guildID, embed, reason) {
      return this.rest.makeRequest("patch", Endpoints.Guild(guildID).embed, true, {
        enabled: embed.enabled,
        channel_id: this.client.resolver.resolveChannelID(embed.channel)
      }, void 0, reason);
    }
    setRolePositions(guildID, roles) {
      return this.rest.makeRequest("patch", Endpoints.Guild(guildID).roles, true, roles).then(() => this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: guildID,
        roles
      }).guild);
    }
    setChannelPositions(guildID, channels) {
      return this.rest.makeRequest("patch", Endpoints.Guild(guildID).channels, true, channels).then(() => this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: guildID,
        channels
      }).guild);
    }
    addMessageReaction(message, emoji) {
      return this.rest.makeRequest("put", Endpoints.Message(message).Reaction(emoji).User("@me"), true).then(() => message._addReaction(Util2.parseEmoji(emoji), message.client.user));
    }
    removeMessageReaction(message, emoji, userID) {
      const endpoint = Endpoints.Message(message).Reaction(emoji).User(userID === this.client.user.id ? "@me" : userID);
      return this.rest.makeRequest("delete", endpoint, true).then(() => this.client.actions.MessageReactionRemove.handle({
        user_id: userID,
        message_id: message.id,
        emoji: Util2.parseEmoji(emoji),
        channel_id: message.channel.id
      }).reaction);
    }
    removeMessageReactions(message) {
      return this.rest.makeRequest("delete", Endpoints.Message(message).reactions, true).then(() => message);
    }
    getMessageReactionUsers(message, emoji, options) {
      const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join("&");
      return this.rest.makeRequest("get", `${Endpoints.Message(message).Reaction(emoji)}?${queryString}`, true);
    }
    getApplication(id) {
      return this.rest.makeRequest("get", Endpoints.OAUTH2.Application(id), true).then((app) => new OAuth2Application(this.client, app));
    }
    resetApplication(id) {
      return this.rest.makeRequest("post", Endpoints.OAUTH2.Application(id).resetToken, true).then(() => this.rest.makeRequest("post", Endpoints.OAUTH2.Application(id).resetSecret, true)).then((app) => new OAuth2Application(this.client, app));
    }
    setNote(user, note) {
      return this.rest.makeRequest("put", Endpoints.User(user).note, true, {note}).then(() => user);
    }
    acceptInvite(code) {
      if (code.id)
        code = code.id;
      return new Promise((resolve, reject) => this.rest.makeRequest("post", Endpoints.Invite(code), true).then((res) => {
        const handler = (guild) => {
          if (guild.id === res.id) {
            resolve(guild);
            this.client.removeListener(Constants2.Events.GUILD_CREATE, handler);
          }
        };
        this.client.on(Constants2.Events.GUILD_CREATE, handler);
        this.client.setTimeout(() => {
          this.client.removeListener(Constants2.Events.GUILD_CREATE, handler);
          reject(new Error("Accepting invite timed out"));
        }, 12e4);
      }));
    }
    patchUserSettings(data) {
      return this.rest.makeRequest("patch", Constants2.Endpoints.User("@me").settings, true, data);
    }
    patchClientUserGuildSettings(guildID, data) {
      return this.rest.makeRequest("patch", Constants2.Endpoints.User("@me").Guild(guildID).settings, true, data);
    }
  };
  module2.exports = RESTMethods;
});

// node_modules/discord.js/src/client/rest/RequestHandlers/RequestHandler.js
var require_RequestHandler = __commonJS((exports2, module2) => {
  var RequestHandler = class {
    constructor(restManager) {
      this.restManager = restManager;
      this.queue = [];
    }
    get globalLimit() {
      return this.restManager.globallyRateLimited;
    }
    set globalLimit(value) {
      this.restManager.globallyRateLimited = value;
    }
    push(request) {
      this.queue.push(request);
    }
    handle() {
    }
    destroy() {
      this.queue = [];
    }
  };
  module2.exports = RequestHandler;
});

// node_modules/discord.js/src/client/rest/DiscordAPIError.js
var require_DiscordAPIError = __commonJS((exports2, module2) => {
  var DiscordAPIError = class extends Error {
    constructor(path, error, method) {
      super();
      const flattened = this.constructor.flattenErrors(error.errors || error).join("\n");
      this.name = "DiscordAPIError";
      this.message = error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened;
      this.path = path;
      this.code = error.code;
      this.method = method;
    }
    static flattenErrors(obj, key = "") {
      let messages = [];
      for (const k of Object.keys(obj)) {
        if (k === "message")
          continue;
        const newKey = key ? isNaN(k) ? `${key}.${k}` : `${key}[${k}]` : k;
        if (obj[k]._errors) {
          messages.push(`${newKey}: ${obj[k]._errors.map((e) => e.message).join(" ")}`);
        } else if (obj[k].code || obj[k].message) {
          messages.push(`${obj[k].code ? `${obj[k].code}: ` : ""}: ${obj[k].message}`.trim());
        } else if (typeof obj[k] === "string") {
          messages.push(obj[k]);
        } else {
          messages = messages.concat(this.flattenErrors(obj[k], newKey));
        }
      }
      return messages;
    }
  };
  module2.exports = DiscordAPIError;
});

// node_modules/discord.js/src/client/rest/RequestHandlers/Sequential.js
var require_Sequential = __commonJS((exports2, module2) => {
  var RequestHandler = require_RequestHandler();
  var DiscordAPIError = require_DiscordAPIError();
  var {Events: {RATE_LIMIT}} = require_Constants();
  var SequentialRequestHandler = class extends RequestHandler {
    constructor(restManager, endpoint) {
      super(restManager, endpoint);
      this.client = restManager.client;
      this.endpoint = endpoint;
      this.timeDifference = 0;
      this.busy = false;
    }
    push(request) {
      super.push(request);
      this.handle();
    }
    execute(item) {
      this.busy = true;
      return new Promise((resolve) => {
        item.request.gen().end((err, res) => {
          if (res && res.headers) {
            this.requestLimit = Number(res.headers["x-ratelimit-limit"]);
            this.requestResetTime = Number(res.headers["x-ratelimit-reset"]) * 1e3;
            this.requestRemaining = Number(res.headers["x-ratelimit-remaining"]);
            this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
          }
          if (err) {
            if (err.status === 429) {
              this.queue.unshift(item);
              this.client.setTimeout(() => {
                this.globalLimit = false;
                resolve();
              }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
              if (res.headers["x-ratelimit-global"])
                this.globalLimit = true;
            } else if (err.status >= 500 && err.status < 600) {
              if (item.retries === this.client.options.retryLimit) {
                item.reject(err);
                resolve();
              } else {
                item.retries++;
                this.queue.unshift(item);
                this.client.setTimeout(resolve, 1e3 + this.client.options.restTimeOffset);
              }
            } else {
              item.reject(err.status >= 400 && err.status < 500 ? new DiscordAPIError(res.request.path, res.body, res.request.method) : err);
              resolve(err);
            }
          } else {
            this.globalLimit = false;
            const data = res && res.body ? res.body : {};
            item.resolve(data);
            if (this.requestRemaining === 0) {
              if (this.client.listenerCount(RATE_LIMIT)) {
                this.client.emit(RATE_LIMIT, {
                  limit: this.requestLimit,
                  timeDifference: this.timeDifference,
                  path: item.request.path,
                  method: item.request.method
                });
              }
              this.client.setTimeout(() => resolve(data), this.requestResetTime - Date.now() + this.timeDifference + this.client.options.restTimeOffset);
            } else {
              resolve(data);
            }
          }
        });
      });
    }
    handle() {
      super.handle();
      if (this.busy || this.remaining === 0 || this.queue.length === 0 || this.globalLimit)
        return;
      this.execute(this.queue.shift()).then(() => {
        this.busy = false;
        this.handle();
      });
    }
  };
  module2.exports = SequentialRequestHandler;
});

// node_modules/discord.js/src/client/rest/RequestHandlers/Burst.js
var require_Burst = __commonJS((exports2, module2) => {
  var RequestHandler = require_RequestHandler();
  var DiscordAPIError = require_DiscordAPIError();
  var {Events: {RATE_LIMIT}} = require_Constants();
  var BurstRequestHandler = class extends RequestHandler {
    constructor(restManager, endpoint) {
      super(restManager, endpoint);
      this.client = restManager.client;
      this.limit = Infinity;
      this.resetTime = null;
      this.remaining = 1;
      this.timeDifference = 0;
      this.resetTimeout = null;
    }
    push(request) {
      super.push(request);
      this.handle();
    }
    execute(item) {
      if (!item)
        return;
      item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.limit = Number(res.headers["x-ratelimit-limit"]);
          this.resetTime = Number(res.headers["x-ratelimit-reset"]) * 1e3;
          this.remaining = Number(res.headers["x-ratelimit-remaining"]);
          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            if (res.headers["x-ratelimit-global"])
              this.globalLimit = true;
            if (this.resetTimeout)
              return;
            this.resetTimeout = this.client.setTimeout(() => {
              this.remaining = this.limit;
              this.globalLimit = false;
              this.handle();
              this.resetTimeout = null;
            }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              this.handle();
            } else {
              item.retries++;
              this.queue.unshift(item);
              this.resetTimeout = this.client.setTimeout(() => {
                this.handle();
                this.resetTimeout = null;
              }, 1e3 + this.client.options.restTimeOffset);
            }
          } else {
            item.reject(err.status >= 400 && err.status < 500 ? new DiscordAPIError(res.request.path, res.body, res.request.method) : err);
            this.handle();
          }
        } else {
          if (this.remaining === 0) {
            if (this.client.listenerCount(RATE_LIMIT)) {
              this.client.emit(RATE_LIMIT, {
                limit: this.limit,
                timeDifference: this.timeDifference,
                path: item.request.path,
                method: item.request.method
              });
            }
          }
          this.globalLimit = false;
          const data = res && res.body ? res.body : {};
          item.resolve(data);
          this.handle();
        }
      });
    }
    handle() {
      super.handle();
      if (this.queue.length === 0)
        return;
      if ((this.remaining <= 0 || this.globalLimit) && Date.now() - this.timeDifference < this.resetTime)
        return;
      this.execute(this.queue.shift());
      this.remaining--;
      this.handle();
    }
  };
  module2.exports = BurstRequestHandler;
});

// node_modules/discord.js/src/client/rest/APIRequest.js
var require_APIRequest = __commonJS((exports2, module2) => {
  var snekfetch = require_snekfetch();
  var Constants2 = require_Constants();
  var APIRequest = class {
    constructor(rest, method, path, auth, data, files, reason) {
      this.rest = rest;
      this.client = rest.client;
      this.method = method;
      this.path = path.toString();
      this.auth = auth;
      this.data = data;
      this.files = files;
      this.route = this.getRoute(this.path);
      this.reason = reason;
    }
    getRoute(url) {
      let route = url.split("?")[0];
      if (route.includes("/channels/") || route.includes("/guilds/")) {
        const startInd = route.includes("/channels/") ? route.indexOf("/channels/") : route.indexOf("/guilds/");
        const majorID = route.substring(startInd).split("/")[2];
        route = route.replace(/(\d{8,})/g, ":id").replace(":id", majorID);
      }
      return route;
    }
    getAuth() {
      if (this.client.token && this.client.user && this.client.user.bot) {
        return `Bot ${this.client.token}`;
      } else if (this.client.token) {
        return this.client.token;
      }
      throw new Error(Constants2.Errors.NO_TOKEN);
    }
    gen() {
      const API = `${this.client.options.http.host}/api/v${this.client.options.http.version}`;
      const request = snekfetch[this.method](`${API}${this.path}`);
      if (this.auth)
        request.set("Authorization", this.getAuth());
      if (this.reason)
        request.set("X-Audit-Log-Reason", encodeURIComponent(this.reason));
      if (!this.rest.client.browser)
        request.set("User-Agent", this.rest.userAgentManager.userAgent);
      if (this.files) {
        for (const file of this.files)
          if (file && file.file)
            request.attach(file.name, file.file, file.name);
        if (typeof this.data !== "undefined")
          request.attach("payload_json", JSON.stringify(this.data));
      } else if (this.data) {
        request.send(this.data);
      }
      return request;
    }
  };
  module2.exports = APIRequest;
});

// node_modules/discord.js/src/client/rest/RESTManager.js
var require_RESTManager = __commonJS((exports2, module2) => {
  var UserAgentManager = require_UserAgentManager();
  var RESTMethods = require_RESTMethods();
  var SequentialRequestHandler = require_Sequential();
  var BurstRequestHandler = require_Burst();
  var APIRequest = require_APIRequest();
  var Constants2 = require_Constants();
  var RESTManager2 = class {
    constructor(client) {
      this.client = client;
      this.handlers = {};
      this.userAgentManager = new UserAgentManager(this);
      this.methods = new RESTMethods(this);
      this.rateLimitedEndpoints = {};
      this.globallyRateLimited = false;
    }
    destroy() {
      for (const handlerKey of Object.keys(this.handlers)) {
        const handler = this.handlers[handlerKey];
        if (handler.destroy)
          handler.destroy();
      }
    }
    push(handler, apiRequest) {
      return new Promise((resolve, reject) => {
        handler.push({
          request: apiRequest,
          resolve,
          reject,
          retries: 0
        });
      });
    }
    getRequestHandler() {
      switch (this.client.options.apiRequestMethod) {
        case "sequential":
          return SequentialRequestHandler;
        case "burst":
          return BurstRequestHandler;
        default:
          throw new Error(Constants2.Errors.INVALID_RATE_LIMIT_METHOD);
      }
    }
    makeRequest(method, url, auth, data, file, reason) {
      const apiRequest = new APIRequest(this, method, url, auth, data, file, reason);
      if (!this.handlers[apiRequest.route]) {
        const RequestHandlerType = this.getRequestHandler();
        this.handlers[apiRequest.route] = new RequestHandlerType(this, apiRequest.route);
      }
      return this.push(this.handlers[apiRequest.route], apiRequest);
    }
  };
  module2.exports = RESTManager2;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports2, module2) => {
  var Permissions2 = require_Permissions();
  var PermissionOverwrites = class {
    constructor(guildChannel, data) {
      Object.defineProperty(this, "channel", {value: guildChannel});
      if (data)
        this.setup(data);
    }
    setup(data) {
      this.id = data.id;
      this.type = data.type;
      this.deny = data.deny;
      this.allow = data.allow;
      this.denied = new Permissions2(data.deny).freeze();
      this.allowed = new Permissions2(data.allow).freeze();
    }
    delete(reason) {
      return this.channel.client.rest.methods.deletePermissionOverwrites(this, reason);
    }
  };
  module2.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports2, module2) => {
  var Channel = require_Channel();
  var Role = require_Role();
  var PermissionOverwrites = require_PermissionOverwrites();
  var Permissions2 = require_Permissions();
  var Collection2 = require_Collection();
  var Constants2 = require_Constants();
  var Invite = require_Invite();
  var GuildChannel = class extends Channel {
    constructor(guild, data) {
      super(guild.client, data);
      this.guild = guild;
    }
    setup(data) {
      super.setup(data);
      this.name = data.name;
      this.position = data.position;
      this.parentID = data.parent_id;
      this.permissionOverwrites = new Collection2();
      if (data.permission_overwrites) {
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));
        }
      }
    }
    get calculatedPosition() {
      const sorted = this.guild._sortedChannels(this.type);
      return sorted.array().indexOf(sorted.get(this.id));
    }
    get parent() {
      return this.guild.channels.get(this.parentID) || null;
    }
    memberPermissions(member) {
      member = this.client.resolver.resolveGuildMember(this.guild, member);
      if (!member)
        return null;
      if (member.id === this.guild.ownerID)
        return new Permissions2(member, Permissions2.ALL);
      const roles = member.roles;
      const permissions = new Permissions2(roles.map((role) => role.permissions));
      if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR))
        return new Permissions2(Permissions2.ALL).freeze();
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();
    }
    rolePermissions(role) {
      if (role.permissions & Permissions2.FLAGS.ADMINISTRATOR)
        return new Permissions2(Permissions2.ALL).freeze();
      const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.get(role.id);
      return new Permissions2(role.permissions).remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();
    }
    permissionsFor(memberOrRole) {
      const member = this.guild.member(memberOrRole);
      if (member)
        return this.memberPermissions(member);
      const role = this.client.resolver.resolveRole(this.guild, memberOrRole);
      if (role)
        return this.rolePermissions(role);
      return null;
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.client.resolver.resolveGuildMember(this.guild, member);
      if (!member)
        return [];
      roles = roles || member.roles;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    replacePermissionOverwrites({overwrites, reason} = {}) {
      return this.edit({permissionOverwrites: overwrites, reason}).then(() => this);
    }
    overwritePermissions(userOrRole, options, reason) {
      const payload = {
        allow: 0,
        deny: 0
      };
      if (userOrRole instanceof Role) {
        payload.type = "role";
      } else if (this.guild.roles.has(userOrRole)) {
        userOrRole = this.guild.roles.get(userOrRole);
        payload.type = "role";
      } else {
        userOrRole = this.client.resolver.resolveUser(userOrRole);
        payload.type = "member";
        if (!userOrRole)
          return Promise.reject(new TypeError("Supplied parameter was neither a User nor a Role."));
      }
      payload.id = userOrRole.id;
      const prevOverwrite = this.permissionOverwrites.get(userOrRole.id);
      if (prevOverwrite) {
        payload.allow = prevOverwrite.allow;
        payload.deny = prevOverwrite.deny;
      }
      for (const perm in options) {
        if (options[perm] === true) {
          payload.allow |= Permissions2.FLAGS[perm] || 0;
          payload.deny &= ~(Permissions2.FLAGS[perm] || 0);
        } else if (options[perm] === false) {
          payload.allow &= ~(Permissions2.FLAGS[perm] || 0);
          payload.deny |= Permissions2.FLAGS[perm] || 0;
        } else if (options[perm] === null) {
          payload.allow &= ~(Permissions2.FLAGS[perm] || 0);
          payload.deny &= ~(Permissions2.FLAGS[perm] || 0);
        }
      }
      return this.client.rest.methods.setChannelOverwrite(this, payload, reason).then(() => this);
    }
    lockPermissions() {
      if (!this.parent)
        return Promise.reject(new TypeError("Could not find a parent to this guild channel."));
      const permissionOverwrites = this.parent.permissionOverwrites.map((overwrite) => ({
        deny: overwrite.deny,
        allow: overwrite.allow,
        id: overwrite.id,
        type: overwrite.type
      }));
      return this.edit({permissionOverwrites});
    }
    edit(data, reason) {
      return this.client.rest.methods.updateChannel(this, data, reason).then(() => this);
    }
    setName(name, reason) {
      return this.edit({name}, reason);
    }
    setPosition(position, relative) {
      return this.guild.setChannelPosition(this, position, relative);
    }
    setParent(parent, reason) {
      parent = this.client.resolver.resolveChannelID(parent);
      return this.edit({parent}, reason);
    }
    setTopic(topic, reason) {
      return this.edit({topic}, reason);
    }
    createInvite(options = {}, reason) {
      return this.client.rest.methods.createChannelInvite(this, options, reason);
    }
    clone(name = this.name, withPermissions = true, withTopic = true, reason) {
      return this.guild.createChannel(name, {
        type: this.type,
        permissionOverwrites: withPermissions ? this.permissionOverwrites : void 0,
        topic: withTopic ? this.topic : void 0,
        reason
      });
    }
    fetchInvites() {
      return this.client.rest.makeRequest("get", Constants2.Endpoints.Channel(this.id).invites, true).then((data) => {
        const invites = new Collection2();
        for (let invite of data) {
          invite = new Invite(this.client, invite);
          invites.set(invite.code, invite);
        }
        return invites;
      });
    }
    delete(reason) {
      return this.client.rest.methods.deleteChannel(this, reason);
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.equals(channel.permissionOverwrites);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.id !== this.guild.id && this.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_CHANNELS);
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerID)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has([Permissions2.FLAGS.MANAGE_CHANNELS, Permissions2.FLAGS.VIEW_CHANNEL]);
    }
    get muted() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).muted;
      } catch (err) {
        return false;
      }
    }
    get messageNotifications() {
      if (this.client.user.bot)
        return null;
      try {
        return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).messageNotifications;
      } catch (err) {
        return Constants2.MessageNotificationTypes[3];
      }
    }
    toString() {
      return `<#${this.id}>`;
    }
  };
  module2.exports = GuildChannel;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports2, module2) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var Collection2 = require_Collection();
  var TextChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.type = "text";
      this.messages = new Collection2();
      this._typing = new Map();
    }
    setup(data) {
      super.setup(data);
      this.topic = data.topic;
      this.nsfw = Boolean(data.nsfw);
      this.lastMessageID = data.last_message_id;
      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
      this.rateLimitPerUser = data.rate_limit_per_user || 0;
    }
    get members() {
      const members = new Collection2();
      for (const member of this.guild.members.values()) {
        if (this.permissionsFor(member).has("READ_MESSAGES")) {
          members.set(member.id, member);
        }
      }
      return members;
    }
    fetchWebhooks() {
      return this.client.rest.methods.getChannelWebhooks(this);
    }
    setNSFW(nsfw, reason) {
      return this.edit({nsfw}, reason);
    }
    createWebhook(name, avatar, reason) {
      if (typeof avatar === "string" && avatar.startsWith("data:")) {
        return this.client.rest.methods.createWebhook(this, name, avatar, reason);
      } else {
        return this.client.resolver.resolveImage(avatar).then((data) => this.client.rest.methods.createWebhook(this, name, data, reason));
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({rateLimitPerUser}, reason);
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendMessage() {
    }
    sendEmbed() {
    }
    sendFile() {
    }
    sendFiles() {
    }
    sendCode() {
    }
    fetchMessage() {
    }
    fetchMessages() {
    }
    fetchPinnedMessages() {
    }
    search() {
    }
    startTyping() {
    }
    stopTyping() {
    }
    get typing() {
    }
    get typingCount() {
    }
    createCollector() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    bulkDelete() {
    }
    acknowledge() {
    }
    _cacheMessage() {
    }
  };
  TextBasedChannel.applyToClass(TextChannel, true);
  module2.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports2, module2) => {
  var GuildChannel = require_GuildChannel();
  var Collection2 = require_Collection();
  var Permissions2 = require_Permissions();
  var VoiceChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.members = new Collection2();
      this.type = "voice";
    }
    setup(data) {
      super.setup(data);
      this.bitrate = data.bitrate * 1e-3;
      this.userLimit = data.user_limit;
    }
    get connection() {
      const connection = this.guild.voiceConnection;
      if (connection && connection.channel.id === this.id)
        return connection;
      return null;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get deletable() {
      return super.deletable && this.permissionsFor(this.client.user).has(Permissions2.FLAGS.CONNECT);
    }
    get joinable() {
      if (this.client.browser)
        return false;
      if (!this.permissionsFor(this.client.user).has("CONNECT"))
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has("MOVE_MEMBERS"))
        return false;
      return true;
    }
    get speakable() {
      return this.permissionsFor(this.client.user).has("SPEAK");
    }
    setBitrate(bitrate, reason) {
      bitrate *= 1e3;
      return this.edit({bitrate}, reason);
    }
    setUserLimit(userLimit, reason) {
      return this.edit({userLimit}, reason);
    }
    join() {
      if (this.client.browser)
        return Promise.reject(new Error("Voice connections are not available in browsers."));
      return this.client.voice.joinChannel(this);
    }
    leave() {
      if (this.client.browser)
        return;
      const connection = this.client.voice.connections.get(this.guild.id);
      if (connection && connection.channel.id === this.id)
        connection.disconnect();
    }
  };
  module2.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports2, module2) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.type = "category";
    }
    get children() {
      return this.guild.channels.filter((c) => c.parentID === this.id);
    }
  };
  module2.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports2, module2) => {
  var TextChannel = require_TextChannel();
  var NewsChannel = class extends TextChannel {
    constructor(guild, data) {
      super(guild, data);
      this.type = "news";
    }
    setup(data) {
      super.setup(data);
      this.rateLimitPerUser = 0;
    }
  };
  module2.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/StoreChannel.js
var require_StoreChannel = __commonJS((exports2, module2) => {
  var GuildChannel = require_GuildChannel();
  var StoreChannel = class extends GuildChannel {
    constructor(guild, data) {
      super(guild, data);
      this.type = "store";
    }
    setup(data) {
      super.setup(data);
      this.nsfw = data.nsfw;
    }
  };
  module2.exports = StoreChannel;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports2, module2) => {
  var Channel = require_Channel();
  var TextBasedChannel = require_TextBasedChannel();
  var Collection2 = require_Collection();
  var DMChannel = class extends Channel {
    constructor(client, data) {
      super(client, data);
      this.type = "dm";
      this.messages = new Collection2();
      this._typing = new Map();
    }
    setup(data) {
      super.setup(data);
      this.recipient = this.client.dataManager.newUser(data.recipients[0]);
      this.lastMessageID = data.last_message_id;
      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
    }
    toString() {
      return this.recipient.toString();
    }
    get lastPinAt() {
    }
    send() {
    }
    sendMessage() {
    }
    sendEmbed() {
    }
    sendFile() {
    }
    sendFiles() {
    }
    sendCode() {
    }
    fetchMessage() {
    }
    fetchMessages() {
    }
    fetchPinnedMessages() {
    }
    search() {
    }
    startTyping() {
    }
    stopTyping() {
    }
    get typing() {
    }
    get typingCount() {
    }
    createCollector() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    acknowledge() {
    }
    _cacheMessage() {
    }
  };
  TextBasedChannel.applyToClass(DMChannel, true, ["bulkDelete"]);
  module2.exports = DMChannel;
});

// node_modules/discord.js/src/client/ClientDataManager.js
var require_ClientDataManager = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var Guild = require_Guild();
  var User = require_User();
  var Emoji = require_Emoji();
  var GuildChannel = require_GuildChannel();
  var TextChannel = require_TextChannel();
  var VoiceChannel = require_VoiceChannel();
  var CategoryChannel = require_CategoryChannel();
  var NewsChannel = require_NewsChannel();
  var StoreChannel = require_StoreChannel();
  var DMChannel = require_DMChannel();
  var GroupDMChannel = require_GroupDMChannel();
  var ClientDataManager2 = class {
    constructor(client) {
      this.client = client;
    }
    get pastReady() {
      return this.client.ws.connection.status === Constants2.Status.READY;
    }
    newGuild(data) {
      const already = this.client.guilds.has(data.id);
      const guild = new Guild(this.client, data);
      this.client.guilds.set(guild.id, guild);
      if (this.pastReady && !already) {
        if (this.client.options.fetchAllMembers) {
          guild.fetchMembers().then(() => {
            this.client.emit(Constants2.Events.GUILD_CREATE, guild);
          });
        } else {
          this.client.emit(Constants2.Events.GUILD_CREATE, guild);
        }
      }
      return guild;
    }
    newUser(data, cache = true) {
      if (this.client.users.has(data.id))
        return this.client.users.get(data.id);
      const user = new User(this.client, data);
      if (cache)
        this.client.users.set(user.id, user);
      return user;
    }
    newChannel(data, guild) {
      const already = this.client.channels.has(data.id);
      let channel;
      if (data.type === Constants2.ChannelTypes.DM) {
        channel = new DMChannel(this.client, data);
      } else if (data.type === Constants2.ChannelTypes.GROUP_DM) {
        channel = new GroupDMChannel(this.client, data);
      } else {
        guild = guild || this.client.guilds.get(data.guild_id);
        if (already) {
          channel = this.client.channels.get(data.id);
        } else if (guild) {
          switch (data.type) {
            case Constants2.ChannelTypes.TEXT:
              channel = new TextChannel(guild, data);
              break;
            case Constants2.ChannelTypes.VOICE:
              channel = new VoiceChannel(guild, data);
              break;
            case Constants2.ChannelTypes.CATEGORY:
              channel = new CategoryChannel(guild, data);
              break;
            case Constants2.ChannelTypes.NEWS:
              channel = new NewsChannel(guild, data);
              break;
            case Constants2.ChannelTypes.STORE:
              channel = new StoreChannel(guild, data);
              break;
          }
          guild.channels.set(channel.id, channel);
        }
      }
      if (channel && !already) {
        if (this.pastReady)
          this.client.emit(Constants2.Events.CHANNEL_CREATE, channel);
        this.client.channels.set(channel.id, channel);
        return channel;
      } else if (already) {
        return channel;
      }
      return null;
    }
    newEmoji(data, guild) {
      const already = guild.emojis.has(data.id);
      if (data && !already) {
        let emoji = new Emoji(guild, data);
        this.client.emit(Constants2.Events.GUILD_EMOJI_CREATE, emoji);
        guild.emojis.set(emoji.id, emoji);
        return emoji;
      } else if (already) {
        return guild.emojis.get(data.id);
      }
      return null;
    }
    killEmoji(emoji) {
      if (!(emoji instanceof Emoji && emoji.guild))
        return;
      this.client.emit(Constants2.Events.GUILD_EMOJI_DELETE, emoji);
      emoji.guild.emojis.delete(emoji.id);
    }
    killGuild(guild) {
      const already = this.client.guilds.has(guild.id);
      this.client.guilds.delete(guild.id);
      if (already && this.pastReady)
        this.client.emit(Constants2.Events.GUILD_DELETE, guild);
    }
    killUser(user) {
      this.client.users.delete(user.id);
    }
    killChannel(channel) {
      this.client.channels.delete(channel.id);
      if (channel instanceof GuildChannel)
        channel.guild.channels.delete(channel.id);
    }
    updateGuild(currentGuild, newData) {
      const oldGuild = Util2.cloneObject(currentGuild);
      currentGuild.setup(newData);
      if (this.pastReady)
        this.client.emit(Constants2.Events.GUILD_UPDATE, oldGuild, currentGuild);
    }
    updateChannel(currentChannel, newData) {
      currentChannel.setup(newData);
    }
    updateEmoji(currentEmoji, newData) {
      const oldEmoji = Util2.cloneObject(currentEmoji);
      currentEmoji.setup(newData);
      this.client.emit(Constants2.Events.GUILD_EMOJI_UPDATE, oldEmoji, currentEmoji);
      return currentEmoji;
    }
  };
  module2.exports = ClientDataManager2;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/AbstractHandler.js
var require_AbstractHandler = __commonJS((exports2, module2) => {
  var AbstractHandler = class {
    constructor(packetManager) {
      this.packetManager = packetManager;
    }
    handle(packet) {
      return packet;
    }
  };
  module2.exports = AbstractHandler;
});

// node_modules/discord.js/src/structures/ClientUserSettings.js
var require_ClientUserSettings = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var ClientUserSettings = class {
    constructor(user, data) {
      this.user = user;
      this.patch(data);
    }
    patch(data) {
      for (const key of Object.keys(Constants2.UserSettingsMap)) {
        const value = Constants2.UserSettingsMap[key];
        if (!data.hasOwnProperty(key))
          continue;
        if (typeof value === "function") {
          this[value.name] = value(data[key]);
        } else {
          this[value] = data[key];
        }
      }
    }
    update(name, value) {
      return this.user.client.rest.methods.patchUserSettings({[name]: value});
    }
    setGuildPosition(guild, position, relative) {
      const temp = Object.assign([], this.guildPositions);
      Util2.moveElementInArray(temp, guild.id, position, relative);
      return this.update("guild_positions", temp).then(() => guild);
    }
    addRestrictedGuild(guild) {
      const temp = Object.assign([], this.restrictedGuilds);
      if (temp.includes(guild.id))
        return Promise.reject(new Error("Guild is already restricted"));
      temp.push(guild.id);
      return this.update("restricted_guilds", temp).then(() => guild);
    }
    removeRestrictedGuild(guild) {
      const temp = Object.assign([], this.restrictedGuilds);
      const index = temp.indexOf(guild.id);
      if (index < 0)
        return Promise.reject(new Error("Guild is not restricted"));
      temp.splice(index, 1);
      return this.update("restricted_guilds", temp).then(() => guild);
    }
  };
  module2.exports = ClientUserSettings;
});

// node_modules/discord.js/src/structures/ClientUserChannelOverride.js
var require_ClientUserChannelOverride = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var ClientUserChannelOverride = class {
    constructor(data) {
      this.patch(data);
    }
    patch(data) {
      for (const key of Object.keys(Constants2.UserChannelOverrideMap)) {
        const value = Constants2.UserChannelOverrideMap[key];
        if (!data.hasOwnProperty(key))
          continue;
        if (typeof value === "function") {
          this[value.name] = value(data[key]);
        } else {
          this[value] = data[key];
        }
      }
    }
  };
  module2.exports = ClientUserChannelOverride;
});

// node_modules/discord.js/src/structures/ClientUserGuildSettings.js
var require_ClientUserGuildSettings = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var Collection2 = require_Collection();
  var ClientUserChannelOverride = require_ClientUserChannelOverride();
  var ClientUserGuildSettings = class {
    constructor(data, client) {
      Object.defineProperty(this, "client", {value: client});
      this.guildID = data.guild_id;
      this.channelOverrides = new Collection2();
      this.patch(data);
    }
    patch(data) {
      for (const key of Object.keys(Constants2.UserGuildSettingsMap)) {
        const value = Constants2.UserGuildSettingsMap[key];
        if (!data.hasOwnProperty(key))
          continue;
        if (key === "channel_overrides") {
          for (const channel of data[key]) {
            this.channelOverrides.set(channel.channel_id, new ClientUserChannelOverride(channel));
          }
        } else if (typeof value === "function") {
          this[value.name] = value(data[key]);
        } else {
          this[value] = data[key];
        }
      }
    }
    update(name, value) {
      return this.client.rest.methods.patchClientUserGuildSettings(this.guildID, {[name]: value});
    }
  };
  module2.exports = ClientUserGuildSettings;
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports2, module2) => {
  var User = require_User();
  var Collection2 = require_Collection();
  var ClientUserSettings = require_ClientUserSettings();
  var ClientUserGuildSettings = require_ClientUserGuildSettings();
  var Constants2 = require_Constants();
  var util = require("util");
  var ClientUser = class extends User {
    setup(data) {
      super.setup(data);
      this.verified = data.verified;
      this.email = data.email;
      this.localPresence = {};
      this._typing = new Map();
      this.friends = new Collection2();
      this.blocked = new Collection2();
      this.notes = new Collection2();
      this.premium = typeof data.premium === "boolean" ? data.premium : null;
      this.mfaEnabled = data.mfa_enabled;
      this.mobile = typeof data.mobile === "boolean" ? data.mobile : null;
      this.settings = data.user_settings ? new ClientUserSettings(this, data.user_settings) : null;
      this.guildSettings = new Collection2();
      if (data.user_guild_settings) {
        for (const settings of data.user_guild_settings) {
          this.guildSettings.set(settings.guild_id, new ClientUserGuildSettings(settings, this.client));
        }
      }
    }
    edit(data) {
      return this.client.rest.methods.updateCurrentUser(data);
    }
    setUsername(username, password) {
      return this.client.rest.methods.updateCurrentUser({username}, password);
    }
    setEmail(email, password) {
      return this.client.rest.methods.updateCurrentUser({email}, password);
    }
    setPassword(newPassword, oldPassword) {
      return this.client.rest.methods.updateCurrentUser({password: newPassword}, oldPassword);
    }
    setAvatar(avatar) {
      return this.client.resolver.resolveImage(avatar).then((data) => this.client.rest.methods.updateCurrentUser({avatar: data}));
    }
    setPresence(data) {
      return new Promise((resolve) => {
        let status = this.localPresence.status || this.presence.status;
        let game = this.localPresence.game;
        let afk = this.localPresence.afk || this.presence.afk;
        if (!game && this.presence.game) {
          game = {
            name: this.presence.game.name,
            type: this.presence.game.type,
            url: this.presence.game.url
          };
        }
        if (data.status) {
          if (typeof data.status !== "string")
            throw new TypeError("Status must be a string");
          if (this.bot) {
            status = data.status;
          } else {
            this.settings.update(Constants2.UserSettingsMap.status, data.status);
            status = "invisible";
          }
        }
        if (data.game) {
          game = data.game;
          game.type = game.url && typeof game.type === "undefined" ? 1 : game.type || 0;
          if (typeof game.type === "string") {
            game.type = Constants2.ActivityTypes.indexOf(game.type.toUpperCase());
          }
        } else if (typeof data.game !== "undefined") {
          game = null;
        }
        if (typeof data.afk !== "undefined")
          afk = data.afk;
        afk = Boolean(afk);
        this.localPresence = {status, game, afk};
        this.localPresence.since = 0;
        this.localPresence.game = this.localPresence.game || null;
        this.client.ws.send({
          op: 3,
          d: this.localPresence
        });
        this.client._setPresence(this.id, this.localPresence);
        resolve(this);
      });
    }
    setStatus(status) {
      return this.setPresence({status});
    }
    setGame(game, streamingURL) {
      if (!game)
        return this.setPresence({game: null});
      return this.setPresence({
        game: {
          name: game,
          url: streamingURL
        }
      });
    }
    setActivity(name, {url, type} = {}) {
      if (!name)
        return this.setPresence({game: null});
      return this.setPresence({
        game: {name, type, url}
      }).then((clientUser) => clientUser.presence);
    }
    setAFK(afk) {
      return this.setPresence({afk});
    }
    fetchMentions(options = {}) {
      return this.client.rest.methods.fetchMentions(options);
    }
    addFriend(user) {
      user = this.client.resolver.resolveUser(user);
      return this.client.rest.methods.addFriend(user);
    }
    removeFriend(user) {
      user = this.client.resolver.resolveUser(user);
      return this.client.rest.methods.removeFriend(user);
    }
    createGuild(name, region, icon = null) {
      if (typeof icon === "string" && icon.startsWith("data:")) {
        return this.client.rest.methods.createGuild({name, icon, region});
      } else {
        return this.client.resolver.resolveImage(icon).then((data) => this.client.rest.methods.createGuild({name, icon: data, region}));
      }
    }
    createGroupDM(recipients) {
      return this.client.rest.methods.createGroupDM({
        recipients: recipients.map((u) => this.client.resolver.resolveUserID(u.user)),
        accessTokens: recipients.map((u) => u.accessToken),
        nicks: recipients.reduce((o, r) => {
          if (r.nick)
            o[r.user ? r.user.id : r.id] = r.nick;
          return o;
        }, {})
      });
    }
    acceptInvite(invite) {
      return this.client.rest.methods.acceptInvite(invite);
    }
  };
  ClientUser.prototype.acceptInvite = util.deprecate(ClientUser.prototype.acceptInvite, "ClientUser#acceptInvite: userbot methods will be removed");
  ClientUser.prototype.setGame = util.deprecate(ClientUser.prototype.setGame, "ClientUser#setGame: use ClientUser#setActivity instead");
  ClientUser.prototype.addFriend = util.deprecate(ClientUser.prototype.addFriend, "ClientUser#addFriend: userbot methods will be removed");
  ClientUser.prototype.removeFriend = util.deprecate(ClientUser.prototype.removeFriend, "ClientUser#removeFriend: userbot methods will be removed");
  ClientUser.prototype.setPassword = util.deprecate(ClientUser.prototype.setPassword, "ClientUser#setPassword: userbot methods will be removed");
  ClientUser.prototype.setEmail = util.deprecate(ClientUser.prototype.setEmail, "ClientUser#setEmail: userbot methods will be removed");
  ClientUser.prototype.fetchMentions = util.deprecate(ClientUser.prototype.fetchMentions, "ClientUser#fetchMentions: userbot methods will be removed");
  module2.exports = ClientUser;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/Ready.js
var require_Ready = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var ClientUser = require_ClientUser();
  var ReadyHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.ws.heartbeat();
      data.user.user_settings = data.user_settings;
      data.user.user_guild_settings = data.user_guild_settings;
      const clientUser = new ClientUser(client, data.user);
      client.user = clientUser;
      client.readyAt = new Date();
      client.users.set(clientUser.id, clientUser);
      for (const guild of data.guilds)
        if (!client.guilds.has(guild.id))
          client.dataManager.newGuild(guild);
      for (const privateDM of data.private_channels)
        client.dataManager.newChannel(privateDM);
      for (const relation of data.relationships) {
        const user = client.dataManager.newUser(relation.user);
        if (relation.type === 1) {
          client.user.friends.set(user.id, user);
        } else if (relation.type === 2) {
          client.user.blocked.set(user.id, user);
        }
      }
      data.presences = data.presences || [];
      for (const presence of data.presences) {
        client.dataManager.newUser(presence.user);
        client._setPresence(presence.user.id, presence);
      }
      if (data.notes) {
        for (const user in data.notes) {
          let note = data.notes[user];
          if (!note.length)
            note = null;
          client.user.notes.set(user, note);
        }
      }
      if (!client.user.bot && client.options.sync)
        client.setInterval(client.syncGuilds.bind(client), 3e4);
      if (!client.users.has("1")) {
        client.dataManager.newUser({
          id: "1",
          username: "Clyde",
          discriminator: "0000",
          avatar: "https://discordapp.com/assets/f78426a064bc9dd24847519259bc42af.png",
          bot: true,
          status: "online",
          game: null,
          verified: true
        });
      }
      const t = client.setTimeout(() => {
        client.ws.connection.triggerReady();
      }, 1200 * data.guilds.length);
      client.setMaxListeners(data.guilds.length + 10);
      client.once("ready", () => {
        client.syncGuilds();
        client.setMaxListeners(10);
        client.clearTimeout(t);
      });
      const ws = this.packetManager.ws;
      ws.sessionID = data.session_id;
      ws._trace = data._trace;
      client.emit("debug", `READY ${ws._trace.join(" -> ")} ${ws.sessionID}`);
      ws.checkIfReady();
    }
  };
  module2.exports = ReadyHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/Resumed.js
var require_Resumed = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var ResumedHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const ws = client.ws.connection;
      ws._trace = packet.d._trace;
      ws.status = Constants2.Status.READY;
      this.packetManager.handleQueue();
      const replayed = ws.sequence - ws.closeSequence;
      ws.debug(`RESUMED ${ws._trace.join(" -> ")} | replayed ${replayed} events.`);
      client.emit(Constants2.Events.RESUME, replayed);
      ws.heartbeat();
    }
  };
  module2.exports = ResumedHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildCreate.js
var require_GuildCreate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildCreateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.id);
      if (guild) {
        if (!guild.available && !data.unavailable) {
          guild.setup(data);
          this.packetManager.ws.checkIfReady();
        }
      } else {
        client.dataManager.newGuild(data);
      }
    }
  };
  module2.exports = GuildCreateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildDelete.js
var require_GuildDelete = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var GuildDeleteHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const response = client.actions.GuildDelete.handle(data);
      if (response.guild)
        client.emit(Constants2.Events.GUILD_DELETE, response.guild);
    }
  };
  module2.exports = GuildDeleteHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildUpdate.handle(data);
    }
  };
  module2.exports = GuildUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var GuildBanAddHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      const user = client.users.get(data.user.id);
      if (guild && user)
        client.emit(Constants2.Events.GUILD_BAN_ADD, guild, user);
    }
  };
  module2.exports = GuildBanAddHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildBanRemoveHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildBanRemove.handle(data);
    }
  };
  module2.exports = GuildBanRemoveHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildMemberAdd.js
var require_GuildMemberAdd = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildMemberAddHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        guild.memberCount++;
        guild._addMember(data);
      }
    }
  };
  module2.exports = GuildMemberAddHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildMemberRemoveHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildMemberRemove.handle(data);
    }
  };
  module2.exports = GuildMemberRemoveHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildMemberUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        const member = guild.members.get(data.user.id);
        if (member)
          guild._updateMember(member, data);
      }
    }
  };
  module2.exports = GuildMemberUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildRoleCreateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildRoleCreate.handle(data);
    }
  };
  module2.exports = GuildRoleCreateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildRoleDeleteHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildRoleDelete.handle(data);
    }
  };
  module2.exports = GuildRoleDeleteHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildRoleUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildRoleUpdate.handle(data);
    }
  };
  module2.exports = GuildRoleUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildEmojisUpdate = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildEmojisUpdate.handle(data);
    }
  };
  module2.exports = GuildEmojisUpdate;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildMembersChunk.js
var require_GuildMembersChunk = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var GuildMembersChunkHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      if (!guild)
        return;
      const members = data.members.map((member) => guild._addMember(member, false));
      client.emit(Constants2.Events.GUILD_MEMBERS_CHUNK, members, guild);
      client.ws.lastHeartbeatAck = true;
    }
  };
  module2.exports = GuildMembersChunkHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var {Events} = require_Constants();
  var GuildIntegrationsHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      if (guild)
        client.emit(Events.GUILD_INTEGRATIONS_UPDATE, guild);
    }
  };
  module2.exports = GuildIntegrationsHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var ChannelCreateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.ChannelCreate.handle(data);
    }
  };
  module2.exports = ChannelCreateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var ChannelDeleteHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const response = client.actions.ChannelDelete.handle(data);
      if (response.channel)
        client.emit(Constants2.Events.CHANNEL_DELETE, response.channel);
    }
  };
  module2.exports = ChannelDeleteHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var ChannelUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.ChannelUpdate.handle(data);
    }
  };
  module2.exports = ChannelUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/ChannelPinsUpdate.js
var require_ChannelPinsUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var ChannelPinsUpdate = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const channel = client.channels.get(data.channel_id);
      const time = new Date(data.last_pin_timestamp);
      if (channel && time) {
        channel.lastPinTimestamp = time.getTime() || null;
        client.emit(Constants2.Events.CHANNEL_PINS_UPDATE, channel, time);
      }
    }
  };
  module2.exports = ChannelPinsUpdate;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var PresenceUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      let user = client.users.get(data.user.id);
      const guild = client.guilds.get(data.guild_id);
      if (!user) {
        if (data.user.username) {
          user = client.dataManager.newUser(data.user);
        } else {
          return;
        }
      }
      const oldUser = Util2.cloneObject(user);
      user.patch(data.user);
      if (!user.equals(oldUser)) {
        client.emit(Constants2.Events.USER_UPDATE, oldUser, user);
      }
      if (guild) {
        let member = guild.members.get(user.id);
        if (!member && data.status !== "offline") {
          member = guild._addMember({
            user,
            roles: data.roles,
            deaf: false,
            mute: false
          }, false);
          client.emit(Constants2.Events.GUILD_MEMBER_AVAILABLE, member);
        }
        if (member) {
          if (client.listenerCount(Constants2.Events.PRESENCE_UPDATE) === 0) {
            guild._setPresence(user.id, data);
            return;
          }
          const oldMember = Util2.cloneObject(member);
          if (member.presence) {
            oldMember.frozenPresence = Util2.cloneObject(member.presence);
          }
          guild._setPresence(user.id, data);
          client.emit(Constants2.Events.PRESENCE_UPDATE, oldMember, member);
        } else {
          guild._setPresence(user.id, data);
        }
      }
    }
  };
  module2.exports = PresenceUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/UserUpdate.js
var require_UserUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var UserUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.UserUpdate.handle(data);
    }
  };
  module2.exports = UserUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/UserNoteUpdate.js
var require_UserNoteUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var UserNoteUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.UserNoteUpdate.handle(data);
    }
  };
  module2.exports = UserNoteUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/UserSettingsUpdate.js
var require_UserSettingsUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var UserSettingsUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      client.user.settings.patch(packet.d);
      client.emit(Constants2.Events.USER_SETTINGS_UPDATE, client.user.settings);
    }
  };
  module2.exports = UserSettingsUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/UserGuildSettingsUpdate.js
var require_UserGuildSettingsUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var ClientUserGuildSettings = require_ClientUserGuildSettings();
  var UserGuildSettingsUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const settings = client.user.guildSettings.get(packet.d.guild_id);
      if (settings)
        settings.patch(packet.d);
      else
        client.user.guildSettings.set(packet.d.guild_id, new ClientUserGuildSettings(packet.d, client));
      client.emit(Constants2.Events.USER_GUILD_SETTINGS_UPDATE, client.user.guildSettings.get(packet.d.guild_id));
    }
  };
  module2.exports = UserGuildSettingsUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var VoiceStateUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        const member = guild.members.get(data.user_id);
        if (member) {
          const oldVoiceChannelMember = Util2.cloneObject(member);
          if (member.voiceChannel && member.voiceChannel.id !== data.channel_id) {
            member.voiceChannel.members.delete(oldVoiceChannelMember.id);
          }
          if (!data.channel_id)
            member.speaking = null;
          if (member.user.id === client.user.id && data.channel_id) {
            client.emit("self.voiceStateUpdate", data);
          }
          const newChannel = client.channels.get(data.channel_id);
          if (newChannel) {
            newChannel.members.set(member.id, member);
            member.guild.channels.set(data.channel_id, newChannel);
          }
          member.serverMute = data.mute;
          member.serverDeaf = data.deaf;
          member.selfMute = data.self_mute;
          member.selfDeaf = data.self_deaf;
          member.voiceSessionID = data.session_id;
          member.voiceChannelID = data.channel_id;
          client.emit(Constants2.Events.VOICE_STATE_UPDATE, oldVoiceChannelMember, member);
        }
      }
    }
  };
  module2.exports = VoiceStateUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/TypingStart.js
var require_TypingStart = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var TypingStartHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const channel = client.channels.get(data.channel_id);
      const user = client.users.get(data.user_id);
      const timestamp = new Date(data.timestamp * 1e3);
      if (channel && user) {
        if (channel.type === "voice") {
          client.emit(Constants2.Events.WARN, `Discord sent a typing packet to voice channel ${channel.id}`);
          return;
        }
        if (channel._typing.has(user.id)) {
          const typing = channel._typing.get(user.id);
          typing.lastTimestamp = timestamp;
          typing.resetTimeout(tooLate(channel, user));
        } else {
          channel._typing.set(user.id, new TypingData(client, timestamp, timestamp, tooLate(channel, user)));
          client.emit(Constants2.Events.TYPING_START, channel, user);
        }
      }
    }
  };
  var TypingData = class {
    constructor(client, since, lastTimestamp, _timeout) {
      this.client = client;
      this.since = since;
      this.lastTimestamp = lastTimestamp;
      this._timeout = _timeout;
    }
    resetTimeout(_timeout) {
      this.client.clearTimeout(this._timeout);
      this._timeout = _timeout;
    }
    get elapsedTime() {
      return Date.now() - this.since;
    }
  };
  function tooLate(channel, user) {
    return channel.client.setTimeout(() => {
      channel.client.emit(Constants2.Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
      channel._typing.delete(user.id);
    }, 6e3);
  }
  module2.exports = TypingStartHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageCreate.js
var require_MessageCreate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var MessageCreateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const response = client.actions.MessageCreate.handle(data);
      if (response.message)
        client.emit(Constants2.Events.MESSAGE_CREATE, response.message);
    }
  };
  module2.exports = MessageCreateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageDelete.js
var require_MessageDelete = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var Constants2 = require_Constants();
  var MessageDeleteHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const response = client.actions.MessageDelete.handle(data);
      if (response.message)
        client.emit(Constants2.Events.MESSAGE_DELETE, response.message);
    }
  };
  module2.exports = MessageDeleteHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var MessageUpdateHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.MessageUpdate.handle(data);
    }
  };
  module2.exports = MessageUpdateHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var MessageDeleteBulkHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.MessageDeleteBulk.handle(data);
    }
  };
  module2.exports = MessageDeleteBulkHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/VoiceServerUpdate.js
var require_VoiceServerUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var VoiceServerUpdate = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.emit("self.voiceServer", data);
    }
  };
  module2.exports = VoiceServerUpdate;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/GuildSync.js
var require_GuildSync = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var GuildSyncHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.GuildSync.handle(data);
    }
  };
  module2.exports = GuildSyncHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/RelationshipAdd.js
var require_RelationshipAdd = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var RelationshipAddHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      if (data.type === 1) {
        client.fetchUser(data.id).then((user) => {
          client.user.friends.set(user.id, user);
        });
      } else if (data.type === 2) {
        client.fetchUser(data.id).then((user) => {
          client.user.blocked.set(user.id, user);
        });
      }
    }
  };
  module2.exports = RelationshipAddHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/RelationshipRemove.js
var require_RelationshipRemove = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var RelationshipRemoveHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      if (data.type === 2) {
        if (client.user.blocked.has(data.id)) {
          client.user.blocked.delete(data.id);
        }
      } else if (data.type === 1) {
        if (client.user.friends.has(data.id)) {
          client.user.friends.delete(data.id);
        }
      }
    }
  };
  module2.exports = RelationshipRemoveHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var MessageReactionAddHandler = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.MessageReactionAdd.handle(data);
    }
  };
  module2.exports = MessageReactionAddHandler;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var MessageReactionRemove = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.MessageReactionRemove.handle(data);
    }
  };
  module2.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var MessageReactionRemoveAll = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      client.actions.MessageReactionRemoveAll.handle(data);
    }
  };
  module2.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/websocket/packets/handlers/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports2, module2) => {
  var AbstractHandler = require_AbstractHandler();
  var {Events} = require_Constants();
  var WebhooksUpdate = class extends AbstractHandler {
    handle(packet) {
      const client = this.packetManager.client;
      const data = packet.d;
      const channel = client.channels.get(data.channel_id);
      if (channel)
        client.emit(Events.WEBHOOKS_UPDATE, channel);
    }
  };
  module2.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/websocket/packets/WebSocketPacketManager.js
var require_WebSocketPacketManager = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var BeforeReadyWhitelist = [
    Constants2.WSEvents.READY,
    Constants2.WSEvents.RESUMED,
    Constants2.WSEvents.GUILD_CREATE,
    Constants2.WSEvents.GUILD_DELETE,
    Constants2.WSEvents.GUILD_MEMBERS_CHUNK,
    Constants2.WSEvents.GUILD_MEMBER_ADD,
    Constants2.WSEvents.GUILD_MEMBER_REMOVE
  ];
  var WebSocketPacketManager = class {
    constructor(connection) {
      this.ws = connection;
      this.handlers = {};
      this.queue = [];
      this.register(Constants2.WSEvents.READY, require_Ready());
      this.register(Constants2.WSEvents.RESUMED, require_Resumed());
      this.register(Constants2.WSEvents.GUILD_CREATE, require_GuildCreate());
      this.register(Constants2.WSEvents.GUILD_DELETE, require_GuildDelete());
      this.register(Constants2.WSEvents.GUILD_UPDATE, require_GuildUpdate());
      this.register(Constants2.WSEvents.GUILD_BAN_ADD, require_GuildBanAdd());
      this.register(Constants2.WSEvents.GUILD_BAN_REMOVE, require_GuildBanRemove());
      this.register(Constants2.WSEvents.GUILD_MEMBER_ADD, require_GuildMemberAdd());
      this.register(Constants2.WSEvents.GUILD_MEMBER_REMOVE, require_GuildMemberRemove());
      this.register(Constants2.WSEvents.GUILD_MEMBER_UPDATE, require_GuildMemberUpdate());
      this.register(Constants2.WSEvents.GUILD_ROLE_CREATE, require_GuildRoleCreate());
      this.register(Constants2.WSEvents.GUILD_ROLE_DELETE, require_GuildRoleDelete());
      this.register(Constants2.WSEvents.GUILD_ROLE_UPDATE, require_GuildRoleUpdate());
      this.register(Constants2.WSEvents.GUILD_EMOJIS_UPDATE, require_GuildEmojisUpdate());
      this.register(Constants2.WSEvents.GUILD_MEMBERS_CHUNK, require_GuildMembersChunk());
      this.register(Constants2.WSEvents.GUILD_INTEGRATIONS_UPDATE, require_GuildIntegrationsUpdate());
      this.register(Constants2.WSEvents.CHANNEL_CREATE, require_ChannelCreate());
      this.register(Constants2.WSEvents.CHANNEL_DELETE, require_ChannelDelete());
      this.register(Constants2.WSEvents.CHANNEL_UPDATE, require_ChannelUpdate());
      this.register(Constants2.WSEvents.CHANNEL_PINS_UPDATE, require_ChannelPinsUpdate());
      this.register(Constants2.WSEvents.PRESENCE_UPDATE, require_PresenceUpdate());
      this.register(Constants2.WSEvents.USER_UPDATE, require_UserUpdate());
      this.register(Constants2.WSEvents.USER_NOTE_UPDATE, require_UserNoteUpdate());
      this.register(Constants2.WSEvents.USER_SETTINGS_UPDATE, require_UserSettingsUpdate());
      this.register(Constants2.WSEvents.USER_GUILD_SETTINGS_UPDATE, require_UserGuildSettingsUpdate());
      this.register(Constants2.WSEvents.VOICE_STATE_UPDATE, require_VoiceStateUpdate());
      this.register(Constants2.WSEvents.TYPING_START, require_TypingStart());
      this.register(Constants2.WSEvents.MESSAGE_CREATE, require_MessageCreate());
      this.register(Constants2.WSEvents.MESSAGE_DELETE, require_MessageDelete());
      this.register(Constants2.WSEvents.MESSAGE_UPDATE, require_MessageUpdate());
      this.register(Constants2.WSEvents.MESSAGE_DELETE_BULK, require_MessageDeleteBulk());
      this.register(Constants2.WSEvents.VOICE_SERVER_UPDATE, require_VoiceServerUpdate());
      this.register(Constants2.WSEvents.GUILD_SYNC, require_GuildSync());
      this.register(Constants2.WSEvents.RELATIONSHIP_ADD, require_RelationshipAdd());
      this.register(Constants2.WSEvents.RELATIONSHIP_REMOVE, require_RelationshipRemove());
      this.register(Constants2.WSEvents.MESSAGE_REACTION_ADD, require_MessageReactionAdd());
      this.register(Constants2.WSEvents.MESSAGE_REACTION_REMOVE, require_MessageReactionRemove());
      this.register(Constants2.WSEvents.MESSAGE_REACTION_REMOVE_ALL, require_MessageReactionRemoveAll());
      this.register(Constants2.WSEvents.WEBHOOKS_UPDATE, require_WebhooksUpdate());
    }
    get client() {
      return this.ws.client;
    }
    register(event, Handler) {
      this.handlers[event] = new Handler(this);
    }
    handleQueue() {
      this.queue.forEach((element, index) => {
        this.handle(this.queue[index], true);
        this.queue.splice(index, 1);
      });
    }
    handle(packet, queue = false) {
      if (packet.op === Constants2.OPCodes.HEARTBEAT_ACK) {
        this.ws.client._pong(this.ws.client._pingTimestamp);
        this.ws.lastHeartbeatAck = true;
        this.ws.client.emit("debug", "Heartbeat acknowledged");
      } else if (packet.op === Constants2.OPCodes.HEARTBEAT) {
        this.client.ws.send({
          op: Constants2.OPCodes.HEARTBEAT,
          d: this.client.ws.sequence
        });
        this.ws.client.emit("debug", "Received gateway heartbeat");
      }
      if (this.ws.status === Constants2.Status.RECONNECTING) {
        this.ws.reconnecting = false;
        this.ws.checkIfReady();
      }
      this.ws.setSequence(packet.s);
      if (this.ws.disabledEvents[packet.t] !== void 0)
        return false;
      if (this.ws.status !== Constants2.Status.READY) {
        if (BeforeReadyWhitelist.indexOf(packet.t) === -1) {
          this.queue.push(packet);
          return false;
        }
      }
      if (!queue && this.queue.length > 0)
        this.handleQueue();
      if (this.handlers[packet.t])
        return this.handlers[packet.t].handle(packet);
      return false;
    }
  };
  module2.exports = WebSocketPacketManager;
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports2, module2) => {
  var sep = require("path").sep || "/";
  module2.exports = fileUriToPath;
  function fileUriToPath(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  function bindings(opts) {
    if (typeof opts == "string") {
      opts = {bindings: opts};
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports2.getRoot(exports2.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (; i < l; i++) {
      n = join.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
      return opts.arrow + a;
    }).join("\n"));
    err.tries = tries;
    throw err;
  }
  module2.exports = exports2 = bindings;
  exports2.getFileName = function getFileName(calling_file) {
    var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length; i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports2.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join(dir, "..");
    }
  };
});

// node_modules/erlpack/js/index.js
var require_js = __commonJS((exports2, module2) => {
  module2.exports = require_bindings()("erlpack");
});

// node_modules/async-limiter/index.js
var require_async_limiter = __commonJS((exports2, module2) => {
  "use strict";
  function Queue(options) {
    if (!(this instanceof Queue)) {
      return new Queue(options);
    }
    options = options || {};
    this.concurrency = options.concurrency || Infinity;
    this.pending = 0;
    this.jobs = [];
    this.cbs = [];
    this._done = done.bind(this);
  }
  var arrayAddMethods = [
    "push",
    "unshift",
    "splice"
  ];
  arrayAddMethods.forEach(function(method) {
    Queue.prototype[method] = function() {
      var methodResult = Array.prototype[method].apply(this.jobs, arguments);
      this._run();
      return methodResult;
    };
  });
  Object.defineProperty(Queue.prototype, "length", {
    get: function() {
      return this.pending + this.jobs.length;
    }
  });
  Queue.prototype._run = function() {
    if (this.pending === this.concurrency) {
      return;
    }
    if (this.jobs.length) {
      var job = this.jobs.shift();
      this.pending++;
      job(this._done);
      this._run();
    }
    if (this.pending === 0) {
      while (this.cbs.length !== 0) {
        var cb = this.cbs.pop();
        process.nextTick(cb);
      }
    }
  };
  Queue.prototype.onDone = function(cb) {
    if (typeof cb === "function") {
      this.cbs.push(cb);
      this._run();
    }
  };
  function done() {
    this.pending--;
    this._run();
  }
  module2.exports = Queue;
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    EMPTY_BUFFER: Buffer.alloc(0),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports2, module2) => {
  "use strict";
  var {EMPTY_BUFFER} = require_constants();
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    var offset = 0;
    for (var i = 0; i < list.length; i++) {
      const buf = list[i];
      buf.copy(target, offset);
      offset += buf.length;
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (var i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    const length = buffer.length;
    for (var i = 0; i < length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    var buf;
    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = viewToBuffer(data);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  function viewToBuffer(view) {
    const buf = Buffer.from(view.buffer);
    if (view.byteLength !== view.buffer.byteLength) {
      return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
    }
    return buf;
  }
  try {
    const bufferUtil = require("bufferutil");
    const bu = bufferUtil.BufferUtil || bufferUtil;
    module2.exports = {
      concat,
      mask(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bu.mask(source, mask, output, offset, length);
      },
      toArrayBuffer,
      toBuffer,
      unmask(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bu.unmask(buffer, mask);
      }
    };
  } catch (e) {
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports2, module2) => {
  "use strict";
  var Limiter = require_async_limiter();
  var zlib = require("zlib");
  var bufferUtil = require_buffer_util();
  var {kStatusCode, NOOP} = require_constants();
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var EMPTY_BLOCK = Buffer.from([0]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;
  var PerMessageDeflate = class {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter({concurrency});
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        this._deflate.close();
        this._deflate = null;
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          var value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.push((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.push((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw(Object.assign({}, this._options.zlibInflateOptions, {windowBits}));
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      if (!data || data.length === 0) {
        process.nextTick(callback, null, EMPTY_BLOCK);
        return;
      }
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw(Object.assign({}, this._options.zlibDeflateOptions, {windowBits}));
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("error", NOOP);
        this._deflate.on("data", deflateOnData);
      }
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        var data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin)
          data2 = data2.slice(0, data2.length - 4);
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.close();
          this._deflate = null;
        } else {
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
        }
        callback(null, data2);
      });
    }
  };
  module2.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports2, module2) => {
  "use strict";
  var Event = class {
    constructor(type, target) {
      this.target = target;
      this.type = type;
    }
  };
  var MessageEvent = class extends Event {
    constructor(data, target) {
      super("message", target);
      this.data = data;
    }
  };
  var CloseEvent = class extends Event {
    constructor(code, reason, target) {
      super("close", target);
      this.wasClean = target._closeFrameReceived && target._closeFrameSent;
      this.reason = reason;
      this.code = code;
    }
  };
  var OpenEvent = class extends Event {
    constructor(target) {
      super("open", target);
    }
  };
  var ErrorEvent = class extends Event {
    constructor(error, target) {
      super("error", target);
      this.message = error.message;
      this.error = error;
    }
  };
  var EventTarget = {
    addEventListener(method, listener) {
      if (typeof listener !== "function")
        return;
      function onMessage(data) {
        listener.call(this, new MessageEvent(data, this));
      }
      function onClose(code, message) {
        listener.call(this, new CloseEvent(code, message, this));
      }
      function onError(error) {
        listener.call(this, new ErrorEvent(error, this));
      }
      function onOpen() {
        listener.call(this, new OpenEvent(this));
      }
      if (method === "message") {
        onMessage._listener = listener;
        this.on(method, onMessage);
      } else if (method === "close") {
        onClose._listener = listener;
        this.on(method, onClose);
      } else if (method === "error") {
        onError._listener = listener;
        this.on(method, onError);
      } else if (method === "open") {
        onOpen._listener = listener;
        this.on(method, onOpen);
      } else {
        this.on(method, listener);
      }
    },
    removeEventListener(method, listener) {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener || listeners[i]._listener === listener) {
          this.removeListener(method, listeners[i]);
        }
      }
    }
  };
  module2.exports = EventTarget;
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports2, module2) => {
  "use strict";
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function push(dest, name, elem) {
    if (Object.prototype.hasOwnProperty.call(dest, name))
      dest[name].push(elem);
    else
      dest[name] = [elem];
  }
  function parse(header) {
    const offers = {};
    if (header === void 0 || header === "")
      return offers;
    var params = {};
    var mustUnescape = false;
    var isEscaping = false;
    var inQuotes = false;
    var extensionName;
    var paramName;
    var start = -1;
    var end = -1;
    for (var i = 0; i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (extensionName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = {};
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = {};
            extensionName = void 0;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          var value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = {};
            extensionName = void 0;
          }
          paramName = void 0;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === void 0) {
      push(offers, token, {});
    } else {
      if (paramName === void 0) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          var values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module2.exports = {format, parse};
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports2) => {
  "use strict";
  try {
    const isValidUTF8 = require("utf-8-validate");
    exports2.isValidUTF8 = typeof isValidUTF8 === "object" ? isValidUTF8.Validation.isValidUTF8 : isValidUTF8;
  } catch (e) {
    exports2.isValidUTF8 = () => true;
  }
  exports2.isValidStatusCode = (code) => {
    return code >= 1e3 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
  };
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports2, module2) => {
  "use strict";
  var {Writable} = require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var {concat, toArrayBuffer, unmask} = require_buffer_util();
  var {isValidStatusCode, isValidUTF8} = require_validation();
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var Receiver = class extends Writable {
    constructor(binaryType, extensions, maxPayload) {
      super();
      this._binaryType = binaryType || BINARY_TYPES[0];
      this[kWebSocket] = void 0;
      this._extensions = extensions || {};
      this._maxPayload = maxPayload | 0;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = void 0;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        if (n >= buf.length) {
          this._buffers.shift().copy(dst, dst.length - n);
        } else {
          buf.copy(dst, dst.length - n, 0, n);
          this._buffers[0] = buf.slice(n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      var err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          default:
            this._loop = false;
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002);
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002);
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002);
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        if (this._payloadLength > 125) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002);
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009);
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009);
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      var data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked)
          unmask(data, this._mask);
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          var data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data);
        } else {
          const buf = concat(fragments, messageLength);
          if (!isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007);
          }
          this.emit("message", buf.toString());
        }
      }
      this._state = GET_INFO;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, "");
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, "invalid payload length 1", true, 1002);
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002);
          }
          const buf = data.slice(2);
          if (!isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007);
          }
          this.emit("conclude", code, buf.toString());
          this.end();
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
      } else {
        this.emit("pong", data);
      }
      this._state = GET_INFO;
    }
  };
  module2.exports = Receiver;
  function error(ErrorCtor, message, prefix, statusCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err[kStatusCode] = statusCode;
    return err;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports2, module2) => {
  "use strict";
  var {randomBytes} = require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var {EMPTY_BUFFER} = require_constants();
  var {isValidStatusCode} = require_validation();
  var {mask: applyMask, toBuffer} = require_buffer_util();
  var Sender = class {
    constructor(socket, extensions) {
      this._extensions = extensions || {};
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      const merge = options.mask && options.readOnly;
      var offset = options.mask ? 6 : 2;
      var payloadLength = data.length;
      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }
      if (!options.mask)
        return [target, data];
      const mask = randomBytes(4);
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (merge) {
        applyMask(data, mask, target, offset, data.length);
        return [target];
      }
      applyMask(data, mask, data, 0, data.length);
      return [target, data];
    }
    close(code, data, mask, cb) {
      var buf;
      if (code === void 0) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === void 0 || data === "") {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
        buf.writeUInt16BE(code, 0);
        buf.write(data, 2);
      }
      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask, cb]);
      } else {
        this.doClose(buf, mask, cb);
      }
    }
    doClose(data, mask, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 8,
        mask,
        readOnly: false
      }), cb);
    }
    ping(data, mask, cb) {
      const buf = toBuffer(data);
      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPing(buf, mask, toBuffer.readOnly, cb);
      }
    }
    doPing(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 9,
        mask,
        readOnly
      }), cb);
    }
    pong(data, mask, cb) {
      const buf = toBuffer(data);
      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPong(buf, mask, toBuffer.readOnly, cb);
      }
    }
    doPong(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 10,
        mask,
        readOnly
      }), cb);
    }
    send(data, options, cb) {
      const buf = toBuffer(data);
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      var opcode = options.binary ? 2 : 1;
      var rsv1 = options.compress;
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          fin: options.fin,
          rsv1,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[1].length;
        params[0].apply(this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[1].length;
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  };
  module2.exports = Sender;
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events");
  var crypto = require("crypto");
  var https = require("https");
  var http = require("http");
  var net = require("net");
  var tls = require("tls");
  var url = require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var EventTarget = require_event_target();
  var extension = require_extension();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var protocolVersions = [8, 13];
  var closeTimeout = 30 * 1e3;
  var WebSocket = class extends EventEmitter2 {
    constructor(address, protocols, options) {
      super();
      this.readyState = WebSocket.CONNECTING;
      this.protocol = "";
      this._binaryType = BINARY_TYPES[0];
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = "";
      this._closeTimer = null;
      this._closeCode = 1006;
      this._extensions = {};
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._isServer = false;
        this._redirects = 0;
        if (Array.isArray(protocols)) {
          protocols = protocols.join(", ");
        } else if (typeof protocols === "object" && protocols !== null) {
          options = protocols;
          protocols = void 0;
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._isServer = true;
      }
    }
    get CONNECTING() {
      return WebSocket.CONNECTING;
    }
    get CLOSING() {
      return WebSocket.CLOSING;
    }
    get CLOSED() {
      return WebSocket.CLOSED;
    }
    get OPEN() {
      return WebSocket.OPEN;
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return 0;
      return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    setSocket(socket, head, maxPayload) {
      const receiver = new Receiver(this._binaryType, this._extensions, maxPayload);
      this._sender = new Sender(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this.readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      this.readyState = WebSocket.CLOSED;
      if (!this._socket) {
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && this._closeFrameReceived)
          this._socket.end();
        return;
      }
      this.readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived)
          this._socket.end();
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    ping(data, mask, cb) {
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (this.readyState !== WebSocket.OPEN) {
        const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
        if (cb)
          return cb(err);
        throw err;
      }
      if (typeof data === "number")
        data = data.toString();
      if (mask === void 0)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (this.readyState !== WebSocket.OPEN) {
        const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
        if (cb)
          return cb(err);
        throw err;
      }
      if (typeof data === "number")
        data = data.toString();
      if (mask === void 0)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    send(data, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (this.readyState !== WebSocket.OPEN) {
        const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
        if (cb)
          return cb(err);
        throw err;
      }
      if (typeof data === "number")
        data = data.toString();
      const opts = Object.assign({
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this._socket) {
        this.readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  };
  readyStates.forEach((readyState, i) => {
    WebSocket[readyState] = i;
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      get() {
        const listeners = this.listeners(method);
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener)
            return listeners[i]._listener;
        }
        return void 0;
      },
      set(listener) {
        const listeners = this.listeners(method);
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i]._listener)
            this.removeListener(method, listeners[i]);
        }
        this.addEventListener(method, listener);
      }
    });
  });
  WebSocket.prototype.addEventListener = EventTarget.addEventListener;
  WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
  module2.exports = WebSocket;
  function initAsClient(websocket, address, protocols, options) {
    const opts = Object.assign({
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10
    }, options, {
      createConnection: void 0,
      socketPath: void 0,
      hostname: void 0,
      protocol: void 0,
      timeout: void 0,
      method: void 0,
      auth: void 0,
      host: void 0,
      path: void 0,
      port: void 0
    });
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
    }
    var parsedUrl;
    if (typeof address === "object" && address.href !== void 0) {
      parsedUrl = address;
      websocket.url = address.href;
    } else {
      parsedUrl = url.URL ? new url.URL(address) : url.parse(address);
      websocket.url = address;
    }
    const isUnixSocket = parsedUrl.protocol === "ws+unix:";
    if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
      throw new Error(`Invalid URL: ${websocket.url}`);
    }
    const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
    const defaultPort = isSecure ? 443 : 80;
    const key = crypto.randomBytes(16).toString("base64");
    const get = isSecure ? https.get : http.get;
    const path = parsedUrl.search ? `${parsedUrl.pathname || "/"}${parsedUrl.search}` : parsedUrl.pathname || "/";
    var perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = Object.assign({
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    }, opts.headers);
    opts.path = path;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = extension.format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols) {
      opts.headers["Sec-WebSocket-Protocol"] = protocols;
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.auth) {
      opts.auth = parsedUrl.auth;
    } else if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isUnixSocket) {
      const parts = path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    var req = websocket._req = get(opts);
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (websocket._req.aborted)
        return;
      req = websocket._req = null;
      websocket.readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        const addr = url.URL ? new url.URL(location, address) : url.resolve(address, location);
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const digest = crypto.createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      const protList = (protocols || "").split(/, */);
      var protError;
      if (!protocols && serverProt) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (protocols && !serverProt) {
        protError = "Server sent no subprotocol";
      } else if (serverProt && !protList.includes(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket.protocol = serverProt;
      if (perMessageDeflate) {
        try {
          const extensions = extension.parse(res.headers["sec-websocket-extensions"]);
          if (extensions[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
          return;
        }
      }
      websocket.setSocket(socket, head, opts.maxPayload);
    });
  }
  function netConnect(options) {
    if (options.protocolVersion)
      options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = void 0;
    options.servername = options.servername || options.host;
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket.readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream.abort();
      stream.once("abort", websocket.emitClose.bind(websocket));
      websocket.emit("error", err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._socket.removeListener("data", socketOnData);
    websocket._socket.resume();
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    this[kWebSocket]._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    websocket._socket.removeListener("data", socketOnData);
    websocket.readyState = WebSocket.CLOSING;
    websocket._closeCode = err[kStatusCode];
    websocket.emit("error", err);
    websocket._socket.destroy();
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data) {
    this[kWebSocket].emit("message", data);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("end", socketOnEnd);
    websocket.readyState = WebSocket.CLOSING;
    websocket._socket.read();
    websocket._receiver.end();
    this.removeListener("data", socketOnData);
    this[kWebSocket] = void 0;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket.readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events");
  var crypto = require("crypto");
  var http = require("http");
  var PerMessageDeflate = require_permessage_deflate();
  var extension = require_extension();
  var WebSocket = require_websocket();
  var {GUID} = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var WebSocketServer = class extends EventEmitter2 {
    constructor(options, callback) {
      super();
      options = Object.assign({
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null
      }, options);
      if (options.port == null && !options.server && !options.noServer) {
        throw new TypeError('One of the "port", "server", or "noServer" options must be specified');
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, (ws) => {
              this.emit("connection", ws, req);
            });
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking)
        this.clients = new Set();
      this.options = options;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (cb)
        this.once("close", cb);
      if (this.clients) {
        for (const client of this.clients)
          client.terminate();
      }
      const server = this._server;
      if (server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
        if (this.options.port != null) {
          server.close(() => this.emit("close"));
          return;
        }
      }
      process.nextTick(emitClose, this);
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
      const version = +req.headers["sec-websocket-version"];
      const extensions = {};
      if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake(socket, 400);
      }
      if (this.options.perMessageDeflate) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(req.headers["sec-websocket-extensions"]);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.connection.authorized || req.connection.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(key, extensions, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(key, extensions, req, socket, head, cb);
    }
    completeUpgrade(key, extensions, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      const digest = crypto.createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new WebSocket(null);
      var protocol = req.headers["sec-websocket-protocol"];
      if (protocol) {
        protocol = protocol.trim().split(/ *, */);
        if (this.options.handleProtocols) {
          protocol = this.options.handleProtocols(protocol, req);
        } else {
          protocol = protocol[0];
        }
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws.protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, this.options.maxPayload);
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => this.clients.delete(ws));
      }
      cb(ws);
    }
  };
  module2.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    if (socket.writable) {
      message = message || http.STATUS_CODES[code];
      headers = Object.assign({
        Connection: "close",
        "Content-type": "text/html",
        "Content-Length": Buffer.byteLength(message)
      }, headers);
      socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    socket.removeListener("error", socketOnError);
    socket.destroy();
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports2, module2) => {
  "use strict";
  var WebSocket = require_websocket();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver();
  WebSocket.Sender = require_sender();
  module2.exports = WebSocket;
});

// node_modules/discord.js/src/client/websocket/WebSocketConnection.js
var require_WebSocketConnection = __commonJS((exports2, module2) => {
  var browser = typeof window !== "undefined";
  var EventEmitter2 = require("events");
  var Constants2 = require_Constants();
  var zlib = require("zlib");
  var PacketManager = require_WebSocketPacketManager();
  var erlpack = function findErlpack() {
    try {
      const e = require_js();
      if (!e.pack)
        return null;
      return e;
    } catch (e) {
      return null;
    }
  }();
  var WebSocket = function findWebSocket() {
    if (browser)
      return window.WebSocket;
    try {
      return require("@discordjs/uws");
    } catch (e) {
      return require_ws();
    }
  }();
  var WebSocketConnection = class extends EventEmitter2 {
    constructor(manager, gateway) {
      super();
      this.manager = manager;
      this.client = manager.client;
      this.ws = null;
      this.sequence = -1;
      this.status = Constants2.Status.IDLE;
      this.packetManager = new PacketManager(this);
      this.lastPingTimestamp = 0;
      this.ratelimit = {
        queue: [],
        remaining: 120,
        total: 120,
        time: 6e4,
        resetTimer: null
      };
      this.connect(gateway);
      this.disabledEvents = {};
      this.closeSequence = 0;
      this.expectingClose = false;
      for (const event of this.client.options.disabledEvents)
        this.disabledEvents[event] = true;
    }
    triggerReady() {
      if (this.status === Constants2.Status.READY) {
        this.debug("Tried to mark self as ready, but already ready");
        return;
      }
      this.status = Constants2.Status.READY;
      this.client.emit(Constants2.Events.READY);
      this.packetManager.handleQueue();
    }
    checkIfReady() {
      if (this.status === Constants2.Status.READY || this.status === Constants2.Status.NEARLY)
        return false;
      let unavailableGuilds = 0;
      for (const guild of this.client.guilds.values()) {
        if (!guild.available)
          unavailableGuilds++;
      }
      if (unavailableGuilds === 0) {
        this.status = Constants2.Status.NEARLY;
        if (!this.client.options.fetchAllMembers)
          return this.triggerReady();
        const promises = this.client.guilds.map((g) => g.fetchMembers());
        Promise.all(promises).then(() => this.triggerReady()).catch((e) => {
          this.debug(`Failed to fetch all members before ready! ${e}`);
          this.triggerReady();
        });
      }
      return true;
    }
    debug(message) {
      if (message instanceof Error)
        message = message.stack;
      return this.manager.debug(`[connection] ${message}`);
    }
    unpack(data) {
      if (data instanceof ArrayBuffer)
        data = Buffer.from(new Uint8Array(data));
      if (erlpack && typeof data !== "string")
        return erlpack.unpack(data);
      else if (data instanceof Buffer)
        data = zlib.inflateSync(data).toString();
      return JSON.parse(data);
    }
    pack(data) {
      return erlpack ? erlpack.pack(data) : JSON.stringify(data);
    }
    processQueue() {
      if (this.ratelimit.remaining === 0)
        return;
      if (this.ratelimit.queue.length === 0)
        return;
      if (this.ratelimit.remaining === this.ratelimit.total) {
        this.ratelimit.resetTimer = this.client.setTimeout(() => {
          this.ratelimit.remaining = this.ratelimit.total;
          this.processQueue();
        }, this.ratelimit.time);
      }
      while (this.ratelimit.remaining > 0) {
        const item = this.ratelimit.queue.shift();
        if (!item)
          return;
        this._send(item);
        this.ratelimit.remaining--;
      }
    }
    _send(data) {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        this.debug(`Tried to send packet ${JSON.stringify(data)} but no WebSocket is available!`);
        return;
      }
      this.ws.send(this.pack(data));
    }
    send(data) {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        this.debug(`Tried to send packet ${JSON.stringify(data)} but no WebSocket is available!`);
        return;
      }
      this.ratelimit.queue.push(data);
      this.processQueue();
    }
    connect(gateway = this.gateway, after = 0, force = false) {
      if (after)
        return this.client.setTimeout(() => this.connect(gateway, 0, force), after);
      if (this.ws && !force) {
        this.debug("WebSocket connection already exists");
        return false;
      } else if (typeof gateway !== "string") {
        this.debug(`Tried to connect to an invalid gateway: ${gateway}`);
        return false;
      }
      this.expectingClose = false;
      this.gateway = gateway;
      this.debug(`Connecting to ${gateway}`);
      const ws = this.ws = new WebSocket(gateway);
      if (browser)
        ws.binaryType = "arraybuffer";
      ws.onmessage = this.onMessage.bind(this);
      ws.onopen = this.onOpen.bind(this);
      ws.onerror = this.onError.bind(this);
      ws.onclose = this.onClose.bind(this);
      this.status = Constants2.Status.CONNECTING;
      return true;
    }
    destroy() {
      const ws = this.ws;
      if (!ws) {
        this.debug("Attempted to destroy WebSocket but no connection exists!");
        return false;
      }
      this.heartbeat(-1);
      this.expectingClose = true;
      ws.close(1e3);
      this.packetManager.handleQueue();
      this.ws = null;
      this.status = Constants2.Status.DISCONNECTED;
      this.ratelimit.remaining = this.ratelimit.total;
      return true;
    }
    onMessage(event) {
      let data;
      try {
        data = this.unpack(event.data);
      } catch (err) {
        this.emit("debug", err);
      }
      return this.onPacket(data);
    }
    setSequence(s) {
      this.sequence = s > this.sequence ? s : this.sequence;
    }
    onPacket(packet) {
      if (!packet) {
        this.debug("Received null packet");
        return false;
      }
      this.client.emit("raw", packet);
      switch (packet.op) {
        case Constants2.OPCodes.HELLO:
          return this.heartbeat(packet.d.heartbeat_interval);
        case Constants2.OPCodes.RECONNECT:
          return this.reconnect();
        case Constants2.OPCodes.INVALID_SESSION:
          if (!packet.d)
            this.sessionID = null;
          this.sequence = -1;
          this.debug("Session invalidated -- will identify with a new session");
          return this.identify(packet.d ? 2500 : 0);
        case Constants2.OPCodes.HEARTBEAT_ACK:
          return this.ackHeartbeat();
        case Constants2.OPCodes.HEARTBEAT:
          return this.heartbeat();
        default:
          return this.packetManager.handle(packet);
      }
    }
    onOpen(event) {
      if (event && event.target && event.target.url)
        this.gateway = event.target.url;
      this.debug(`Connected to gateway ${this.gateway}`);
      this.identify();
    }
    reconnect() {
      this.debug("Attemping to reconnect in 5500ms...");
      this.client.emit(Constants2.Events.RECONNECTING);
      this.connect(this.gateway, 5500, true);
    }
    onError(error) {
      if (error && error.message === "uWs client connection error") {
        this.reconnect();
        return;
      }
      this.client.emit(Constants2.Events.ERROR, error);
    }
    onClose(event) {
      this.debug(`${this.expectingClose ? "Client" : "Server"} closed the WebSocket connection: ${event.code}`);
      this.closeSequence = this.sequence;
      this.emit("close", event);
      this.heartbeat(-1);
      if (event.code === 1e3 ? this.expectingClose : Constants2.WSCodes[event.code]) {
        this.expectingClose = false;
        this.client.emit(Constants2.Events.DISCONNECT, event);
        this.debug(Constants2.WSCodes[event.code]);
        this.destroy();
        return;
      }
      this.expectingClose = false;
      this.reconnect();
    }
    ackHeartbeat() {
      this.debug(`Heartbeat acknowledged, latency of ${Date.now() - this.lastPingTimestamp}ms`);
      this.client._pong(this.lastPingTimestamp);
    }
    heartbeat(time) {
      if (!isNaN(time)) {
        if (time === -1) {
          this.debug("Clearing heartbeat interval");
          this.client.clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        } else {
          this.debug(`Setting a heartbeat interval for ${time}ms`);
          this.heartbeatInterval = this.client.setInterval(() => this.heartbeat(), time);
        }
        return;
      }
      this.debug("Sending a heartbeat");
      this.lastPingTimestamp = Date.now();
      this.send({
        op: Constants2.OPCodes.HEARTBEAT,
        d: this.sequence
      });
    }
    identify(after) {
      if (after)
        return this.client.setTimeout(this.identify.bind(this), after);
      return this.sessionID ? this.identifyResume() : this.identifyNew();
    }
    identifyNew() {
      if (!this.client.token) {
        this.debug("No token available to identify a new session with");
        return;
      }
      const d = Object.assign({token: this.client.token}, this.client.options.ws);
      const {shardId, shardCount} = this.client.options;
      if (shardCount > 0)
        d.shard = [Number(shardId), Number(shardCount)];
      this.debug("Identifying as a new session");
      this.send({op: Constants2.OPCodes.IDENTIFY, d});
    }
    identifyResume() {
      if (!this.sessionID) {
        this.debug("Warning: wanted to resume but session ID not available; identifying as a new session instead");
        return this.identifyNew();
      }
      this.debug(`Attempting to resume session ${this.sessionID}`);
      const d = {
        token: this.client.token,
        session_id: this.sessionID,
        seq: this.sequence
      };
      return this.send({
        op: Constants2.OPCodes.RESUME,
        d
      });
    }
  };
  WebSocketConnection.ENCODING = erlpack ? "etf" : "json";
  WebSocketConnection.WebSocket = WebSocket;
  module2.exports = WebSocketConnection;
});

// node_modules/discord.js/src/client/ClientManager.js
var require_ClientManager = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var WebSocketConnection = require_WebSocketConnection();
  var ClientManager2 = class {
    constructor(client) {
      this.client = client;
      this.heartbeatInterval = null;
    }
    get status() {
      return this.connection ? this.connection.status : Constants2.Status.IDLE;
    }
    connectToWebSocket(token, resolve, reject) {
      this.client.emit(Constants2.Events.DEBUG, `Authenticated using token ${token}`);
      this.client.token = token;
      const timeout = this.client.setTimeout(() => reject(new Error(Constants2.Errors.TOOK_TOO_LONG)), 1e3 * 300);
      this.client.rest.methods.getGateway().then((res) => {
        const protocolVersion = Constants2.DefaultOptions.ws.version;
        const gateway = `${res.url}/?v=${protocolVersion}&encoding=${WebSocketConnection.ENCODING}`;
        this.client.emit(Constants2.Events.DEBUG, `Using gateway ${gateway}`);
        this.client.ws.connect(gateway);
        this.client.ws.connection.once("error", reject);
        this.client.ws.connection.once("close", (event) => {
          if (event.code === 4004)
            reject(new Error(Constants2.Errors.BAD_LOGIN));
          if (event.code === 4010)
            reject(new Error(Constants2.Errors.INVALID_SHARD));
          if (event.code === 4011)
            reject(new Error(Constants2.Errors.SHARDING_REQUIRED));
        });
        this.client.once(Constants2.Events.READY, () => {
          resolve(token);
          this.client.clearTimeout(timeout);
        });
      }, reject);
    }
    destroy() {
      this.client.ws.destroy();
      this.client.rest.destroy();
      if (!this.client.user)
        return Promise.resolve();
      if (this.client.user.bot) {
        this.client.token = null;
        return Promise.resolve();
      } else {
        return this.client.rest.methods.logout().then(() => {
          this.client.token = null;
        });
      }
    }
  };
  module2.exports = ClientManager2;
});

// node_modules/discord.js/src/client/voice/util/SecretKey.js
var require_SecretKey = __commonJS((exports2, module2) => {
  var SecretKey = class {
    constructor(key) {
      this.key = new Uint8Array(new ArrayBuffer(key.length));
      for (const index in key)
        this.key[index] = key[index];
    }
  };
  module2.exports = SecretKey;
});

// node_modules/discord.js/src/client/voice/VoiceWebSocket.js
var require_VoiceWebSocket = __commonJS((exports2, module2) => {
  var Constants2 = require_Constants();
  var SecretKey = require_SecretKey();
  var EventEmitter2 = require("events").EventEmitter;
  var WebSocket;
  try {
    WebSocket = require("@discordjs/uws");
  } catch (err) {
    WebSocket = require_ws();
  }
  var VoiceWebSocket = class extends EventEmitter2 {
    constructor(voiceConnection) {
      super();
      this.client = voiceConnection.voiceManager.client;
      this.voiceConnection = voiceConnection;
      this.attempts = 0;
      this.connect();
      this.dead = false;
      this.voiceConnection.on("closing", this.shutdown.bind(this));
    }
    shutdown() {
      this.dead = true;
      this.reset();
    }
    reset() {
      if (this.ws) {
        if (this.ws.readyState !== WebSocket.CLOSED)
          this.ws.close();
        this.ws = null;
      }
      this.clearHeartbeat();
    }
    connect() {
      if (this.dead)
        return;
      if (this.ws)
        this.reset();
      if (this.attempts >= 5) {
        this.emit("debug", new Error(`Too many connection attempts (${this.attempts}).`));
        return;
      }
      this.attempts++;
      this.ws = new WebSocket(`wss://${this.voiceConnection.authentication.endpoint}`);
      this.ws.onopen = this.onOpen.bind(this);
      this.ws.onmessage = this.onMessage.bind(this);
      this.ws.onclose = this.onClose.bind(this);
      this.ws.onerror = this.onError.bind(this);
    }
    send(data) {
      return new Promise((resolve, reject) => {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          throw new Error(`Voice websocket not open to send ${data}.`);
        }
        this.ws.send(data, null, (error) => {
          if (error)
            reject(error);
          else
            resolve(data);
        });
      });
    }
    sendPacket(packet) {
      try {
        packet = JSON.stringify(packet);
      } catch (error) {
        return Promise.reject(error);
      }
      return this.send(packet);
    }
    onOpen() {
      this.sendPacket({
        op: Constants2.OPCodes.DISPATCH,
        d: {
          server_id: this.voiceConnection.channel.guild.id,
          user_id: this.client.user.id,
          token: this.voiceConnection.authentication.token,
          session_id: this.voiceConnection.authentication.sessionID
        }
      }).catch(() => {
        this.emit("error", new Error("Tried to send join packet, but the WebSocket is not open."));
      });
    }
    onMessage(event) {
      try {
        return this.onPacket(JSON.parse(event.data));
      } catch (error) {
        return this.onError(error);
      }
    }
    onClose() {
      if (!this.dead)
        this.client.setTimeout(this.connect.bind(this), this.attempts * 1e3);
    }
    onError(error) {
      this.emit("error", error);
    }
    onPacket(packet) {
      switch (packet.op) {
        case Constants2.VoiceOPCodes.READY:
          this.setHeartbeat(packet.d.heartbeat_interval);
          this.emit("ready", packet.d);
          break;
        case Constants2.VoiceOPCodes.SESSION_DESCRIPTION:
          this.emit("sessionDescription", packet.d.mode, new SecretKey(packet.d.secret_key));
          break;
        case Constants2.VoiceOPCodes.SPEAKING:
          this.emit("speaking", packet.d);
          break;
        default:
          this.emit("unknownPacket", packet);
          break;
      }
    }
    setHeartbeat(interval) {
      if (!interval || isNaN(interval)) {
        this.onError(new Error("Tried to set voice heartbeat but no valid interval was specified."));
        return;
      }
      if (this.heartbeatInterval) {
        this.emit("warn", "A voice heartbeat interval is being overwritten");
        clearInterval(this.heartbeatInterval);
      }
      this.heartbeatInterval = this.client.setInterval(this.sendHeartbeat.bind(this), interval);
    }
    clearHeartbeat() {
      if (!this.heartbeatInterval) {
        this.emit("warn", "Tried to clear a heartbeat interval that does not exist");
        return;
      }
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    sendHeartbeat() {
      this.sendPacket({op: Constants2.VoiceOPCodes.HEARTBEAT, d: null}).catch(() => {
        this.emit("warn", "Tried to send heartbeat, but connection is not open");
        this.clearHeartbeat();
      });
    }
  };
  module2.exports = VoiceWebSocket;
});

// node_modules/discord.js/src/client/voice/VoiceUDPClient.js
var require_VoiceUDPClient = __commonJS((exports2, module2) => {
  var udp = require("dgram");
  var Constants2 = require_Constants();
  var EventEmitter2 = require("events").EventEmitter;
  var VoiceConnectionUDPClient = class extends EventEmitter2 {
    constructor(voiceConnection) {
      super();
      this.voiceConnection = voiceConnection;
      this.socket = null;
      this.discordAddress = null;
      this.localAddress = null;
      this.localPort = null;
      this.voiceConnection.on("closing", this.shutdown.bind(this));
    }
    shutdown() {
      if (this.socket) {
        this.socket.removeAllListeners("message");
        try {
          this.socket.close();
        } finally {
          this.socket = null;
        }
      }
    }
    get discordPort() {
      return this.voiceConnection.authentication.port;
    }
    send(packet) {
      return new Promise((resolve, reject) => {
        if (!this.socket)
          throw new Error("Tried to send a UDP packet, but there is no socket available.");
        if (!this.discordAddress || !this.discordPort)
          throw new Error("Malformed UDP address or port.");
        this.socket.send(packet, 0, packet.length, this.discordPort, this.discordAddress, (error) => {
          if (error)
            reject(error);
          else
            resolve(packet);
        });
      });
    }
    createUDPSocket(address) {
      this.discordAddress = address;
      const socket = this.socket = udp.createSocket("udp4");
      socket.once("message", (message) => {
        const packet = parseLocalPacket(message);
        if (packet.error) {
          this.emit("error", packet.error);
          return;
        }
        this.localAddress = packet.address;
        this.localPort = packet.port;
        this.voiceConnection.sockets.ws.sendPacket({
          op: Constants2.VoiceOPCodes.SELECT_PROTOCOL,
          d: {
            protocol: "udp",
            data: {
              address: packet.address,
              port: packet.port,
              mode: "xsalsa20_poly1305"
            }
          }
        });
      });
      const blankMessage = Buffer.alloc(70);
      blankMessage.writeUIntBE(this.voiceConnection.authentication.ssrc, 0, 4);
      this.send(blankMessage);
    }
  };
  function parseLocalPacket(message) {
    try {
      const packet = Buffer.from(message);
      let address = "";
      for (let i = 4; i < packet.indexOf(0, i); i++)
        address += String.fromCharCode(packet[i]);
      const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
      return {address, port};
    } catch (error) {
      return {error};
    }
  }
  module2.exports = VoiceConnectionUDPClient;
});

// node_modules/prism-media/src/transcoders/ffmpeg/FfmpegProcess.js
var require_FfmpegProcess = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events").EventEmitter;
  var ChildProcess = require("child_process");
  var FfmpegProcess = class extends EventEmitter2 {
    constructor(ffmpegTranscoder, options) {
      super();
      this.process = ChildProcess.spawn(ffmpegTranscoder.command, options.ffmpegArguments);
      this.transcoder = ffmpegTranscoder;
      this.inputMedia = options.media;
      if (typeof this.inputMedia !== "string") {
        try {
          this.connectStream(this.inputMedia);
        } catch (e) {
          this.emit("error", e, "instantiation");
        }
      } else {
        this.attachErrorHandlers();
      }
      this.on("error", this.kill.bind(this));
      this.once("end", this.kill.bind(this));
    }
    get output() {
      return this.process ? this.process.stdout : null;
    }
    attachErrorHandlers() {
      this.process.stdin.on("error", (e) => {
        if (this.process) {
          this.emit("error", e, "ffmpegProcess.stdin");
        }
      });
      this.process.stdout.on("error", (e) => {
        if (this.process) {
          this.emit("error", e, "ffmpegProcess.stdout");
        }
      });
      this.process.on("error", (e) => this.emit("error", e, "ffmpegProcess"));
      this.process.stdout.on("end", () => this.emit("end"));
    }
    connectStream(inputMedia) {
      if (!this.process)
        throw new Error("No FFMPEG process available");
      this.inputMedia = inputMedia;
      this.inputMedia.pipe(this.process.stdin, {end: false});
      inputMedia.on("error", (e) => this.emit("error", e, "inputstream", inputMedia));
      this.attachErrorHandlers();
      return this.process.stdout;
    }
    kill() {
      if (!this.process)
        return;
      if (this.inputMedia && this.inputMedia.unpipe) {
        this.inputMedia.unpipe(this.process.stdin);
      }
      this.process.kill("SIGKILL");
      this.process = null;
    }
  };
  module2.exports = FfmpegProcess;
});

// node_modules/prism-media/src/transcoders/ffmpeg/Ffmpeg.js
var require_Ffmpeg = __commonJS((exports2, module2) => {
  var ChildProcess = require("child_process");
  var FfmpegProcess = require_FfmpegProcess();
  var FfmpegTranscoder = class {
    constructor(mediaTranscoder) {
      this.mediaTranscoder = mediaTranscoder;
      this.command = FfmpegTranscoder.selectFfmpegCommand();
      this.processes = [];
    }
    static verifyOptions(options) {
      if (!options)
        throw new Error("Options not provided!");
      if (!options.media)
        throw new Error("Media must be provided");
      if (!options.ffmpegArguments || !(options.ffmpegArguments instanceof Array)) {
        throw new Error("FFMPEG Arguments must be an array");
      }
      if (options.ffmpegArguments.includes("-i"))
        return options;
      if (typeof options.media === "string") {
        options.ffmpegArguments = ["-i", `${options.media}`].concat(options.ffmpegArguments).concat(["pipe:1"]);
      } else {
        options.ffmpegArguments = ["-i", "-"].concat(options.ffmpegArguments).concat(["pipe:1"]);
      }
      return options;
    }
    transcode(options) {
      if (!this.command)
        this.command = FfmpegTranscoder.selectFfmpegCommand();
      const proc = new FfmpegProcess(this, FfmpegTranscoder.verifyOptions(options));
      this.processes.push(proc);
      return proc;
    }
    static selectFfmpegCommand() {
      try {
        return require("ffmpeg-binaries");
      } catch (err) {
        for (const command of ["ffmpeg", "avconv", "./ffmpeg", "./avconv"]) {
          if (!ChildProcess.spawnSync(command, ["-h"]).error)
            return command;
        }
        throw new Error("FFMPEG not found");
      }
    }
  };
  module2.exports = FfmpegTranscoder;
});

// node_modules/prism-media/src/transcoders/MediaTranscoder.js
var require_MediaTranscoder = __commonJS((exports2, module2) => {
  var Ffmpeg = require_Ffmpeg();
  var transcoders = [
    "ffmpeg"
  ];
  var MediaTranscoder = class {
    constructor(prism) {
      this.prism = prism;
      this.ffmpeg = new Ffmpeg(this);
    }
    static verifyOptions(options) {
      if (!options)
        throw new Error("Options must be passed to MediaTranscoder.transcode()");
      if (!options.type)
        throw new Error("Options.type must be passed to MediaTranscoder.transcode()");
      if (!transcoders.includes(options.type))
        throw new Error(`Options.type must be: ${transcoders.join(" ")}`);
      return options;
    }
    transcode(options) {
      options = MediaTranscoder.verifyOptions(options);
      return this[options.type].transcode(options);
    }
  };
  module2.exports = MediaTranscoder;
});

// node_modules/prism-media/src/Prism.js
var require_Prism = __commonJS((exports2, module2) => {
  var MediaTranscoder = require_MediaTranscoder();
  var Prism = class {
    constructor() {
      this.transcoder = new MediaTranscoder(this);
    }
    createTranscoder(...args) {
      return this.transcode(...args);
    }
    transcode(...args) {
      return this.transcoder.transcode(...args);
    }
  };
  module2.exports = Prism;
});

// node_modules/prism-media/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  var Prism = require_Prism();
  var MediaTranscoder = require_MediaTranscoder();
  Prism.MediaTranscoder = MediaTranscoder;
  module2.exports = Prism;
});

// node_modules/discord.js/src/client/voice/util/VolumeInterface.js
var require_VolumeInterface = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events");
  var VolumeInterface = class extends EventEmitter2 {
    constructor({volume = 1} = {}) {
      super();
      this.setVolume(volume);
    }
    get volume() {
      return this._volume;
    }
    get volumeDecibels() {
      return Math.log10(this._volume) * 20;
    }
    get volumeLogarithmic() {
      return Math.pow(this._volume, 1 / 1.660964);
    }
    applyVolume(buffer, volume) {
      volume = volume || this._volume;
      if (volume === 1)
        return buffer;
      const out = Buffer.alloc(buffer.length);
      for (let i = 0; i < buffer.length; i += 2) {
        if (i >= buffer.length - 1)
          break;
        const uint = Math.min(32767, Math.max(-32767, Math.floor(volume * buffer.readInt16LE(i))));
        out.writeInt16LE(uint, i);
      }
      return out;
    }
    setVolume(volume) {
      this.emit("volumeChange", this._volume, volume);
      this._volume = volume;
    }
    setVolumeDecibels(db) {
      this.setVolume(Math.pow(10, db / 20));
    }
    setVolumeLogarithmic(value) {
      this.setVolume(Math.pow(value, 1.660964));
    }
  };
  module2.exports = VolumeInterface;
});

// node_modules/discord.js/src/client/voice/opus/BaseOpusEngine.js
var require_BaseOpusEngine = __commonJS((exports2, module2) => {
  var BaseOpus = class {
    constructor({bitrate = 48, fec = false, plp = 0} = {}) {
      this.ctl = {
        BITRATE: 4002,
        FEC: 4012,
        PLP: 4014
      };
      this.samplingRate = 48e3;
      this.channels = 2;
      this.bitrate = bitrate;
      this.options = {fec, plp};
    }
    init() {
      try {
        this.setBitrate(this.bitrate);
        if (this.options.fec)
          this.setFEC(this.options.fec);
        if (this.options.plp)
          this.setPLP(this.options.plp);
      } catch (err) {
      }
    }
    encode(buffer) {
      return buffer;
    }
    decode(buffer) {
      return buffer;
    }
    destroy() {
    }
  };
  module2.exports = BaseOpus;
});

// node_modules/discord.js/src/client/voice/opus/NodeOpusEngine.js
var require_NodeOpusEngine = __commonJS((exports2, module2) => {
  var OpusEngine = require_BaseOpusEngine();
  var opus;
  var NodeOpusEngine = class extends OpusEngine {
    constructor(player) {
      super(player);
      try {
        opus = require("node-opus");
      } catch (err) {
        throw err;
      }
      this.encoder = new opus.OpusEncoder(this.samplingRate, this.channels);
      super.init();
    }
    setBitrate(bitrate) {
      this.encoder.applyEncoderCTL(this.ctl.BITRATE, Math.min(128, Math.max(16, bitrate)) * 1e3);
    }
    setFEC(enabled) {
      this.encoder.applyEncoderCTL(this.ctl.FEC, enabled ? 1 : 0);
    }
    setPLP(percent) {
      this.encoder.applyEncoderCTL(this.ctl.PLP, Math.min(100, Math.max(0, percent * 100)));
    }
    encode(buffer) {
      super.encode(buffer);
      return this.encoder.encode(buffer, 1920);
    }
    decode(buffer) {
      super.decode(buffer);
      return this.encoder.decode(buffer, 1920);
    }
  };
  module2.exports = NodeOpusEngine;
});

// node_modules/discord.js/src/client/voice/opus/OpusScriptEngine.js
var require_OpusScriptEngine = __commonJS((exports2, module2) => {
  var OpusEngine = require_BaseOpusEngine();
  var OpusScript;
  var OpusScriptEngine = class extends OpusEngine {
    constructor(player) {
      super(player);
      try {
        OpusScript = require("opusscript");
      } catch (err) {
        throw err;
      }
      this.encoder = new OpusScript(this.samplingRate, this.channels);
      super.init();
    }
    setBitrate(bitrate) {
      this.encoder.encoderCTL(this.ctl.BITRATE, Math.min(128, Math.max(16, bitrate)) * 1e3);
    }
    setFEC(enabled) {
      this.encoder.encoderCTL(this.ctl.FEC, enabled ? 1 : 0);
    }
    setPLP(percent) {
      this.encoder.encoderCTL(this.ctl.PLP, Math.min(100, Math.max(0, percent * 100)));
    }
    encode(buffer) {
      super.encode(buffer);
      return this.encoder.encode(buffer, 960);
    }
    decode(buffer) {
      super.decode(buffer);
      return this.encoder.decode(buffer);
    }
    destroy() {
      super.destroy();
      this.encoder.delete();
    }
  };
  module2.exports = OpusScriptEngine;
});

// node_modules/discord.js/src/client/voice/opus/OpusEngineList.js
var require_OpusEngineList = __commonJS((exports2) => {
  var list = [
    require_NodeOpusEngine(),
    require_OpusScriptEngine()
  ];
  function fetch(Encoder, engineOptions) {
    try {
      return new Encoder(engineOptions);
    } catch (err) {
      if (err.message.includes("Cannot find module"))
        return null;
      throw err;
    }
  }
  exports2.add = (encoder) => {
    list.push(encoder);
  };
  exports2.fetch = (engineOptions) => {
    for (const encoder of list) {
      const fetched = fetch(encoder, engineOptions);
      if (fetched)
        return fetched;
    }
    throw new Error("Couldn't find an Opus engine.");
  };
});

// node_modules/discord.js/src/client/voice/VoiceBroadcast.js
var require_VoiceBroadcast = __commonJS((exports2, module2) => {
  var VolumeInterface = require_VolumeInterface();
  var Prism = require_src2();
  var OpusEncoders = require_OpusEngineList();
  var Collection2 = require_Collection();
  var ffmpegArguments = [
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    "s16le",
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
  var VoiceBroadcast2 = class extends VolumeInterface {
    constructor(client) {
      super();
      this.client = client;
      this._dispatchers = new Collection2();
      this._encoders = new Collection2();
      this.prism = new Prism();
      this.currentTranscoder = null;
      this.tickInterval = null;
      this._volume = 1;
    }
    get dispatchers() {
      let d = [];
      for (const container of this._dispatchers.values()) {
        d = d.concat(Array.from(container.values()));
      }
      return d;
    }
    get _playableStream() {
      const currentTranscoder = this.currentTranscoder;
      if (!currentTranscoder)
        return null;
      const transcoder = currentTranscoder.transcoder;
      const options = currentTranscoder.options;
      return transcoder && transcoder.output || options.stream;
    }
    unregisterDispatcher(dispatcher, old) {
      const volume = old || dispatcher.volume;
      this.emit("unsubscribe", dispatcher);
      for (const container of this._dispatchers.values()) {
        container.delete(dispatcher);
        if (!container.size) {
          this._encoders.get(volume).destroy();
          this._dispatchers.delete(volume);
          this._encoders.delete(volume);
        }
      }
    }
    registerDispatcher(dispatcher) {
      if (!this._dispatchers.has(dispatcher.volume)) {
        this._dispatchers.set(dispatcher.volume, new Set());
        this._encoders.set(dispatcher.volume, OpusEncoders.fetch());
      }
      const container = this._dispatchers.get(dispatcher.volume);
      if (!container.has(dispatcher)) {
        container.add(dispatcher);
        dispatcher.once("end", () => this.unregisterDispatcher(dispatcher));
        dispatcher.on("volumeChange", (o, n) => {
          this.unregisterDispatcher(dispatcher, o);
          if (!this._dispatchers.has(n)) {
            this._dispatchers.set(n, new Set());
            this._encoders.set(n, OpusEncoders.fetch());
          }
          this._dispatchers.get(n).add(dispatcher);
        });
        this.emit("subscribe", dispatcher);
      }
    }
    killCurrentTranscoder() {
      if (this.currentTranscoder) {
        if (this.currentTranscoder.transcoder)
          this.currentTranscoder.transcoder.kill();
        this.currentTranscoder = null;
        this.emit("end");
      }
    }
    playStream(stream, options = {}) {
      this.setVolume(options.volume || 1);
      return this._playTranscodable(stream, options);
    }
    playFile(file, options = {}) {
      this.setVolume(options.volume || 1);
      return this._playTranscodable(`file:${file}`, options);
    }
    _playTranscodable(media, options) {
      this.killCurrentTranscoder();
      const transcoder = this.prism.transcode({
        type: "ffmpeg",
        media,
        ffmpegArguments: ffmpegArguments.concat(["-ss", String(options.seek || 0)])
      });
      transcoder.once("error", (e) => {
        if (this.listenerCount("error") > 0)
          this.emit("error", e);
        else
          this.emit("warn", e);
      });
      transcoder.once("end", () => this.killCurrentTranscoder());
      this.currentTranscoder = {
        transcoder,
        options
      };
      transcoder.output.once("readable", () => this._startPlaying());
      return this;
    }
    playConvertedStream(stream, options = {}) {
      this.killCurrentTranscoder();
      this.setVolume(options.volume || 1);
      this.currentTranscoder = {options: {stream}};
      stream.once("readable", () => this._startPlaying());
      return this;
    }
    playOpusStream(stream) {
      this.currentTranscoder = {options: {stream}, opus: true};
      stream.once("readable", () => this._startPlaying());
      return this;
    }
    playArbitraryInput(input, options = {}) {
      this.setVolume(options.volume || 1);
      options.input = input;
      return this._playTranscodable(input, options);
    }
    pause() {
      this.paused = true;
      for (const container of this._dispatchers.values()) {
        for (const dispatcher of container.values()) {
          dispatcher.pause();
        }
      }
    }
    resume() {
      this.paused = false;
      for (const container of this._dispatchers.values()) {
        for (const dispatcher of container.values()) {
          dispatcher.resume();
        }
      }
    }
    _startPlaying() {
      if (this.tickInterval)
        clearInterval(this.tickInterval);
      this._startTime = Date.now();
      this._count = 0;
      this._pausedTime = 0;
      this._missed = 0;
      this.tick();
    }
    tick() {
      if (!this._playableStream)
        return;
      if (this.paused) {
        this._pausedTime += 20;
        setTimeout(() => this.tick(), 20);
        return;
      }
      const opus = this.currentTranscoder.opus;
      const buffer = this.readStreamBuffer();
      if (!buffer) {
        this._missed++;
        if (this._missed < 5) {
          this._pausedTime += 200;
          setTimeout(() => this.tick(), 200);
        } else {
          this.killCurrentTranscoder();
        }
        return;
      }
      this._missed = 0;
      let packetMatrix = {};
      const getOpusPacket = (volume) => {
        if (packetMatrix[volume])
          return packetMatrix[volume];
        const opusEncoder = this._encoders.get(volume);
        const opusPacket = opusEncoder.encode(this.applyVolume(buffer, this._volume * volume));
        packetMatrix[volume] = opusPacket;
        return opusPacket;
      };
      for (const dispatcher of this.dispatchers) {
        if (opus) {
          dispatcher.processPacket(buffer);
          continue;
        }
        const volume = dispatcher.volume;
        dispatcher.processPacket(getOpusPacket(volume));
      }
      const next = 20 + (this._startTime + this._pausedTime + this._count * 20 - Date.now());
      this._count++;
      setTimeout(() => this.tick(), next);
    }
    readStreamBuffer() {
      const opus = this.currentTranscoder.opus;
      const bufferLength = (opus ? 80 : 1920) * 2;
      let buffer = this._playableStream.read(bufferLength);
      if (opus)
        return buffer;
      if (!buffer)
        return null;
      if (buffer.length !== bufferLength) {
        const newBuffer = Buffer.alloc(bufferLength).fill(0);
        buffer.copy(newBuffer);
        buffer = newBuffer;
      }
      return buffer;
    }
    end() {
      this.killCurrentTranscoder();
    }
    destroy() {
      this.end();
      for (const container of this._dispatchers.values()) {
        for (const dispatcher of container.values()) {
          dispatcher.destroy("end", "broadcast ended");
        }
      }
    }
  };
  module2.exports = VoiceBroadcast2;
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports2, module2) => {
  (function(nacl) {
    "use strict";
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0; i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z[i] = 0;
      for (i = 0; i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d32, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d32 = c;
        d32 += h0 * r3;
        d32 += h1 * r2;
        d32 += h2 * r1;
        d32 += h3 * r0;
        d32 += h4 * (5 * r9);
        c = d32 >>> 13;
        d32 &= 8191;
        d32 += h5 * (5 * r8);
        d32 += h6 * (5 * r7);
        d32 += h7 * (5 * r6);
        d32 += h8 * (5 * r5);
        d32 += h9 * (5 * r4);
        c += d32 >>> 13;
        d32 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d32;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0; i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++)
        z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0; i < n; i++)
        x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++)
        x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x[i] = r[i];
      for (i = 0; i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0; i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0; i < 64; i++)
        x[i] = 0;
      for (i = 0; i < 32; i++)
        x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      if (n < 64)
        return -1;
      if (unpackneg(q, pk))
        return -1;
      for (i = 0; i < n; i++)
        m[i] = sm[i];
      for (i = 0; i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++)
        m[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D,
      L,
      pack25519,
      unpack25519,
      M,
      A,
      S,
      Z,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
        return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {publicKey: pk, secretKey: sk};
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0)
        return false;
      if (x.length !== y.length)
        return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto && crypto.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto = require("crypto");
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
});

// node_modules/discord.js/src/client/voice/util/Secretbox.js
var require_Secretbox = __commonJS((exports2) => {
  var libs = {
    sodium: (sodium) => ({
      open: sodium.api.crypto_secretbox_open_easy,
      close: sodium.api.crypto_secretbox_easy
    }),
    "libsodium-wrappers": (sodium) => ({
      open: sodium.crypto_secretbox_open_easy,
      close: sodium.crypto_secretbox_easy
    }),
    tweetnacl: (tweetnacl) => ({
      open: tweetnacl.secretbox.open,
      close: tweetnacl.secretbox
    })
  };
  exports2.methods = {};
  for (const libName of Object.keys(libs)) {
    try {
      const lib = require(libName);
      if (libName === "libsodium-wrappers" && lib.ready) {
        lib.ready.then(() => {
          exports2.methods = libs[libName](lib);
        }).catch(() => {
          const tweetnacl = require_nacl_fast();
          exports2.methods = libs.tweetnacl(tweetnacl);
        }).catch(() => void 0);
      } else {
        exports2.methods = libs[libName](lib);
      }
      break;
    } catch (err) {
    }
  }
});

// node_modules/discord.js/src/client/voice/dispatcher/StreamDispatcher.js
var require_StreamDispatcher = __commonJS((exports2, module2) => {
  var VolumeInterface = require_VolumeInterface();
  var VoiceBroadcast2 = require_VoiceBroadcast();
  var Constants2 = require_Constants();
  var secretbox = require_Secretbox();
  var nonce = Buffer.alloc(24);
  nonce.fill(0);
  var StreamDispatcher = class extends VolumeInterface {
    constructor(player, stream, streamOptions) {
      super(streamOptions);
      this.player = player;
      this.stream = stream;
      if (!(this.stream instanceof VoiceBroadcast2))
        this.startStreaming();
      this.streamOptions = streamOptions;
      const data = this.streamingData;
      data.length = 20;
      data.missed = 0;
      this.paused = false;
      this.destroyed = false;
      this._opus = streamOptions.opus;
    }
    get passes() {
      return this.streamOptions.passes || 1;
    }
    set passes(n) {
      this.streamOptions.passes = n;
    }
    get streamingData() {
      return this.player.streamingData;
    }
    get time() {
      return this.streamingData.count * (this.streamingData.length || 0);
    }
    get totalStreamTime() {
      return this.time + this.streamingData.pausedTime;
    }
    pause() {
      this.setPaused(true);
    }
    resume() {
      this.setPaused(false);
    }
    end(reason = "user") {
      this.destroy("end", reason);
    }
    setSpeaking(value) {
      if (this.speaking === value)
        return;
      if (this.player.voiceConnection.status !== Constants2.VoiceStatus.CONNECTED)
        return;
      this.speaking = value;
      this.emit("speaking", value);
    }
    setBitrate(bitrate) {
      this.player.setBitrate(bitrate);
    }
    sendBuffer(buffer, sequence, timestamp, opusPacket) {
      opusPacket = opusPacket || this.player.opusEncoder.encode(buffer);
      const packet = this.createPacket(sequence, timestamp, opusPacket);
      this.sendPacket(packet);
    }
    sendPacket(packet) {
      let repeats = this.passes;
      this.setSpeaking(true);
      while (repeats-- && this.player.voiceConnection.sockets.udp) {
        this.player.voiceConnection.sockets.udp.send(packet).catch((e) => {
          this.setSpeaking(false);
          this.emit("debug", `Failed to send a packet ${e}`);
        });
      }
    }
    createPacket(sequence, timestamp, buffer) {
      const packetBuffer = Buffer.alloc(buffer.length + 28);
      packetBuffer.fill(0);
      packetBuffer[0] = 128;
      packetBuffer[1] = 120;
      packetBuffer.writeUIntBE(sequence, 2, 2);
      packetBuffer.writeUIntBE(timestamp, 4, 4);
      packetBuffer.writeUIntBE(this.player.voiceConnection.authentication.ssrc, 8, 4);
      packetBuffer.copy(nonce, 0, 0, 12);
      buffer = secretbox.methods.close(buffer, nonce, this.player.voiceConnection.authentication.secretKey.key);
      for (let i = 0; i < buffer.length; i++)
        packetBuffer[i + 12] = buffer[i];
      return packetBuffer;
    }
    processPacket(packet) {
      try {
        if (this.destroyed || !this.player.voiceConnection.authentication.secretKey) {
          this.setSpeaking(false);
          return;
        }
        const data = this.streamingData;
        if (this.paused) {
          this.setSpeaking(false);
          data.pausedTime = data.length * 10;
          return;
        }
        if (!packet) {
          data.missed++;
          data.pausedTime += data.length * 10;
          return;
        }
        this.started();
        this.missed = 0;
        this.stepStreamingData();
        this.sendBuffer(null, data.sequence, data.timestamp, packet);
      } catch (e) {
        this.destroy("error", e);
      }
    }
    process() {
      try {
        if (this.destroyed) {
          this.setSpeaking(false);
          return;
        }
        const data = this.streamingData;
        if (data.missed >= 5) {
          this.destroy("end", "Stream is not generating quickly enough.");
          return;
        }
        if (this.paused) {
          this.setSpeaking(false);
          data.pausedTime += data.length * 10;
          this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), data.length * 10);
          return;
        }
        this.started();
        const buffer = this.readStreamBuffer();
        if (!buffer) {
          data.missed++;
          data.pausedTime += data.length * 10;
          this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), data.length * 10);
          return;
        }
        data.missed = 0;
        this.stepStreamingData();
        if (this._opus) {
          this.sendBuffer(null, data.sequence, data.timestamp, buffer);
        } else {
          this.sendBuffer(buffer, data.sequence, data.timestamp);
        }
        const nextTime = data.length + (data.startTime + data.pausedTime + data.count * data.length - Date.now());
        this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), nextTime);
      } catch (e) {
        this.destroy("error", e);
      }
    }
    readStreamBuffer() {
      const data = this.streamingData;
      const bufferLength = (this._opus ? 80 : 1920) * data.channels;
      let buffer = this.stream.read(bufferLength);
      if (this._opus)
        return buffer;
      if (!buffer)
        return null;
      if (buffer.length !== bufferLength) {
        const newBuffer = Buffer.alloc(bufferLength).fill(0);
        buffer.copy(newBuffer);
        buffer = newBuffer;
      }
      buffer = this.applyVolume(buffer);
      return buffer;
    }
    started() {
      const data = this.streamingData;
      if (!data.startTime) {
        this.emit("start");
        data.startTime = Date.now();
      }
    }
    stepStreamingData() {
      const data = this.streamingData;
      data.count++;
      data.sequence = data.sequence < 65535 ? data.sequence + 1 : 0;
      data.timestamp = data.timestamp + 960 < 4294967295 ? data.timestamp + 960 : 0;
    }
    destroy(type, reason) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.setSpeaking(false);
      this.emit(type, reason);
      if (type !== "end")
        this.emit("end", `destroyed due to ${type} - ${reason}`);
    }
    startStreaming() {
      if (!this.stream) {
        this.emit("error", "No stream");
        return;
      }
      this.stream.on("end", (err) => this.destroy("end", err || "stream"));
      this.stream.on("error", (err) => this.destroy("error", err));
      const data = this.streamingData;
      data.length = 20;
      data.missed = 0;
      this.stream.once("readable", () => {
        data.startTime = null;
        data.count = 0;
        this.process();
      });
    }
    setPaused(paused) {
      this.setSpeaking(!(this.paused = paused));
    }
  };
  module2.exports = StreamDispatcher;
});

// node_modules/discord.js/src/client/voice/player/AudioPlayer.js
var require_AudioPlayer = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events").EventEmitter;
  var Prism = require_src2();
  var StreamDispatcher = require_StreamDispatcher();
  var Collection2 = require_Collection();
  var OpusEncoders = require_OpusEngineList();
  var ffmpegArguments = [
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    "s16le",
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
  var AudioPlayer = class extends EventEmitter2 {
    constructor(voiceConnection) {
      super();
      this.voiceConnection = voiceConnection;
      this.prism = new Prism();
      this.streams = new Collection2();
      this.currentStream = {};
      this.streamingData = {
        channels: 2,
        count: 0,
        sequence: 0,
        timestamp: 0,
        pausedTime: 0
      };
      this.voiceConnection.once("closing", () => this.destroyCurrentStream());
    }
    get transcoder() {
      return this.currentStream.transcoder;
    }
    get dispatcher() {
      return this.currentStream.dispatcher;
    }
    destroy() {
      if (this.opusEncoder)
        this.opusEncoder.destroy();
      this.opusEncoder = null;
    }
    destroyCurrentStream() {
      const transcoder = this.transcoder;
      const dispatcher = this.dispatcher;
      if (transcoder)
        transcoder.kill();
      if (dispatcher) {
        const end = dispatcher.listeners("end")[0];
        const error = dispatcher.listeners("error")[0];
        if (end)
          dispatcher.removeListener("end", end);
        if (error)
          dispatcher.removeListener("error", error);
        dispatcher.destroy("end");
      }
      this.currentStream = {};
    }
    setBitrate(value) {
      if (!value)
        return;
      if (!this.opusEncoder)
        return;
      const bitrate = value === "auto" ? this.voiceConnection.channel.bitrate : value;
      this.opusEncoder.setBitrate(bitrate);
    }
    playUnknownStream(stream, options = {}) {
      this.destroy();
      this.opusEncoder = OpusEncoders.fetch(options);
      const transcoder = this.prism.transcode({
        type: "ffmpeg",
        media: stream,
        ffmpegArguments: ffmpegArguments.concat(["-ss", String(options.seek || 0)])
      });
      this.destroyCurrentStream();
      this.currentStream = {
        transcoder,
        output: transcoder.output,
        input: stream
      };
      transcoder.on("error", (e) => {
        this.destroyCurrentStream();
        if (this.listenerCount("error") > 0)
          this.emit("error", e);
        this.emit("warn", `prism transcoder error - ${e}`);
      });
      return this.playPCMStream(transcoder.output, options, true);
    }
    playPCMStream(stream, options = {}, fromUnknown = false) {
      this.destroy();
      this.opusEncoder = OpusEncoders.fetch(options);
      this.setBitrate(options.bitrate);
      const dispatcher = this.createDispatcher(stream, options);
      if (fromUnknown) {
        this.currentStream.dispatcher = dispatcher;
      } else {
        this.destroyCurrentStream();
        this.currentStream = {
          dispatcher,
          input: stream,
          output: stream
        };
      }
      return dispatcher;
    }
    playOpusStream(stream, options = {}) {
      options.opus = true;
      this.destroyCurrentStream();
      const dispatcher = this.createDispatcher(stream, options);
      this.currentStream = {
        dispatcher,
        input: stream,
        output: stream
      };
      return dispatcher;
    }
    playBroadcast(broadcast, options) {
      this.destroyCurrentStream();
      const dispatcher = this.createDispatcher(broadcast, options);
      this.currentStream = {
        dispatcher,
        broadcast,
        input: broadcast,
        output: broadcast
      };
      broadcast.registerDispatcher(dispatcher);
      return dispatcher;
    }
    createDispatcher(stream, {seek = 0, volume = 1, passes = 1, opus} = {}) {
      const options = {seek, volume, passes, opus};
      const dispatcher = new StreamDispatcher(this, stream, options);
      dispatcher.on("end", () => this.destroyCurrentStream());
      dispatcher.on("error", () => this.destroyCurrentStream());
      dispatcher.on("speaking", (value) => this.voiceConnection.setSpeaking(value));
      return dispatcher;
    }
  };
  module2.exports = AudioPlayer;
});

// node_modules/discord.js/src/client/voice/receiver/VoiceReadable.js
var require_VoiceReadable = __commonJS((exports2, module2) => {
  var Readable = require("stream").Readable;
  var VoiceReadable = class extends Readable {
    constructor() {
      super();
      this._packets = [];
      this.open = true;
    }
    _read() {
    }
    _push(d) {
      if (this.open)
        this.push(d);
    }
  };
  module2.exports = VoiceReadable;
});

// node_modules/discord.js/src/client/voice/receiver/VoiceReceiver.js
var require_VoiceReceiver = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events").EventEmitter;
  var secretbox = require_Secretbox();
  var Readable = require_VoiceReadable();
  var OpusEncoders = require_OpusEngineList();
  var nonce = Buffer.alloc(24);
  nonce.fill(0);
  var VoiceReceiver = class extends EventEmitter2 {
    constructor(connection) {
      super();
      this.queues = new Map();
      this.pcmStreams = new Map();
      this.opusStreams = new Map();
      this.opusEncoders = new Map();
      this.destroyed = false;
      this.voiceConnection = connection;
      this._listener = (msg) => {
        const ssrc = +msg.readUInt32BE(8).toString(10);
        const user = this.voiceConnection.ssrcMap.get(ssrc);
        if (!user) {
          if (!this.queues.has(ssrc))
            this.queues.set(ssrc, []);
          this.queues.get(ssrc).push(msg);
        } else {
          if (this.queues.get(ssrc)) {
            this.queues.get(ssrc).push(msg);
            this.queues.get(ssrc).map((m) => this.handlePacket(m, user));
            this.queues.delete(ssrc);
            return;
          }
          this.handlePacket(msg, user);
        }
      };
      this.voiceConnection.sockets.udp.socket.on("message", this._listener);
    }
    recreate() {
      if (!this.destroyed)
        return;
      this.voiceConnection.sockets.udp.socket.on("message", this._listener);
      this.destroyed = false;
    }
    destroy() {
      this.voiceConnection.sockets.udp.socket.removeListener("message", this._listener);
      for (const [id, stream] of this.pcmStreams) {
        stream._push(null);
        this.pcmStreams.delete(id);
      }
      for (const [id, stream] of this.opusStreams) {
        stream._push(null);
        this.opusStreams.delete(id);
      }
      for (const [id, encoder] of this.opusEncoders) {
        encoder.destroy();
        this.opusEncoders.delete(id);
      }
      this.destroyed = true;
    }
    stoppedSpeaking(user) {
      const opusStream = this.opusStreams.get(user.id);
      const pcmStream = this.pcmStreams.get(user.id);
      const opusEncoder = this.opusEncoders.get(user.id);
      if (opusStream) {
        opusStream.push(null);
        opusStream.open = false;
        this.opusStreams.delete(user.id);
      }
      if (pcmStream) {
        pcmStream.push(null);
        pcmStream.open = false;
        this.pcmStreams.delete(user.id);
      }
      if (opusEncoder) {
        opusEncoder.destroy();
      }
    }
    createOpusStream(user) {
      user = this.voiceConnection.voiceManager.client.resolver.resolveUser(user);
      if (!user)
        throw new Error("Couldn't resolve the user to create Opus stream.");
      if (this.opusStreams.get(user.id))
        throw new Error("There is already an existing stream for that user.");
      const stream = new Readable();
      this.opusStreams.set(user.id, stream);
      return stream;
    }
    createPCMStream(user) {
      user = this.voiceConnection.voiceManager.client.resolver.resolveUser(user);
      if (!user)
        throw new Error("Couldn't resolve the user to create PCM stream.");
      if (this.pcmStreams.get(user.id))
        throw new Error("There is already an existing stream for that user.");
      const stream = new Readable();
      this.pcmStreams.set(user.id, stream);
      return stream;
    }
    handlePacket(msg, user) {
      msg.copy(nonce, 0, 0, 12);
      let data = secretbox.methods.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key);
      if (!data) {
        this.emit("warn", "decrypt", "Failed to decrypt voice packet");
        return;
      }
      data = Buffer.from(data);
      if (data[0] === 190 && data[1] === 222 && data.length > 4) {
        const headerExtensionLength = data.readUInt16BE(2);
        let offset = 4;
        for (let i = 0; i < headerExtensionLength; i++) {
          const byte = data[offset];
          offset++;
          if (byte === 0) {
            continue;
          }
          offset += 1 + (15 & byte >> 4);
        }
        while (data[offset] === 0) {
          offset++;
        }
        data = data.slice(offset);
      }
      if (this.opusStreams.get(user.id))
        this.opusStreams.get(user.id)._push(data);
      this.emit("opus", user, data);
      if (this.listenerCount("pcm") > 0 || this.pcmStreams.size > 0) {
        if (!this.opusEncoders.get(user.id))
          this.opusEncoders.set(user.id, OpusEncoders.fetch());
        const {pcm, error} = VoiceReceiver._tryDecode(this.opusEncoders.get(user.id), data);
        if (error) {
          this.emit("warn", "decode", `Failed to decode packet voice to PCM because: ${error.message}`);
          return;
        }
        if (this.pcmStreams.get(user.id))
          this.pcmStreams.get(user.id)._push(pcm);
        this.emit("pcm", user, pcm);
      }
    }
    static _tryDecode(encoder, data) {
      try {
        return {pcm: encoder.decode(data)};
      } catch (error) {
        return {error};
      }
    }
  };
  module2.exports = VoiceReceiver;
});

// node_modules/discord.js/src/client/voice/VoiceConnection.js
var require_VoiceConnection = __commonJS((exports2, module2) => {
  var VoiceWebSocket = require_VoiceWebSocket();
  var VoiceUDP = require_VoiceUDPClient();
  var Util2 = require_Util();
  var Constants2 = require_Constants();
  var AudioPlayer = require_AudioPlayer();
  var VoiceReceiver = require_VoiceReceiver();
  var EventEmitter2 = require("events").EventEmitter;
  var Prism = require_src2();
  var VoiceConnection = class extends EventEmitter2 {
    constructor(voiceManager, channel) {
      super();
      this.voiceManager = voiceManager;
      this.client = voiceManager.client;
      this.prism = new Prism();
      this.channel = channel;
      this.status = Constants2.VoiceStatus.AUTHENTICATING;
      this.speaking = false;
      this.receivers = [];
      this.authentication = {};
      this.player = new AudioPlayer(this);
      this.player.on("debug", (m) => {
        this.emit("debug", `audio player - ${m}`);
      });
      this.player.on("error", (e) => {
        this.emit("warn", e);
      });
      this.ssrcMap = new Map();
      this.sockets = {};
      this.authenticate();
    }
    get dispatcher() {
      return this.player.dispatcher;
    }
    setSpeaking(value) {
      if (this.speaking === value)
        return;
      if (this.status !== Constants2.VoiceStatus.CONNECTED)
        return;
      this.speaking = value;
      this.sockets.ws.sendPacket({
        op: Constants2.VoiceOPCodes.SPEAKING,
        d: {
          speaking: true,
          delay: 0
        }
      }).catch((e) => {
        this.emit("debug", e);
      });
    }
    sendVoiceStateUpdate(options = {}) {
      options = Util2.mergeDefault({
        guild_id: this.channel.guild.id,
        channel_id: this.channel.id,
        self_mute: false,
        self_deaf: false
      }, options);
      this.client.ws.send({
        op: Constants2.OPCodes.VOICE_STATE_UPDATE,
        d: options
      });
    }
    setTokenAndEndpoint(token, endpoint) {
      if (!endpoint) {
        return;
      }
      if (!token) {
        this.authenticateFailed("Token not provided from voice server packet.");
        return;
      }
      endpoint = endpoint.match(/([^:]*)/)[0];
      if (!endpoint) {
        this.authenticateFailed("Invalid endpoint received.");
        return;
      }
      if (this.status === Constants2.VoiceStatus.AUTHENTICATING) {
        this.authentication.token = token;
        this.authentication.endpoint = endpoint;
        this.checkAuthenticated();
      } else if (token !== this.authentication.token || endpoint !== this.authentication.endpoint) {
        this.reconnect(token, endpoint);
      }
    }
    setSessionID(sessionID) {
      if (!sessionID) {
        this.authenticateFailed("Session ID not supplied.");
        return;
      }
      if (this.status === Constants2.VoiceStatus.AUTHENTICATING) {
        this.authentication.sessionID = sessionID;
        this.checkAuthenticated();
      } else if (sessionID !== this.authentication.sessionID) {
        this.authentication.sessionID = sessionID;
        this.emit("newSession", sessionID);
      }
    }
    checkAuthenticated() {
      const {token, endpoint, sessionID} = this.authentication;
      if (token && endpoint && sessionID) {
        clearTimeout(this.connectTimeout);
        this.status = Constants2.VoiceStatus.CONNECTING;
        this.emit("authenticated");
        this.connect();
      }
    }
    authenticateFailed(reason) {
      clearTimeout(this.connectTimeout);
      if (this.status === Constants2.VoiceStatus.AUTHENTICATING) {
        this.emit("failed", new Error(reason));
      } else {
        this.emit("error", new Error(reason));
      }
      this.status = Constants2.VoiceStatus.DISCONNECTED;
    }
    updateChannel(channel) {
      this.channel = channel;
      this.sendVoiceStateUpdate();
    }
    authenticate() {
      this.sendVoiceStateUpdate();
      this.connectTimeout = this.client.setTimeout(() => this.authenticateFailed(new Error("Connection not established within 15 seconds.")), 15e3);
    }
    reconnect(token, endpoint) {
      this.authentication.token = token;
      this.authentication.endpoint = endpoint;
      this.status = Constants2.VoiceStatus.RECONNECTING;
      this.emit("reconnecting");
      this.connect();
    }
    disconnect() {
      this.emit("closing");
      this.sendVoiceStateUpdate({
        channel_id: null
      });
      this.player.destroy();
      this.cleanup();
      this.status = Constants2.VoiceStatus.DISCONNECTED;
      this.emit("disconnect");
    }
    cleanup() {
      const {ws, udp} = this.sockets;
      if (ws) {
        ws.removeAllListeners("error");
        ws.removeAllListeners("ready");
        ws.removeAllListeners("sessionDescription");
        ws.removeAllListeners("speaking");
      }
      if (udp)
        udp.removeAllListeners("error");
      this.sockets.ws = null;
      this.sockets.udp = null;
    }
    connect() {
      if (this.status !== Constants2.VoiceStatus.RECONNECTING) {
        if (this.sockets.ws)
          throw new Error("There is already an existing WebSocket connection.");
        if (this.sockets.udp)
          throw new Error("There is already an existing UDP connection.");
      }
      if (this.sockets.ws)
        this.sockets.ws.shutdown();
      if (this.sockets.udp)
        this.sockets.udp.shutdown();
      this.sockets.ws = new VoiceWebSocket(this);
      this.sockets.udp = new VoiceUDP(this);
      const {ws, udp} = this.sockets;
      ws.on("error", (err) => this.emit("error", err));
      udp.on("error", (err) => this.emit("error", err));
      ws.on("ready", this.onReady.bind(this));
      ws.on("sessionDescription", this.onSessionDescription.bind(this));
      ws.on("speaking", this.onSpeaking.bind(this));
    }
    onReady({port, ssrc, ip}) {
      this.authentication.port = port;
      this.authentication.ssrc = ssrc;
      this.sockets.udp.createUDPSocket(ip);
    }
    onSessionDescription(mode, secret) {
      this.authentication.encryptionMode = mode;
      this.authentication.secretKey = secret;
      this.status = Constants2.VoiceStatus.CONNECTED;
      this.emit("ready");
    }
    onSpeaking({user_id, ssrc, speaking}) {
      const guild = this.channel.guild;
      const user = this.client.users.get(user_id);
      this.ssrcMap.set(+ssrc, user);
      if (!speaking) {
        for (const receiver of this.receivers) {
          receiver.stoppedSpeaking(user);
        }
      }
      if (this.status === Constants2.VoiceStatus.CONNECTED)
        this.emit("speaking", user, speaking);
      guild._memberSpeakUpdate(user_id, speaking);
    }
    playFile(file, options) {
      return this.player.playUnknownStream(`file:${file}`, options);
    }
    playArbitraryInput(input, options) {
      return this.player.playUnknownStream(input, options);
    }
    playStream(stream, options) {
      return this.player.playUnknownStream(stream, options);
    }
    playConvertedStream(stream, options) {
      return this.player.playPCMStream(stream, options);
    }
    playOpusStream(stream, options) {
      return this.player.playOpusStream(stream, options);
    }
    playBroadcast(broadcast, options) {
      return this.player.playBroadcast(broadcast, options);
    }
    createReceiver() {
      const receiver = new VoiceReceiver(this);
      this.receivers.push(receiver);
      return receiver;
    }
  };
  module2.exports = VoiceConnection;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports2, module2) => {
  var Collection2 = require_Collection();
  var VoiceConnection = require_VoiceConnection();
  var ClientVoiceManager2 = class {
    constructor(client) {
      this.client = client;
      this.connections = new Collection2();
      this.client.on("self.voiceServer", this.onVoiceServer.bind(this));
      this.client.on("self.voiceStateUpdate", this.onVoiceStateUpdate.bind(this));
    }
    onVoiceServer({guild_id, token, endpoint}) {
      const connection = this.connections.get(guild_id);
      if (connection)
        connection.setTokenAndEndpoint(token, endpoint);
    }
    onVoiceStateUpdate({guild_id, session_id, channel_id}) {
      const connection = this.connections.get(guild_id);
      if (connection) {
        connection.channel = this.client.channels.get(channel_id);
        connection.setSessionID(session_id);
      }
    }
    joinChannel(channel) {
      return new Promise((resolve, reject) => {
        if (!channel.joinable) {
          if (channel.full) {
            throw new Error("You do not have permission to join this voice channel; it is full.");
          } else {
            throw new Error("You do not have permission to join this voice channel.");
          }
        }
        let connection = this.connections.get(channel.guild.id);
        if (connection) {
          if (connection.channel.id !== channel.id) {
            this.connections.get(channel.guild.id).updateChannel(channel);
          }
          resolve(connection);
          return;
        } else {
          connection = new VoiceConnection(this, channel);
          this.connections.set(channel.guild.id, connection);
        }
        connection.once("failed", (reason) => {
          this.connections.delete(channel.guild.id);
          reject(reason);
        });
        connection.once("authenticated", () => {
          connection.once("ready", () => resolve(connection));
          connection.once("error", reject);
          connection.once("disconnect", () => this.connections.delete(channel.guild.id));
        });
      });
    }
  };
  module2.exports = ClientVoiceManager2;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports2, module2) => {
  var EventEmitter2 = require("events").EventEmitter;
  var Constants2 = require_Constants();
  var WebSocketConnection = require_WebSocketConnection();
  var WebSocketManager2 = class extends EventEmitter2 {
    constructor(client) {
      super();
      this.client = client;
      this.connection = null;
    }
    heartbeat() {
      if (!this.connection)
        return this.debug("No connection to heartbeat");
      return this.connection.heartbeat();
    }
    debug(message) {
      return this.client.emit("debug", `[ws] ${message}`);
    }
    destroy() {
      if (!this.connection) {
        this.debug("Attempted to destroy WebSocket but no connection exists!");
        return false;
      }
      return this.connection.destroy();
    }
    send(packet) {
      if (!this.connection) {
        this.debug("No connection to websocket");
        return;
      }
      this.connection.send(packet);
    }
    connect(gateway) {
      if (!this.connection) {
        this.connection = new WebSocketConnection(this, gateway);
        return true;
      }
      switch (this.connection.status) {
        case Constants2.Status.IDLE:
        case Constants2.Status.DISCONNECTED:
          this.connection.connect(gateway, 5500);
          return true;
        default:
          this.debug(`Couldn't connect to ${gateway} as the websocket is at state ${this.connection.status}`);
          return false;
      }
    }
  };
  module2.exports = WebSocketManager2;
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports2, module2) => {
  var GenericAction = class {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
  };
  module2.exports = GenericAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Message = require_Message();
  var MessageCreateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.get((data instanceof Array ? data[0] : data).channel_id);
      const user = client.users.get((data instanceof Array ? data[0] : data).author.id);
      if (channel) {
        const member = channel.guild ? channel.guild.member(user) : null;
        if (data instanceof Array) {
          const messages = new Array(data.length);
          for (let i = 0; i < data.length; i++) {
            messages[i] = channel._cacheMessage(new Message(channel, data[i], client));
          }
          const lastMessage = messages[messages.length - 1];
          channel.lastMessageID = lastMessage.id;
          if (user) {
            user.lastMessageID = lastMessage.id;
            user.lastMessage = lastMessage;
          }
          if (member) {
            member.lastMessageID = lastMessage.id;
            member.lastMessage = lastMessage;
          }
          return {
            messages
          };
        } else {
          const message = channel._cacheMessage(new Message(channel, data, client));
          channel.lastMessageID = data.id;
          if (user) {
            user.lastMessageID = data.id;
            user.lastMessage = message;
          }
          if (member) {
            member.lastMessageID = data.id;
            member.lastMessage = message;
          }
          return {
            message
          };
        }
      }
      return {
        message: null
      };
    }
  };
  module2.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var MessageDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      const channel = client.channels.get(data.channel_id);
      let message;
      if (channel) {
        message = channel.messages.get(data.id);
        if (message) {
          channel.messages.delete(message.id);
          this.deleted.set(channel.id + message.id, message);
          this.scheduleForDeletion(channel.id, message.id);
        } else {
          message = this.deleted.get(channel.id + data.id) || null;
        }
        if (message)
          message.deleted = true;
      }
      return {message};
    }
    scheduleForDeletion(channelID, messageID) {
      this.client.setTimeout(() => this.deleted.delete(channelID + messageID), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Collection2 = require_Collection();
  var Constants2 = require_Constants();
  var MessageDeleteBulkAction = class extends Action {
    handle(data) {
      const messages = new Collection2();
      const channel = this.client.channels.get(data.channel_id);
      if (channel) {
        for (const id of data.ids) {
          const message = channel.messages.get(id);
          if (message) {
            message.deleted = true;
            messages.set(message.id, message);
            channel.messages.delete(id);
          }
        }
      }
      if (messages.size > 0)
        this.client.emit(Constants2.Events.MESSAGE_BULK_DELETE, messages);
      return {messages};
    }
  };
  module2.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var MessageUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.get(data.channel_id);
      if (channel) {
        const message = channel.messages.get(data.id);
        if (message) {
          message.patch(data);
          client.emit(Constants2.Events.MESSAGE_UPDATE, message._edits[0], message);
          return {
            old: message._edits[0],
            updated: message
          };
        }
        return {
          old: message,
          updated: message
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var MessageReactionAdd = class extends Action {
    handle(data) {
      const user = this.client.users.get(data.user_id);
      if (!user)
        return false;
      const channel = this.client.channels.get(data.channel_id);
      if (!channel || channel.type === "voice")
        return false;
      const message = channel.messages.get(data.message_id);
      if (!message)
        return false;
      if (!data.emoji)
        return false;
      const reaction = message._addReaction(data.emoji, user);
      if (reaction)
        this.client.emit(Constants2.Events.MESSAGE_REACTION_ADD, reaction, user);
      return {message, reaction, user};
    }
  };
  module2.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var MessageReactionRemove = class extends Action {
    handle(data) {
      const user = this.client.users.get(data.user_id);
      if (!user)
        return false;
      const channel = this.client.channels.get(data.channel_id);
      if (!channel || channel.type === "voice")
        return false;
      const message = channel.messages.get(data.message_id);
      if (!message)
        return false;
      if (!data.emoji)
        return false;
      const reaction = message._removeReaction(data.emoji, user);
      if (reaction)
        this.client.emit(Constants2.Events.MESSAGE_REACTION_REMOVE, reaction, user);
      return {message, reaction, user};
    }
  };
  module2.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var MessageReactionRemoveAll = class extends Action {
    handle(data) {
      const channel = this.client.channels.get(data.channel_id);
      if (!channel || channel.type === "voice")
        return false;
      const message = channel.messages.get(data.message_id);
      if (!message)
        return false;
      message._clearReactions();
      this.client.emit(Constants2.Events.MESSAGE_REACTION_REMOVE_ALL, message);
      return {message};
    }
  };
  module2.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var ChannelCreateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.dataManager.newChannel(data);
      return {channel};
    }
  };
  module2.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var ChannelDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      let channel = client.channels.get(data.id);
      if (channel) {
        client.dataManager.killChannel(channel);
        this.deleted.set(channel.id, channel);
        this.scheduleForDeletion(channel.id);
      } else {
        channel = this.deleted.get(data.id) || null;
      }
      if (channel)
        channel.deleted = true;
      return {channel};
    }
    scheduleForDeletion(id) {
      this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var TextChannel = require_TextChannel();
  var VoiceChannel = require_VoiceChannel();
  var CategoryChannel = require_CategoryChannel();
  var NewsChannel = require_NewsChannel();
  var StoreChannel = require_StoreChannel();
  var Constants2 = require_Constants();
  var ChannelTypes = Constants2.ChannelTypes;
  var Util2 = require_Util();
  var ChannelUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.get(data.id);
      if (channel) {
        const oldChannel = Util2.cloneObject(channel);
        if (ChannelTypes[channel.type.toUpperCase()] !== data.type) {
          let channelClass;
          switch (data.type) {
            case ChannelTypes.TEXT:
              channelClass = TextChannel;
              break;
            case ChannelTypes.VOICE:
              channelClass = VoiceChannel;
              break;
            case ChannelTypes.CATEGORY:
              channelClass = CategoryChannel;
              break;
            case ChannelTypes.NEWS:
              channelClass = NewsChannel;
              break;
            case ChannelTypes.STORE:
              channelClass = StoreChannel;
              break;
          }
          const newChannel = new channelClass(channel.guild, data);
          if (channel.messages && newChannel.messages) {
            for (const [id, message] of channel.messages)
              newChannel.messages.set(id, message);
          }
          channel = newChannel;
          this.client.channels.set(channel.id, channel);
        } else {
          channel.setup(data);
        }
        client.emit(Constants2.Events.CHANNEL_UPDATE, oldChannel, channel);
        return {
          old: oldChannel,
          updated: channel
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var GuildDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      let guild = client.guilds.get(data.id);
      if (guild) {
        for (const channel of guild.channels.values()) {
          if (channel.type === "text")
            channel.stopTyping(true);
        }
        if (guild.available && data.unavailable) {
          guild.available = false;
          client.emit(Constants2.Events.GUILD_UNAVAILABLE, guild);
          return {
            guild: null
          };
        }
        for (const channel of guild.channels.values())
          this.client.channels.delete(channel.id);
        if (guild.voiceConnection)
          guild.voiceConnection.disconnect();
        client.guilds.delete(guild.id);
        this.deleted.set(guild.id, guild);
        this.scheduleForDeletion(guild.id);
      } else {
        guild = this.deleted.get(data.id) || null;
      }
      if (guild)
        guild.deleted = true;
      return {guild};
    }
    scheduleForDeletion(id) {
      this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var GuildUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.id);
      if (guild) {
        const oldGuild = Util2.cloneObject(guild);
        guild.setup(data);
        client.emit(Constants2.Events.GUILD_UPDATE, oldGuild, guild);
        return {
          old: oldGuild,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberGet.js
var require_GuildMemberGet = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildMemberGetAction = class extends Action {
    handle(guild, data) {
      const member = guild._addMember(data, false);
      return {member};
    }
  };
  module2.exports = GuildMemberGetAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var GuildMemberRemoveAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      let member = null;
      if (guild) {
        member = guild.members.get(data.user.id);
        guild.memberCount--;
        if (member) {
          guild._removeMember(member);
          this.deleted.set(guild.id + data.user.id, member);
          if (client.status === Constants2.Status.READY)
            client.emit(Constants2.Events.GUILD_MEMBER_REMOVE, member);
          this.scheduleForDeletion(guild.id, data.user.id);
        } else {
          member = this.deleted.get(guild.id + data.user.id) || null;
        }
        if (member)
          member.deleted = true;
      }
      return {guild, member};
    }
    scheduleForDeletion(guildID, userID) {
      this.client.setTimeout(() => this.deleted.delete(guildID + userID), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var GuildBanRemove = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      const user = client.dataManager.newUser(data.user);
      if (guild && user)
        client.emit(Constants2.Events.GUILD_BAN_REMOVE, guild, user);
    }
  };
  module2.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var Role = require_Role();
  var GuildRoleCreate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.has(data.role.id);
        role = new Role(guild, data.role);
        guild.roles.set(role.id, role);
        if (!already)
          client.emit(Constants2.Events.GUILD_ROLE_CREATE, role);
      }
      return {role};
    }
  };
  module2.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var GuildRoleDeleteAction = class extends Action {
    constructor(client) {
      super(client);
      this.deleted = new Map();
    }
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.get(data.role_id);
        if (role) {
          guild.roles.delete(data.role_id);
          this.deleted.set(guild.id + data.role_id, role);
          this.scheduleForDeletion(guild.id, data.role_id);
          client.emit(Constants2.Events.GUILD_ROLE_DELETE, role);
        } else {
          role = this.deleted.get(guild.id + data.role_id) || null;
        }
        if (role)
          role.deleted = true;
      }
      return {role};
    }
    scheduleForDeletion(guildID, roleID) {
      this.client.setTimeout(() => this.deleted.delete(guildID + roleID), this.client.options.restWsBridgeTimeout);
    }
  };
  module2.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var GuildRoleUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        const roleData = data.role;
        let oldRole = null;
        const role = guild.roles.get(roleData.id);
        if (role) {
          oldRole = Util2.cloneObject(role);
          role.setup(data.role);
          client.emit(Constants2.Events.GUILD_ROLE_UPDATE, oldRole, role);
        }
        return {
          old: oldRole,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/UserGet.js
var require_UserGet = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var UserGetAction = class extends Action {
    handle(data) {
      const client = this.client;
      const user = client.dataManager.newUser(data);
      return {user};
    }
  };
  module2.exports = UserGetAction;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var UserUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      if (client.user) {
        if (client.user.equals(data)) {
          return {
            old: client.user,
            updated: client.user
          };
        }
        const oldUser = Util2.cloneObject(client.user);
        client.user.patch(data);
        client.emit(Constants2.Events.USER_UPDATE, oldUser, client.user);
        return {
          old: oldUser,
          updated: client.user
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  };
  module2.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/UserNoteUpdate.js
var require_UserNoteUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var Constants2 = require_Constants();
  var UserNoteUpdateAction = class extends Action {
    handle(data) {
      const client = this.client;
      const oldNote = client.user.notes.get(data.id);
      const note = data.note.length ? data.note : null;
      client.user.notes.set(data.id, note);
      client.emit(Constants2.Events.USER_NOTE_UPDATE, data.id, oldNote, note);
      return {
        old: oldNote,
        updated: note
      };
    }
  };
  module2.exports = UserNoteUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildSync.js
var require_GuildSync2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildSync = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.id);
      if (guild) {
        if (data.presences) {
          for (const presence of data.presences)
            guild._setPresence(presence.user.id, presence);
        }
        if (data.members) {
          for (const syncMember of data.members) {
            const member = guild.members.get(syncMember.user.id);
            if (member) {
              guild._updateMember(member, syncMember);
            } else {
              guild._addMember(syncMember, false);
            }
          }
        }
        if ("large" in data)
          guild.large = data.large;
      }
    }
  };
  module2.exports = GuildSync;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildEmojiCreateAction = class extends Action {
    handle(guild, createdEmoji) {
      const client = this.client;
      const emoji = client.dataManager.newEmoji(createdEmoji, guild);
      return {emoji};
    }
  };
  module2.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildEmojiDeleteAction = class extends Action {
    handle(emoji) {
      const client = this.client;
      client.dataManager.killEmoji(emoji);
      emoji.deleted = true;
      return {emoji};
    }
  };
  module2.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildEmojiUpdateAction = class extends Action {
    handle(oldEmoji, newEmoji) {
      const emoji = this.client.dataManager.updateEmoji(oldEmoji, newEmoji);
      return {emoji};
    }
  };
  module2.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate2 = __commonJS((exports2, module2) => {
  var Action = require_Action();
  function mappify(iterable) {
    const map = new Map();
    for (const x of iterable)
      map.set(...x);
    return map;
  }
  var GuildEmojisUpdateAction = class extends Action {
    handle(data) {
      const guild = this.client.guilds.get(data.guild_id);
      if (!guild || !guild.emojis)
        return;
      const deletions = mappify(guild.emojis.entries());
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji, true)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  };
  module2.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildRolesPositionUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.get(partialRole.id);
          if (role)
            role.position = partialRole.position;
        }
      }
      return {guild};
    }
  };
  module2.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports2, module2) => {
  var Action = require_Action();
  var GuildChannelsPositionUpdate = class extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.get(partialChannel.id);
          if (channel)
            channel.position = partialChannel.position;
        }
      }
      return {guild};
    }
  };
  module2.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports2, module2) => {
  var ActionsManager2 = class {
    constructor(client) {
      this.client = client;
      this.register(require_MessageCreate2());
      this.register(require_MessageDelete2());
      this.register(require_MessageDeleteBulk2());
      this.register(require_MessageUpdate2());
      this.register(require_MessageReactionAdd2());
      this.register(require_MessageReactionRemove2());
      this.register(require_MessageReactionRemoveAll2());
      this.register(require_ChannelCreate2());
      this.register(require_ChannelDelete2());
      this.register(require_ChannelUpdate2());
      this.register(require_GuildDelete2());
      this.register(require_GuildUpdate2());
      this.register(require_GuildMemberGet());
      this.register(require_GuildMemberRemove2());
      this.register(require_GuildBanRemove2());
      this.register(require_GuildRoleCreate2());
      this.register(require_GuildRoleDelete2());
      this.register(require_GuildRoleUpdate2());
      this.register(require_UserGet());
      this.register(require_UserUpdate2());
      this.register(require_UserNoteUpdate2());
      this.register(require_GuildSync2());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate2());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildChannelsPositionUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  };
  module2.exports = ActionsManager2;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports2, module2) => {
  var Util2 = require_Util();
  var ShardClientUtil2 = class {
    constructor(client) {
      this.client = client;
      process.on("message", this._handleMessage.bind(this));
      client.on("ready", () => {
        process.send({_ready: true});
      });
      client.on("disconnect", () => {
        process.send({_disconnect: true});
      });
      client.on("reconnecting", () => {
        process.send({_reconnecting: true});
      });
    }
    get id() {
      return this.client.options.shardId;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        process.send(message, (err) => {
          if (err)
            reject(err);
          else
            resolve();
        });
      });
    }
    fetchClientValues(prop) {
      return new Promise((resolve, reject) => {
        const listener = (message) => {
          if (!message || message._sFetchProp !== prop)
            return;
          process.removeListener("message", listener);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util2.makeError(message._error));
        };
        process.on("message", listener);
        this.send({_sFetchProp: prop}).catch((err) => {
          process.removeListener("message", listener);
          reject(err);
        });
      });
    }
    broadcastEval(script) {
      return new Promise((resolve, reject) => {
        const listener = (message) => {
          if (!message || message._sEval !== script)
            return;
          process.removeListener("message", listener);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util2.makeError(message._error));
        };
        process.on("message", listener);
        this.send({_sEval: script}).catch((err) => {
          process.removeListener("message", listener);
          reject(err);
        });
      });
    }
    _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        const props = message._fetchProp.split(".");
        let value = this.client;
        for (const prop of props)
          value = value[prop];
        this._respond("fetchProp", {_fetchProp: message._fetchProp, _result: value});
      } else if (message._eval) {
        try {
          this._respond("eval", {_eval: message._eval, _result: this.client._eval(message._eval)});
        } catch (err) {
          this._respond("eval", {_eval: message._eval, _error: Util2.makePlainError(err)});
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        err.message = `Error when sending ${type} response to master process: ${err.message}`;
        this.client.emit("error", err);
      });
    }
    static singleton(client) {
      if (!this._singleton) {
        this._singleton = new this(client);
      } else {
        client.emit("warn", "Multiple clients created in child process; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
  };
  module2.exports = ShardClientUtil2;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var EventEmitter = require("events");
  var Constants = require_Constants();
  var Permissions = require_Permissions();
  var Util = require_Util();
  var RESTManager = require_RESTManager();
  var ClientDataManager = require_ClientDataManager();
  var ClientManager = require_ClientManager();
  var ClientDataResolver = require_ClientDataResolver();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var ActionsManager = require_ActionsManager();
  var Collection = require_Collection();
  var Presence = require_Presence().Presence;
  var ShardClientUtil = require_ShardClientUtil();
  var VoiceBroadcast = require_VoiceBroadcast();
  var Client = class extends EventEmitter {
    constructor(options = {}) {
      super();
      if (!options.shardId && "SHARD_ID" in process.env)
        options.shardId = Number(process.env.SHARD_ID);
      if (!options.shardCount && "SHARD_COUNT" in process.env)
        options.shardCount = Number(process.env.SHARD_COUNT);
      this.options = Util.mergeDefault(Constants.DefaultOptions, options);
      this._validateOptions();
      this.rest = new RESTManager(this);
      this.dataManager = new ClientDataManager(this);
      this.manager = new ClientManager(this);
      this.ws = new WebSocketManager(this);
      this.resolver = new ClientDataResolver(this);
      this.actions = new ActionsManager(this);
      this.voice = !this.browser ? new ClientVoiceManager(this) : null;
      this.shard = process.send ? ShardClientUtil.singleton(this) : null;
      this.users = new Collection();
      this.guilds = new Collection();
      this.channels = new Collection();
      this.presences = new Collection();
      Object.defineProperty(this, "token", {writable: true});
      if (!this.token && "CLIENT_TOKEN" in process.env) {
        this.token = process.env.CLIENT_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.readyAt = null;
      this.broadcasts = [];
      this.pings = [];
      this._timeouts = new Set();
      this._intervals = new Set();
      if (this.options.messageSweepInterval > 0) {
        this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1e3);
      }
    }
    get _pingTimestamp() {
      return this.ws.connection ? this.ws.connection.lastPingTimestamp : 0;
    }
    get status() {
      return this.ws.connection ? this.ws.connection.status : Constants.Status.IDLE;
    }
    get uptime() {
      return this.readyAt ? Date.now() - this.readyAt : null;
    }
    get ping() {
      return this.pings.reduce((prev, p) => prev + p, 0) / this.pings.length;
    }
    get voiceConnections() {
      if (this.browser)
        return new Collection();
      return this.voice.connections;
    }
    get emojis() {
      const emojis = new Collection();
      for (const guild of this.guilds.values()) {
        for (const emoji of guild.emojis.values())
          emojis.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyTimestamp() {
      return this.readyAt ? this.readyAt.getTime() : null;
    }
    get browser() {
      return typeof window !== "undefined";
    }
    createVoiceBroadcast() {
      const broadcast = new VoiceBroadcast(this);
      this.broadcasts.push(broadcast);
      return broadcast;
    }
    login(token = this.token) {
      return this.rest.methods.login(token);
    }
    destroy() {
      for (const t of this._timeouts)
        clearTimeout(t);
      for (const i of this._intervals)
        clearInterval(i);
      this._timeouts.clear();
      this._intervals.clear();
      return this.manager.destroy();
    }
    syncGuilds(guilds = this.guilds) {
      if (this.user.bot)
        return;
      this.ws.send({
        op: 12,
        d: guilds instanceof Collection ? guilds.keyArray() : guilds.map((g) => g.id)
      });
    }
    fetchUser(id, cache = true) {
      if (this.users.has(id))
        return Promise.resolve(this.users.get(id));
      return this.rest.methods.getUser(id, cache);
    }
    fetchInvite(invite) {
      const code = this.resolver.resolveInviteCode(invite);
      return this.rest.methods.getInvite(code);
    }
    fetchWebhook(id, token) {
      return this.rest.methods.getWebhook(id, token);
    }
    fetchVoiceRegions() {
      return this.rest.methods.fetchVoiceRegions();
    }
    sweepMessages(lifetime = this.options.messageCacheLifetime) {
      if (typeof lifetime !== "number" || isNaN(lifetime))
        throw new TypeError("The lifetime must be a number.");
      if (lifetime <= 0) {
        this.emit("debug", "Didn't sweep messages - lifetime is unlimited");
        return -1;
      }
      const lifetimeMs = lifetime * 1e3;
      const now = Date.now();
      let channels = 0;
      let messages = 0;
      for (const channel of this.channels.values()) {
        if (!channel.messages)
          continue;
        channels++;
        messages += channel.messages.sweep((message) => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);
      }
      this.emit("debug", `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);
      return messages;
    }
    fetchApplication(id = "@me") {
      if (id !== "@me")
        process.emitWarning('fetchApplication: use "@me" as an argument', "DeprecationWarning");
      return this.rest.methods.getApplication(id);
    }
    generateInvite(permissions) {
      permissions = typeof permissions === "undefined" ? 0 : Permissions.resolve(permissions);
      return this.fetchApplication().then((application) => `https://discordapp.com/oauth2/authorize?client_id=${application.id}&permissions=${permissions}&scope=bot`);
    }
    setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        fn(...args);
        this._timeouts.delete(timeout);
      }, delay);
      this._timeouts.add(timeout);
      return timeout;
    }
    clearTimeout(timeout) {
      clearTimeout(timeout);
      this._timeouts.delete(timeout);
    }
    setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this._intervals.add(interval);
      return interval;
    }
    clearInterval(interval) {
      clearInterval(interval);
      this._intervals.delete(interval);
    }
    _pong(startTime) {
      this.pings.unshift(Date.now() - startTime);
      if (this.pings.length > 3)
        this.pings.length = 3;
      this.ws.lastHeartbeatAck = true;
    }
    _setPresence(id, presence) {
      if (this.presences.has(id)) {
        this.presences.get(id).update(presence);
        return;
      }
      this.presences.set(id, new Presence(presence, this));
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount)) {
        throw new TypeError("The shardCount option must be a number.");
      }
      if (typeof options.shardId !== "number" || isNaN(options.shardId)) {
        throw new TypeError("The shardId option must be a number.");
      }
      if (options.shardCount < 0)
        throw new RangeError("The shardCount option must be at least 0.");
      if (options.shardId < 0)
        throw new RangeError("The shardId option must be at least 0.");
      if (options.shardId !== 0 && options.shardId >= options.shardCount) {
        throw new RangeError("The shardId option must be less than shardCount.");
      }
      if (typeof options.messageCacheMaxSize !== "number" || isNaN(options.messageCacheMaxSize)) {
        throw new TypeError("The messageCacheMaxSize option must be a number.");
      }
      if (typeof options.messageCacheLifetime !== "number" || isNaN(options.messageCacheLifetime)) {
        throw new TypeError("The messageCacheLifetime option must be a number.");
      }
      if (typeof options.messageSweepInterval !== "number" || isNaN(options.messageSweepInterval)) {
        throw new TypeError("The messageSweepInterval option must be a number.");
      }
      if (typeof options.fetchAllMembers !== "boolean") {
        throw new TypeError("The fetchAllMembers option must be a boolean.");
      }
      if (typeof options.disableEveryone !== "boolean") {
        throw new TypeError("The disableEveryone option must be a boolean.");
      }
      if (typeof options.restWsBridgeTimeout !== "number" || isNaN(options.restWsBridgeTimeout)) {
        throw new TypeError("The restWsBridgeTimeout option must be a number.");
      }
      if (!(options.disabledEvents instanceof Array))
        throw new TypeError("The disabledEvents option must be an Array.");
      if (typeof options.retryLimit !== "number" || isNaN(options.retryLimit)) {
        throw new TypeError("The retryLimit  options must be a number.");
      }
    }
  };
  module.exports = Client;
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports2, module2) => {
  var childProcess = require("child_process");
  var EventEmitter2 = require("events");
  var path = require("path");
  var Util2 = require_Util();
  var Shard = class extends EventEmitter2 {
    constructor(manager, id, args = []) {
      super();
      this.manager = manager;
      this.id = id;
      this.env = Object.assign({}, process.env, {
        SHARD_ID: this.id,
        SHARD_COUNT: this.manager.totalShards,
        CLIENT_TOKEN: this.manager.token
      });
      this.ready = false;
      this._evals = new Map();
      this._fetches = new Map();
      this._exitListener = this._handleExit.bind(this, void 0);
      this.process = null;
      this.spawn(args);
    }
    spawn(args = this.manager.args, execArgv = this.manager.execArgv) {
      this.process = childProcess.fork(path.resolve(this.manager.file), args, {
        env: this.env,
        execArgv
      }).on("exit", this._exitListener).on("message", this._handleMessage.bind(this));
      this.emit("spawn", this.process);
      return new Promise((resolve, reject) => {
        this.once("ready", resolve);
        this.once("disconnect", () => reject(new Error(`Shard ${this.id}'s Client disconnected before becoming ready.`)));
        this.once("death", () => reject(new Error(`Shard ${this.id}'s process exited before its Client became ready.`)));
        setTimeout(() => reject(new Error(`Shard ${this.id}'s Client took too long to become ready.`)), 3e4);
      }).then(() => this.process);
    }
    kill() {
      this.process.removeListener("exit", this._exitListener);
      this.process.kill();
      this._handleExit(false);
    }
    respawn(delay = 500) {
      this.kill();
      if (delay > 0)
        return Util2.delayFor(delay).then(() => this.spawn());
      return this.spawn();
    }
    send(message) {
      return new Promise((resolve, reject) => {
        this.process.send(message, (err) => {
          if (err)
            reject(err);
          else
            resolve(this);
        });
      });
    }
    fetchClientValue(prop) {
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const listener = (message) => {
          if (!message || message._fetchProp !== prop)
            return;
          this.process.removeListener("message", listener);
          this._fetches.delete(prop);
          resolve(message._result);
        };
        this.process.on("message", listener);
        this.send({_fetchProp: prop}).catch((err) => {
          this.process.removeListener("message", listener);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    eval(script) {
      if (this._evals.has(script))
        return this._evals.get(script);
      const promise = new Promise((resolve, reject) => {
        const listener = (message) => {
          if (!message || message._eval !== script)
            return;
          this.process.removeListener("message", listener);
          this._evals.delete(script);
          if (!message._error)
            resolve(message._result);
          else
            reject(Util2.makeError(message._error));
        };
        this.process.on("message", listener);
        this.send({_eval: script}).catch((err) => {
          this.process.removeListener("message", listener);
          this._evals.delete(script);
          reject(err);
        });
      });
      this._evals.set(script, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit("ready");
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit("disconnect");
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit("reconnecting");
          return;
        }
        if (message._sFetchProp) {
          this.manager.fetchClientValues(message._sFetchProp).then((results) => this.send({_sFetchProp: message._sFetchProp, _result: results}), (err) => this.send({_sFetchProp: message._sFetchProp, _error: Util2.makePlainError(err)}));
          return;
        }
        if (message._sEval) {
          this.manager.broadcastEval(message._sEval).then((results) => this.send({_sEval: message._sEval, _result: results}), (err) => this.send({_sEval: message._sEval, _error: Util2.makePlainError(err)}));
          return;
        }
      }
      this.manager.emit("message", this, message);
      this.emit("message", message);
    }
    _handleExit(respawn = this.manager.respawn) {
      this.emit("death", this.process);
      this.process = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.manager.createShard(this.id);
    }
  };
  module2.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  var EventEmitter2 = require("events").EventEmitter;
  var Shard = require_Shard();
  var Collection2 = require_Collection();
  var Util2 = require_Util();
  var ShardingManager = class extends EventEmitter2 {
    constructor(file, options = {}) {
      super();
      options = Util2.mergeDefault({
        totalShards: "auto",
        respawn: true,
        shardArgs: [],
        token: null
      }, options);
      this.file = file;
      if (!file)
        throw new Error("File must be specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new Error("File path does not point to a file.");
      this.totalShards = options.totalShards;
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new TypeError("Amount of shards must be a number.");
        }
        if (this.totalShards < 1)
          throw new RangeError("Amount of shards must be at least 1.");
        if (this.totalShards !== Math.floor(this.totalShards)) {
          throw new RangeError("Amount of shards must be an integer.");
        }
      }
      this.respawn = options.respawn;
      this.shardArgs = options.shardArgs;
      this.execArgv = options.execArgv;
      this.token = options.token ? options.token.replace(/^Bot\s*/i, "") : null;
      this.shards = new Collection2();
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id, this.shardArgs);
      this.shards.set(id, shard);
      this.emit("launch", shard);
      return Promise.resolve(shard);
    }
    spawn(amount = this.totalShards, delay = 7500) {
      if (amount === "auto") {
        return Util2.fetchRecommendedShards(this.token).then((count) => {
          this.totalShards = count;
          return this._spawn(count, delay);
        });
      } else {
        if (typeof amount !== "number" || isNaN(amount))
          throw new TypeError("Amount of shards must be a number.");
        if (amount < 1)
          throw new RangeError("Amount of shards must be at least 1.");
        if (amount !== Math.floor(amount))
          throw new TypeError("Amount of shards must be an integer.");
        return this._spawn(amount, delay);
      }
    }
    _spawn(amount, delay) {
      return new Promise((resolve) => {
        if (this.shards.size >= amount)
          throw new Error(`Already spawned ${this.shards.size} shards.`);
        this.totalShards = amount;
        this.createShard();
        if (this.shards.size >= this.totalShards) {
          resolve(this.shards);
          return;
        }
        if (delay <= 0) {
          while (this.shards.size < this.totalShards)
            this.createShard();
          resolve(this.shards);
        } else {
          const interval = setInterval(() => {
            this.createShard();
            if (this.shards.size >= this.totalShards) {
              clearInterval(interval);
              resolve(this.shards);
            }
          }, delay);
        }
      });
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    broadcastEval(script) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.eval(script));
      return Promise.all(promises);
    }
    fetchClientValues(prop) {
      if (this.shards.size === 0)
        return Promise.reject(new Error("No shards have been spawned."));
      if (this.shards.size !== this.totalShards)
        return Promise.reject(new Error("Still spawning shards."));
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.fetchClientValue(prop));
      return Promise.all(promises);
    }
    respawnAll(shardDelay = 5e3, respawnDelay = 500, waitForReady = true, currentShardIndex = 0) {
      let s = 0;
      const shard = this.shards.get(currentShardIndex);
      const promises = [shard.respawn(respawnDelay, waitForReady)];
      if (++s < this.shards.size && shardDelay > 0)
        promises.push(Util2.delayFor(shardDelay));
      return Promise.all(promises).then(() => {
        if (++currentShardIndex === this.shards.size)
          return this.shards;
        return this.respawnAll(shardDelay, respawnDelay, waitForReady, currentShardIndex);
      });
    }
  };
  module2.exports = ShardingManager;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports2, module2) => {
  var Webhook = require_Webhook();
  var RESTManager2 = require_RESTManager();
  var ClientDataResolver2 = require_ClientDataResolver();
  var Constants2 = require_Constants();
  var Util2 = require_Util();
  var WebhookClient = class extends Webhook {
    constructor(id, token, options) {
      super(null, id, token);
      this.options = Util2.mergeDefault(Constants2.DefaultOptions, options);
      this.rest = new RESTManager2(this);
      this.resolver = new ClientDataResolver2(this);
      this._timeouts = new Set();
      this._intervals = new Set();
    }
    setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        fn(...args);
        this._timeouts.delete(timeout);
      }, delay);
      this._timeouts.add(timeout);
      return timeout;
    }
    clearTimeout(timeout) {
      clearTimeout(timeout);
      this._timeouts.delete(timeout);
    }
    setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this._intervals.add(interval);
      return interval;
    }
    clearInterval(interval) {
      clearInterval(interval);
      this._intervals.delete(interval);
    }
    destroy() {
      for (const t of this._timeouts)
        clearTimeout(t);
      for (const i of this._intervals)
        clearInterval(i);
      this._timeouts.clear();
      this._intervals.clear();
    }
  };
  module2.exports = WebhookClient;
});

// node_modules/discord.js/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  var Util2 = require_Util();
  module2.exports = {
    Client: require_Client(),
    Shard: require_Shard(),
    ShardClientUtil: require_ShardClientUtil(),
    ShardingManager: require_ShardingManager(),
    WebhookClient: require_WebhookClient(),
    Collection: require_Collection(),
    Constants: require_Constants(),
    DiscordAPIError: require_DiscordAPIError(),
    EvaluatedPermissions: require_Permissions(),
    Permissions: require_Permissions(),
    Snowflake: require_Snowflake(),
    SnowflakeUtil: require_Snowflake(),
    Util: Util2,
    util: Util2,
    version: require_package2().version,
    escapeMarkdown: Util2.escapeMarkdown,
    fetchRecommendedShards: Util2.fetchRecommendedShards,
    splitMessage: Util2.splitMessage,
    Attachment: require_Attachment(),
    CategoryChannel: require_CategoryChannel(),
    Channel: require_Channel(),
    ClientUser: require_ClientUser(),
    ClientUserSettings: require_ClientUserSettings(),
    Collector: require_Collector(),
    DMChannel: require_DMChannel(),
    Emoji: require_Emoji(),
    Game: require_Presence().Game,
    GroupDMChannel: require_GroupDMChannel(),
    Guild: require_Guild(),
    GuildAuditLogs: require_GuildAuditLogs(),
    GuildChannel: require_GuildChannel(),
    GuildMember: require_GuildMember(),
    Invite: require_Invite(),
    Message: require_Message(),
    MessageAttachment: require_MessageAttachment(),
    MessageCollector: require_MessageCollector(),
    MessageEmbed: require_MessageEmbed(),
    MessageMentions: require_MessageMentions(),
    MessageReaction: require_MessageReaction(),
    NewsChannel: require_NewsChannel(),
    OAuth2Application: require_OAuth2Application(),
    ClientOAuth2Application: require_OAuth2Application(),
    PartialGuild: require_PartialGuild(),
    PartialGuildChannel: require_PartialGuildChannel(),
    PermissionOverwrites: require_PermissionOverwrites(),
    Presence: require_Presence().Presence,
    ReactionEmoji: require_ReactionEmoji(),
    ReactionCollector: require_ReactionCollector(),
    RichEmbed: require_RichEmbed(),
    Role: require_Role(),
    StoreChannel: require_StoreChannel(),
    TextChannel: require_TextChannel(),
    User: require_User(),
    VoiceChannel: require_VoiceChannel(),
    Webhook: require_Webhook()
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug3(...args) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src4 = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser2();
  } else {
    module2.exports = require_node2();
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof global.Map !== "undefined") {
    module2.exports = global.Map;
    module2.exports.Map = global.Map;
  } else {
    Map2 = function(array) {
      this._keys = [];
      this._values = {};
      for (var i = 0; i < array.length; i++) {
        if (array[i] == null)
          continue;
        var entry = array[i];
        var key = entry[0];
        var value = entry[1];
        this._keys.push(key);
        this._values[key] = {v: value, i: this._keys.length - 1};
      }
    };
    Map2.prototype.clear = function() {
      this._keys = [];
      this._values = {};
    };
    Map2.prototype.delete = function(key) {
      var value = this._values[key];
      if (value == null)
        return false;
      delete this._values[key];
      this._keys.splice(value.i, 1);
      return true;
    };
    Map2.prototype.entries = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? [key, self2._values[key].v] : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.forEach = function(callback, self2) {
      self2 = self2 || this;
      for (var i = 0; i < this._keys.length; i++) {
        var key = this._keys[i];
        callback.call(self2, this._values[key].v, key, self2);
      }
    };
    Map2.prototype.get = function(key) {
      return this._values[key] ? this._values[key].v : void 0;
    };
    Map2.prototype.has = function(key) {
      return this._values[key] != null;
    };
    Map2.prototype.keys = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? key : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Map2.prototype.set = function(key, value) {
      if (this._values[key]) {
        this._values[key].v = value;
        return this;
      }
      this._keys.push(key);
      this._values[key] = {v: value, i: this._keys.length - 1};
      return this;
    };
    Map2.prototype.values = function() {
      var self2 = this;
      var index = 0;
      return {
        next: function() {
          var key = self2._keys[index++];
          return {
            value: key !== void 0 ? self2._values[key].v : void 0,
            done: key !== void 0 ? false : true
          };
        }
      };
    };
    Object.defineProperty(Map2.prototype, "size", {
      enumerable: true,
      get: function() {
        return this._keys.length;
      }
    });
    module2.exports = Map2;
    module2.exports.Map = Map2;
  }
  var Map2;
});

// node_modules/bson/lib/bson/long.js
var require_long2 = __commonJS((exports2, module2) => {
  function Long2(low, high) {
    if (!(this instanceof Long2))
      return new Long2(low, high);
    this._bsontype = "Long";
    this.low_ = low | 0;
    this.high_ = high | 0;
  }
  Long2.prototype.toInt = function() {
    return this.low_;
  };
  Long2.prototype.toNumber = function() {
    return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  Long2.prototype.toJSON = function() {
    return this.toString();
  };
  Long2.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.equals(Long2.MIN_VALUE)) {
        var radixLong = Long2.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return "-" + this.negate().toString(radix);
      }
    }
    var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
    rem = this;
    var result = "";
    while (!rem.isZero()) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = "0" + digits;
        }
        result = "" + digits + result;
      }
    }
  };
  Long2.prototype.getHighBits = function() {
    return this.high_;
  };
  Long2.prototype.getLowBits = function() {
    return this.low_;
  };
  Long2.prototype.getLowBitsUnsigned = function() {
    return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
  };
  Long2.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(Long2.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ !== 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }
      return this.high_ !== 0 ? bit + 33 : bit + 1;
    }
  };
  Long2.prototype.isZero = function() {
    return this.high_ === 0 && this.low_ === 0;
  };
  Long2.prototype.isNegative = function() {
    return this.high_ < 0;
  };
  Long2.prototype.isOdd = function() {
    return (this.low_ & 1) === 1;
  };
  Long2.prototype.equals = function(other) {
    return this.high_ === other.high_ && this.low_ === other.low_;
  };
  Long2.prototype.notEquals = function(other) {
    return this.high_ !== other.high_ || this.low_ !== other.low_;
  };
  Long2.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };
  Long2.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };
  Long2.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };
  Long2.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };
  Long2.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }
    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  Long2.prototype.negate = function() {
    if (this.equals(Long2.MIN_VALUE)) {
      return Long2.MIN_VALUE;
    } else {
      return this.not().add(Long2.ONE);
    }
  };
  Long2.prototype.add = function(other) {
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Long2.prototype.subtract = function(other) {
    return this.add(other.negate());
  };
  Long2.prototype.multiply = function(other) {
    if (this.isZero()) {
      return Long2.ZERO;
    } else if (other.isZero()) {
      return Long2.ZERO;
    }
    if (this.equals(Long2.MIN_VALUE)) {
      return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
    } else if (other.equals(Long2.MIN_VALUE)) {
      return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }
    if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
      return Long2.fromNumber(this.toNumber() * other.toNumber());
    }
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Long2.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error("division by zero");
    } else if (this.isZero()) {
      return Long2.ZERO;
    }
    if (this.equals(Long2.MIN_VALUE)) {
      if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
        return Long2.MIN_VALUE;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ONE;
      } else {
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(Long2.ZERO)) {
          return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(Long2.MIN_VALUE)) {
      return Long2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }
    var res = Long2.ZERO;
    rem = this;
    while (rem.greaterThanOrEqual(other)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
      var approxRes = Long2.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = Long2.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }
      if (approxRes.isZero()) {
        approxRes = Long2.ONE;
      }
      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };
  Long2.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };
  Long2.prototype.not = function() {
    return Long2.fromBits(~this.low_, ~this.high_);
  };
  Long2.prototype.and = function(other) {
    return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
  };
  Long2.prototype.or = function(other) {
    return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
  };
  Long2.prototype.xor = function(other) {
    return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
  };
  Long2.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
      } else {
        return Long2.fromBits(0, low << numBits - 32);
      }
    }
  };
  Long2.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
      } else {
        return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
      }
    }
  };
  Long2.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
      } else if (numBits === 32) {
        return Long2.fromBits(high, 0);
      } else {
        return Long2.fromBits(high >>> numBits - 32, 0);
      }
    }
  };
  Long2.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = Long2.INT_CACHE_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }
    var obj = new Long2(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      Long2.INT_CACHE_[value] = obj;
    }
    return obj;
  };
  Long2.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return Long2.ZERO;
    } else if (value <= -Long2.TWO_PWR_63_DBL_) {
      return Long2.MIN_VALUE;
    } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
      return Long2.MAX_VALUE;
    } else if (value < 0) {
      return Long2.fromNumber(-value).negate();
    } else {
      return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
    }
  };
  Long2.fromBits = function(lowBits, highBits) {
    return new Long2(lowBits, highBits);
  };
  Long2.fromString = function(str, opt_radix) {
    if (str.length === 0) {
      throw Error("number format error: empty string");
    }
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (str.charAt(0) === "-") {
      return Long2.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf("-") >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }
    var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
    var result = Long2.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = Long2.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(Long2.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(Long2.fromNumber(value));
      }
    }
    return result;
  };
  Long2.INT_CACHE_ = {};
  Long2.TWO_PWR_16_DBL_ = 1 << 16;
  Long2.TWO_PWR_24_DBL_ = 1 << 24;
  Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
  Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
  Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
  Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
  Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
  Long2.ZERO = Long2.fromInt(0);
  Long2.ONE = Long2.fromInt(1);
  Long2.NEG_ONE = Long2.fromInt(-1);
  Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
  Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
  Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
  module2.exports = Long2;
  module2.exports.Long = Long2;
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS((exports2, module2) => {
  function Double2(value) {
    if (!(this instanceof Double2))
      return new Double2(value);
    this._bsontype = "Double";
    this.value = value;
  }
  Double2.prototype.valueOf = function() {
    return this.value;
  };
  Double2.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Double2;
  module2.exports.Double = Double2;
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  function Timestamp2(low, high) {
    if (!(this instanceof Timestamp2))
      return new Timestamp2(low, high);
    this._bsontype = "Timestamp";
    this.low_ = low | 0;
    this.high_ = high | 0;
  }
  Timestamp2.prototype.toInt = function() {
    return this.low_;
  };
  Timestamp2.prototype.toNumber = function() {
    return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  Timestamp2.prototype.toJSON = function() {
    return this.toString();
  };
  Timestamp2.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        var radixTimestamp = Timestamp2.fromNumber(radix);
        var div = this.div(radixTimestamp);
        var rem = div.multiply(radixTimestamp).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return "-" + this.negate().toString(radix);
      }
    }
    var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
    rem = this;
    var result = "";
    while (!rem.isZero()) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = "0" + digits;
        }
        result = "" + digits + result;
      }
    }
  };
  Timestamp2.prototype.getHighBits = function() {
    return this.high_;
  };
  Timestamp2.prototype.getLowBits = function() {
    return this.low_;
  };
  Timestamp2.prototype.getLowBitsUnsigned = function() {
    return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
  };
  Timestamp2.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ !== 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }
      return this.high_ !== 0 ? bit + 33 : bit + 1;
    }
  };
  Timestamp2.prototype.isZero = function() {
    return this.high_ === 0 && this.low_ === 0;
  };
  Timestamp2.prototype.isNegative = function() {
    return this.high_ < 0;
  };
  Timestamp2.prototype.isOdd = function() {
    return (this.low_ & 1) === 1;
  };
  Timestamp2.prototype.equals = function(other) {
    return this.high_ === other.high_ && this.low_ === other.low_;
  };
  Timestamp2.prototype.notEquals = function(other) {
    return this.high_ !== other.high_ || this.low_ !== other.low_;
  };
  Timestamp2.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };
  Timestamp2.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };
  Timestamp2.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };
  Timestamp2.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };
  Timestamp2.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }
    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  Timestamp2.prototype.negate = function() {
    if (this.equals(Timestamp2.MIN_VALUE)) {
      return Timestamp2.MIN_VALUE;
    } else {
      return this.not().add(Timestamp2.ONE);
    }
  };
  Timestamp2.prototype.add = function(other) {
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Timestamp2.prototype.subtract = function(other) {
    return this.add(other.negate());
  };
  Timestamp2.prototype.multiply = function(other) {
    if (this.isZero()) {
      return Timestamp2.ZERO;
    } else if (other.isZero()) {
      return Timestamp2.ZERO;
    }
    if (this.equals(Timestamp2.MIN_VALUE)) {
      return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
    } else if (other.equals(Timestamp2.MIN_VALUE)) {
      return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }
    if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
      return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
    }
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 65535;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 65535;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 65535;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  Timestamp2.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error("division by zero");
    } else if (this.isZero()) {
      return Timestamp2.ZERO;
    }
    if (this.equals(Timestamp2.MIN_VALUE)) {
      if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
        return Timestamp2.MIN_VALUE;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ONE;
      } else {
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(Timestamp2.ZERO)) {
          return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(Timestamp2.MIN_VALUE)) {
      return Timestamp2.ZERO;
    }
    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }
    var res = Timestamp2.ZERO;
    rem = this;
    while (rem.greaterThanOrEqual(other)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
      var approxRes = Timestamp2.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = Timestamp2.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }
      if (approxRes.isZero()) {
        approxRes = Timestamp2.ONE;
      }
      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };
  Timestamp2.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };
  Timestamp2.prototype.not = function() {
    return Timestamp2.fromBits(~this.low_, ~this.high_);
  };
  Timestamp2.prototype.and = function(other) {
    return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
  };
  Timestamp2.prototype.or = function(other) {
    return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
  };
  Timestamp2.prototype.xor = function(other) {
    return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
  };
  Timestamp2.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
      } else {
        return Timestamp2.fromBits(0, low << numBits - 32);
      }
    }
  };
  Timestamp2.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
      } else {
        return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
      }
    }
  };
  Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
      } else if (numBits === 32) {
        return Timestamp2.fromBits(high, 0);
      } else {
        return Timestamp2.fromBits(high >>> numBits - 32, 0);
      }
    }
  };
  Timestamp2.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = Timestamp2.INT_CACHE_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }
    var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      Timestamp2.INT_CACHE_[value] = obj;
    }
    return obj;
  };
  Timestamp2.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return Timestamp2.ZERO;
    } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
      return Timestamp2.MIN_VALUE;
    } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
      return Timestamp2.MAX_VALUE;
    } else if (value < 0) {
      return Timestamp2.fromNumber(-value).negate();
    } else {
      return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
    }
  };
  Timestamp2.fromBits = function(lowBits, highBits) {
    return new Timestamp2(lowBits, highBits);
  };
  Timestamp2.fromString = function(str, opt_radix) {
    if (str.length === 0) {
      throw Error("number format error: empty string");
    }
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error("radix out of range: " + radix);
    }
    if (str.charAt(0) === "-") {
      return Timestamp2.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf("-") >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }
    var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
    var result = Timestamp2.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = Timestamp2.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(Timestamp2.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(Timestamp2.fromNumber(value));
      }
    }
    return result;
  };
  Timestamp2.INT_CACHE_ = {};
  Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
  Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
  Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
  Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
  Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
  Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
  Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
  Timestamp2.ZERO = Timestamp2.fromInt(0);
  Timestamp2.ONE = Timestamp2.fromInt(1);
  Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
  Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
  Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
  Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
  module2.exports = Timestamp2;
  module2.exports.Timestamp = Timestamp2;
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS((exports2, module2) => {
  "use strict";
  function normalizedFunctionString(fn) {
    return fn.toString().replace(/function *\(/, "function (");
  }
  function newBuffer(item, encoding) {
    return new Buffer(item, encoding);
  }
  function allocBuffer() {
    return Buffer.alloc.apply(Buffer, arguments);
  }
  function toBuffer() {
    return Buffer.from.apply(Buffer, arguments);
  }
  module2.exports = {
    normalizedFunctionString,
    allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
    toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
  };
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS((exports2, module2) => {
  var inspect = "inspect";
  var utils2 = require_utils();
  var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
  var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
  try {
    if (Buffer && Buffer.from) {
      hasBufferType = true;
      inspect = require("util").inspect.custom || "inspect";
    }
  } catch (err) {
    hasBufferType = false;
  }
  var hasBufferType;
  var ObjectID2 = function ObjectID3(id) {
    if (id instanceof ObjectID3)
      return id;
    if (!(this instanceof ObjectID3))
      return new ObjectID3(id);
    this._bsontype = "ObjectID";
    if (id == null || typeof id === "number") {
      this.id = this.generate(id);
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
      return;
    }
    var valid = ObjectID3.isValid(id);
    if (!valid && id != null) {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
      return new ObjectID3(utils2.toBuffer(id, "hex"));
    } else if (valid && typeof id === "string" && id.length === 24) {
      return ObjectID3.createFromHexString(id);
    } else if (id != null && id.length === 12) {
      this.id = id;
    } else if (id != null && typeof id.toHexString === "function") {
      return id;
    } else {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    }
    if (ObjectID3.cacheHexString)
      this.__id = this.toString("hex");
  };
  var hexTable = [];
  for (var i = 0; i < 256; i++) {
    hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
  }
  ObjectID2.prototype.toHexString = function() {
    if (ObjectID2.cacheHexString && this.__id)
      return this.__id;
    var hexString = "";
    if (!this.id || !this.id.length) {
      throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
    }
    if (this.id instanceof _Buffer) {
      hexString = convertToHex(this.id);
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    }
    for (var i2 = 0; i2 < this.id.length; i2++) {
      hexString += hexTable[this.id.charCodeAt(i2)];
    }
    if (ObjectID2.cacheHexString)
      this.__id = hexString;
    return hexString;
  };
  ObjectID2.prototype.get_inc = function() {
    return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
  };
  ObjectID2.prototype.getInc = function() {
    return this.get_inc();
  };
  ObjectID2.prototype.generate = function(time) {
    if (typeof time !== "number") {
      time = ~~(Date.now() / 1e3);
    }
    var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
    var inc = this.get_inc();
    var buffer = utils2.allocBuffer(12);
    buffer[3] = time & 255;
    buffer[2] = time >> 8 & 255;
    buffer[1] = time >> 16 & 255;
    buffer[0] = time >> 24 & 255;
    buffer[6] = MACHINE_ID & 255;
    buffer[5] = MACHINE_ID >> 8 & 255;
    buffer[4] = MACHINE_ID >> 16 & 255;
    buffer[8] = pid & 255;
    buffer[7] = pid >> 8 & 255;
    buffer[11] = inc & 255;
    buffer[10] = inc >> 8 & 255;
    buffer[9] = inc >> 16 & 255;
    return buffer;
  };
  ObjectID2.prototype.toString = function(format) {
    if (this.id && this.id.copy) {
      return this.id.toString(typeof format === "string" ? format : "hex");
    }
    return this.toHexString();
  };
  ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
  ObjectID2.prototype.toJSON = function() {
    return this.toHexString();
  };
  ObjectID2.prototype.equals = function equals(otherId) {
    if (otherId instanceof ObjectID2) {
      return this.toString() === otherId.toString();
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
      return otherId === this.id.toString("binary");
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
      return otherId.toLowerCase() === this.toHexString();
    } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
      return otherId === this.id;
    } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
      return otherId.toHexString() === this.toHexString();
    } else {
      return false;
    }
  };
  ObjectID2.prototype.getTimestamp = function() {
    var timestamp = new Date();
    var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
    timestamp.setTime(Math.floor(time) * 1e3);
    return timestamp;
  };
  ObjectID2.index = ~~(Math.random() * 16777215);
  ObjectID2.createPk = function createPk() {
    return new ObjectID2();
  };
  ObjectID2.createFromTime = function createFromTime(time) {
    var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    buffer[3] = time & 255;
    buffer[2] = time >> 8 & 255;
    buffer[1] = time >> 16 & 255;
    buffer[0] = time >> 24 & 255;
    return new ObjectID2(buffer);
  };
  var decodeLookup = [];
  i = 0;
  while (i < 10)
    decodeLookup[48 + i] = i++;
  while (i < 16)
    decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
  var _Buffer = Buffer;
  var convertToHex = function(bytes) {
    return bytes.toString("hex");
  };
  ObjectID2.createFromHexString = function createFromHexString(string) {
    if (typeof string === "undefined" || string != null && string.length !== 24) {
      throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    }
    if (hasBufferType)
      return new ObjectID2(utils2.toBuffer(string, "hex"));
    var array = new _Buffer(12);
    var n = 0;
    var i2 = 0;
    while (i2 < 24) {
      array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
    }
    return new ObjectID2(array);
  };
  ObjectID2.isValid = function isValid(id) {
    if (id == null)
      return false;
    if (typeof id === "number") {
      return true;
    }
    if (typeof id === "string") {
      return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
    }
    if (id instanceof ObjectID2) {
      return true;
    }
    if (id instanceof _Buffer) {
      return true;
    }
    if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
      return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
    }
    return false;
  };
  Object.defineProperty(ObjectID2.prototype, "generationTime", {
    enumerable: true,
    get: function() {
      return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
    },
    set: function(value) {
      this.id[3] = value & 255;
      this.id[2] = value >> 8 & 255;
      this.id[1] = value >> 16 & 255;
      this.id[0] = value >> 24 & 255;
    }
  });
  module2.exports = ObjectID2;
  module2.exports.ObjectID = ObjectID2;
  module2.exports.ObjectId = ObjectID2;
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS((exports2, module2) => {
  function BSONRegExp2(pattern, options) {
    if (!(this instanceof BSONRegExp2))
      return new BSONRegExp2();
    this._bsontype = "BSONRegExp";
    this.pattern = pattern || "";
    this.options = options || "";
    for (var i = 0; i < this.options.length; i++) {
      if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
        throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
      }
    }
  }
  module2.exports = BSONRegExp2;
  module2.exports.BSONRegExp = BSONRegExp2;
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS((exports2, module2) => {
  var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
  function Symbol2(value) {
    if (!(this instanceof Symbol2))
      return new Symbol2(value);
    this._bsontype = "Symbol";
    this.value = value;
  }
  Symbol2.prototype.valueOf = function() {
    return this.value;
  };
  Symbol2.prototype.toString = function() {
    return this.value;
  };
  Symbol2.prototype[inspect] = function() {
    return this.value;
  };
  Symbol2.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Symbol2;
  module2.exports.Symbol = Symbol2;
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS((exports2, module2) => {
  var Int322 = function(value) {
    if (!(this instanceof Int322))
      return new Int322(value);
    this._bsontype = "Int32";
    this.value = value;
  };
  Int322.prototype.valueOf = function() {
    return this.value;
  };
  Int322.prototype.toJSON = function() {
    return this.value;
  };
  module2.exports = Int322;
  module2.exports.Int32 = Int322;
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS((exports2, module2) => {
  var Code2 = function Code3(code, scope) {
    if (!(this instanceof Code3))
      return new Code3(code, scope);
    this._bsontype = "Code";
    this.code = code;
    this.scope = scope;
  };
  Code2.prototype.toJSON = function() {
    return {scope: this.scope, code: this.code};
  };
  module2.exports = Code2;
  module2.exports.Code = Code2;
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_long2();
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = [
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var INF_NEGATIVE_BUFFER = [
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var INF_POSITIVE_BUFFER = [
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse();
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var utils2 = require_utils();
  var isDigit = function(value) {
    return !isNaN(parseInt(value, 10));
  };
  var divideu128 = function(value) {
    var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
    var _rem = Long2.fromNumber(0);
    var i = 0;
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return {quotient: value, rem: _rem};
    }
    for (i = 0; i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long2(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low_;
      _rem = _rem.modulo(DIVISOR);
    }
    return {quotient: value, rem: _rem};
  };
  var multiply64x2 = function(left, right) {
    if (!left && !right) {
      return {high: Long2.fromNumber(0), low: Long2.fromNumber(0)};
    }
    var leftHigh = left.shiftRightUnsigned(32);
    var leftLow = new Long2(left.getLowBits(), 0);
    var rightHigh = right.shiftRightUnsigned(32);
    var rightLow = new Long2(right.getLowBits(), 0);
    var productHigh = leftHigh.multiply(rightHigh);
    var productMid = leftHigh.multiply(rightLow);
    var productMid2 = leftLow.multiply(rightHigh);
    var productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
    return {high: productHigh, low: productLow};
  };
  var lessThan = function(left, right) {
    var uhleft = left.high_ >>> 0;
    var uhright = right.high_ >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      var ulleft = left.low_ >>> 0;
      var ulright = right.low_ >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  };
  var Decimal1282 = function(bytes) {
    this._bsontype = "Decimal128";
    this.bytes = bytes;
  };
  Decimal1282.fromString = function(string) {
    var isNegative = false;
    var sawRadix = false;
    var foundNonZero = false;
    var significantDigits = 0;
    var nDigitsRead = 0;
    var nDigits = 0;
    var radixPosition = 0;
    var firstNonZero = 0;
    var digits = [0];
    var nDigitsStored = 0;
    var digitsInsert = 0;
    var firstDigit = 0;
    var lastDigit = 0;
    var exponent = 0;
    var i = 0;
    var significandHigh = [0, 0];
    var significandLow = [0, 0];
    var biasedExponent = 0;
    var index = 0;
    string = string.trim();
    if (string.length >= 7e3) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    var stringMatch = string.match(PARSE_STRING_REGEXP);
    var infMatch = string.match(PARSE_INF_REGEXP);
    var nanMatch = string.match(PARSE_NAN_REGEXP);
    if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (string[index] === "+" || string[index] === "-") {
      isNegative = string[index++] === "-";
    }
    if (!isDigit(string[index]) && string[index] !== ".") {
      if (string[index] === "i" || string[index] === "I") {
        return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
      } else if (string[index] === "N") {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
    }
    while (isDigit(string[index]) || string[index] === ".") {
      if (string[index] === ".") {
        if (sawRadix) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        sawRadix = true;
        index = index + 1;
        continue;
      }
      if (nDigitsStored < 34) {
        if (string[index] !== "0" || foundNonZero) {
          if (!foundNonZero) {
            firstNonZero = nDigitsRead;
          }
          foundNonZero = true;
          digits[digitsInsert++] = parseInt(string[index], 10);
          nDigitsStored = nDigitsStored + 1;
        }
      }
      if (foundNonZero) {
        nDigits = nDigits + 1;
      }
      if (sawRadix) {
        radixPosition = radixPosition + 1;
      }
      nDigitsRead = nDigitsRead + 1;
      index = index + 1;
    }
    if (sawRadix && !nDigitsRead) {
      throw new Error("" + string + " not a valid Decimal128 string");
    }
    if (string[index] === "e" || string[index] === "E") {
      var match = string.substr(++index).match(EXPONENT_REGEX);
      if (!match || !match[2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      exponent = parseInt(match[0], 10);
      index = index + match[0].length;
    }
    if (string[index]) {
      return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
    }
    firstDigit = 0;
    if (!nDigitsStored) {
      firstDigit = 0;
      lastDigit = 0;
      digits[0] = 0;
      nDigits = 1;
      nDigitsStored = 1;
      significantDigits = 0;
    } else {
      lastDigit = nDigitsStored - 1;
      significantDigits = nDigits;
      if (exponent !== 0 && significantDigits !== 1) {
        while (string[firstNonZero + significantDigits - 1] === "0") {
          significantDigits = significantDigits - 1;
        }
      }
    }
    if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
      exponent = EXPONENT_MIN;
    } else {
      exponent = exponent - radixPosition;
    }
    while (exponent > EXPONENT_MAX) {
      lastDigit = lastDigit + 1;
      if (lastDigit - firstDigit > MAX_DIGITS) {
        var digitsString = digits.join("");
        if (digitsString.match(/^0+$/)) {
          exponent = EXPONENT_MAX;
          break;
        } else {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        }
      }
      exponent = exponent - 1;
    }
    while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
      if (lastDigit === 0) {
        exponent = EXPONENT_MIN;
        significantDigits = 0;
        break;
      }
      if (nDigitsStored < nDigits) {
        nDigits = nDigits - 1;
      } else {
        lastDigit = lastDigit - 1;
      }
      if (exponent < EXPONENT_MAX) {
        exponent = exponent + 1;
      } else {
        digitsString = digits.join("");
        if (digitsString.match(/^0+$/)) {
          exponent = EXPONENT_MAX;
          break;
        } else {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        }
      }
    }
    if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
      var endOfString = nDigitsRead;
      if (sawRadix && exponent === EXPONENT_MIN) {
        firstNonZero = firstNonZero + 1;
        endOfString = endOfString + 1;
      }
      var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
      var roundBit = 0;
      if (roundDigit >= 5) {
        roundBit = 1;
        if (roundDigit === 5) {
          roundBit = digits[lastDigit] % 2 === 1;
          for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
            if (parseInt(string[i], 10)) {
              roundBit = 1;
              break;
            }
          }
        }
      }
      if (roundBit) {
        var dIdx = lastDigit;
        for (; dIdx >= 0; dIdx--) {
          if (++digits[dIdx] > 9) {
            digits[dIdx] = 0;
            if (dIdx === 0) {
              if (exponent < EXPONENT_MAX) {
                exponent = exponent + 1;
                digits[dIdx] = 1;
              } else {
                return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
              }
            }
          } else {
            break;
          }
        }
      }
    }
    significandHigh = Long2.fromNumber(0);
    significandLow = Long2.fromNumber(0);
    if (significantDigits === 0) {
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
    } else if (lastDigit - firstDigit < 17) {
      dIdx = firstDigit;
      significandLow = Long2.fromNumber(digits[dIdx++]);
      significandHigh = new Long2(0, 0);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long2.fromNumber(10));
        significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
      }
    } else {
      dIdx = firstDigit;
      significandHigh = Long2.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit - 17; dIdx++) {
        significandHigh = significandHigh.multiply(Long2.fromNumber(10));
        significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
      }
      significandLow = Long2.fromNumber(digits[dIdx++]);
      for (; dIdx <= lastDigit; dIdx++) {
        significandLow = significandLow.multiply(Long2.fromNumber(10));
        significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
      }
    }
    var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
    significand.low = significand.low.add(significandLow);
    if (lessThan(significand.low, significandLow)) {
      significand.high = significand.high.add(Long2.fromNumber(1));
    }
    biasedExponent = exponent + EXPONENT_BIAS;
    var dec = {low: Long2.fromNumber(0), high: Long2.fromNumber(0)};
    if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
      dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
      dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
      dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
    } else {
      dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
      dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
    }
    dec.low = significand.low;
    if (isNegative) {
      dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
    }
    var buffer = utils2.allocBuffer(16);
    index = 0;
    buffer[index++] = dec.low.low_ & 255;
    buffer[index++] = dec.low.low_ >> 8 & 255;
    buffer[index++] = dec.low.low_ >> 16 & 255;
    buffer[index++] = dec.low.low_ >> 24 & 255;
    buffer[index++] = dec.low.high_ & 255;
    buffer[index++] = dec.low.high_ >> 8 & 255;
    buffer[index++] = dec.low.high_ >> 16 & 255;
    buffer[index++] = dec.low.high_ >> 24 & 255;
    buffer[index++] = dec.high.low_ & 255;
    buffer[index++] = dec.high.low_ >> 8 & 255;
    buffer[index++] = dec.high.low_ >> 16 & 255;
    buffer[index++] = dec.high.low_ >> 24 & 255;
    buffer[index++] = dec.high.high_ & 255;
    buffer[index++] = dec.high.high_ >> 8 & 255;
    buffer[index++] = dec.high.high_ >> 16 & 255;
    buffer[index++] = dec.high.high_ >> 24 & 255;
    return new Decimal1282(buffer);
  };
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;
  EXPONENT_BIAS = 6176;
  Decimal1282.prototype.toString = function() {
    var high;
    var midh;
    var midl;
    var low;
    var combination;
    var biased_exponent;
    var significand_digits = 0;
    var significand = new Array(36);
    for (var i = 0; i < significand.length; i++)
      significand[i] = 0;
    var index = 0;
    var exponent;
    var scientific_exponent;
    var is_zero = false;
    var significand_msb;
    var significand128 = {parts: new Array(4)};
    i;
    var j, k;
    var string = [];
    index = 0;
    var buffer = this.bytes;
    low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    index = 0;
    var dec = {
      low: new Long2(low, midl),
      high: new Long2(midh, high)
    };
    if (dec.high.lessThan(Long2.ZERO)) {
      string.push("-");
    }
    combination = high >> 26 & COMBINATION_MASK;
    if (combination >> 3 === 3) {
      if (combination === COMBINATION_INFINITY) {
        return string.join("") + "Infinity";
      } else if (combination === COMBINATION_NAN) {
        return "NaN";
      } else {
        biased_exponent = high >> 15 & EXPONENT_MASK;
        significand_msb = 8 + (high >> 14 & 1);
      }
    } else {
      significand_msb = high >> 14 & 7;
      biased_exponent = high >> 17 & EXPONENT_MASK;
    }
    exponent = biased_exponent - EXPONENT_BIAS;
    significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
    significand128.parts[1] = midh;
    significand128.parts[2] = midl;
    significand128.parts[3] = low;
    if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
      is_zero = true;
    } else {
      for (k = 3; k >= 0; k--) {
        var least_digits = 0;
        var result = divideu128(significand128);
        significand128 = result.quotient;
        least_digits = result.rem.low_;
        if (!least_digits)
          continue;
        for (j = 8; j >= 0; j--) {
          significand[k * 9 + j] = least_digits % 10;
          least_digits = Math.floor(least_digits / 10);
        }
      }
    }
    if (is_zero) {
      significand_digits = 1;
      significand[index] = 0;
    } else {
      significand_digits = 36;
      i = 0;
      while (!significand[index]) {
        i++;
        significand_digits = significand_digits - 1;
        index = index + 1;
      }
    }
    scientific_exponent = significand_digits - 1 + exponent;
    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
      string.push(significand[index++]);
      significand_digits = significand_digits - 1;
      if (significand_digits) {
        string.push(".");
      }
      for (i = 0; i < significand_digits; i++) {
        string.push(significand[index++]);
      }
      string.push("E");
      if (scientific_exponent > 0) {
        string.push("+" + scientific_exponent);
      } else {
        string.push(scientific_exponent);
      }
    } else {
      if (exponent >= 0) {
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index++]);
        }
      } else {
        var radix_position = significand_digits + exponent;
        if (radix_position > 0) {
          for (i = 0; i < radix_position; i++) {
            string.push(significand[index++]);
          }
        } else {
          string.push("0");
        }
        string.push(".");
        while (radix_position++ < 0) {
          string.push("0");
        }
        for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
          string.push(significand[index++]);
        }
      }
    }
    return string.join("");
  };
  Decimal1282.prototype.toJSON = function() {
    return {$numberDecimal: this.toString()};
  };
  module2.exports = Decimal1282;
  module2.exports.Decimal128 = Decimal1282;
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS((exports2, module2) => {
  function MinKey2() {
    if (!(this instanceof MinKey2))
      return new MinKey2();
    this._bsontype = "MinKey";
  }
  module2.exports = MinKey2;
  module2.exports.MinKey = MinKey2;
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS((exports2, module2) => {
  function MaxKey2() {
    if (!(this instanceof MaxKey2))
      return new MaxKey2();
    this._bsontype = "MaxKey";
  }
  module2.exports = MaxKey2;
  module2.exports.MaxKey = MaxKey2;
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS((exports2, module2) => {
  function DBRef2(namespace, oid, db) {
    if (!(this instanceof DBRef2))
      return new DBRef2(namespace, oid, db);
    this._bsontype = "DBRef";
    this.namespace = namespace;
    this.oid = oid;
    this.db = db;
  }
  DBRef2.prototype.toJSON = function() {
    return {
      $ref: this.namespace,
      $id: this.oid,
      $db: this.db == null ? "" : this.db
    };
  };
  module2.exports = DBRef2;
  module2.exports.DBRef = DBRef2;
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS((exports2, module2) => {
  if (typeof global !== "undefined") {
    Buffer2 = require("buffer").Buffer;
  }
  var Buffer2;
  var utils2 = require_utils();
  function Binary2(buffer, subType) {
    if (!(this instanceof Binary2))
      return new Binary2(buffer, subType);
    if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
      throw new Error("only String, Buffer, Uint8Array or Array accepted");
    }
    this._bsontype = "Binary";
    if (buffer instanceof Number) {
      this.sub_type = buffer;
      this.position = 0;
    } else {
      this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
      this.position = 0;
    }
    if (buffer != null && !(buffer instanceof Number)) {
      if (typeof buffer === "string") {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.toBuffer(buffer);
        } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
          this.buffer = writeStringToArray(buffer);
        } else {
          throw new Error("only String, Buffer, Uint8Array or Array accepted");
        }
      } else {
        this.buffer = buffer;
      }
      this.position = buffer.length;
    } else {
      if (typeof Buffer2 !== "undefined") {
        this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
      } else if (typeof Uint8Array !== "undefined") {
        this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
      } else {
        this.buffer = new Array(Binary2.BUFFER_SIZE);
      }
      this.position = 0;
    }
  }
  Binary2.prototype.put = function put(byte_value) {
    if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
      throw new Error("only accepts single character String, Uint8Array or Array");
    if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
      throw new Error("only accepts number in a valid unsigned byte range 0-255");
    var decoded_byte = null;
    if (typeof byte_value === "string") {
      decoded_byte = byte_value.charCodeAt(0);
    } else if (byte_value["length"] != null) {
      decoded_byte = byte_value[0];
    } else {
      decoded_byte = byte_value;
    }
    if (this.buffer.length > this.position) {
      this.buffer[this.position++] = decoded_byte;
    } else {
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
        this.buffer = buffer;
        this.buffer[this.position++] = decoded_byte;
      } else {
        buffer = null;
        if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
        } else {
          buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
        }
        for (var i = 0; i < this.buffer.length; i++) {
          buffer[i] = this.buffer[i];
        }
        this.buffer = buffer;
        this.buffer[this.position++] = decoded_byte;
      }
    }
  };
  Binary2.prototype.write = function write(string, offset) {
    offset = typeof offset === "number" ? offset : this.position;
    if (this.buffer.length < offset + string.length) {
      var buffer = null;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        buffer = utils2.allocBuffer(this.buffer.length + string.length);
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
      } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
        buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
        for (var i = 0; i < this.position; i++) {
          buffer[i] = this.buffer[i];
        }
      }
      this.buffer = buffer;
    }
    if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
      string.copy(this.buffer, offset, 0, string.length);
      this.position = offset + string.length > this.position ? offset + string.length : this.position;
    } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
      this.buffer.write(string, offset, "binary");
      this.position = offset + string.length > this.position ? offset + string.length : this.position;
    } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
      for (i = 0; i < string.length; i++) {
        this.buffer[offset++] = string[i];
      }
      this.position = offset > this.position ? offset : this.position;
    } else if (typeof string === "string") {
      for (i = 0; i < string.length; i++) {
        this.buffer[offset++] = string.charCodeAt(i);
      }
      this.position = offset > this.position ? offset : this.position;
    }
  };
  Binary2.prototype.read = function read(position, length) {
    length = length && length > 0 ? length : this.position;
    if (this.buffer["slice"]) {
      return this.buffer.slice(position, position + length);
    } else {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
      for (var i = 0; i < length; i++) {
        buffer[i] = this.buffer[position++];
      }
    }
    return buffer;
  };
  Binary2.prototype.value = function value(asRaw) {
    asRaw = asRaw == null ? false : asRaw;
    if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
      return this.buffer;
    if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
      return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
    } else {
      if (asRaw) {
        if (this.buffer["slice"] != null) {
          return this.buffer.slice(0, this.position);
        } else {
          var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
          for (var i = 0; i < this.position; i++) {
            newBuffer[i] = this.buffer[i];
          }
          return newBuffer;
        }
      } else {
        return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
      }
    }
  };
  Binary2.prototype.length = function length() {
    return this.position;
  };
  Binary2.prototype.toJSON = function() {
    return this.buffer != null ? this.buffer.toString("base64") : "";
  };
  Binary2.prototype.toString = function(format) {
    return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : "";
  };
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var writeStringToArray = function(data) {
    var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      buffer[i] = data.charCodeAt(i);
    }
    return buffer;
  };
  var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
    var result = "";
    for (var i = startIndex; i < endIndex; i++) {
      result = result + String.fromCharCode(byteArray[i]);
    }
    return result;
  };
  Binary2.BUFFER_SIZE = 256;
  Binary2.SUBTYPE_DEFAULT = 0;
  Binary2.SUBTYPE_FUNCTION = 1;
  Binary2.SUBTYPE_BYTE_ARRAY = 2;
  Binary2.SUBTYPE_UUID_OLD = 3;
  Binary2.SUBTYPE_UUID = 4;
  Binary2.SUBTYPE_MD5 = 5;
  Binary2.SUBTYPE_USER_DEFINED = 128;
  module2.exports = Binary2;
  module2.exports.Binary = Binary2;
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS((exports, module) => {
  "use strict";
  var Long = require_long2().Long;
  var Double = require_double().Double;
  var Timestamp = require_timestamp().Timestamp;
  var ObjectID = require_objectid().ObjectID;
  var Symbol = require_symbol().Symbol;
  var Code = require_code().Code;
  var MinKey = require_min_key().MinKey;
  var MaxKey = require_max_key().MaxKey;
  var Decimal128 = require_decimal128();
  var Int32 = require_int_32();
  var DBRef = require_db_ref().DBRef;
  var BSONRegExp = require_regexp().BSONRegExp;
  var Binary = require_binary().Binary;
  var utils = require_utils();
  var deserialize = function(buffer, options, isArray) {
    options = options == null ? {} : options;
    var index = options && options.index ? options.index : 0;
    var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
    if (size < 5 || buffer.length < size || size + index > buffer.length) {
      throw new Error("corrupt bson message");
    }
    if (buffer[index + size - 1] !== 0) {
      throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer, index, options, isArray);
  };
  var deserializeObject = function(buffer, index, options, isArray) {
    var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
    var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
    var cacheFunctionsCrc32 = options["cacheFunctionsCrc32"] == null ? false : options["cacheFunctionsCrc32"];
    if (!cacheFunctionsCrc32)
      var crc32 = null;
    var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    var raw = options["raw"] == null ? false : options["raw"];
    var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
    var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
    var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
    var startIndex = index;
    if (buffer.length < 5)
      throw new Error("corrupt bson message < 5 bytes long");
    var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    if (size < 5 || size > buffer.length)
      throw new Error("corrupt bson message");
    var object = isArray ? [] : {};
    var arrayIndex = 0;
    var done = false;
    while (!done) {
      var elementType = buffer[index++];
      if (elementType === 0)
        break;
      var i = index;
      while (buffer[i] !== 0 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length)
        throw new Error("Bad BSON Document: illegal CString");
      var name = isArray ? arrayIndex++ : buffer.toString("utf8", index, i);
      index = i + 1;
      if (elementType === BSON.BSON_DATA_STRING) {
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        object[name] = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_OID) {
        var oid = utils.allocBuffer(12);
        buffer.copy(oid, 0, index, index + 12);
        object[name] = new ObjectID(oid);
        index = index + 12;
      } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
        object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
      } else if (elementType === BSON.BSON_DATA_INT) {
        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
        object[name] = new Double(buffer.readDoubleLE(index));
        index = index + 8;
      } else if (elementType === BSON.BSON_DATA_NUMBER) {
        object[name] = buffer.readDoubleLE(index);
        index = index + 8;
      } else if (elementType === BSON.BSON_DATA_DATE) {
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        object[name] = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
        if (buffer[index] !== 0 && buffer[index] !== 1)
          throw new Error("illegal boolean type value");
        object[name] = buffer[index++] === 1;
      } else if (elementType === BSON.BSON_DATA_OBJECT) {
        var _index = index;
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        if (objectSize <= 0 || objectSize > buffer.length - index)
          throw new Error("bad embedded document length in bson");
        if (raw) {
          object[name] = buffer.slice(index, index + objectSize);
        } else {
          object[name] = deserializeObject(buffer, _index, options, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON.BSON_DATA_ARRAY) {
        _index = index;
        objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        var arrayOptions = options;
        var stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = {};
          for (var n in options)
            arrayOptions[n] = options[n];
          arrayOptions["raw"] = true;
        }
        object[name] = deserializeObject(buffer, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer[index - 1] !== 0)
          throw new Error("invalid array terminator byte");
        if (index !== stopIndex)
          throw new Error("corrupted array bson");
      } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
        object[name] = void 0;
      } else if (elementType === BSON.BSON_DATA_NULL) {
        object[name] = null;
      } else if (elementType === BSON.BSON_DATA_LONG) {
        lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var long = new Long(lowBits, highBits);
        if (promoteLongs && promoteValues === true) {
          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          object[name] = long;
        }
      } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
        var bytes = utils.allocBuffer(16);
        buffer.copy(bytes, 0, index, index + 16);
        index = index + 16;
        var decimal128 = new Decimal128(bytes);
        object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
      } else if (elementType === BSON.BSON_DATA_BINARY) {
        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var totalBinarySize = binarySize;
        var subType = buffer[index++];
        if (binarySize < 0)
          throw new Error("Negative binary type element size found");
        if (binarySize > buffer.length)
          throw new Error("Binary type size larger than document size");
        if (buffer["slice"] != null) {
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
            if (binarySize < 0)
              throw new Error("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to short binary size");
          }
          if (promoteBuffers && promoteValues) {
            object[name] = buffer.slice(index, index + binarySize);
          } else {
            object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
          }
        } else {
          var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
            if (binarySize < 0)
              throw new Error("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new Error("Binary type with subtype 0x02 contains to short binary size");
          }
          for (i = 0; i < binarySize; i++) {
            _buffer[i] = buffer[index + i];
          }
          if (promoteBuffers && promoteValues) {
            object[name] = _buffer;
          } else {
            object[name] = new Binary(_buffer, subType);
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var source = buffer.toString("utf8", index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var regExpOptions = buffer.toString("utf8", index, i);
        index = i + 1;
        var optionsArray = new Array(regExpOptions.length);
        for (i = 0; i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        object[name] = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        source = buffer.toString("utf8", index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        regExpOptions = buffer.toString("utf8", index, i);
        index = i + 1;
        object[name] = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON.BSON_DATA_SYMBOL) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        object[name] = new Symbol(buffer.toString("utf8", index, index + stringSize - 1));
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
        lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        object[name] = new Timestamp(lowBits, highBits);
      } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
        object[name] = new MinKey();
      } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
        object[name] = new MaxKey();
      } else if (elementType === BSON.BSON_DATA_CODE) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        var functionString = buffer.toString("utf8", index, index + stringSize - 1);
        if (evalFunctions) {
          if (cacheFunctions) {
            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            object[name] = isolateEval(functionString);
          }
        } else {
          object[name] = new Code(functionString);
        }
        index = index + stringSize;
      } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new Error("code_w_scope total size shorter minimum expected length");
        }
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        functionString = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
        _index = index;
        objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        var scopeObject = deserializeObject(buffer, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new Error("code_w_scope total size is to short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new Error("code_w_scope total size is to long, clips outer document");
        }
        if (evalFunctions) {
          if (cacheFunctions) {
            hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            object[name] = isolateEval(functionString);
          }
          object[name].scope = scopeObject;
        } else {
          object[name] = new Code(functionString, scopeObject);
        }
      } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
        stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
          throw new Error("bad string length in bson");
        var namespace = buffer.toString("utf8", index, index + stringSize - 1);
        index = index + stringSize;
        var oidBuffer = utils.allocBuffer(12);
        buffer.copy(oidBuffer, 0, index, index + 12);
        oid = new ObjectID(oidBuffer);
        index = index + 12;
        var parts = namespace.split(".");
        var db = parts.shift();
        var collection = parts.join(".");
        object[name] = new DBRef(collection, oid, db);
      } else {
        throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser');
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new Error("corrupt array bson");
      throw new Error("corrupt object bson");
    }
    if (object["$id"] != null)
      object = new DBRef(object["$ref"], object["$id"], object["$db"]);
    return object;
  };
  var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
    var value = null;
    if (functionCache[hash] == null) {
      eval("value = " + functionString);
      functionCache[hash] = value;
    }
    return functionCache[hash].bind(object);
  };
  var isolateEval = function(functionString) {
    var value = null;
    eval("value = " + functionString);
    return value;
  };
  var BSON = {};
  var functionCache = BSON.functionCache = {};
  BSON.BSON_DATA_NUMBER = 1;
  BSON.BSON_DATA_STRING = 2;
  BSON.BSON_DATA_OBJECT = 3;
  BSON.BSON_DATA_ARRAY = 4;
  BSON.BSON_DATA_BINARY = 5;
  BSON.BSON_DATA_UNDEFINED = 6;
  BSON.BSON_DATA_OID = 7;
  BSON.BSON_DATA_BOOLEAN = 8;
  BSON.BSON_DATA_DATE = 9;
  BSON.BSON_DATA_NULL = 10;
  BSON.BSON_DATA_REGEXP = 11;
  BSON.BSON_DATA_DBPOINTER = 12;
  BSON.BSON_DATA_CODE = 13;
  BSON.BSON_DATA_SYMBOL = 14;
  BSON.BSON_DATA_CODE_W_SCOPE = 15;
  BSON.BSON_DATA_INT = 16;
  BSON.BSON_DATA_TIMESTAMP = 17;
  BSON.BSON_DATA_LONG = 18;
  BSON.BSON_DATA_DECIMAL128 = 19;
  BSON.BSON_DATA_MIN_KEY = 255;
  BSON.BSON_DATA_MAX_KEY = 127;
  BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  BSON.BSON_INT32_MAX = 2147483647;
  BSON.BSON_INT32_MIN = -2147483648;
  BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON.JS_INT_MAX = 9007199254740992;
  BSON.JS_INT_MIN = -9007199254740992;
  var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
  var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
  module.exports = deserialize;
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS((exports2) => {
  var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
    var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
      ;
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
    var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
      ;
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
      ;
    buffer[offset + i - d] |= s * 128;
  };
  exports2.readIEEE754 = readIEEE754;
  exports2.writeIEEE754 = writeIEEE754;
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS((exports2, module2) => {
  "use strict";
  var writeIEEE754 = require_float_parser().writeIEEE754;
  var Long2 = require_long2().Long;
  var Map2 = require_map();
  var Binary2 = require_binary().Binary;
  var normalizedFunctionString = require_utils().normalizedFunctionString;
  var regexp = /\x00/;
  var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
  var isDate = function isDate2(d) {
    return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
  };
  var isRegExp = function isRegExp2(d) {
    return Object.prototype.toString.call(d) === "[object RegExp]";
  };
  var serializeString = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_STRING;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes + 1;
    buffer[index - 1] = 0;
    var size = buffer.write(value, index + 4, "utf8");
    buffer[index + 3] = size + 1 >> 24 & 255;
    buffer[index + 2] = size + 1 >> 16 & 255;
    buffer[index + 1] = size + 1 >> 8 & 255;
    buffer[index] = size + 1 & 255;
    index = index + 4 + size;
    buffer[index++] = 0;
    return index;
  };
  var serializeNumber = function(buffer, key, value, index, isArray) {
    if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
      if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
        buffer[index++] = BSON2.BSON_DATA_INT;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        buffer[index++] = value & 255;
        buffer[index++] = value >> 8 & 255;
        buffer[index++] = value >> 16 & 255;
        buffer[index++] = value >> 24 & 255;
      } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        buffer[index++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        writeIEEE754(buffer, value, index, "little", 52, 8);
        index = index + 8;
      } else {
        buffer[index++] = BSON2.BSON_DATA_LONG;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var longVal = Long2.fromNumber(value);
        var lowBits = longVal.getLowBits();
        var highBits = longVal.getHighBits();
        buffer[index++] = lowBits & 255;
        buffer[index++] = lowBits >> 8 & 255;
        buffer[index++] = lowBits >> 16 & 255;
        buffer[index++] = lowBits >> 24 & 255;
        buffer[index++] = highBits & 255;
        buffer[index++] = highBits >> 8 & 255;
        buffer[index++] = highBits >> 16 & 255;
        buffer[index++] = highBits >> 24 & 255;
      }
    } else {
      buffer[index++] = BSON2.BSON_DATA_NUMBER;
      numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value, index, "little", 52, 8);
      index = index + 8;
    }
    return index;
  };
  var serializeNull = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_NULL;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  };
  var serializeBoolean = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BOOLEAN;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value ? 1 : 0;
    return index;
  };
  var serializeDate = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_DATE;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var dateInMilis = Long2.fromNumber(value.getTime());
    var lowBits = dateInMilis.getLowBits();
    var highBits = dateInMilis.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = lowBits >> 8 & 255;
    buffer[index++] = lowBits >> 16 & 255;
    buffer[index++] = lowBits >> 24 & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = highBits >> 8 & 255;
    buffer[index++] = highBits >> 16 & 255;
    buffer[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeRegExp = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw Error("value " + value.source + " must not contain null bytes");
    }
    index = index + buffer.write(value.source, index, "utf8");
    buffer[index++] = 0;
    if (value.global)
      buffer[index++] = 115;
    if (value.ignoreCase)
      buffer[index++] = 105;
    if (value.multiline)
      buffer[index++] = 109;
    buffer[index++] = 0;
    return index;
  };
  var serializeBSONRegExp = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw Error("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + buffer.write(value.pattern, index, "utf8");
    buffer[index++] = 0;
    index = index + buffer.write(value.options.split("").sort().join(""), index, "utf8");
    buffer[index++] = 0;
    return index;
  };
  var serializeMinMax = function(buffer, key, value, index, isArray) {
    if (value === null) {
      buffer[index++] = BSON2.BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer[index++] = BSON2.BSON_DATA_MIN_KEY;
    } else {
      buffer[index++] = BSON2.BSON_DATA_MAX_KEY;
    }
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  };
  var serializeObjectId = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_OID;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (typeof value.id === "string") {
      buffer.write(value.id, index, "binary");
    } else if (value.id && value.id.copy) {
      value.id.copy(buffer, index, 0, 12);
    } else {
      throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
    }
    return index + 12;
  };
  var serializeBuffer = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = value.length;
    buffer[index++] = size & 255;
    buffer[index++] = size >> 8 & 255;
    buffer[index++] = size >> 16 & 255;
    buffer[index++] = size >> 24 & 255;
    buffer[index++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
    value.copy(buffer, index, 0, size);
    index = index + size;
    return index;
  };
  var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
    for (var i = 0; i < path.length; i++) {
      if (path[i] === value)
        throw new Error("cyclic dependency detected");
    }
    path.push(value);
    buffer[index++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.pop();
    return endIndex;
  };
  var serializeDecimal128 = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_DECIMAL128;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    value.bytes.copy(buffer, index, 0, 16);
    return index + 16;
  };
  var serializeLong = function(buffer, key, value, index, isArray) {
    buffer[index++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var lowBits = value.getLowBits();
    var highBits = value.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = lowBits >> 8 & 255;
    buffer[index++] = lowBits >> 16 & 255;
    buffer[index++] = lowBits >> 24 & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = highBits >> 8 & 255;
    buffer[index++] = highBits >> 16 & 255;
    buffer[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeInt32 = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_INT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value & 255;
    buffer[index++] = value >> 8 & 255;
    buffer[index++] = value >> 16 & 255;
    buffer[index++] = value >> 24 & 255;
    return index;
  };
  var serializeDouble = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_NUMBER;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    writeIEEE754(buffer, value, index, "little", 52, 8);
    index = index + 8;
    return index;
  };
  var serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {
    buffer[index++] = BSON2.BSON_DATA_CODE;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var functionString = normalizedFunctionString(value);
    var size = buffer.write(functionString, index + 4, "utf8") + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = size >> 8 & 255;
    buffer[index + 2] = size >> 16 & 255;
    buffer[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  };
  var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
    if (value.scope && typeof value.scope === "object") {
      buffer[index++] = BSON2.BSON_DATA_CODE_W_SCOPE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var functionString = typeof value.code === "string" ? value.code : value.code.toString();
      index = index + 4;
      var codeSize = buffer.write(functionString, index + 4, "utf8") + 1;
      buffer[index] = codeSize & 255;
      buffer[index + 1] = codeSize >> 8 & 255;
      buffer[index + 2] = codeSize >> 16 & 255;
      buffer[index + 3] = codeSize >> 24 & 255;
      buffer[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
      index = endIndex - 1;
      var totalSize = endIndex - startIndex;
      buffer[startIndex++] = totalSize & 255;
      buffer[startIndex++] = totalSize >> 8 & 255;
      buffer[startIndex++] = totalSize >> 16 & 255;
      buffer[startIndex++] = totalSize >> 24 & 255;
      buffer[index++] = 0;
    } else {
      buffer[index++] = BSON2.BSON_DATA_CODE;
      numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      functionString = value.code.toString();
      var size = buffer.write(functionString, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
    }
    return index;
  };
  var serializeBinary = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var data = value.value(true);
    var size = value.position;
    if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    buffer[index++] = size & 255;
    buffer[index++] = size >> 8 & 255;
    buffer[index++] = size >> 16 & 255;
    buffer[index++] = size >> 24 & 255;
    buffer[index++] = value.sub_type;
    if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
    }
    data.copy(buffer, index, 0, value.position);
    index = index + value.position;
    return index;
  };
  var serializeSymbol = function(buffer, key, value, index, isArray) {
    buffer[index++] = BSON2.BSON_DATA_SYMBOL;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = buffer.write(value.value, index + 4, "utf8") + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = size >> 8 & 255;
    buffer[index + 2] = size >> 16 & 255;
    buffer[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  };
  var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {
    buffer[index++] = BSON2.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var endIndex;
    if (value.db != null) {
      endIndex = serializeInto(buffer, {
        $ref: value.namespace,
        $id: value.oid,
        $db: value.db
      }, false, index, depth + 1, serializeFunctions);
    } else {
      endIndex = serializeInto(buffer, {
        $ref: value.namespace,
        $id: value.oid
      }, false, index, depth + 1, serializeFunctions);
    }
    var size = endIndex - startIndex;
    buffer[startIndex++] = size & 255;
    buffer[startIndex++] = size >> 8 & 255;
    buffer[startIndex++] = size >> 16 & 255;
    buffer[startIndex++] = size >> 24 & 255;
    return endIndex;
  };
  var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    startingIndex = startingIndex || 0;
    path = path || [];
    path.push(object);
    var index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        var key = "" + i;
        var value = object[i];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== "function")
            throw new Error("toBSON is not a function");
          value = value.toBSON();
        }
        var type = typeof value;
        if (type === "string") {
          index = serializeString(buffer, key, value, index, true);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index, true);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index, true);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index, true);
        } else if (value === void 0) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index, true);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index, true);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index, true);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index, true);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index, true);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index, true);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    } else if (object instanceof Map2) {
      var iterator = object.entries();
      var done = false;
      while (!done) {
        var entry = iterator.next();
        done = entry.done;
        if (done)
          continue;
        key = entry.value[0];
        value = entry.value[1];
        type = typeof value;
        if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
          if (key.match(regexp) != null) {
            throw Error("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw Error("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw Error("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (value === null || value === void 0 && ignoreUndefined === false) {
          index = serializeNull(buffer, key, value, index);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    } else {
      if (object.toBSON) {
        if (typeof object.toBSON !== "function")
          throw new Error("toBSON is not a function");
        object = object.toBSON();
        if (object != null && typeof object !== "object")
          throw new Error("toBSON function did not return an object");
      }
      for (key in object) {
        value = object[key];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== "function")
            throw new Error("toBSON is not a function");
          value = value.toBSON();
        }
        type = typeof value;
        if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
          if (key.match(regexp) != null) {
            throw Error("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw Error("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw Error("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (value === void 0) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index);
        } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          index = serializeObjectId(buffer, key, value, index);
        } else if (Buffer.isBuffer(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === "object" && value["_bsontype"] == null) {
          index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
        } else if (type === "object" && value["_bsontype"] === "Decimal128") {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
          index = serializeLong(buffer, key, value, index);
        } else if (value["_bsontype"] === "Double") {
          index = serializeDouble(buffer, key, value, index);
        } else if (value["_bsontype"] === "Code") {
          index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
        } else if (value["_bsontype"] === "Binary") {
          index = serializeBinary(buffer, key, value, index);
        } else if (value["_bsontype"] === "Symbol") {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value["_bsontype"] === "DBRef") {
          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
        } else if (value["_bsontype"] === "BSONRegExp") {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value["_bsontype"] === "Int32") {
          index = serializeInt32(buffer, key, value, index);
        } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value["_bsontype"] !== "undefined") {
          throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
        }
      }
    }
    path.pop();
    buffer[index++] = 0;
    var size = index - startingIndex;
    buffer[startingIndex++] = size & 255;
    buffer[startingIndex++] = size >> 8 & 255;
    buffer[startingIndex++] = size >> 16 & 255;
    buffer[startingIndex++] = size >> 24 & 255;
    return index;
  };
  var BSON2 = {};
  BSON2.BSON_DATA_NUMBER = 1;
  BSON2.BSON_DATA_STRING = 2;
  BSON2.BSON_DATA_OBJECT = 3;
  BSON2.BSON_DATA_ARRAY = 4;
  BSON2.BSON_DATA_BINARY = 5;
  BSON2.BSON_DATA_UNDEFINED = 6;
  BSON2.BSON_DATA_OID = 7;
  BSON2.BSON_DATA_BOOLEAN = 8;
  BSON2.BSON_DATA_DATE = 9;
  BSON2.BSON_DATA_NULL = 10;
  BSON2.BSON_DATA_REGEXP = 11;
  BSON2.BSON_DATA_CODE = 13;
  BSON2.BSON_DATA_SYMBOL = 14;
  BSON2.BSON_DATA_CODE_W_SCOPE = 15;
  BSON2.BSON_DATA_INT = 16;
  BSON2.BSON_DATA_TIMESTAMP = 17;
  BSON2.BSON_DATA_LONG = 18;
  BSON2.BSON_DATA_DECIMAL128 = 19;
  BSON2.BSON_DATA_MIN_KEY = 255;
  BSON2.BSON_DATA_MAX_KEY = 127;
  BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  module2.exports = serializeInto;
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_long2().Long;
  var Double2 = require_double().Double;
  var Timestamp2 = require_timestamp().Timestamp;
  var ObjectID2 = require_objectid().ObjectID;
  var Symbol2 = require_symbol().Symbol;
  var BSONRegExp2 = require_regexp().BSONRegExp;
  var Code2 = require_code().Code;
  var Decimal1282 = require_decimal128();
  var MinKey2 = require_min_key().MinKey;
  var MaxKey2 = require_max_key().MaxKey;
  var DBRef2 = require_db_ref().DBRef;
  var Binary2 = require_binary().Binary;
  var normalizedFunctionString = require_utils().normalizedFunctionString;
  var isDate = function isDate2(d) {
    return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
  };
  var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
    var totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (object.toBSON) {
        object = object.toBSON();
      }
      for (var key in object) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  };
  function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
    if (value && value.toBSON) {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
      case "number":
        if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
      case "object":
        if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
        } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
        } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
        } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
        } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
          }
        } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
          if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
          }
        } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
        } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
          var ordered_values = {
            $ref: value.namespace,
            $id: value.oid
          };
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
        } else {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else {
          if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else if (serializeFunctions) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
          }
        }
    }
    return 0;
  }
  var BSON2 = {};
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  module2.exports = calculateObjectSize;
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS((exports2, module2) => {
  "use strict";
  var Map2 = require_map();
  var Long2 = require_long2();
  var Double2 = require_double();
  var Timestamp2 = require_timestamp();
  var ObjectID2 = require_objectid();
  var BSONRegExp2 = require_regexp();
  var Symbol2 = require_symbol();
  var Int322 = require_int_32();
  var Code2 = require_code();
  var Decimal1282 = require_decimal128();
  var MinKey2 = require_min_key();
  var MaxKey2 = require_max_key();
  var DBRef2 = require_db_ref();
  var Binary2 = require_binary();
  var deserialize2 = require_deserializer();
  var serializer = require_serializer();
  var calculateObjectSize = require_calculate_size();
  var utils2 = require_utils();
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = utils2.allocBuffer(MAXSIZE);
  var BSON2 = function() {
  };
  BSON2.prototype.serialize = function serialize(object, options) {
    options = options || {};
    var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = utils2.allocBuffer(minInternalBufferSize);
    }
    var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
    var finishedBuffer = utils2.allocBuffer(serializationIndex);
    buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
    return finishedBuffer;
  };
  BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options) {
    options = options || {};
    var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    var startIndex = typeof options.index === "number" ? options.index : 0;
    var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
    return serializationIndex - 1;
  };
  BSON2.prototype.deserialize = function(buffer2, options) {
    return deserialize2(buffer2, options);
  };
  BSON2.prototype.calculateObjectSize = function(object, options) {
    options = options || {};
    var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
  };
  BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    options = options != null ? options : {};
    var index = startIndex;
    for (var i = 0; i < numberOfDocuments; i++) {
      var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
      options["index"] = index;
      documents[docStartIndex + i] = this.deserialize(data, options);
      index = index + size;
    }
    return index;
  };
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  BSON2.BSON_DATA_NUMBER = 1;
  BSON2.BSON_DATA_STRING = 2;
  BSON2.BSON_DATA_OBJECT = 3;
  BSON2.BSON_DATA_ARRAY = 4;
  BSON2.BSON_DATA_BINARY = 5;
  BSON2.BSON_DATA_OID = 7;
  BSON2.BSON_DATA_BOOLEAN = 8;
  BSON2.BSON_DATA_DATE = 9;
  BSON2.BSON_DATA_NULL = 10;
  BSON2.BSON_DATA_REGEXP = 11;
  BSON2.BSON_DATA_CODE = 13;
  BSON2.BSON_DATA_SYMBOL = 14;
  BSON2.BSON_DATA_CODE_W_SCOPE = 15;
  BSON2.BSON_DATA_INT = 16;
  BSON2.BSON_DATA_TIMESTAMP = 17;
  BSON2.BSON_DATA_LONG = 18;
  BSON2.BSON_DATA_MIN_KEY = 255;
  BSON2.BSON_DATA_MAX_KEY = 127;
  BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
  BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
  BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  module2.exports = BSON2;
  module2.exports.Code = Code2;
  module2.exports.Map = Map2;
  module2.exports.Symbol = Symbol2;
  module2.exports.BSON = BSON2;
  module2.exports.DBRef = DBRef2;
  module2.exports.Binary = Binary2;
  module2.exports.ObjectID = ObjectID2;
  module2.exports.Long = Long2;
  module2.exports.Timestamp = Timestamp2;
  module2.exports.Double = Double2;
  module2.exports.Int32 = Int322;
  module2.exports.MinKey = MinKey2;
  module2.exports.MaxKey = MaxKey2;
  module2.exports.BSONRegExp = BSONRegExp2;
  module2.exports.Decimal128 = Decimal1282;
});

// node_modules/bson/index.js
var require_bson2 = __commonJS((exports2, module2) => {
  var BSON2 = require_bson();
  var Binary2 = require_binary();
  var Code2 = require_code();
  var DBRef2 = require_db_ref();
  var Decimal1282 = require_decimal128();
  var Double2 = require_double();
  var Int322 = require_int_32();
  var Long2 = require_long2();
  var Map2 = require_map();
  var MaxKey2 = require_max_key();
  var MinKey2 = require_min_key();
  var ObjectId = require_objectid();
  var BSONRegExp2 = require_regexp();
  var Symbol2 = require_symbol();
  var Timestamp2 = require_timestamp();
  BSON2.BSON_INT32_MAX = 2147483647;
  BSON2.BSON_INT32_MIN = -2147483648;
  BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
  BSON2.JS_INT_MAX = 9007199254740992;
  BSON2.JS_INT_MIN = -9007199254740992;
  BSON2.Binary = Binary2;
  BSON2.Code = Code2;
  BSON2.DBRef = DBRef2;
  BSON2.Decimal128 = Decimal1282;
  BSON2.Double = Double2;
  BSON2.Int32 = Int322;
  BSON2.Long = Long2;
  BSON2.Map = Map2;
  BSON2.MaxKey = MaxKey2;
  BSON2.MinKey = MinKey2;
  BSON2.ObjectId = ObjectId;
  BSON2.ObjectID = ObjectId;
  BSON2.BSONRegExp = BSONRegExp2;
  BSON2.Symbol = Symbol2;
  BSON2.Timestamp = Timestamp2;
  module2.exports = BSON2;
});

// node_modules/require_optional/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var Module = require("module");
  module2.exports = function(fromDir, moduleId) {
    if (typeof fromDir !== "string" || typeof moduleId !== "string") {
      throw new TypeError("Expected `fromDir` and `moduleId` to be a string");
    }
    fromDir = path.resolve(fromDir);
    var fromFile = path.join(fromDir, "noop.js");
    try {
      return Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
    } catch (err) {
      return null;
    }
  };
});

// node_modules/require_optional/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug3;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug3 = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug3 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug3(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug3("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug3("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug3("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug3("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug3("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug3("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug3("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug3("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug3("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug3("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug3("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug3("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug3("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug3("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug3("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug3(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/require_optional/index.js
var require_require_optional = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs = require("fs");
  var f = require("util").format;
  var resolveFrom = require_resolve_from();
  var semver = require_semver();
  var exists = fs.existsSync || path.existsSync;
  var find_package_json = function(location) {
    var found = false;
    while (!found) {
      if (exists(location + "/package.json")) {
        found = location;
      } else if (location !== "/") {
        location = path.dirname(location);
      } else {
        return false;
      }
    }
    return location;
  };
  var find_package_json_with_name = function(name) {
    var currentModule = module2;
    var found = false;
    while (currentModule) {
      location = currentModule.filename;
      var location = find_package_json(location);
      if (!location) {
        currentModule = currentModule.parent;
        continue;
      }
      var object = JSON.parse(fs.readFileSync(f("%s/package.json", location)));
      var parts = name.split(/\//);
      if (!object.peerOptionalDependencies || object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {
        currentModule = currentModule.parent;
        continue;
      }
      found = true;
      break;
    }
    if (!found) {
      throw new Error(f("no optional dependency [%s] defined in peerOptionalDependencies in any package.json", parts[0]));
    }
    return {
      object,
      parts
    };
  };
  var require_optional = function(name, options) {
    options = options || {};
    options.strict = typeof options.strict == "boolean" ? options.strict : true;
    var res = find_package_json_with_name(name);
    var object = res.object;
    var parts = res.parts;
    var expectedVersions = object.peerOptionalDependencies[parts[0]];
    var moduleEntry = void 0;
    var moduleEntryFile = name;
    try {
      moduleEntry = require(moduleEntryFile);
    } catch (err) {
      try {
        moduleEntryFile = resolveFrom(process.cwd(), name);
        if (moduleEntryFile == null)
          return void 0;
        moduleEntry = require(moduleEntryFile);
      } catch (err2) {
        if (err2.code === "MODULE_NOT_FOUND")
          return void 0;
      }
    }
    var location = find_package_json(require.resolve(moduleEntryFile));
    if (!location) {
      throw new Error("package.json can not be located");
    }
    var dependentOnModule = JSON.parse(fs.readFileSync(f("%s/package.json", location)));
    var version = dependentOnModule.version;
    if (semver.satisfies(version, expectedVersions) == false && options.strict) {
      var error = new Error(f("optional dependency [%s] found but version [%s] did not satisfy constraint [%s]", parts[0], version, expectedVersions));
      error.code = "OPTIONAL_MODULE_NOT_FOUND";
      throw error;
    }
    return moduleEntry;
  };
  require_optional.exists = function(name) {
    try {
      var m = require_optional(name);
      if (m === void 0)
        return false;
      return true;
    } catch (err) {
      return false;
    }
  };
  module2.exports = require_optional;
});

// node_modules/mongodb/package.json
var require_package3 = __commonJS((exports2, module2) => {
  module2.exports = {
    _from: "mongodb",
    _id: "mongodb@3.6.3",
    _inBundle: false,
    _integrity: "sha512-rOZuR0QkodZiM+UbQE5kDsJykBqWi0CL4Ec2i1nrGrUI3KO11r6Fbxskqmq3JK2NH7aW4dcccBuUujAP0ERl5w==",
    _location: "/mongodb",
    _phantomChildren: {},
    _requested: {
      type: "tag",
      registry: true,
      raw: "mongodb",
      name: "mongodb",
      escapedName: "mongodb",
      rawSpec: "",
      saveSpec: null,
      fetchSpec: "latest"
    },
    _requiredBy: [
      "#USER",
      "/"
    ],
    _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.3.tgz",
    _shasum: "eddaed0cc3598474d7a15f0f2a5b04848489fd05",
    _spec: "mongodb",
    _where: "D:\\Programming-School\\scrummy-bot",
    bugs: {
      url: "https://github.com/mongodb/node-mongodb-native/issues"
    },
    bundleDependencies: false,
    dependencies: {
      bl: "^2.2.1",
      bson: "^1.1.4",
      denque: "^1.4.1",
      require_optional: "^1.0.1",
      "safe-buffer": "^5.1.2",
      saslprep: "^1.0.0"
    },
    deprecated: false,
    description: "The official MongoDB driver for Node.js",
    devDependencies: {
      chai: "^4.1.1",
      "chai-subset": "^1.6.0",
      chalk: "^2.4.2",
      co: "4.6.0",
      coveralls: "^2.11.6",
      eslint: "^7.10.0",
      "eslint-config-prettier": "^6.11.0",
      "eslint-plugin-es": "^3.0.1",
      "eslint-plugin-prettier": "^3.1.3",
      istanbul: "^0.4.5",
      jsdoc: "3.5.5",
      "lodash.camelcase": "^4.3.0",
      mocha: "5.2.0",
      "mocha-sinon": "^2.1.0",
      "mongodb-extjson": "^2.1.1",
      "mongodb-mock-server": "^1.0.1",
      prettier: "^1.19.1",
      semver: "^5.5.0",
      sinon: "^4.3.0",
      "sinon-chai": "^3.2.0",
      snappy: "^6.3.4",
      "standard-version": "^4.4.0",
      "util.promisify": "^1.0.1",
      "worker-farm": "^1.5.0",
      wtfnode: "^0.8.0",
      yargs: "^14.2.0"
    },
    engines: {
      node: ">=4"
    },
    files: [
      "index.js",
      "lib"
    ],
    homepage: "https://github.com/mongodb/node-mongodb-native",
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    license: "Apache-2.0",
    main: "index.js",
    name: "mongodb",
    optionalDependencies: {
      saslprep: "^1.0.0"
    },
    peerDependenciesMeta: {
      kerberos: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      },
      "mongodb-extjson": {
        optional: true
      },
      snappy: {
        optional: true
      },
      "bson-ext": {
        optional: true
      },
      aws4: {
        optional: true
      }
    },
    peerOptionalDependencies: {
      kerberos: "^1.1.0",
      "mongodb-client-encryption": "^1.0.0",
      "mongodb-extjson": "^2.1.2",
      snappy: "^6.3.4",
      "bson-ext": "^2.0.0"
    },
    repository: {
      type: "git",
      url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
    },
    scripts: {
      atlas: "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
      bench: "node test/benchmarks/driverBench/",
      "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
      "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
      "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
      coverage: "istanbul cover mongodb-test-runner -- -t 60000 test/unit test/functional",
      format: "npm run lint -- --fix",
      "generate-evergreen": "node .evergreen/generate_evergreen_tasks.js",
      lint: "eslint -v && eslint lib test",
      release: "standard-version -i HISTORY.md",
      test: "npm run lint && mocha --recursive test/functional test/unit",
      "test-nolint": "mocha --recursive test/functional test/unit"
    },
    version: "3.6.3"
  };
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var crypto = require("crypto");
  var requireOptional = require_require_optional();
  var uuidV4 = () => {
    const result = crypto.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  };
  function relayEvents(listener, emitter, events) {
    events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
  }
  function retrieveKerberos() {
    let kerberos;
    try {
      kerberos = requireOptional("kerberos");
    } catch (err) {
      if (err.code === "MODULE_NOT_FOUND") {
        throw new Error("The `kerberos` module was not found. Please install it and try again.");
      }
      throw err;
    }
    return kerberos;
  }
  var noEJSONError = function() {
    throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
  };
  function retrieveEJSON() {
    let EJSON = null;
    try {
      EJSON = requireOptional("mongodb-extjson");
    } catch (error) {
    }
    if (!EJSON) {
      EJSON = {
        parse: noEJSONError,
        deserialize: noEJSONError,
        serialize: noEJSONError,
        stringify: noEJSONError,
        setBSONModule: noEJSONError,
        BSON: noEJSONError
      };
    }
    return EJSON;
  }
  function maxWireVersion(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.ismaster) {
        return topologyOrServer.ismaster.maxWireVersion;
      }
      if (typeof topologyOrServer.lastIsMaster === "function") {
        const lastIsMaster = topologyOrServer.lastIsMaster();
        if (lastIsMaster) {
          return lastIsMaster.maxWireVersion;
        }
      }
      if (topologyOrServer.description) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  }
  function collationNotSupported(server, cmd) {
    return cmd && cmd.collation && maxWireVersion(server) < 5;
  }
  function isPromiseLike(maybePromise) {
    return maybePromise && typeof maybePromise.then === "function";
  }
  function eachAsync(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = 0;
    for (idx = 0; idx < arr.length; ++idx) {
      awaiting++;
      eachFn(arr[idx], eachCallback);
    }
    if (awaiting === 0) {
      callback();
      return;
    }
    function eachCallback(err) {
      awaiting--;
      if (err) {
        callback(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback();
      }
    }
  }
  function eachAsyncSeries(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = arr.length;
    if (awaiting === 0) {
      callback();
      return;
    }
    function eachCallback(err) {
      idx++;
      awaiting--;
      if (err) {
        callback(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback();
        return;
      }
      eachFn(arr[idx], eachCallback);
    }
    eachFn(arr[idx], eachCallback);
  }
  function isUnifiedTopology(topology) {
    return topology.description != null;
  }
  function arrayStrictEqual(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  }
  function tagsStrictEqual(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  }
  function errorStrictEqual(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  }
  function makeStateMachine(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  }
  function makeClientMetadata(options) {
    options = options || {};
    const metadata = {
      driver: {
        name: "nodejs",
        version: require_package3().version
      },
      os: {
        type: os.type(),
        name: process.platform,
        architecture: process.arch,
        version: os.release()
      },
      platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? "unified" : "legacy"})`
    };
    if (options.driverInfo) {
      if (options.driverInfo.name) {
        metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;
      }
      if (options.driverInfo.version) {
        metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;
      }
      if (options.driverInfo.platform) {
        metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;
      }
    }
    if (options.appname) {
      const buffer = Buffer.from(options.appname);
      metadata.application = {
        name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options.appname
      };
    }
    return metadata;
  }
  var noop = () => {
  };
  module2.exports = {
    uuidV4,
    relayEvents,
    collationNotSupported,
    retrieveEJSON,
    retrieveKerberos,
    maxWireVersion,
    isPromiseLike,
    eachAsync,
    eachAsyncSeries,
    isUnifiedTopology,
    arrayStrictEqual,
    tagsStrictEqual,
    errorStrictEqual,
    makeStateMachine,
    makeClientMetadata,
    noop
  };
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS((exports2, module2) => {
  "use strict";
  var kErrorLabels = Symbol("errorLabels");
  var MongoError = class extends Error {
    constructor(message) {
      if (message instanceof Error) {
        super(message.message);
        this.stack = message.stack;
      } else {
        if (typeof message === "string") {
          super(message);
        } else {
          super(message.message || message.errmsg || message.$err || "n/a");
          if (message.errorLabels) {
            this[kErrorLabels] = new Set(message.errorLabels);
          }
          for (var name in message) {
            if (name === "errorLabels" || name === "errmsg") {
              continue;
            }
            this[name] = message[name];
          }
        }
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    static create(options) {
      return new MongoError(options);
    }
    hasErrorLabel(label) {
      if (this[kErrorLabels] == null) {
        return false;
      }
      return this[kErrorLabels].has(label);
    }
    addErrorLabel(label) {
      if (this[kErrorLabels] == null) {
        this[kErrorLabels] = new Set();
      }
      this[kErrorLabels].add(label);
    }
    get errorLabels() {
      return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
    }
  };
  var kBeforeHandshake = Symbol("beforeHandshake");
  function isNetworkErrorBeforeHandshake(err) {
    return err[kBeforeHandshake] === true;
  }
  var MongoNetworkError = class extends MongoError {
    constructor(message, options) {
      super(message);
      this.name = "MongoNetworkError";
      if (options && options.beforeHandshake === true) {
        this[kBeforeHandshake] = true;
      }
    }
  };
  var MongoNetworkTimeoutError = class extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
      this.name = "MongoNetworkTimeoutError";
    }
  };
  var MongoParseError = class extends MongoError {
    constructor(message) {
      super(message);
      this.name = "MongoParseError";
    }
  };
  var MongoTimeoutError = class extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(reason.error.message || reason.error);
      } else {
        super(message);
      }
      this.name = "MongoTimeoutError";
      if (reason) {
        this.reason = reason;
      }
    }
  };
  var MongoServerSelectionError = class extends MongoTimeoutError {
    constructor(message, reason) {
      super(message, reason);
      this.name = "MongoServerSelectionError";
    }
  };
  function makeWriteConcernResultObject(input) {
    const output = Object.assign({}, input);
    if (output.ok === 0) {
      output.ok = 1;
      delete output.errmsg;
      delete output.code;
      delete output.codeName;
    }
    return output;
  }
  var MongoWriteConcernError = class extends MongoError {
    constructor(message, result) {
      super(message);
      this.name = "MongoWriteConcernError";
      if (result && Array.isArray(result.errorLabels)) {
        this[kErrorLabels] = new Set(result.errorLabels);
      }
      if (result != null) {
        this.result = makeWriteConcernResultObject(result);
      }
    }
  };
  var RETRYABLE_ERROR_CODES = new Set([
    6,
    7,
    89,
    91,
    189,
    9001,
    10107,
    11600,
    11602,
    13435,
    13436
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = new Set([
    11600,
    11602,
    10107,
    13435,
    13436,
    189,
    91,
    7,
    6,
    89,
    9001,
    262
  ]);
  function isRetryableWriteError(error) {
    if (error instanceof MongoWriteConcernError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(error.code) || RETRYABLE_WRITE_ERROR_CODES.has(error.result.code);
    }
    return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
  }
  function isRetryableError(error) {
    return RETRYABLE_ERROR_CODES.has(error.code) || error instanceof MongoNetworkError || error.message.match(/not master/) || error.message.match(/node is recovering/);
  }
  var SDAM_RECOVERING_CODES = new Set([
    91,
    189,
    11600,
    11602,
    13436
  ]);
  var SDAM_NOTMASTER_CODES = new Set([
    10107,
    13435
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    11600,
    91
  ]);
  function isRecoveringError(err) {
    if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
      return true;
    }
    return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
  }
  function isNotMasterError(err) {
    if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
      return true;
    }
    if (isRecoveringError(err)) {
      return false;
    }
    return err.message.match(/not master/);
  }
  function isNodeShuttingDownError(err) {
    return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
  }
  function isSDAMUnrecoverableError(error) {
    if (error instanceof MongoParseError || error == null) {
      return true;
    }
    if (isRecoveringError(error) || isNotMasterError(error)) {
      return true;
    }
    return false;
  }
  module2.exports = {
    MongoError,
    MongoNetworkError,
    MongoNetworkTimeoutError,
    MongoParseError,
    MongoTimeoutError,
    MongoServerSelectionError,
    MongoWriteConcernError,
    isRetryableError,
    isSDAMUnrecoverableError,
    isNodeShuttingDownError,
    isRetryableWriteError,
    isNetworkErrorBeforeHandshake
  };
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS((exports2, module2) => {
  "use strict";
  var require_optional = require_require_optional();
  function debugOptions(debugFields, options) {
    var finaloptions = {};
    debugFields.forEach(function(n) {
      finaloptions[n] = options[n];
    });
    return finaloptions;
  }
  function retrieveBSON() {
    var BSON2 = require_bson2();
    BSON2.native = false;
    try {
      var optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
    } catch (err) {
    }
    return BSON2;
  }
  function noSnappyWarning() {
    throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
  }
  function retrieveSnappy() {
    var snappy = null;
    try {
      snappy = require_optional("snappy");
    } catch (error) {
    }
    if (!snappy) {
      snappy = {
        compress: noSnappyWarning,
        uncompress: noSnappyWarning,
        compressSync: noSnappyWarning,
        uncompressSync: noSnappyWarning
      };
    }
    return snappy;
  }
  module2.exports = {
    debugOptions,
    retrieveBSON,
    retrieveSnappy
  };
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = function(mode, tags, options) {
    if (!ReadPreference.isValid(mode)) {
      throw new TypeError(`Invalid read preference mode ${mode}`);
    }
    if (tags && !Array.isArray(tags)) {
      console.warn("ReadPreference tags must be an array, this will change in the next major version");
      const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
      const tagsHasHedge = typeof tags.hedge !== "undefined";
      const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
      if (tagsHasOptions) {
        options = tags;
        tags = void 0;
      } else {
        tags = [tags];
      }
    }
    this.mode = mode;
    this.tags = tags;
    this.hedge = options && options.hedge;
    options = options || {};
    if (options.maxStalenessSeconds != null) {
      if (options.maxStalenessSeconds <= 0) {
        throw new TypeError("maxStalenessSeconds must be a positive integer");
      }
      this.maxStalenessSeconds = options.maxStalenessSeconds;
      this.minWireVersion = 5;
    }
    if (this.mode === ReadPreference.PRIMARY) {
      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
        throw new TypeError("Primary read preference cannot be combined with tags");
      }
      if (this.maxStalenessSeconds) {
        throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
      }
      if (this.hedge) {
        throw new TypeError("Primary read preference cannot be combined with hedge");
      }
    }
  };
  Object.defineProperty(ReadPreference.prototype, "preference", {
    enumerable: true,
    get: function() {
      return this.mode;
    }
  });
  ReadPreference.PRIMARY = "primary";
  ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
  ReadPreference.SECONDARY = "secondary";
  ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
  ReadPreference.NEAREST = "nearest";
  var VALID_MODES = [
    ReadPreference.PRIMARY,
    ReadPreference.PRIMARY_PREFERRED,
    ReadPreference.SECONDARY,
    ReadPreference.SECONDARY_PREFERRED,
    ReadPreference.NEAREST,
    null
  ];
  ReadPreference.fromOptions = function(options) {
    if (!options)
      return null;
    const readPreference = options.readPreference;
    if (!readPreference)
      return null;
    const readPreferenceTags = options.readPreferenceTags;
    const maxStalenessSeconds = options.maxStalenessSeconds;
    if (typeof readPreference === "string") {
      return new ReadPreference(readPreference, readPreferenceTags);
    } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
      const mode = readPreference.mode || readPreference.preference;
      if (mode && typeof mode === "string") {
        return new ReadPreference(mode, readPreference.tags, {
          maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
          hedge: readPreference.hedge
        });
      }
    }
    return readPreference;
  };
  ReadPreference.resolve = function(parent, options) {
    options = options || {};
    const session = options.session;
    const inheritedReadPreference = parent && parent.readPreference;
    let readPreference;
    if (options.readPreference) {
      readPreference = ReadPreference.fromOptions(options);
    } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
      readPreference = session.transaction.options.readPreference;
    } else if (inheritedReadPreference != null) {
      readPreference = inheritedReadPreference;
    } else {
      readPreference = ReadPreference.primary;
    }
    return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
  };
  ReadPreference.translate = function(options) {
    if (options.readPreference == null)
      return options;
    const r = options.readPreference;
    if (typeof r === "string") {
      options.readPreference = new ReadPreference(r);
    } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
      const mode = r.mode || r.preference;
      if (mode && typeof mode === "string") {
        options.readPreference = new ReadPreference(mode, r.tags, {
          maxStalenessSeconds: r.maxStalenessSeconds
        });
      }
    } else if (!(r instanceof ReadPreference)) {
      throw new TypeError("Invalid read preference: " + r);
    }
    return options;
  };
  ReadPreference.isValid = function(mode) {
    return VALID_MODES.indexOf(mode) !== -1;
  };
  ReadPreference.prototype.isValid = function(mode) {
    return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
  };
  var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
  ReadPreference.prototype.slaveOk = function() {
    return needSlaveOk.indexOf(this.mode) !== -1;
  };
  ReadPreference.prototype.equals = function(readPreference) {
    return readPreference.mode === this.mode;
  };
  ReadPreference.prototype.toJSON = function() {
    const readPreference = {mode: this.mode};
    if (Array.isArray(this.tags))
      readPreference.tags = this.tags;
    if (this.maxStalenessSeconds)
      readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
    if (this.hedge)
      readPreference.hedge = this.hedge;
    return readPreference;
  };
  ReadPreference.primary = new ReadPreference("primary");
  ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
  ReadPreference.secondary = new ReadPreference("secondary");
  ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
  ReadPreference.nearest = new ReadPreference("nearest");
  module2.exports = ReadPreference;
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common2 = __commonJS((exports2, module2) => {
  "use strict";
  var STATE_CLOSING = "closing";
  var STATE_CLOSED = "closed";
  var STATE_CONNECTING = "connecting";
  var STATE_CONNECTED = "connected";
  var TopologyType = {
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown"
  };
  var ServerType = {
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown"
  };
  function serverType(server) {
    let description = server.s.description || server.s.serverDescription;
    if (description.topologyType === TopologyType.Single)
      return description.servers[0].type;
    return description.type;
  }
  var TOPOLOGY_DEFAULTS = {
    useUnifiedTopology: true,
    localThresholdMS: 15,
    serverSelectionTimeoutMS: 3e4,
    heartbeatFrequencyMS: 1e4,
    minHeartbeatFrequencyMS: 500
  };
  function drainTimerQueue(queue) {
    queue.forEach(clearTimeout);
    queue.clear();
  }
  function clearAndRemoveTimerFrom(timer, timers) {
    clearTimeout(timer);
    return timers.delete(timer);
  }
  module2.exports = {
    STATE_CLOSING,
    STATE_CLOSED,
    STATE_CONNECTING,
    STATE_CONNECTED,
    TOPOLOGY_DEFAULTS,
    TopologyType,
    ServerType,
    serverType,
    drainTimerQueue,
    clearAndRemoveTimerFrom
  };
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports2, module2) => {
  "use strict";
  var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "fsync"]);
  var WriteConcern = class {
    constructor(w, wtimeout, j, fsync) {
      if (w != null) {
        this.w = w;
      }
      if (wtimeout != null) {
        this.wtimeout = wtimeout;
      }
      if (j != null) {
        this.j = j;
      }
      if (fsync != null) {
        this.fsync = fsync;
      }
    }
    static fromOptions(options) {
      if (options == null || options.writeConcern == null && options.w == null && options.wtimeout == null && options.j == null && options.fsync == null) {
        return;
      }
      if (options.writeConcern) {
        if (typeof options.writeConcern === "string") {
          return new WriteConcern(options.writeConcern);
        }
        if (!Object.keys(options.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
          return;
        }
        return new WriteConcern(options.writeConcern.w, options.writeConcern.wtimeout, options.writeConcern.j, options.writeConcern.fsync);
      }
      return new WriteConcern(options.w, options.wtimeout, options.j, options.fsync);
    }
  };
  module2.exports = WriteConcern;
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS((exports2) => {
  "use strict";
  function asyncIterator() {
    const cursor = this;
    return {
      next: function() {
        return Promise.resolve().then(() => cursor.next()).then((value) => {
          if (!value) {
            return cursor.close().then(() => ({value, done: true}));
          }
          return {value, done: false};
        });
      }
    };
  }
  exports2.asyncIterator = asyncIterator;
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var WriteConcern = require_write_concern();
  var shallowClone = function(obj) {
    var copy = {};
    for (var name in obj)
      copy[name] = obj[name];
    return copy;
  };
  var getSingleProperty = function(obj, name, value) {
    Object.defineProperty(obj, name, {
      enumerable: true,
      get: function() {
        return value;
      }
    });
  };
  var formatSortValue = exports2.formatSortValue = function(sortDirection) {
    var value = ("" + sortDirection).toLowerCase();
    switch (value) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
    }
  };
  var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
    var orderBy = {};
    if (sortValue == null)
      return null;
    if (Array.isArray(sortValue)) {
      if (sortValue.length === 0) {
        return null;
      }
      for (var i = 0; i < sortValue.length; i++) {
        if (sortValue[i].constructor === String) {
          orderBy[sortValue[i]] = 1;
        } else {
          orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
        }
      }
    } else if (sortValue != null && typeof sortValue === "object") {
      orderBy = sortValue;
    } else if (typeof sortValue === "string") {
      orderBy[sortValue] = 1;
    } else {
      throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
    }
    return orderBy;
  };
  var checkCollectionName = function checkCollectionName2(collectionName) {
    if (typeof collectionName !== "string") {
      throw new MongoError("collection name must be a String");
    }
    if (!collectionName || collectionName.indexOf("..") !== -1) {
      throw new MongoError("collection names cannot be empty");
    }
    if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
      throw new MongoError("collection names must not contain '$'");
    }
    if (collectionName.match(/^\.|\.$/) != null) {
      throw new MongoError("collection names must not start or end with '.'");
    }
    if (collectionName.indexOf("\0") !== -1) {
      throw new MongoError("collection names cannot contain a null character");
    }
  };
  var handleCallback = function(callback, err, value1, value2) {
    try {
      if (callback == null)
        return;
      if (callback) {
        return value2 ? callback(err, value1, value2) : callback(err, value1);
      }
    } catch (err2) {
      process.nextTick(function() {
        throw err2;
      });
      return false;
    }
    return true;
  };
  var toError = function(error) {
    if (error instanceof Error)
      return error;
    var msg = error.err || error.errmsg || error.errMessage || error;
    var e = MongoError.create({message: msg, driver: true});
    var keys = typeof error === "object" ? Object.keys(error) : [];
    for (var i = 0; i < keys.length; i++) {
      try {
        e[keys[i]] = error[keys[i]];
      } catch (err) {
      }
    }
    return e;
  };
  var normalizeHintField = function normalizeHintField2(hint) {
    var finalHint = null;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach(function(param) {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (var name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  };
  var parseIndexOptions = function(fieldOrSpec) {
    var fieldHash = {};
    var indexes = [];
    var keys;
    if (typeof fieldOrSpec === "string") {
      indexes.push(fieldOrSpec + "_" + 1);
      fieldHash[fieldOrSpec] = 1;
    } else if (Array.isArray(fieldOrSpec)) {
      fieldOrSpec.forEach(function(f) {
        if (typeof f === "string") {
          indexes.push(f + "_" + 1);
          fieldHash[f] = 1;
        } else if (Array.isArray(f)) {
          indexes.push(f[0] + "_" + (f[1] || 1));
          fieldHash[f[0]] = f[1] || 1;
        } else if (isObject(f)) {
          keys = Object.keys(f);
          keys.forEach(function(k) {
            indexes.push(k + "_" + f[k]);
            fieldHash[k] = f[k];
          });
        } else {
        }
      });
    } else if (isObject(fieldOrSpec)) {
      keys = Object.keys(fieldOrSpec);
      keys.forEach(function(key) {
        indexes.push(key + "_" + fieldOrSpec[key]);
        fieldHash[key] = fieldOrSpec[key];
      });
    }
    return {
      name: indexes.join("_"),
      keys,
      fieldHash
    };
  };
  var isObject = exports2.isObject = function(arg) {
    return Object.prototype.toString.call(arg) === "[object Object]";
  };
  var debugOptions = function(debugFields, options) {
    var finaloptions = {};
    debugFields.forEach(function(n) {
      finaloptions[n] = options[n];
    });
    return finaloptions;
  };
  var decorateCommand = function(command, options, exclude) {
    for (var name in options) {
      if (exclude.indexOf(name) === -1)
        command[name] = options[name];
    }
    return command;
  };
  var mergeOptions = function(target, source) {
    for (var name in source) {
      target[name] = source[name];
    }
    return target;
  };
  var translateOptions = function(target, source) {
    var translations = {
      sslCA: "ca",
      sslCRL: "crl",
      sslValidate: "rejectUnauthorized",
      sslKey: "key",
      sslCert: "cert",
      sslPass: "passphrase",
      socketTimeoutMS: "socketTimeout",
      connectTimeoutMS: "connectionTimeout",
      replicaSet: "setName",
      rs_name: "setName",
      secondaryAcceptableLatencyMS: "acceptableLatency",
      connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
      acceptableLatencyMS: "localThresholdMS"
    };
    for (var name in source) {
      if (translations[name]) {
        target[translations[name]] = source[name];
      } else {
        target[name] = source[name];
      }
    }
    return target;
  };
  var filterOptions = function(options, names) {
    var filterOptions2 = {};
    for (var name in options) {
      if (names.indexOf(name) !== -1)
        filterOptions2[name] = options[name];
    }
    return filterOptions2;
  };
  var writeConcernKeys = ["w", "j", "wtimeout", "fsync"];
  var mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {
    for (var i = 0; i < keys.length; i++) {
      if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== void 0) {
        targetOptions[keys[i]] = sourceOptions[keys[i]];
      }
    }
    if (!mergeWriteConcern)
      return targetOptions;
    var found = false;
    for (i = 0; i < writeConcernKeys.length; i++) {
      if (targetOptions[writeConcernKeys[i]]) {
        found = true;
        break;
      }
    }
    if (!found) {
      for (i = 0; i < writeConcernKeys.length; i++) {
        if (sourceOptions[writeConcernKeys[i]]) {
          targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];
        }
      }
    }
    return targetOptions;
  };
  var executeLegacyOperation = (topology, operation, args, options) => {
    if (topology == null) {
      throw new TypeError("This method requires a valid topology instance");
    }
    if (!Array.isArray(args)) {
      throw new TypeError("This method requires an array of arguments to apply");
    }
    options = options || {};
    const Promise2 = topology.s.promiseLibrary;
    let callback = args[args.length - 1];
    let session, opOptions, owner;
    if (!options.skipSessions && topology.hasSessionSupport()) {
      opOptions = args[args.length - 2];
      if (opOptions == null || opOptions.session == null) {
        owner = Symbol();
        session = topology.startSession({owner});
        const optionsIndex = args.length - 2;
        args[optionsIndex] = Object.assign({}, args[optionsIndex], {session});
      } else if (opOptions.session && opOptions.session.hasEnded) {
        throw new MongoError("Use of expired sessions is not permitted");
      }
    }
    const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {
      if (session && session.owner === owner && !options.returnsCursor) {
        session.endSession(() => {
          delete opOptions.session;
          if (err)
            return reject(err);
          resolve(result);
        });
      } else {
        if (err)
          return reject(err);
        resolve(result);
      }
    };
    if (typeof callback === "function") {
      callback = args.pop();
      const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
      args.push(handler);
      try {
        return operation.apply(null, args);
      } catch (e) {
        handler(e);
        throw e;
      }
    }
    if (args[args.length - 1] != null) {
      throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
    }
    return new Promise2(function(resolve, reject) {
      const handler = makeExecuteCallback(resolve, reject);
      args[args.length - 1] = handler;
      try {
        return operation.apply(null, args);
      } catch (e) {
        handler(e);
      }
    });
  };
  function applyRetryableWrites(target, db) {
    if (db && db.s.options.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  }
  function applyWriteConcern(target, sources, options) {
    options = options || {};
    const db = sources.db;
    const coll = sources.collection;
    if (options.session && options.session.inTransaction()) {
      if (target.writeConcern) {
        delete target.writeConcern;
      }
      return target;
    }
    const writeConcern = WriteConcern.fromOptions(options);
    if (writeConcern) {
      return Object.assign(target, {writeConcern});
    }
    if (coll && coll.writeConcern) {
      return Object.assign(target, {writeConcern: Object.assign({}, coll.writeConcern)});
    }
    if (db && db.writeConcern) {
      return Object.assign(target, {writeConcern: Object.assign({}, db.writeConcern)});
    }
    return target;
  }
  function isPromiseLike(maybePromise2) {
    return maybePromise2 && typeof maybePromise2.then === "function";
  }
  function decorateWithCollation(command, target, options) {
    const topology = target.s && target.s.topology || target.topology;
    if (!topology) {
      throw new TypeError('parameter "target" is missing a topology');
    }
    const capabilities = topology.capabilities();
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new MongoError(`Current topology does not support collation`);
      }
    }
  }
  function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    let readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, {readConcern});
    }
  }
  var emitProcessWarning = (msg) => process.emitWarning(msg, "DeprecationWarning");
  var emitConsoleWarning = (msg) => console.error(msg);
  var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
  function defaultMsgHandler(name, option) {
    return `${name} option [${option}] is deprecated and will be removed in a later version.`;
  }
  function deprecateOptions(config, fn) {
    if (process.noDeprecation === true) {
      return fn;
    }
    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
    const optionsWarned = new Set();
    function deprecated() {
      const options = arguments[config.optionsIndex];
      if (!isObject(options) || Object.keys(options).length === 0) {
        return fn.apply(this, arguments);
      }
      config.deprecatedOptions.forEach((deprecatedOption) => {
        if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
          optionsWarned.add(deprecatedOption);
          const msg = msgHandler(config.name, deprecatedOption);
          emitDeprecationWarning(msg);
          if (this && this.getLogger) {
            const logger = this.getLogger();
            if (logger) {
              logger.warn(msg);
            }
          }
        }
      });
      return fn.apply(this, arguments);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
      deprecated.prototype = fn.prototype;
    }
    return deprecated;
  }
  var SUPPORTS = {};
  try {
    require_async_iterator();
    SUPPORTS.ASYNC_ITERATOR = true;
  } catch (e) {
    SUPPORTS.ASYNC_ITERATOR = false;
  }
  var MongoDBNamespace = class {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (!namespace) {
        throw new Error(`Cannot parse namespace from "${namespace}"`);
      }
      const index = namespace.indexOf(".");
      return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));
    }
  };
  function* makeCounter(seed) {
    let count = seed || 0;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  function maybePromise(parent, callback, fn) {
    const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
    let result;
    if (typeof callback !== "function") {
      result = new PromiseLibrary((resolve, reject) => {
        callback = (err, res) => {
          if (err)
            return reject(err);
          resolve(res);
        };
      });
    }
    fn(function(err, res) {
      if (err != null) {
        try {
          callback(err);
        } catch (error) {
          return process.nextTick(() => {
            throw error;
          });
        }
        return;
      }
      callback(err, res);
    });
    return result;
  }
  function now() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
  }
  function calculateDurationInMs(started) {
    if (typeof started !== "number") {
      throw TypeError("numeric value required to calculate duration");
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  }
  function makeInterruptableAsyncInterval(fn, options) {
    let timerId;
    let lastCallTime;
    let lastWakeTime;
    let stopped = false;
    options = options || {};
    const interval = options.interval || 1e3;
    const minInterval = options.minInterval || 500;
    const immediate = typeof options.immediate === "boolean" ? options.immediate : false;
    const clock = typeof options.clock === "function" ? options.clock : now;
    function wake() {
      const currentTime = clock();
      const timeSinceLastWake = currentTime - lastWakeTime;
      const timeSinceLastCall = currentTime - lastCallTime;
      const timeUntilNextCall = interval - timeSinceLastCall;
      lastWakeTime = currentTime;
      if (timeSinceLastWake < minInterval) {
        return;
      }
      if (timeUntilNextCall > minInterval) {
        reschedule(minInterval);
      }
      if (timeUntilNextCall < 0) {
        executeAndReschedule();
      }
    }
    function stop() {
      stopped = true;
      if (timerId) {
        clearTimeout(timerId);
        timerId = null;
      }
      lastCallTime = 0;
      lastWakeTime = 0;
    }
    function reschedule(ms) {
      if (stopped)
        return;
      clearTimeout(timerId);
      timerId = setTimeout(executeAndReschedule, ms || interval);
    }
    function executeAndReschedule() {
      lastWakeTime = 0;
      lastCallTime = clock();
      fn((err) => {
        if (err)
          throw err;
        reschedule(interval);
      });
    }
    if (immediate) {
      executeAndReschedule();
    } else {
      lastCallTime = clock();
      reschedule();
    }
    return {wake, stop};
  }
  function hasAtomicOperators(doc) {
    if (Array.isArray(doc)) {
      return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
    }
    const keys = Object.keys(doc);
    return keys.length > 0 && keys[0][0] === "$";
  }
  module2.exports = {
    filterOptions,
    mergeOptions,
    translateOptions,
    shallowClone,
    getSingleProperty,
    checkCollectionName,
    toError,
    formattedOrderClause,
    parseIndexOptions,
    normalizeHintField,
    handleCallback,
    decorateCommand,
    isObject,
    debugOptions,
    MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
    mergeOptionsAndWriteConcern,
    executeLegacyOperation,
    applyRetryableWrites,
    applyWriteConcern,
    isPromiseLike,
    decorateWithCollation,
    decorateWithReadConcern,
    deprecateOptions,
    SUPPORTS,
    MongoDBNamespace,
    emitDeprecationWarning,
    makeCounter,
    maybePromise,
    now,
    calculateDurationInMs,
    makeInterruptableAsyncInterval,
    hasAtomicOperators
  };
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS((exports2, module2) => {
  "use strict";
  var arrayStrictEqual = require_utils2().arrayStrictEqual;
  var tagsStrictEqual = require_utils2().tagsStrictEqual;
  var errorStrictEqual = require_utils2().errorStrictEqual;
  var ServerType = require_common2().ServerType;
  var now = require_utils4().now;
  var WRITABLE_SERVER_TYPES = new Set([
    ServerType.RSPrimary,
    ServerType.Standalone,
    ServerType.Mongos
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    ServerType.RSPrimary,
    ServerType.RSSecondary,
    ServerType.Mongos,
    ServerType.Standalone
  ]);
  var ISMASTER_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "compression",
    "me",
    "hosts",
    "passives",
    "arbiters",
    "tags",
    "setName",
    "setVersion",
    "electionId",
    "primary",
    "logicalSessionTimeoutMinutes",
    "saslSupportedMechs",
    "__nodejs_mock_server__",
    "$clusterTime"
  ];
  var ServerDescription = class {
    constructor(address, ismaster, options) {
      options = options || {};
      ismaster = Object.assign({
        minWireVersion: 0,
        maxWireVersion: 0,
        hosts: [],
        passives: [],
        arbiters: [],
        tags: []
      }, ismaster);
      this.address = address;
      this.error = options.error;
      this.roundTripTime = options.roundTripTime || -1;
      this.lastUpdateTime = now();
      this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
      this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
      this.type = parseServerType(ismaster);
      this.topologyVersion = options.topologyVersion || ismaster.topologyVersion;
      ISMASTER_FIELDS.forEach((field) => {
        if (typeof ismaster[field] !== "undefined")
          this[field] = ismaster[field];
      });
      if (this.me)
        this.me = this.me.toLowerCase();
      this.hosts = this.hosts.map((host) => host.toLowerCase());
      this.passives = this.passives.map((host) => host.toLowerCase());
      this.arbiters = this.arbiters.map((host) => host.toLowerCase());
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : port;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
      return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  };
  function parseServerType(ismaster) {
    if (!ismaster || !ismaster.ok) {
      return ServerType.Unknown;
    }
    if (ismaster.isreplicaset) {
      return ServerType.RSGhost;
    }
    if (ismaster.msg && ismaster.msg === "isdbgrid") {
      return ServerType.Mongos;
    }
    if (ismaster.setName) {
      if (ismaster.hidden) {
        return ServerType.RSOther;
      } else if (ismaster.ismaster) {
        return ServerType.RSPrimary;
      } else if (ismaster.secondary) {
        return ServerType.RSSecondary;
      } else if (ismaster.arbiterOnly) {
        return ServerType.RSArbiter;
      } else {
        return ServerType.RSOther;
      }
    }
    return ServerType.Standalone;
  }
  function compareTopologyVersion(lhs, rhs) {
    if (lhs == null || rhs == null) {
      return -1;
    }
    if (lhs.processId.equals(rhs.processId)) {
      if (lhs.counter === rhs.counter) {
        return 0;
      } else if (lhs.counter < rhs.counter) {
        return -1;
      }
      return 1;
    }
    return -1;
  }
  module2.exports = {
    ServerDescription,
    parseServerType,
    compareTopologyVersion
  };
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var MIN_SUPPORTED_SERVER_VERSION = "2.6";
  var MAX_SUPPORTED_SERVER_VERSION = "4.4";
  var MIN_SUPPORTED_WIRE_VERSION = 2;
  var MAX_SUPPORTED_WIRE_VERSION = 9;
  module2.exports = {
    MIN_SUPPORTED_SERVER_VERSION,
    MAX_SUPPORTED_SERVER_VERSION,
    MIN_SUPPORTED_WIRE_VERSION,
    MAX_SUPPORTED_WIRE_VERSION
  };
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var ServerDescription = require_server_description().ServerDescription;
  var WIRE_CONSTANTS = require_constants2();
  var TopologyType = require_common2().TopologyType;
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var TopologyDescription = class {
    constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {
      options = options || {};
      this.type = topologyType || TopologyType.Unknown;
      this.setName = setName || null;
      this.maxSetVersion = maxSetVersion || null;
      this.maxElectionId = maxElectionId || null;
      this.servers = serverDescriptions || new Map();
      this.stale = false;
      this.compatible = true;
      this.compatibilityError = null;
      this.logicalSessionTimeoutMinutes = null;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;
      this.localThresholdMS = options.localThresholdMS || 0;
      this.commonWireVersion = commonWireVersion || null;
      Object.defineProperty(this, "options", {value: options, enumberable: false});
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === ServerType.Unknown)
          continue;
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      const readableServers = Array.from(this.servers.values()).filter((s) => s.isReadable);
      this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {
        if (server.logicalSessionTimeoutMinutes == null)
          return null;
        if (result == null)
          return server.logicalSessionTimeoutMinutes;
        return Math.min(result, server.logicalSessionTimeoutMinutes);
      }, null);
    }
    updateFromSrvPollingEvent(ev) {
      const newAddresses = ev.addresses();
      const serverDescriptions = new Map(this.servers);
      for (const server of this.servers) {
        if (newAddresses.has(server[0])) {
          newAddresses.delete(server[0]);
        } else {
          serverDescriptions.delete(server[0]);
        }
      }
      if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
        return this;
      }
      for (const address of newAddresses) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let topologyType = this.type;
      let setName = this.setName;
      let maxSetVersion = this.maxSetVersion;
      let maxElectionId = this.maxElectionId;
      let commonWireVersion = this.commonWireVersion;
      if (serverDescription.setName && setName && serverDescription.setName !== setName) {
        serverDescription = new ServerDescription(address, null);
      }
      const serverType = serverDescription.type;
      let serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === TopologyType.Single) {
        return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      if (topologyType === TopologyType.Unknown) {
        if (serverType === ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === TopologyType.Sharded) {
        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === TopologyType.ReplicaSetNoPrimary) {
        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
          serverDescriptions.delete(address);
        }
        if (serverType === ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
          topologyType = result[0], setName = result[1];
        }
      }
      if (topologyType === TopologyType.ReplicaSetWithPrimary) {
        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return void 0;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
  };
  function topologyTypeForServerType(serverType) {
    if (serverType === ServerType.Standalone) {
      return TopologyType.Single;
    }
    if (serverType === ServerType.Mongos) {
      return TopologyType.Sharded;
    }
    if (serverType === ServerType.RSPrimary) {
      return TopologyType.ReplicaSetWithPrimary;
    }
    if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
      return TopologyType.Unknown;
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  function compareObjectId(oid1, oid2) {
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
      const oid1Buffer = oid1.id;
      const oid2Buffer = oid2.id;
      return oid1Buffer.compare(oid2Buffer);
    }
    const oid1String = oid1.toString();
    const oid2String = oid2.toString();
    return oid1String.localeCompare(oid2String);
  }
  function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    const electionId = serverDescription.electionId ? serverDescription.electionId : null;
    if (serverDescription.setVersion && electionId) {
      if (maxSetVersion && maxElectionId) {
        if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
          serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      }
      maxElectionId = serverDescription.electionId;
    }
    if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
      maxSetVersion = serverDescription.setVersion;
    }
    for (const address of serverDescriptions.keys()) {
      const server = serverDescriptions.get(address);
      if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new ServerDescription(server.address));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }
  function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
    if (setName == null) {
      throw new TypeError("setName is required");
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  }
  function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
    let topologyType = TopologyType.ReplicaSetNoPrimary;
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  }
  function checkHasPrimary(serverDescriptions) {
    for (const addr of serverDescriptions.keys()) {
      if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  module2.exports = {
    TopologyDescription
  };
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var ServerType = require_common2().ServerType;
  var TopologyDescription = require_topology_description().TopologyDescription;
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;
  var opcodes = {
    OP_REPLY: 1,
    OP_UPDATE: 2001,
    OP_INSERT: 2002,
    OP_QUERY: 2004,
    OP_GETMORE: 2005,
    OP_DELETE: 2006,
    OP_KILL_CURSORS: 2007,
    OP_COMPRESSED: 2012,
    OP_MSG: 2013
  };
  var getReadPreference = function(cmd, options) {
    var readPreference = cmd.readPreference || new ReadPreference("primary");
    if (options.readPreference) {
      readPreference = options.readPreference;
    }
    if (typeof readPreference === "string") {
      readPreference = new ReadPreference(readPreference);
    }
    if (!(readPreference instanceof ReadPreference)) {
      throw new MongoError("read preference must be a ReadPreference instance");
    }
    return readPreference;
  };
  var parseHeader = function(message) {
    return {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
  };
  function applyCommonQueryOptions(queryOptions, options) {
    Object.assign(queryOptions, {
      raw: typeof options.raw === "boolean" ? options.raw : false,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      monitoring: typeof options.monitoring === "boolean" ? options.monitoring : false,
      fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false
    });
    if (typeof options.socketTimeout === "number") {
      queryOptions.socketTimeout = options.socketTimeout;
    }
    if (options.session) {
      queryOptions.session = options.session;
    }
    if (typeof options.documentsReturnedIn === "string") {
      queryOptions.documentsReturnedIn = options.documentsReturnedIn;
    }
    return queryOptions;
  }
  function isSharded(topologyOrServer) {
    if (topologyOrServer.type === "mongos")
      return true;
    if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === ServerType.Mongos);
    }
    return false;
  }
  function databaseNamespace(ns) {
    return ns.split(".")[0];
  }
  function collectionNamespace(ns) {
    return ns.split(".").slice(1).join(".");
  }
  module2.exports = {
    getReadPreference,
    MESSAGE_HEADER_SIZE,
    COMPRESSION_DETAILS_SIZE,
    opcodes,
    parseHeader,
    applyCommonQueryOptions,
    isSharded,
    databaseNamespace,
    collectionNamespace
  };
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS((exports2, module2) => {
  "use strict";
  var Snappy = require_utils3().retrieveSnappy();
  var zlib = require("zlib");
  var compressorIDs = {
    snappy: 1,
    zlib: 2
  };
  var uncompressibleCommands = new Set([
    "ismaster",
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  function compress(self2, dataToBeCompressed, callback) {
    switch (self2.options.agreedCompressor) {
      case "snappy":
        Snappy.compress(dataToBeCompressed, callback);
        break;
      case "zlib":
        var zlibOptions = {};
        if (self2.options.zlibCompressionLevel) {
          zlibOptions.level = self2.options.zlibCompressionLevel;
        }
        zlib.deflate(dataToBeCompressed, zlibOptions, callback);
        break;
      default:
        throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
    }
  }
  function decompress(compressorID, compressedData, callback) {
    if (compressorID < 0 || compressorID > compressorIDs.length) {
      throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
    }
    switch (compressorID) {
      case compressorIDs.snappy:
        Snappy.uncompress(compressedData, callback);
        break;
      case compressorIDs.zlib:
        zlib.inflate(compressedData, callback);
        break;
      default:
        callback(null, compressedData);
    }
  }
  module2.exports = {
    compressorIDs,
    uncompressibleCommands,
    compress,
    decompress
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var Buffer2 = require_safe_buffer().Buffer;
  var _requestId = 0;
  var opcodes = require_shared().opcodes;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SLAVE = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;
  var Query = function(bson, ns, query, options) {
    var self2 = this;
    if (ns == null)
      throw new Error("ns must be specified for query");
    if (query == null)
      throw new Error("query must be specified for query");
    if (ns.indexOf("\0") !== -1) {
      throw new Error("namespace cannot contain a null character");
    }
    this.bson = bson;
    this.ns = ns;
    this.query = query;
    this.numberToSkip = options.numberToSkip || 0;
    this.numberToReturn = options.numberToReturn || 0;
    this.returnFieldSelector = options.returnFieldSelector || null;
    this.requestId = Query.getRequestId();
    this.pre32Limit = options.pre32Limit;
    this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
    this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : true;
    this.batchSize = self2.numberToReturn;
    this.tailable = false;
    this.slaveOk = typeof options.slaveOk === "boolean" ? options.slaveOk : false;
    this.oplogReplay = false;
    this.noCursorTimeout = false;
    this.awaitData = false;
    this.exhaust = false;
    this.partial = false;
  };
  Query.prototype.incRequestId = function() {
    this.requestId = _requestId++;
  };
  Query.nextRequestId = function() {
    return _requestId + 1;
  };
  Query.prototype.toBin = function() {
    var self2 = this;
    var buffers = [];
    var projection = null;
    var flags = 0;
    if (this.tailable) {
      flags |= OPTS_TAILABLE_CURSOR;
    }
    if (this.slaveOk) {
      flags |= OPTS_SLAVE;
    }
    if (this.oplogReplay) {
      flags |= OPTS_OPLOG_REPLAY;
    }
    if (this.noCursorTimeout) {
      flags |= OPTS_NO_CURSOR_TIMEOUT;
    }
    if (this.awaitData) {
      flags |= OPTS_AWAIT_DATA;
    }
    if (this.exhaust) {
      flags |= OPTS_EXHAUST;
    }
    if (this.partial) {
      flags |= OPTS_PARTIAL;
    }
    if (self2.batchSize !== self2.numberToReturn)
      self2.numberToReturn = self2.batchSize;
    var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
    buffers.push(header);
    var query = self2.bson.serialize(this.query, {
      checkKeys: this.checkKeys,
      serializeFunctions: this.serializeFunctions,
      ignoreUndefined: this.ignoreUndefined
    });
    buffers.push(query);
    if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
      projection = self2.bson.serialize(this.returnFieldSelector, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(projection);
    }
    var totalLength = header.length + query.length + (projection ? projection.length : 0);
    var index = 4;
    header[3] = totalLength >> 24 & 255;
    header[2] = totalLength >> 16 & 255;
    header[1] = totalLength >> 8 & 255;
    header[0] = totalLength & 255;
    header[index + 3] = this.requestId >> 24 & 255;
    header[index + 2] = this.requestId >> 16 & 255;
    header[index + 1] = this.requestId >> 8 & 255;
    header[index] = this.requestId & 255;
    index = index + 4;
    header[index + 3] = 0 >> 24 & 255;
    header[index + 2] = 0 >> 16 & 255;
    header[index + 1] = 0 >> 8 & 255;
    header[index] = 0 & 255;
    index = index + 4;
    header[index + 3] = opcodes.OP_QUERY >> 24 & 255;
    header[index + 2] = opcodes.OP_QUERY >> 16 & 255;
    header[index + 1] = opcodes.OP_QUERY >> 8 & 255;
    header[index] = opcodes.OP_QUERY & 255;
    index = index + 4;
    header[index + 3] = flags >> 24 & 255;
    header[index + 2] = flags >> 16 & 255;
    header[index + 1] = flags >> 8 & 255;
    header[index] = flags & 255;
    index = index + 4;
    index = index + header.write(this.ns, index, "utf8") + 1;
    header[index - 1] = 0;
    header[index + 3] = this.numberToSkip >> 24 & 255;
    header[index + 2] = this.numberToSkip >> 16 & 255;
    header[index + 1] = this.numberToSkip >> 8 & 255;
    header[index] = this.numberToSkip & 255;
    index = index + 4;
    header[index + 3] = this.numberToReturn >> 24 & 255;
    header[index + 2] = this.numberToReturn >> 16 & 255;
    header[index + 1] = this.numberToReturn >> 8 & 255;
    header[index] = this.numberToReturn & 255;
    index = index + 4;
    return buffers;
  };
  Query.getRequestId = function() {
    return ++_requestId;
  };
  var GetMore = function(bson, ns, cursorId, opts) {
    opts = opts || {};
    this.numberToReturn = opts.numberToReturn || 0;
    this.requestId = _requestId++;
    this.bson = bson;
    this.ns = ns;
    this.cursorId = cursorId;
  };
  GetMore.prototype.toBin = function() {
    var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
    var index = 0;
    var _buffer = Buffer2.alloc(length);
    _buffer[index + 3] = length >> 24 & 255;
    _buffer[index + 2] = length >> 16 & 255;
    _buffer[index + 1] = length >> 8 & 255;
    _buffer[index] = length & 255;
    index = index + 4;
    _buffer[index + 3] = this.requestId >> 24 & 255;
    _buffer[index + 2] = this.requestId >> 16 & 255;
    _buffer[index + 1] = this.requestId >> 8 & 255;
    _buffer[index] = this.requestId & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = opcodes.OP_GETMORE >> 24 & 255;
    _buffer[index + 2] = opcodes.OP_GETMORE >> 16 & 255;
    _buffer[index + 1] = opcodes.OP_GETMORE >> 8 & 255;
    _buffer[index] = opcodes.OP_GETMORE & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    index = index + _buffer.write(this.ns, index, "utf8") + 1;
    _buffer[index - 1] = 0;
    _buffer[index + 3] = this.numberToReturn >> 24 & 255;
    _buffer[index + 2] = this.numberToReturn >> 16 & 255;
    _buffer[index + 1] = this.numberToReturn >> 8 & 255;
    _buffer[index] = this.numberToReturn & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 255;
    _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 255;
    _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 255;
    _buffer[index] = this.cursorId.getLowBits() & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 255;
    _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 255;
    _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 255;
    _buffer[index] = this.cursorId.getHighBits() & 255;
    index = index + 4;
    return _buffer;
  };
  var KillCursor = function(bson, ns, cursorIds) {
    this.ns = ns;
    this.requestId = _requestId++;
    this.cursorIds = cursorIds;
  };
  KillCursor.prototype.toBin = function() {
    var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
    var index = 0;
    var _buffer = Buffer2.alloc(length);
    _buffer[index + 3] = length >> 24 & 255;
    _buffer[index + 2] = length >> 16 & 255;
    _buffer[index + 1] = length >> 8 & 255;
    _buffer[index] = length & 255;
    index = index + 4;
    _buffer[index + 3] = this.requestId >> 24 & 255;
    _buffer[index + 2] = this.requestId >> 16 & 255;
    _buffer[index + 1] = this.requestId >> 8 & 255;
    _buffer[index] = this.requestId & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
    _buffer[index + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
    _buffer[index + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
    _buffer[index] = opcodes.OP_KILL_CURSORS & 255;
    index = index + 4;
    _buffer[index + 3] = 0 >> 24 & 255;
    _buffer[index + 2] = 0 >> 16 & 255;
    _buffer[index + 1] = 0 >> 8 & 255;
    _buffer[index] = 0 & 255;
    index = index + 4;
    _buffer[index + 3] = this.cursorIds.length >> 24 & 255;
    _buffer[index + 2] = this.cursorIds.length >> 16 & 255;
    _buffer[index + 1] = this.cursorIds.length >> 8 & 255;
    _buffer[index] = this.cursorIds.length & 255;
    index = index + 4;
    for (var i = 0; i < this.cursorIds.length; i++) {
      _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
      _buffer[index] = this.cursorIds[i].getLowBits() & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
      _buffer[index] = this.cursorIds[i].getHighBits() & 255;
      index = index + 4;
    }
    return _buffer;
  };
  var Response = function(bson, message, msgHeader, msgBody, opts) {
    opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
    this.parsed = false;
    this.raw = message;
    this.data = msgBody;
    this.bson = bson;
    this.opts = opts;
    this.length = msgHeader.length;
    this.requestId = msgHeader.requestId;
    this.responseTo = msgHeader.responseTo;
    this.opCode = msgHeader.opCode;
    this.fromCompressed = msgHeader.fromCompressed;
    this.responseFlags = msgBody.readInt32LE(0);
    this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
    this.startingFrom = msgBody.readInt32LE(12);
    this.numberReturned = msgBody.readInt32LE(16);
    this.documents = new Array(this.numberReturned);
    this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
    this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
    this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
    this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
    this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
    this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
    this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
  };
  Response.prototype.isParsed = function() {
    return this.parsed;
  };
  Response.prototype.parse = function(options) {
    if (this.parsed)
      return;
    options = options || {};
    var raw = options.raw || false;
    var documentsReturnedIn = options.documentsReturnedIn || null;
    var promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
    var promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
    var promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
    var bsonSize, _options;
    _options = {
      promoteLongs,
      promoteValues,
      promoteBuffers
    };
    this.index = 20;
    for (var i = 0; i < this.numberReturned; i++) {
      bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
      if (raw) {
        this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
      } else {
        this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
      }
      this.index = this.index + bsonSize;
    }
    if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
      const fieldsAsRaw = {};
      fieldsAsRaw[documentsReturnedIn] = true;
      _options.fieldsAsRaw = fieldsAsRaw;
      const doc = this.bson.deserialize(this.documents[0], _options);
      this.documents = [doc];
    }
    this.parsed = true;
  };
  module2.exports = {
    Query,
    GetMore,
    Response,
    KillCursor
  };
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var opcodes = require_shared().opcodes;
  var databaseNamespace = require_shared().databaseNamespace;
  var ReadPreference = require_read_preference();
  var _requestId = 0;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;
  var Msg = class {
    constructor(bson, ns, command, options) {
      if (command == null)
        throw new Error("query must be specified for query");
      this.bson = bson;
      this.ns = ns;
      this.command = command;
      this.command.$db = databaseNamespace(ns);
      if (options.readPreference && options.readPreference.mode !== ReadPreference.PRIMARY) {
        this.command.$readPreference = options.readPreference.toJSON();
      }
      this.options = options || {};
      this.requestId = options.requestId ? options.requestId : Msg.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome || false;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer2.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(opcodes.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeDocumentSegment(buffers, document2) {
      const payloadTypeBuffer = Buffer2.alloc(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document2);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
    serializeBson(document2) {
      return this.bson.serialize(document2, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
  };
  Msg.getRequestId = function() {
    _requestId = _requestId + 1 & 2147483647;
    return _requestId;
  };
  var BinMsg = class {
    constructor(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
      this.documents = [];
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options || {};
      this.index = 4;
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
      const promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
      const promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
      const _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers
      };
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 1) {
          console.error("TYPE 1");
        } else if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
          this.index += bsonSize;
        }
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    }
  };
  module2.exports = {Msg, BinMsg};
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS((exports2, module2) => {
  "use strict";
  var f = require("util").format;
  var MongoError = require_error().MongoError;
  var classFilters = {};
  var filteredClasses = {};
  var level = null;
  var pid = process.pid;
  var currentLogger = null;
  var Logger = function(className, options) {
    if (!(this instanceof Logger))
      return new Logger(className, options);
    options = options || {};
    this.className = className;
    if (options.logger) {
      currentLogger = options.logger;
    } else if (currentLogger == null) {
      currentLogger = console.log;
    }
    if (options.loggerLevel) {
      level = options.loggerLevel || "error";
    }
    if (filteredClasses[this.className] == null)
      classFilters[this.className] = true;
  };
  Logger.prototype.debug = function(message, object) {
    if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
      var state = {
        type: "debug",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  };
  Logger.prototype.warn = function(message, object) {
    if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
      var state = {
        type: "warn",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.info = function(message, object) {
    if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
      var state = {
        type: "info",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.error = function(message, object) {
    if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
      var dateTime = new Date().getTime();
      var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
      var state = {
        type: "error",
        message,
        className: this.className,
        pid,
        date: dateTime
      };
      if (object)
        state.meta = object;
      currentLogger(msg, state);
    }
  }, Logger.prototype.isInfo = function() {
    return level === "info" || level === "debug";
  }, Logger.prototype.isError = function() {
    return level === "error" || level === "info" || level === "debug";
  }, Logger.prototype.isWarn = function() {
    return level === "error" || level === "warn" || level === "info" || level === "debug";
  }, Logger.prototype.isDebug = function() {
    return level === "debug";
  };
  Logger.reset = function() {
    level = "error";
    filteredClasses = {};
  };
  Logger.currentLogger = function() {
    return currentLogger;
  };
  Logger.setCurrentLogger = function(logger) {
    if (typeof logger !== "function")
      throw new MongoError("current logger must be a function");
    currentLogger = logger;
  };
  Logger.filter = function(type, values) {
    if (type === "class" && Array.isArray(values)) {
      filteredClasses = {};
      values.forEach(function(x) {
        filteredClasses[x] = true;
      });
    }
  };
  Logger.setLevel = function(_level) {
    if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
      throw new Error(f("%s is an illegal logging level", _level));
    }
    level = _level;
  };
  module2.exports = Logger;
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS((exports2, module2) => {
  "use strict";
  var CommandResult = function(result, connection, message) {
    this.result = result;
    this.connection = connection;
    this.message = message;
  };
  CommandResult.prototype.toJSON = function() {
    let result = Object.assign({}, this, this.result);
    delete result.message;
    return result;
  };
  CommandResult.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  module2.exports = CommandResult;
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events").EventEmitter;
  var crypto = require("crypto");
  var debugOptions = require_utils3().debugOptions;
  var parseHeader = require_shared().parseHeader;
  var decompress = require_compression().decompress;
  var Response = require_commands().Response;
  var BinMsg = require_msg().BinMsg;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var MongoError = require_error().MongoError;
  var Logger = require_logger();
  var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
  var OP_MSG = require_shared().opcodes.OP_MSG;
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var Buffer2 = require_safe_buffer().Buffer;
  var Query = require_commands().Query;
  var CommandResult = require_command_result();
  var _id = 0;
  var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
  var DEBUG_FIELDS = [
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "checkServerIdentity"
  ];
  var connectionAccountingSpy = void 0;
  var connectionAccounting = false;
  var connections = {};
  var Connection = class extends EventEmitter2 {
    constructor(socket, options) {
      super();
      options = options || {};
      if (!options.bson) {
        throw new TypeError("must pass in valid bson parser");
      }
      this.id = _id++;
      this.options = options;
      this.logger = Logger("Connection", options);
      this.bson = options.bson;
      this.tag = options.tag;
      this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
      this.port = options.port || 27017;
      this.host = options.host || "localhost";
      this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      this.keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
      this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
      this.connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : 3e4;
      if (this.keepAliveInitialDelay > this.socketTimeout) {
        this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
      }
      if (this.logger.isDebug()) {
        this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);
      }
      this.responseOptions = {
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false
      };
      this.flushing = false;
      this.queue = [];
      this.writeStream = null;
      this.destroyed = false;
      this.timedOut = false;
      const hash = crypto.createHash("sha1");
      hash.update(this.address);
      this.hashedName = hash.digest("hex");
      this.workItems = [];
      this.socket = socket;
      this.socket.once("error", errorHandler(this));
      this.socket.once("timeout", timeoutHandler(this));
      this.socket.once("close", closeHandler(this));
      this.socket.on("data", dataHandler(this));
      if (connectionAccounting) {
        addConnection(this.id, this);
      }
    }
    setSocketTimeout(value) {
      if (this.socket) {
        this.socket.setTimeout(value);
      }
    }
    resetSocketTimeout() {
      if (this.socket) {
        this.socket.setTimeout(this.socketTimeout);
      }
    }
    static enableConnectionAccounting(spy) {
      if (spy) {
        connectionAccountingSpy = spy;
      }
      connectionAccounting = true;
      connections = {};
    }
    static disableConnectionAccounting() {
      connectionAccounting = false;
      connectionAccountingSpy = void 0;
    }
    static connections() {
      return connections;
    }
    get address() {
      return `${this.host}:${this.port}`;
    }
    unref() {
      if (this.socket == null) {
        this.once("connect", () => this.socket.unref());
        return;
      }
      this.socket.unref();
    }
    flush(err) {
      while (this.workItems.length > 0) {
        const workItem = this.workItems.shift();
        if (workItem.cb) {
          workItem.cb(err);
        }
      }
    }
    destroy(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = Object.assign({force: false}, options);
      if (connectionAccounting) {
        deleteConnection(this.id);
      }
      if (this.socket == null) {
        this.destroyed = true;
        return;
      }
      if (options.force || this.timedOut) {
        this.socket.destroy();
        this.destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this.socket.end((err) => {
        this.destroyed = true;
        if (typeof callback === "function")
          callback(err, null);
      });
    }
    write(buffer) {
      if (this.logger.isDebug()) {
        if (!Array.isArray(buffer)) {
          this.logger.debug(`writing buffer [${buffer.toString("hex")}] to ${this.address}`);
        } else {
          for (let i = 0; i < buffer.length; i++)
            this.logger.debug(`writing buffer [${buffer[i].toString("hex")}] to ${this.address}`);
        }
      }
      if (this.socket.destroyed === false) {
        if (!Array.isArray(buffer)) {
          this.socket.write(buffer, "binary");
          return true;
        }
        for (let i = 0; i < buffer.length; i++) {
          this.socket.write(buffer[i], "binary");
        }
        return true;
      }
      return false;
    }
    toString() {
      return "" + this.id;
    }
    toJSON() {
      return {id: this.id, host: this.host, port: this.port};
    }
    isConnected() {
      if (this.destroyed)
        return false;
      return !this.socket.destroyed && this.socket.writable;
    }
    command(ns, command, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      const conn = this;
      const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      const bson = conn.options.bson;
      const query = new Query(bson, ns, command, {
        numberToSkip: 0,
        numberToReturn: 1
      });
      const noop = () => {
      };
      function _callback(err, result) {
        callback(err, result);
        callback = noop;
      }
      function errorHandler2(err) {
        conn.resetSocketTimeout();
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
        conn.removeListener("message", messageHandler);
        if (err == null) {
          err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
        }
        conn.on("error", noop);
        _callback(err);
      }
      function messageHandler(msg) {
        if (msg.responseTo !== query.requestId) {
          return;
        }
        conn.resetSocketTimeout();
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
        conn.removeListener("message", messageHandler);
        msg.parse({promoteValues: true});
        const response = msg.documents[0];
        if (response.ok === 0 || response.$err || response.errmsg || response.code) {
          _callback(new MongoError(response));
          return;
        }
        _callback(void 0, new CommandResult(response, this, msg));
      }
      conn.setSocketTimeout(socketTimeout);
      CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
      conn.on("message", messageHandler);
      conn.write(query.toBin());
    }
  };
  var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
  function deleteConnection(id) {
    delete connections[id];
    if (connectionAccountingSpy) {
      connectionAccountingSpy.deleteConnection(id);
    }
  }
  function addConnection(id, connection) {
    connections[id] = connection;
    if (connectionAccountingSpy) {
      connectionAccountingSpy.addConnection(id, connection);
    }
  }
  function errorHandler(conn) {
    return function(err) {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
      }
      conn.emit("error", new MongoNetworkError(err), conn);
    };
  }
  function timeoutHandler(conn) {
    return function() {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
      }
      conn.timedOut = true;
      conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
        beforeHandshake: conn.ismaster == null
      }), conn);
    };
  }
  function closeHandler(conn) {
    return function(hadError) {
      if (connectionAccounting)
        deleteConnection(conn.id);
      if (conn.logger.isDebug()) {
        conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
      }
      if (!hadError) {
        conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
      }
    };
  }
  function processMessage(conn, message) {
    const msgHeader = parseHeader(message);
    if (msgHeader.opCode !== OP_COMPRESSED) {
      const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
      conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
      return;
    }
    msgHeader.fromCompressed = true;
    let index = MESSAGE_HEADER_SIZE;
    msgHeader.opCode = message.readInt32LE(index);
    index += 4;
    msgHeader.length = message.readInt32LE(index);
    index += 4;
    const compressorID = message[index];
    index++;
    decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {
      if (err) {
        conn.emit("error", err);
        return;
      }
      if (decompressedMsgBody.length !== msgHeader.length) {
        conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
        return;
      }
      const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
      conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
    });
  }
  function dataHandler(conn) {
    return function(data) {
      while (data.length > 0) {
        if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
          const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
          if (remainingBytesToRead > data.length) {
            data.copy(conn.buffer, conn.bytesRead);
            conn.bytesRead = conn.bytesRead + data.length;
            data = Buffer2.alloc(0);
          } else {
            data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
            data = data.slice(remainingBytesToRead);
            const emitBuffer = conn.buffer;
            conn.buffer = null;
            conn.sizeOfMessage = 0;
            conn.bytesRead = 0;
            conn.stubBuffer = null;
            processMessage(conn, emitBuffer);
          }
        } else {
          if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
            if (conn.stubBuffer.length + data.length > 4) {
              const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
              conn.stubBuffer.copy(newData, 0);
              data.copy(newData, conn.stubBuffer.length);
              data = newData;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
            } else {
              const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
              conn.stubBuffer.copy(newStubBuffer, 0);
              data.copy(newStubBuffer, conn.stubBuffer.length);
              data = Buffer2.alloc(0);
            }
          } else {
            if (data.length > 4) {
              const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
              if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                const errorObject = {
                  err: "socketHandler",
                  trace: "",
                  bin: conn.buffer,
                  parseState: {
                    sizeOfMessage,
                    bytesRead: conn.bytesRead,
                    stubBuffer: conn.stubBuffer
                  }
                };
                conn.emit("parseError", errorObject, conn);
                return;
              }
              if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                conn.buffer = Buffer2.alloc(sizeOfMessage);
                data.copy(conn.buffer, 0);
                conn.bytesRead = data.length;
                conn.sizeOfMessage = sizeOfMessage;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
              } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                const emitBuffer = data;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
                processMessage(conn, emitBuffer);
              } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                const errorObject = {
                  err: "socketHandler",
                  trace: null,
                  bin: data,
                  parseState: {
                    sizeOfMessage,
                    bytesRead: 0,
                    buffer: null,
                    stubBuffer: null
                  }
                };
                conn.emit("parseError", errorObject, conn);
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = Buffer2.alloc(0);
              } else {
                const emitBuffer = data.slice(0, sizeOfMessage);
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
                data = data.slice(sizeOfMessage);
                processMessage(conn, emitBuffer);
              }
            } else {
              conn.stubBuffer = Buffer2.alloc(data.length);
              data.copy(conn.stubBuffer, 0);
              data = Buffer2.alloc(0);
            }
          }
        }
      }
    };
  }
  module2.exports = Connection;
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS((exports2, module2) => {
  "use strict";
  var Msg = require_msg().Msg;
  var KillCursor = require_commands().KillCursor;
  var GetMore = require_commands().GetMore;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var namespace = (command) => command.ns;
  var databaseName = (command) => command.ns.split(".")[0];
  var collectionName = (command) => command.ns.split(".")[1];
  var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
  var maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;
  var isLegacyPool = (pool) => pool.s && pool.queue;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldsSelector: "projection"
  };
  var OP_QUERY_KEYS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "partial",
    "exhaust"
  ];
  var extractCommand = (command) => {
    if (command instanceof GetMore) {
      return {
        getMore: command.cursorId,
        collection: collectionName(command),
        batchSize: command.numberToReturn
      };
    }
    if (command instanceof KillCursor) {
      return {
        killCursors: collectionName(command),
        cursors: command.cursorIds
      };
    }
    if (command instanceof Msg) {
      return command.command;
    }
    if (command.query && command.query.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = {find: collectionName(command)};
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (typeof command.query[key] !== "undefined")
            result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        if (typeof command[key] !== "undefined")
          result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];
      });
      OP_QUERY_KEYS.forEach((key) => {
        if (command[key])
          result[key] = command[key];
      });
      if (typeof command.pre32Limit !== "undefined") {
        result.limit = command.pre32Limit;
      }
      if (command.query.$explain) {
        return {explain: result};
      }
      return result;
    }
    return command.query ? command.query : command;
  };
  var extractReply = (command, reply) => {
    if (command instanceof GetMore) {
      return {
        ok: 1,
        cursor: {
          id: reply.message.cursorId,
          ns: namespace(command),
          nextBatch: reply.message.documents
        }
      };
    }
    if (command instanceof KillCursor) {
      return {
        ok: 1,
        cursorsUnknown: command.cursorIds
      };
    }
    if (command.query && typeof command.query.$query !== "undefined") {
      return {
        ok: 1,
        cursor: {
          id: reply.message.cursorId,
          ns: namespace(command),
          firstBatch: reply.message.documents
        }
      };
    }
    return reply && reply.result ? reply.result : reply;
  };
  var extractConnectionDetails = (pool) => {
    if (isLegacyPool(pool)) {
      return {
        connectionId: generateConnectionId(pool)
      };
    }
    const connection = pool;
    return {
      address: connection.address,
      connectionId: connection.id
    };
  };
  var CommandStartedEvent = class {
    constructor(pool, command) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      if (SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        databaseName: databaseName(command),
        commandName,
        command: cmd
      });
    }
  };
  var CommandSucceededEvent = class {
    constructor(pool, command, reply, started) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        commandName,
        duration: calculateDurationInMs(started),
        reply: maybeRedact(commandName, extractReply(command, reply))
      });
    }
  };
  var CommandFailedEvent = class {
    constructor(pool, command, error, started) {
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const connectionDetails = extractConnectionDetails(pool);
      Object.assign(this, connectionDetails, {
        requestId: command.requestId,
        commandName,
        duration: calculateDurationInMs(started),
        failure: maybeRedact(commandName, error)
      });
    }
  };
  module2.exports = {
    CommandStartedEvent,
    CommandSucceededEvent,
    CommandFailedEvent
  };
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS((exports2, module2) => {
  "use strict";
  var AuthContext = class {
    constructor(connection, credentials, options) {
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  };
  var AuthProvider = class {
    constructor(bson) {
      this.bson = bson;
    }
    prepare(handshakeDoc, context, callback) {
      callback(void 0, handshakeDoc);
    }
    auth(context, callback) {
      callback(new TypeError("`auth` method must be overridden by subclass"));
    }
  };
  module2.exports = {AuthContext, AuthProvider};
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS((exports2, module2) => {
  "use strict";
  var crypto = require("crypto");
  var AuthProvider = require_auth_provider().AuthProvider;
  var MongoCR = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const username = credentials.username;
      const password = credentials.password;
      const source = credentials.source;
      connection.command(`${source}.$cmd`, {getnonce: 1}, (err, result) => {
        let nonce = null;
        let key = null;
        if (err == null) {
          const r = result.result;
          nonce = r.nonce;
          let md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password, "utf8");
          const hash_password = md5.digest("hex");
          md5 = crypto.createHash("md5");
          md5.update(nonce + username + hash_password, "utf8");
          key = md5.digest("hex");
        }
        const authenticateCommand = {
          authenticate: 1,
          user: username,
          nonce,
          key
        };
        connection.command(`${source}.$cmd`, authenticateCommand, callback);
      });
    }
  };
  module2.exports = MongoCR;
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  "use strict";
  var AuthProvider = require_auth_provider().AuthProvider;
  var X509 = class extends AuthProvider {
    prepare(handshakeDoc, authContext, callback) {
      const credentials = authContext.credentials;
      Object.assign(handshakeDoc, {
        speculativeAuthenticate: x509AuthenticateCommand(credentials)
      });
      callback(void 0, handshakeDoc);
    }
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const response = authContext.response;
      if (response.speculativeAuthenticate) {
        return callback();
      }
      connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
    }
  };
  function x509AuthenticateCommand(credentials) {
    const command = {authenticate: 1, mechanism: "MONGODB-X509"};
    if (credentials.username) {
      Object.assign(command, {user: credentials.username});
    }
    return command;
  }
  module2.exports = X509;
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var AuthProvider = require_auth_provider().AuthProvider;
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var Plain = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const username = credentials.username;
      const password = credentials.password;
      const payload = new Binary2(`\0${username}\0${password}`);
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      connection.command("$external.$cmd", command, callback);
    }
  };
  module2.exports = Plain;
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS((exports2, module2) => {
  "use strict";
  var dns = require("dns");
  var AuthProvider = require_auth_provider().AuthProvider;
  var retrieveKerberos = require_utils2().retrieveKerberos;
  var MongoError = require_error().MongoError;
  var kerberos;
  var GSSAPI = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (credentials == null)
        return callback(new MongoError("credentials required"));
      const username = credentials.username;
      function externalCommand(command, cb) {
        return connection.command("$external.$cmd", command, cb);
      }
      makeKerberosClient(authContext, (err, client) => {
        if (err)
          return callback(err);
        if (client == null)
          return callback(new MongoError("gssapi client missing"));
        client.step("", (err2, payload) => {
          if (err2)
            return callback(err2);
          externalCommand(saslStart(payload), (err3, response) => {
            if (err3)
              return callback(err3);
            const result = response.result;
            negotiate(client, 10, result.payload, (err4, payload2) => {
              if (err4)
                return callback(err4);
              externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                if (err5)
                  return callback(err5);
                const result2 = response2.result;
                finalize(client, username, result2.payload, (err6, payload3) => {
                  if (err6)
                    return callback(err6);
                  externalCommand({
                    saslContinue: 1,
                    conversationId: result2.conversationId,
                    payload: payload3
                  }, (err7, result3) => {
                    if (err7)
                      return callback(err7);
                    callback(void 0, result3);
                  });
                });
              });
            });
          });
        });
      });
    }
  };
  module2.exports = GSSAPI;
  function makeKerberosClient(authContext, callback) {
    const host = authContext.options.host;
    const port = authContext.options.port;
    const credentials = authContext.credentials;
    if (!host || !port || !credentials) {
      return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
    }
    if (kerberos == null) {
      try {
        kerberos = retrieveKerberos();
      } catch (e) {
        return callback(e);
      }
    }
    const username = credentials.username;
    const password = credentials.password;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
    performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
      if (err)
        return callback(err);
      const initOptions = {};
      if (password != null) {
        Object.assign(initOptions, {user: username, password});
      }
      kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
        if (err2)
          return callback(new MongoError(err2));
        callback(null, client);
      });
    });
  }
  function saslStart(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  }
  function saslContinue(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  }
  function negotiate(client, retries, payload, callback) {
    client.step(payload, (err, response) => {
      if (err && retries === 0)
        return callback(err);
      if (err)
        return negotiate(client, retries - 1, payload, callback);
      callback(void 0, response || "");
    });
  }
  function finalize(client, user, payload, callback) {
    client.unwrap(payload, (err, response) => {
      if (err)
        return callback(err);
      client.wrap(response || "", {user}, (err2, wrapped) => {
        if (err2)
          return callback(err2);
        callback(void 0, wrapped);
      });
    });
  }
  function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
    const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
    if (!canonicalizeHostName)
      return callback(void 0, host);
    dns.resolveCname(host, (err, r) => {
      if (err)
        return callback(err);
      if (Array.isArray(r) && r.length > 0) {
        return callback(void 0, r[0]);
      }
      callback(void 0, host);
    });
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS((exports2, module2) => {
  "use strict";
  var crypto = require("crypto");
  var Buffer2 = require_safe_buffer().Buffer;
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var AuthProvider = require_auth_provider().AuthProvider;
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var saslprep;
  try {
    saslprep = require("saslprep");
  } catch (e) {
  }
  var ScramSHA = class extends AuthProvider {
    constructor(bson, cryptoMethod) {
      super(bson);
      this.cryptoMethod = cryptoMethod || "sha1";
    }
    prepare(handshakeDoc, authContext, callback) {
      const cryptoMethod = this.cryptoMethod;
      if (cryptoMethod === "sha256" && saslprep == null) {
        console.warn("Warning: no saslprep library specified. Passwords will not be sanitized");
      }
      crypto.randomBytes(24, (err, nonce) => {
        if (err) {
          return callback(err);
        }
        Object.assign(authContext, {nonce});
        const credentials = authContext.credentials;
        const request = Object.assign({}, handshakeDoc, {
          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
            db: credentials.source
          })
        });
        callback(void 0, request);
      });
    }
    auth(authContext, callback) {
      const response = authContext.response;
      if (response && response.speculativeAuthenticate) {
        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
        return;
      }
      executeScram(this.cryptoMethod, authContext, callback);
    }
  };
  function cleanUsername(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  }
  function clientFirstMessageBare(username, nonce) {
    return Buffer2.concat([
      Buffer2.from("n=", "utf8"),
      Buffer2.from(username, "utf8"),
      Buffer2.from(",r=", "utf8"),
      Buffer2.from(nonce.toString("base64"), "utf8")
    ]);
  }
  function makeFirstMessage(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
    return {
      saslStart: 1,
      mechanism,
      payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: {skipEmptyExchange: true}
    };
  }
  function executeScram(cryptoMethod, authContext, callback) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
      const err = resolveError(_err, result);
      if (err) {
        return callback(err);
      }
      continueScramConversation(cryptoMethod, result.result, authContext, callback);
    });
  }
  function continueScramConversation(cryptoMethod, response, authContext, callback) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    let processedPassword;
    if (cryptoMethod === "sha256") {
      processedPassword = saslprep ? saslprep(password) : password;
    } else {
      try {
        processedPassword = passwordDigest(username, password);
      } catch (e) {
        return callback(e);
      }
    }
    const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
    const dict = parsePayload(payload.value());
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
      return;
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
      return;
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H(cryptoMethod, clientKey);
    const authMessage = [
      clientFirstMessageBare(username, nonce),
      payload.value().toString("base64"),
      withoutProof
    ].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new Binary2(Buffer2.from(clientFinal))
    };
    connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
      const err = resolveError(_err, result);
      if (err) {
        return callback(err);
      }
      const r = result.result;
      const parsedResponse = parsePayload(r.payload.value());
      if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
        callback(new MongoError("Server returned an invalid signature"));
        return;
      }
      if (!r || r.done !== false) {
        return callback(err, r);
      }
      const retrySaslContinueCmd = {
        saslContinue: 1,
        conversationId: r.conversationId,
        payload: Buffer2.alloc(0)
      };
      connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
    });
  }
  function parsePayload(payload) {
    const dict = {};
    const parts = payload.split(",");
    for (let i = 0; i < parts.length; i++) {
      const valueParts = parts[i].split("=");
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  }
  function passwordDigest(username, password) {
    if (typeof username !== "string") {
      throw new MongoError("username must be a string");
    }
    if (typeof password !== "string") {
      throw new MongoError("password must be a string");
    }
    if (password.length === 0) {
      throw new MongoError("password cannot be empty");
    }
    const md5 = crypto.createHash("md5");
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  }
  function xor(a, b) {
    if (!Buffer2.isBuffer(a)) {
      a = Buffer2.from(a);
    }
    if (!Buffer2.isBuffer(b)) {
      b = Buffer2.from(b);
    }
    const length = Math.max(a.length, b.length);
    const res = [];
    for (let i = 0; i < length; i += 1) {
      res.push(a[i] ^ b[i]);
    }
    return Buffer2.from(res).toString("base64");
  }
  function H(method, text) {
    return crypto.createHash(method).update(text).digest();
  }
  function HMAC(method, key, text) {
    return crypto.createHmac(method, key).update(text).digest();
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  function _hiCachePurge() {
    _hiCache = {};
    _hiCacheCount = 0;
  }
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };
  function HI(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] !== void 0) {
      return _hiCache[key];
    }
    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  }
  function compareDigest(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto.timingSafeEqual === "function") {
      return crypto.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i = 0; i < lhs.length; i++) {
      result |= lhs[i] ^ rhs[i];
    }
    return result === 0;
  }
  function resolveError(err, result) {
    if (err)
      return err;
    const r = result.result;
    if (r.$err || r.errmsg)
      return new MongoError(r);
  }
  var ScramSHA1 = class extends ScramSHA {
    constructor(bson) {
      super(bson, "sha1");
    }
  };
  var ScramSHA256 = class extends ScramSHA {
    constructor(bson) {
      super(bson, "sha256");
    }
  };
  module2.exports = {ScramSHA1, ScramSHA256};
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports2, module2) => {
  "use strict";
  function getDefaultAuthMechanism(ismaster) {
    if (ismaster) {
      if (Array.isArray(ismaster.saslSupportedMechs)) {
        return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
      }
      if (ismaster.maxWireVersion >= 3) {
        return "scram-sha-1";
      }
    }
    return "mongocr";
  }
  var MongoCredentials = class {
    constructor(options) {
      options = options || {};
      this.username = options.username;
      this.password = options.password;
      this.source = options.source || options.db;
      this.mechanism = options.mechanism || "default";
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (this.username == null && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (this.password == null && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN) {
          this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
        }
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(ismaster) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(ismaster),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
  };
  module2.exports = {MongoCredentials};
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports2, module2) => {
  "use strict";
  var AuthProvider = require_auth_provider().AuthProvider;
  var MongoCredentials = require_mongo_credentials().MongoCredentials;
  var MongoError = require_error().MongoError;
  var crypto = require("crypto");
  var http = require("http");
  var maxWireVersion = require_utils2().maxWireVersion;
  var url = require("url");
  var aws4;
  try {
    aws4 = require("aws4");
  } catch (e) {
  }
  var ASCII_N = 110;
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
  var MongoDBAWS = class extends AuthProvider {
    auth(authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (maxWireVersion(connection) < 9) {
        callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
        return;
      }
      if (aws4 == null) {
        callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
        return;
      }
      if (credentials.username == null) {
        makeTempCredentials(credentials, (err, tempCredentials) => {
          if (err)
            return callback(err);
          authContext.credentials = tempCredentials;
          this.auth(authContext, callback);
        });
        return;
      }
      const username = credentials.username;
      const password = credentials.password;
      const db = credentials.source;
      const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const bson = this.bson;
      crypto.randomBytes(32, (err, nonce) => {
        if (err) {
          callback(err);
          return;
        }
        const saslStart = {
          saslStart: 1,
          mechanism: "MONGODB-AWS",
          payload: bson.serialize({r: nonce, p: ASCII_N})
        };
        connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
          if (err2)
            return callback(err2);
          const res = result.result;
          const serverResponse = bson.deserialize(res.payload.buffer);
          const host = serverResponse.h;
          const serverNonce = serverResponse.s.buffer;
          if (serverNonce.length !== 64) {
            callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
            return;
          }
          if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
            callback(new MongoError("Server nonce does not begin with client nonce"));
            return;
          }
          if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
            callback(new MongoError(`Server returned an invalid host: "${host}"`));
            return;
          }
          const body = "Action=GetCallerIdentity&Version=2011-06-15";
          const options = aws4.sign({
            method: "POST",
            host,
            region: deriveRegion(serverResponse.h),
            service: "sts",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "Content-Length": body.length,
              "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
              "X-MongoDB-GS2-CB-Flag": "n"
            },
            path: "/",
            body
          }, {
            accessKeyId: username,
            secretAccessKey: password,
            token
          });
          const authorization = options.headers.Authorization;
          const date = options.headers["X-Amz-Date"];
          const payload = {a: authorization, d: date};
          if (token) {
            payload.t = token;
          }
          const saslContinue = {
            saslContinue: 1,
            conversationId: 1,
            payload: bson.serialize(payload)
          };
          connection.command(`${db}.$cmd`, saslContinue, (err3) => {
            if (err3)
              return callback(err3);
            callback();
          });
        });
      });
    }
  };
  function makeTempCredentials(credentials, callback) {
    function done(creds) {
      if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
        callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
        return;
      }
      callback(void 0, new MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: "MONGODB-AWS",
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      }));
    }
    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
      request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
        if (err)
          return callback(err);
        done(res);
      });
      return;
    }
    request(`${AWS_EC2_URI}/latest/api/token`, {method: "PUT", json: false, headers: {"X-aws-ec2-metadata-token-ttl-seconds": 30}}, (err, token) => {
      if (err)
        return callback(err);
      request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {json: false, headers: {"X-aws-ec2-metadata-token": token}}, (err2, roleName) => {
        if (err2)
          return callback(err2);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {headers: {"X-aws-ec2-metadata-token": token}}, (err3, creds) => {
          if (err3)
            return callback(err3);
          done(creds);
        });
      });
    });
  }
  function deriveRegion(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  }
  function request(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = Object.assign({
      method: "GET",
      timeout: 1e4,
      json: true
    }, url.parse(uri), options);
    const req = http.request(options, (res) => {
      res.setEncoding("utf8");
      let data = "";
      res.on("data", (d) => data += d);
      res.on("end", () => {
        if (options.json === false) {
          callback(void 0, data);
          return;
        }
        try {
          const parsed = JSON.parse(data);
          callback(void 0, parsed);
        } catch (err) {
          callback(new MongoError(`Invalid JSON response: "${data}"`));
        }
      });
    });
    req.on("error", (err) => callback(err));
    req.end();
  }
  module2.exports = MongoDBAWS;
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS((exports2, module2) => {
  "use strict";
  var MongoCR = require_mongocr();
  var X509 = require_x509();
  var Plain = require_plain();
  var GSSAPI = require_gssapi();
  var ScramSHA1 = require_scram().ScramSHA1;
  var ScramSHA256 = require_scram().ScramSHA256;
  var MongoDBAWS = require_mongodb_aws();
  function defaultAuthProviders(bson) {
    return {
      "mongodb-aws": new MongoDBAWS(bson),
      mongocr: new MongoCR(bson),
      x509: new X509(bson),
      plain: new Plain(bson),
      gssapi: new GSSAPI(bson),
      "scram-sha-1": new ScramSHA1(bson),
      "scram-sha-256": new ScramSHA256(bson)
    };
  }
  module2.exports = {defaultAuthProviders};
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS((exports2, module2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var Connection = require_connection();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
  var AuthContext = require_auth_provider().AuthContext;
  var WIRE_CONSTANTS = require_constants2();
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var AUTH_PROVIDERS;
  function connect(options, cancellationToken, callback) {
    if (typeof cancellationToken === "function") {
      callback = cancellationToken;
      cancellationToken = void 0;
    }
    const ConnectionType = options && options.connectionType ? options.connectionType : Connection;
    if (AUTH_PROVIDERS == null) {
      AUTH_PROVIDERS = defaultAuthProviders(options.bson);
    }
    const family = options.family !== void 0 ? options.family : 0;
    makeConnection(family, options, cancellationToken, (err, socket) => {
      if (err) {
        callback(err, socket);
        return;
      }
      performInitialHandshake(new ConnectionType(socket, options), options, callback);
    });
  }
  function isModernConnectionType(conn) {
    return !(conn instanceof Connection);
  }
  function checkSupportedServer(ismaster, options) {
    const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message2);
    }
    const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
    return new MongoError(message);
  }
  function performInitialHandshake(conn, options, _callback) {
    const callback = function(err, ret) {
      if (err && conn) {
        conn.destroy();
      }
      _callback(err, ret);
    };
    const credentials = options.credentials;
    if (credentials) {
      if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
        callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
        return;
      }
    }
    const authContext = new AuthContext(conn, credentials, options);
    prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
      if (err) {
        return callback(err);
      }
      const handshakeOptions = Object.assign({}, options);
      if (options.connectTimeoutMS || options.connectionTimeout) {
        handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;
      }
      const start = new Date().getTime();
      conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
        if (err2) {
          callback(err2);
          return;
        }
        const response = result.result;
        if (response.ok === 0) {
          callback(new MongoError(response));
          return;
        }
        const supportedServerErr = checkSupportedServer(response, options);
        if (supportedServerErr) {
          callback(supportedServerErr);
          return;
        }
        if (!isModernConnectionType(conn)) {
          if (response.compression) {
            const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
            if (agreedCompressors.length) {
              conn.agreedCompressor = agreedCompressors[0];
            }
            if (options.compression && options.compression.zlibCompressionLevel) {
              conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;
            }
          }
        }
        conn.ismaster = response;
        conn.lastIsMasterMS = new Date().getTime() - start;
        if (!response.arbiterOnly && credentials) {
          Object.assign(authContext, {response});
          const resolvedCredentials = credentials.resolveAuthMechanism(response);
          const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
          authProvider.auth(authContext, (err3) => {
            if (err3)
              return callback(err3);
            callback(void 0, conn);
          });
          return;
        }
        callback(void 0, conn);
      });
    });
  }
  function prepareHandshakeDocument(authContext, callback) {
    const options = authContext.options;
    const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];
    const handshakeDoc = {
      ismaster: true,
      client: options.metadata || makeClientMetadata(options),
      compression: compressors
    };
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
        Object.assign(handshakeDoc, {
          saslSupportedMechs: `${credentials.source}.${credentials.username}`
        });
        AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
        return;
      }
      const authProvider = AUTH_PROVIDERS[credentials.mechanism];
      authProvider.prepare(handshakeDoc, authContext, callback);
      return;
    }
    callback(void 0, handshakeDoc);
  }
  var LEGAL_SSL_SOCKET_OPTIONS = [
    "pfx",
    "key",
    "passphrase",
    "cert",
    "ca",
    "ciphers",
    "NPNProtocols",
    "ALPNProtocols",
    "servername",
    "ecdhCurve",
    "secureProtocol",
    "secureContext",
    "session",
    "minDHSize",
    "crl",
    "rejectUnauthorized"
  ];
  function parseConnectOptions(family, options) {
    const host = typeof options.host === "string" ? options.host : "localhost";
    if (host.indexOf("/") !== -1) {
      return {path: host};
    }
    const result = {
      family,
      host,
      port: typeof options.port === "number" ? options.port : 27017,
      rejectUnauthorized: false
    };
    return result;
  }
  function parseSslOptions(family, options) {
    const result = parseConnectOptions(family, options);
    for (const name in options) {
      if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
        result[name] = options[name];
      }
    }
    if (options.checkServerIdentity === false) {
      result.checkServerIdentity = function() {
        return void 0;
      };
    } else if (typeof options.checkServerIdentity === "function") {
      result.checkServerIdentity = options.checkServerIdentity;
    }
    if (result.servername == null) {
      result.servername = result.host;
    }
    return result;
  }
  var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
  function makeConnection(family, options, cancellationToken, _callback) {
    const useSsl = typeof options.ssl === "boolean" ? options.ssl : false;
    const keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
    let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
    const noDelay = typeof options.noDelay === "boolean" ? options.noDelay : true;
    const connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 3e4;
    const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
    const rejectUnauthorized = typeof options.rejectUnauthorized === "boolean" ? options.rejectUnauthorized : true;
    if (keepAliveInitialDelay > socketTimeout) {
      keepAliveInitialDelay = Math.round(socketTimeout / 2);
    }
    let socket;
    const callback = function(err, ret) {
      if (err && socket) {
        socket.destroy();
      }
      _callback(err, ret);
    };
    try {
      if (useSsl) {
        socket = tls.connect(parseSslOptions(family, options));
        if (typeof socket.disableRenegotiation === "function") {
          socket.disableRenegotiation();
        }
      } else {
        socket = net.createConnection(parseConnectOptions(family, options));
      }
    } catch (err) {
      return callback(err);
    }
    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
    socket.setTimeout(connectionTimeout);
    socket.setNoDelay(noDelay);
    const connectEvent = useSsl ? "secureConnect" : "connect";
    let cancellationHandler;
    function errorHandler(eventName) {
      return (err) => {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        socket.removeListener(connectEvent, connectHandler);
        callback(connectionFailureError(eventName, err));
      };
    }
    function connectHandler() {
      SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
      if (cancellationHandler) {
        cancellationToken.removeListener("cancel", cancellationHandler);
      }
      if (socket.authorizationError && rejectUnauthorized) {
        return callback(socket.authorizationError);
      }
      socket.setTimeout(socketTimeout);
      callback(null, socket);
    }
    SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
    if (cancellationToken) {
      cancellationHandler = errorHandler("cancel");
      cancellationToken.once("cancel", cancellationHandler);
    }
    socket.once(connectEvent, connectHandler);
  }
  function connectionFailureError(type, err) {
    switch (type) {
      case "error":
        return new MongoNetworkError(err);
      case "timeout":
        return new MongoNetworkTimeoutError(`connection timed out`);
      case "close":
        return new MongoNetworkError(`connection closed`);
      case "cancel":
        return new MongoNetworkError(`connection establishment was cancelled`);
      default:
        return new MongoNetworkError(`unknown network error`);
    }
  }
  module2.exports = connect;
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports2, module2) => {
  "use strict";
  var ReadConcern = class {
    constructor(level) {
      if (level != null) {
        this.level = level;
      }
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        if (options.readConcern instanceof ReadConcern) {
          return options.readConcern;
        }
        return new ReadConcern(options.readConcern.level);
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
    }
    static get MAJORITY() {
      return "majority";
    }
    static get AVAILABLE() {
      return "available";
    }
    static get LINEARIZABLE() {
      return "linearizable";
    }
    static get SNAPSHOT() {
      return "snapshot";
    }
  };
  module2.exports = ReadConcern;
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var ReadPreference = require_read_preference();
  var ReadConcern = require_read_concern();
  var WriteConcern = require_write_concern();
  var TxnState;
  var stateMachine;
  (() => {
    const NO_TRANSACTION = "NO_TRANSACTION";
    const STARTING_TRANSACTION = "STARTING_TRANSACTION";
    const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
    const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
    const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
    const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
    TxnState = {
      NO_TRANSACTION,
      STARTING_TRANSACTION,
      TRANSACTION_IN_PROGRESS,
      TRANSACTION_COMMITTED,
      TRANSACTION_COMMITTED_EMPTY,
      TRANSACTION_ABORTED
    };
    stateMachine = {
      [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
      [STARTING_TRANSACTION]: [
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      ],
      [TRANSACTION_IN_PROGRESS]: [
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_ABORTED
      ],
      [TRANSACTION_COMMITTED]: [
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        STARTING_TRANSACTION,
        NO_TRANSACTION
      ],
      [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
      [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
    };
  })();
  var Transaction = class {
    constructor(options) {
      options = options || {};
      this.state = TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w <= 0) {
          throw new MongoError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = void 0;
      this._recoveryToken = void 0;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isActive() {
      return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.indexOf(nextState) !== -1) {
        this.state = nextState;
        if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
          this.unpinServer();
        }
        return;
      }
      throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = void 0;
    }
  };
  function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  }
  module2.exports = {TxnState, Transaction, isTransactionCommand};
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_read_preference();
  var TopologyType = require_common2().TopologyType;
  var MongoError = require_error().MongoError;
  var isRetryableWriteError = require_error().isRetryableWriteError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  function createCompressionInfo(options) {
    if (!options.compression || !options.compression.compressors) {
      return [];
    }
    options.compression.compressors.forEach(function(compressor) {
      if (compressor !== "snappy" && compressor !== "zlib") {
        throw new Error("compressors must be at least one of snappy or zlib");
      }
    });
    return options.compression.compressors;
  }
  function clone(object) {
    return JSON.parse(JSON.stringify(object));
  }
  var getPreviousDescription = function(self2) {
    if (!self2.s.serverDescription) {
      self2.s.serverDescription = {
        address: self2.name,
        arbiters: [],
        hosts: [],
        passives: [],
        type: "Unknown"
      };
    }
    return self2.s.serverDescription;
  };
  var emitServerDescriptionChanged = function(self2, description) {
    if (self2.listeners("serverDescriptionChanged").length > 0) {
      self2.emit("serverDescriptionChanged", {
        topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
        address: self2.name,
        previousDescription: getPreviousDescription(self2),
        newDescription: description
      });
      self2.s.serverDescription = description;
    }
  };
  var getPreviousTopologyDescription = function(self2) {
    if (!self2.s.topologyDescription) {
      self2.s.topologyDescription = {
        topologyType: "Unknown",
        servers: [
          {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: "Unknown"
          }
        ]
      };
    }
    return self2.s.topologyDescription;
  };
  var emitTopologyDescriptionChanged = function(self2, description) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      self2.emit("topologyDescriptionChanged", {
        topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
        address: self2.name,
        previousDescription: getPreviousTopologyDescription(self2),
        newDescription: description
      });
      self2.s.serverDescription = description;
    }
  };
  var changedIsMaster = function(self2, currentIsmaster, ismaster) {
    var currentType = getTopologyType(self2, currentIsmaster);
    var newType = getTopologyType(self2, ismaster);
    if (newType !== currentType)
      return true;
    return false;
  };
  var getTopologyType = function(self2, ismaster) {
    if (!ismaster) {
      ismaster = self2.ismaster;
    }
    if (!ismaster)
      return "Unknown";
    if (ismaster.ismaster && ismaster.msg === "isdbgrid")
      return "Mongos";
    if (ismaster.ismaster && !ismaster.hosts)
      return "Standalone";
    if (ismaster.ismaster)
      return "RSPrimary";
    if (ismaster.secondary)
      return "RSSecondary";
    if (ismaster.arbiterOnly)
      return "RSArbiter";
    return "Unknown";
  };
  var inquireServerState = function(self2) {
    return function(callback) {
      if (self2.s.state === "destroyed")
        return;
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: self2.name});
      self2.command("admin.$cmd", {ismaster: true}, {monitoring: true}, function(err, r) {
        if (!err) {
          self2.emit("ismaster", r, self2);
          var latencyMS = new Date().getTime() - start;
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: self2.name
          });
          if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
            emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
            });
          }
          self2.s.ismaster = r.result;
          self2.s.isMasterLatencyMS = latencyMS;
        } else {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: self2.name
          });
        }
        if (typeof callback === "function") {
          return callback(err, r);
        }
        self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
      });
    };
  };
  var cloneOptions = function(options) {
    var opts = {};
    for (var name in options) {
      opts[name] = options[name];
    }
    return opts;
  };
  function Interval(fn, time) {
    var timer = false;
    this.start = function() {
      if (!this.isRunning()) {
        timer = setInterval(fn, time);
      }
      return this;
    };
    this.stop = function() {
      clearInterval(timer);
      timer = false;
      return this;
    };
    this.isRunning = function() {
      return timer !== false;
    };
  }
  function Timeout(fn, time) {
    var timer = false;
    var func = () => {
      if (timer) {
        clearTimeout(timer);
        timer = false;
        fn();
      }
    };
    this.start = function() {
      if (!this.isRunning()) {
        timer = setTimeout(func, time);
      }
      return this;
    };
    this.stop = function() {
      clearTimeout(timer);
      timer = false;
      return this;
    };
    this.isRunning = function() {
      return timer !== false;
    };
  }
  function diff(previous, current) {
    var diff2 = {
      servers: []
    };
    if (!previous) {
      previous = {servers: []};
    }
    for (var i = 0; i < previous.servers.length; i++) {
      var found = false;
      for (var j = 0; j < current.servers.length; j++) {
        if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
          found = true;
          break;
        }
      }
      if (!found) {
        diff2.servers.push({
          address: previous.servers[i].address,
          from: previous.servers[i].type,
          to: "Unknown"
        });
      }
    }
    for (j = 0; j < current.servers.length; j++) {
      found = false;
      for (i = 0; i < previous.servers.length; i++) {
        if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
          found = true;
          break;
        }
      }
      if (!found) {
        diff2.servers.push({
          address: current.servers[j].address,
          from: "Unknown",
          to: current.servers[j].type
        });
      }
    }
    for (i = 0; i < previous.servers.length; i++) {
      var prevServer = previous.servers[i];
      for (j = 0; j < current.servers.length; j++) {
        var currServer = current.servers[j];
        if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
          if (prevServer.type !== currServer.type) {
            diff2.servers.push({
              address: prevServer.address,
              from: prevServer.type,
              to: currServer.type
            });
          }
        }
      }
    }
    return diff2;
  }
  function resolveClusterTime(topology, $clusterTime) {
    if (topology.clusterTime == null) {
      topology.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
        topology.clusterTime = $clusterTime;
      }
    }
  }
  var SessionMixins = {
    endSessions: function(sessions, callback) {
      if (!Array.isArray(sessions)) {
        sessions = [sessions];
      }
      this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred}, () => {
        if (typeof callback === "function")
          callback();
      });
    }
  };
  function topologyType(topology) {
    if (topology.description) {
      return topology.description.type;
    }
    if (topology.type === "mongos") {
      return TopologyType.Sharded;
    } else if (topology.type === "replset") {
      return TopologyType.ReplicaSetWithPrimary;
    }
    return TopologyType.Single;
  }
  var RETRYABLE_WIRE_VERSION = 6;
  var isRetryableWritesSupported = function(topology) {
    const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
    if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
      return false;
    }
    if (!topology.logicalSessionTimeoutMinutes) {
      return false;
    }
    if (topologyType(topology) === TopologyType.Single) {
      return false;
    }
    return true;
  };
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
  function getMMAPError(err) {
    if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
      return err;
    }
    const newErr = new MongoError({
      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
      originalError: err
    });
    return newErr;
  }
  function legacyIsRetryableWriteError(err, topology) {
    if (!(err instanceof MongoError)) {
      return false;
    }
    if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
      err.addErrorLabel("RetryableWriteError");
    }
    return err.hasErrorLabel("RetryableWriteError");
  }
  module2.exports = {
    SessionMixins,
    resolveClusterTime,
    inquireServerState,
    getTopologyType,
    emitServerDescriptionChanged,
    emitTopologyDescriptionChanged,
    cloneOptions,
    createCompressionInfo,
    clone,
    diff,
    Interval,
    Timeout,
    isRetryableWritesSupported,
    getMMAPError,
    topologyType,
    legacyIsRetryableWriteError
  };
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS((exports2, module2) => {
  "use strict";
  var retrieveBSON = require_utils3().retrieveBSON;
  var EventEmitter2 = require("events");
  var BSON2 = retrieveBSON();
  var Binary2 = BSON2.Binary;
  var uuidV4 = require_utils2().uuidV4;
  var MongoError = require_error().MongoError;
  var isRetryableError = require_error().isRetryableError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var Transaction = require_transactions().Transaction;
  var TxnState = require_transactions().TxnState;
  var isPromiseLike = require_utils2().isPromiseLike;
  var ReadPreference = require_read_preference();
  var maybePromise = require_utils4().maybePromise;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var isSharded = require_shared().isSharded;
  var maxWireVersion = require_utils2().maxWireVersion;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var minWireVersionForShardedTransactions = 8;
  function assertAlive(session, callback) {
    if (session.serverSession == null) {
      const error = new MongoError("Cannot use a session that has ended");
      if (typeof callback === "function") {
        callback(error, null);
        return false;
      }
      throw error;
    }
    return true;
  }
  var kServerSession = Symbol("serverSession");
  var ClientSession = class extends EventEmitter2 {
    constructor(topology, sessionPool, options, clientOptions) {
      super();
      if (topology == null) {
        throw new Error("ClientSession requires a topology");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new Error("ClientSession requires a ServerSessionPool");
      }
      options = options || {};
      clientOptions = clientOptions || {};
      this.topology = topology;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this[kServerSession] = void 0;
      this.supports = {
        causalConsistency: typeof options.causalConsistency !== "undefined" ? options.causalConsistency : true
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = null;
      this.explicit = !!options.explicit;
      this.owner = options.owner;
      this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
      this.transaction = new Transaction();
    }
    get id() {
      return this.serverSession.id;
    }
    get serverSession() {
      if (this[kServerSession] == null) {
        this[kServerSession] = this.sessionPool.acquire();
      }
      return this[kServerSession];
    }
    endSession(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const session = this;
      return maybePromise(this, callback, (done) => {
        if (session.hasEnded) {
          return done();
        }
        function completeEndSession() {
          session.sessionPool.release(session.serverSession);
          session[kServerSession] = void 0;
          session.hasEnded = true;
          session.emit("ended", session);
          done();
        }
        if (session.serverSession && session.inTransaction()) {
          session.abortTransaction((err) => {
            if (err)
              return done(err);
            completeEndSession();
          });
          return;
        }
        completeEndSession();
      });
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      return this.id.id.buffer.equals(session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this.serverSession.txnNumber++;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      assertAlive(this);
      if (this.inTransaction()) {
        throw new MongoError("Transaction already in progress");
      }
      const topologyMaxWireVersion = maxWireVersion(this.topology);
      if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.incrementTransactionNumber();
      this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));
      this.transaction.transition(TxnState.STARTING_TRANSACTION);
    }
    commitTransaction(callback) {
      return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
    }
    abortTransaction(callback) {
      return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
    }
    toBSON() {
      throw new Error("ClientSession cannot be serialized to BSON.");
    }
    withTransaction(fn, options) {
      const startTime = now();
      return attemptTransaction(this, startTime, fn, options);
    }
  };
  var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
  var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
  var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
  var MAX_TIME_MS_EXPIRED_CODE = 50;
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);
  function hasNotTimedOut(startTime, max) {
    return calculateDurationInMs(startTime) < max;
  }
  function isUnknownTransactionCommitResult(err) {
    return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
  }
  function isMaxTimeMSExpiredError(err) {
    if (err == null)
      return false;
    return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
  }
  function attemptTransactionCommit(session, startTime, fn, options) {
    return session.commitTransaction().catch((err) => {
      if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
        if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
          return attemptTransactionCommit(session, startTime, fn, options);
        }
        if (err.hasErrorLabel("TransientTransactionError")) {
          return attemptTransaction(session, startTime, fn, options);
        }
      }
      throw err;
    });
  }
  var USER_EXPLICIT_TXN_END_STATES = new Set([
    TxnState.NO_TRANSACTION,
    TxnState.TRANSACTION_COMMITTED,
    TxnState.TRANSACTION_ABORTED
  ]);
  function userExplicitlyEndedTransaction(session) {
    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
  }
  function attemptTransaction(session, startTime, fn, options) {
    session.startTransaction(options);
    let promise;
    try {
      promise = fn(session);
    } catch (err) {
      promise = Promise.reject(err);
    }
    if (!isPromiseLike(promise)) {
      session.abortTransaction();
      throw new TypeError("Function provided to `withTransaction` must return a Promise");
    }
    return promise.then(() => {
      if (userExplicitlyEndedTransaction(session)) {
        return;
      }
      return attemptTransactionCommit(session, startTime, fn, options);
    }).catch((err) => {
      function maybeRetryOrThrow(err2) {
        if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
          return attemptTransaction(session, startTime, fn, options);
        }
        if (isMaxTimeMSExpiredError(err2)) {
          err2.addErrorLabel("UnknownTransactionCommitResult");
        }
        throw err2;
      }
      if (session.transaction.isActive) {
        return session.abortTransaction().then(() => maybeRetryOrThrow(err));
      }
      return maybeRetryOrThrow(err);
    });
  }
  function endTransaction(session, commandName, callback) {
    if (!assertAlive(session, callback)) {
      return;
    }
    let txnState = session.transaction.state;
    if (txnState === TxnState.NO_TRANSACTION) {
      callback(new MongoError("No transaction started"));
      return;
    }
    if (commandName === "commitTransaction") {
      if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
        session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
        callback(null, null);
        return;
      }
      if (txnState === TxnState.TRANSACTION_ABORTED) {
        callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
        return;
      }
    } else {
      if (txnState === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        callback(null, null);
        return;
      }
      if (txnState === TxnState.TRANSACTION_ABORTED) {
        callback(new MongoError("Cannot call abortTransaction twice"));
        return;
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
        callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
        return;
      }
    }
    const command = {[commandName]: 1};
    let writeConcern;
    if (session.transaction.options.writeConcern) {
      writeConcern = Object.assign({}, session.transaction.options.writeConcern);
    } else if (session.clientOptions && session.clientOptions.w) {
      writeConcern = {w: session.clientOptions.w};
    }
    if (txnState === TxnState.TRANSACTION_COMMITTED) {
      writeConcern = Object.assign({wtimeout: 1e4}, writeConcern, {w: "majority"});
    }
    if (writeConcern) {
      Object.assign(command, {writeConcern});
    }
    if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
      Object.assign(command, {maxTimeMS: session.transaction.options.maxTimeMS});
    }
    function commandHandler(e, r) {
      if (commandName === "commitTransaction") {
        session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
        if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
          if (isUnknownTransactionCommitResult(e)) {
            e.addErrorLabel("UnknownTransactionCommitResult");
            session.transaction.unpinServer();
          }
        }
      } else {
        session.transaction.transition(TxnState.TRANSACTION_ABORTED);
      }
      callback(e, r);
    }
    function transactionError(err) {
      return commandName === "commitTransaction" ? err : null;
    }
    if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
      command.recoveryToken = session.transaction.recoveryToken;
    }
    session.topology.command("admin.$cmd", command, {session}, (err, reply) => {
      if (err && isRetryableError(err)) {
        if (command.commitTransaction) {
          session.transaction.unpinServer();
          command.writeConcern = Object.assign({wtimeout: 1e4}, command.writeConcern, {
            w: "majority"
          });
        }
        return session.topology.command("admin.$cmd", command, {session}, (_err, _reply) => commandHandler(transactionError(_err), _reply));
      }
      commandHandler(transactionError(err), reply);
    });
  }
  function supportsRecoveryToken(session) {
    const topology = session.topology;
    return !!topology.s.options.useRecoveryToken;
  }
  var ServerSession = class {
    constructor() {
      this.id = {id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID)};
      this.lastUse = now();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
  };
  var ServerSessionPool = class {
    constructor(topology) {
      if (topology == null) {
        throw new Error("ServerSessionPool requires a topology");
      }
      this.topology = topology;
      this.sessions = [];
    }
    endAllPooledSessions(callback) {
      if (this.sessions.length) {
        this.topology.endSessions(this.sessions.map((session) => session.id), () => {
          this.sessions = [];
          if (typeof callback === "function") {
            callback();
          }
        });
        return;
      }
      if (typeof callback === "function") {
        callback();
      }
    }
    acquire() {
      const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
      while (this.sessions.length) {
        const session = this.sessions.shift();
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          return session;
        }
      }
      return new ServerSession();
    }
    release(session) {
      const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
      while (this.sessions.length) {
        const pooledSession = this.sessions[this.sessions.length - 1];
        if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
          this.sessions.pop();
        } else {
          break;
        }
      }
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  };
  function commandSupportsReadConcern(command, options) {
    if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
      return true;
    }
    if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
      return true;
    }
    return false;
  }
  function applySession(session, command, options) {
    if (session.hasEnded) {
      return new MongoError("Cannot use a session that has ended");
    }
    if (options && options.writeConcern && options.writeConcern.w === 0) {
      return;
    }
    const serverSession = session.serverSession;
    serverSession.lastUse = now();
    command.lsid = serverSession.id;
    const inTransaction = session.inTransaction() || isTransactionCommand(command);
    const isRetryableWrite = options.willRetryWrite;
    const shouldApplyReadConcern = commandSupportsReadConcern(command, options);
    if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
      command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTransaction) {
      if (session.transaction.state !== TxnState.NO_TRANSACTION) {
        session.transaction.transition(TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
      }
      return;
    }
    if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {
      return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);
    }
    command.autocommit = false;
    if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
      }
    }
  }
  function updateSessionFromResponse(session, document2) {
    if (document2.$clusterTime) {
      resolveClusterTime(session, document2.$clusterTime);
    }
    if (document2.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document2.operationTime);
    }
    if (document2.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document2.recoveryToken;
    }
  }
  module2.exports = {
    ClientSession,
    ServerSession,
    ServerSessionPool,
    TxnState,
    applySession,
    updateSessionFromResponse,
    commandSupportsReadConcern
  };
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var EventEmitter2 = require("events").EventEmitter;
  var MongoError = require_error().MongoError;
  var MongoTimeoutError = require_error().MongoTimeoutError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var Logger = require_logger();
  var f = require("util").format;
  var Msg = require_msg().Msg;
  var CommandResult = require_command_result();
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
  var opcodes = require_shared().opcodes;
  var compress = require_compression().compress;
  var compressorIDs = require_compression().compressorIDs;
  var uncompressibleCommands = require_compression().uncompressibleCommands;
  var apm = require_apm();
  var Buffer2 = require_safe_buffer().Buffer;
  var connect = require_connect();
  var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
  var eachAsync = require_utils2().eachAsync;
  var makeStateMachine = require_utils2().makeStateMachine;
  var now = require_utils4().now;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var DRAINING = "draining";
  var DESTROYING = "destroying";
  var DESTROYED = "destroyed";
  var stateTransition = makeStateMachine({
    [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
    [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
    [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
    [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
    [DESTROYING]: [DESTROYING, DESTROYED],
    [DESTROYED]: [DESTROYED]
  });
  var CONNECTION_EVENTS = new Set([
    "error",
    "close",
    "timeout",
    "parseError",
    "connect",
    "message"
  ]);
  var _id = 0;
  var Pool = function(topology, options) {
    EventEmitter2.call(this);
    this.topology = topology;
    this.s = {
      state: DISCONNECTED,
      cancellationToken: new EventEmitter2()
    };
    this.s.cancellationToken.setMaxListeners(Infinity);
    this.options = Object.assign({
      host: "localhost",
      port: 27017,
      size: 5,
      minSize: 0,
      connectionTimeout: 3e4,
      socketTimeout: 0,
      keepAlive: true,
      keepAliveInitialDelay: 12e4,
      noDelay: true,
      ssl: false,
      checkServerIdentity: true,
      ca: null,
      crl: null,
      cert: null,
      key: null,
      passphrase: null,
      rejectUnauthorized: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      reconnect: true,
      reconnectInterval: 1e3,
      reconnectTries: 30,
      domainsEnabled: false,
      legacyCompatMode: true
    }, options);
    this.id = _id++;
    this.retriesLeft = this.options.reconnectTries;
    this.reconnectId = null;
    this.reconnectError = null;
    if (!options.bson || options.bson && (typeof options.bson.serialize !== "function" || typeof options.bson.deserialize !== "function")) {
      throw new Error("must pass in valid bson parser");
    }
    this.logger = Logger("Pool", options);
    this.availableConnections = [];
    this.inUseConnections = [];
    this.connectingConnections = 0;
    this.executing = false;
    this.queue = [];
    this.numberOfConsecutiveTimeouts = 0;
    this.connectionIndex = 0;
    const pool = this;
    this._messageHandler = messageHandler(this);
    this._connectionCloseHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "close", err, connection);
    };
    this._connectionErrorHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "error", err, connection);
    };
    this._connectionTimeoutHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "timeout", err, connection);
    };
    this._connectionParseErrorHandler = function(err) {
      const connection = this;
      connectionFailureHandler(pool, "parseError", err, connection);
    };
  };
  inherits(Pool, EventEmitter2);
  Object.defineProperty(Pool.prototype, "size", {
    enumerable: true,
    get: function() {
      return this.options.size;
    }
  });
  Object.defineProperty(Pool.prototype, "minSize", {
    enumerable: true,
    get: function() {
      return this.options.minSize;
    }
  });
  Object.defineProperty(Pool.prototype, "connectionTimeout", {
    enumerable: true,
    get: function() {
      return this.options.connectionTimeout;
    }
  });
  Object.defineProperty(Pool.prototype, "socketTimeout", {
    enumerable: true,
    get: function() {
      return this.options.socketTimeout;
    }
  });
  Object.defineProperty(Pool.prototype, "state", {
    enumerable: true,
    get: function() {
      return this.s.state;
    }
  });
  function resetPoolState(pool) {
    pool.inUseConnections = [];
    pool.availableConnections = [];
    pool.connectingConnections = 0;
    pool.executing = false;
    pool.numberOfConsecutiveTimeouts = 0;
    pool.connectionIndex = 0;
    pool.retriesLeft = pool.options.reconnectTries;
    pool.reconnectId = null;
  }
  function connectionFailureHandler(pool, event, err, conn) {
    if (conn) {
      if (conn._connectionFailHandled) {
        return;
      }
      conn._connectionFailHandled = true;
      conn.destroy();
      removeConnection(pool, conn);
      conn.flush(err);
    }
    if (event === "timeout") {
      pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
      if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
        pool.numberOfConsecutiveTimeouts = 0;
        pool.destroy(true);
        return pool.emit("close", pool);
      }
    }
    if (pool.socketCount() === 0) {
      if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
        if (pool.options.reconnect) {
          stateTransition(pool, DISCONNECTED);
        }
      }
      event = event === "error" ? "close" : event;
      pool.emit(event, err);
    }
    if (!pool.reconnectId && pool.options.reconnect) {
      pool.reconnectError = err;
      pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
    }
    const totalConnections = totalConnectionCount(pool);
    if (totalConnections < pool.minSize) {
      createConnection(pool);
    }
  }
  function attemptReconnect(pool, callback) {
    return function() {
      pool.emit("attemptReconnect", pool);
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.retriesLeft = pool.retriesLeft - 1;
      if (pool.retriesLeft <= 0) {
        pool.destroy();
        const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
        pool.emit("reconnectFailed", error);
        if (typeof callback === "function") {
          callback(error);
        }
        return;
      }
      pool.reconnectId = null;
      createConnection(pool, (err, conn) => {
        if (err == null) {
          pool.reconnectId = null;
          pool.retriesLeft = pool.options.reconnectTries;
          pool.emit("reconnect", pool);
        }
        if (typeof callback === "function") {
          callback(err, conn);
        }
      });
    };
  }
  function moveConnectionBetween(connection, from, to) {
    var index = from.indexOf(connection);
    if (index !== -1) {
      from.splice(index, 1);
      to.push(connection);
    }
  }
  function messageHandler(self2) {
    return function(message, connection) {
      var workItem = null;
      for (var i = 0; i < connection.workItems.length; i++) {
        if (connection.workItems[i].requestId === message.responseTo) {
          workItem = connection.workItems[i];
          connection.workItems.splice(i, 1);
        }
      }
      if (workItem && workItem.monitoring) {
        moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
      }
      self2.numberOfConsecutiveTimeouts = 0;
      if (workItem && workItem.socketTimeout) {
        connection.resetSocketTimeout();
      }
      if (self2.logger.isDebug()) {
        self2.logger.debug(f("message [%s] received from %s:%s", message.raw.toString("hex"), self2.options.host, self2.options.port));
      }
      function handleOperationCallback(self3, cb, err, result) {
        if (!self3.options.domainsEnabled) {
          return process.nextTick(function() {
            return cb(err, result);
          });
        }
        cb(err, result);
      }
      if (!self2.executing) {
        process.nextTick(function() {
          _execute(self2)();
        });
      }
      if (workItem && !workItem.immediateRelease) {
        try {
          message.parse(workItem);
        } catch (err) {
          return handleOperationCallback(self2, workItem.cb, new MongoError(err));
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = workItem.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (self2.topology && document2.$clusterTime) {
            self2.topology.clusterTime = document2.$clusterTime;
          }
        }
        if (workItem.command && message.documents[0]) {
          const responseDoc = message.documents[0];
          if (responseDoc.writeConcernError) {
            const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
            return handleOperationCallback(self2, workItem.cb, err);
          }
          if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
          }
        }
        message.hashedName = connection.hashedName;
        handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
      }
    };
  }
  Pool.prototype.socketCount = function() {
    return this.availableConnections.length + this.inUseConnections.length;
  };
  function totalConnectionCount(pool) {
    return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
  }
  Pool.prototype.allConnections = function() {
    return this.availableConnections.concat(this.inUseConnections);
  };
  Pool.prototype.get = function() {
    return this.allConnections()[0];
  };
  Pool.prototype.isConnected = function() {
    if (this.state === DESTROYED || this.state === DESTROYING) {
      return false;
    }
    var connections = this.availableConnections.concat(this.inUseConnections);
    for (var i = 0; i < connections.length; i++) {
      if (connections[i].isConnected())
        return true;
    }
    return false;
  };
  Pool.prototype.isDestroyed = function() {
    return this.state === DESTROYED || this.state === DESTROYING;
  };
  Pool.prototype.isDisconnected = function() {
    return this.state === DISCONNECTED;
  };
  Pool.prototype.connect = function(callback) {
    if (this.state !== DISCONNECTED) {
      throw new MongoError("connection in unlawful state " + this.state);
    }
    stateTransition(this, CONNECTING);
    createConnection(this, (err, conn) => {
      if (err) {
        if (typeof callback === "function") {
          this.destroy();
          callback(err);
          return;
        }
        if (this.state === CONNECTING) {
          this.emit("error", err);
        }
        this.destroy();
        return;
      }
      stateTransition(this, CONNECTED);
      if (this.minSize) {
        for (let i = 0; i < this.minSize; i++) {
          createConnection(this);
        }
      }
      if (typeof callback === "function") {
        callback(null, conn);
      } else {
        this.emit("connect", this, conn);
      }
    });
  };
  Pool.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Pool.prototype.logout = function(dbName, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Pool.prototype.unref = function() {
    var connections = this.availableConnections.concat(this.inUseConnections);
    connections.forEach(function(c) {
      c.unref();
    });
  };
  function destroy(self2, connections, options, callback) {
    stateTransition(self2, DESTROYING);
    self2.s.cancellationToken.emit("cancel");
    eachAsync(connections, (conn, cb) => {
      for (const eventName of CONNECTION_EVENTS) {
        conn.removeAllListeners(eventName);
      }
      conn.on("error", () => {
      });
      conn.destroy(options, cb);
    }, (err) => {
      if (err) {
        if (typeof callback === "function")
          callback(err, null);
        return;
      }
      resetPoolState(self2);
      self2.queue = [];
      stateTransition(self2, DESTROYED);
      if (typeof callback === "function")
        callback(null, null);
    });
  }
  Pool.prototype.destroy = function(force, callback) {
    var self2 = this;
    if (typeof force === "function") {
      callback = force;
      force = false;
    }
    if (this.state === DESTROYED || self2.state === DESTROYING) {
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    stateTransition(this, DRAINING);
    if (force) {
      var connections = self2.availableConnections.concat(self2.inUseConnections);
      while (self2.queue.length > 0) {
        var workItem = self2.queue.shift();
        if (typeof workItem.cb === "function") {
          workItem.cb(new MongoError("Pool was force destroyed"));
        }
      }
      return destroy(self2, connections, {force: true}, callback);
    }
    if (this.reconnectId) {
      clearTimeout(this.reconnectId);
    }
    function checkStatus() {
      if (self2.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      flushMonitoringOperations(self2.queue);
      if (self2.queue.length === 0) {
        var connections2 = self2.availableConnections.concat(self2.inUseConnections);
        for (var i = 0; i < connections2.length; i++) {
          if (connections2[i].workItems.length > 0) {
            return setTimeout(checkStatus, 1);
          }
        }
        destroy(self2, connections2, {force: false}, callback);
      } else {
        _execute(self2)();
        setTimeout(checkStatus, 1);
      }
    }
    checkStatus();
  };
  Pool.prototype.reset = function(callback) {
    if (this.s.state !== CONNECTED) {
      if (typeof callback === "function") {
        callback(new MongoError("pool is not connected, reset aborted"));
      }
      return;
    }
    this.s.cancellationToken.emit("cancel");
    const connections = this.availableConnections.concat(this.inUseConnections);
    eachAsync(connections, (conn, cb) => {
      for (const eventName of CONNECTION_EVENTS) {
        conn.removeAllListeners(eventName);
      }
      conn.destroy({force: true}, cb);
    }, (err) => {
      if (err) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
      }
      resetPoolState(this);
      createConnection(this, () => {
        if (typeof callback === "function") {
          callback(null, null);
        }
      });
    });
  };
  function serializeCommand(self2, command, callback) {
    const originalCommandBuffer = command.toBin();
    const shouldCompress = !!self2.options.agreedCompressor;
    if (!shouldCompress || !canCompress(command)) {
      return callback(null, originalCommandBuffer);
    }
    const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
    compress(self2, messageToBeCompressed, function(err, compressedMessage) {
      if (err)
        return callback(err, null);
      const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
      msgHeader.writeInt32LE(command.requestId, 4);
      msgHeader.writeInt32LE(0, 8);
      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
      const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0);
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
      compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
      return callback(null, [msgHeader, compressionDetails, compressedMessage]);
    });
  }
  Pool.prototype.write = function(command, options, cb) {
    var self2 = this;
    if (typeof options === "function") {
      cb = options;
    }
    options = options || {};
    if (!(typeof cb === "function") && !options.noResponse) {
      throw new MongoError("write method must provide a callback");
    }
    if (this.state === DESTROYED || this.state === DESTROYING) {
      cb(new MongoError("pool destroyed"));
      return;
    }
    if (this.state === DRAINING) {
      cb(new MongoError("pool is draining, new operations prohibited"));
      return;
    }
    if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
      var oldCb = cb;
      cb = process.domain.bind(function() {
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        process.nextTick(function() {
          oldCb.apply(null, args);
        });
      });
    }
    var operation = {
      cb,
      raw: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      fullResult: false
    };
    operation.promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : true;
    operation.promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : true;
    operation.promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false;
    operation.raw = typeof options.raw === "boolean" ? options.raw : false;
    operation.immediateRelease = typeof options.immediateRelease === "boolean" ? options.immediateRelease : false;
    operation.documentsReturnedIn = options.documentsReturnedIn;
    operation.command = typeof options.command === "boolean" ? options.command : false;
    operation.fullResult = typeof options.fullResult === "boolean" ? options.fullResult : false;
    operation.noResponse = typeof options.noResponse === "boolean" ? options.noResponse : false;
    operation.session = options.session || null;
    operation.socketTimeout = options.socketTimeout;
    operation.monitoring = options.monitoring;
    operation.requestId = command.requestId;
    if (self2.options.monitorCommands) {
      this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
      operation.started = now();
      operation.cb = (err, reply) => {
        if (err) {
          self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
        } else {
          if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
          } else {
            self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
          }
        }
        if (typeof cb === "function")
          cb(err, reply);
      };
    }
    serializeCommand(self2, command, (err, serializedBuffers) => {
      if (err)
        throw err;
      operation.buffer = serializedBuffers;
      if (options.monitoring) {
        self2.queue.unshift(operation);
      } else {
        self2.queue.push(operation);
      }
      if (!self2.executing) {
        process.nextTick(function() {
          _execute(self2)();
        });
      }
    });
  };
  function canCompress(command) {
    const commandDoc = command instanceof Msg ? command.command : command.query;
    const commandName = Object.keys(commandDoc)[0];
    return !uncompressibleCommands.has(commandName);
  }
  function remove(connection, connections) {
    for (var i = 0; i < connections.length; i++) {
      if (connections[i] === connection) {
        connections.splice(i, 1);
        return true;
      }
    }
  }
  function removeConnection(self2, connection) {
    if (remove(connection, self2.availableConnections))
      return;
    if (remove(connection, self2.inUseConnections))
      return;
  }
  function createConnection(pool, callback) {
    if (pool.state === DESTROYED || pool.state === DESTROYING) {
      if (typeof callback === "function") {
        callback(new MongoError("Cannot create connection when pool is destroyed"));
      }
      return;
    }
    pool.connectingConnections++;
    connect(pool.options, pool.s.cancellationToken, (err, connection) => {
      pool.connectingConnections--;
      if (err) {
        if (pool.logger.isDebug()) {
          pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
        }
        if (!pool.reconnectId && pool.options.reconnect) {
          if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
            callback(err);
            return;
          }
          pool.reconnectError = err;
          pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
          return;
        }
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Pool was destroyed after connection creation"));
        }
        connection.destroy();
        return;
      }
      connection.on("error", pool._connectionErrorHandler);
      connection.on("close", pool._connectionCloseHandler);
      connection.on("timeout", pool._connectionTimeoutHandler);
      connection.on("parseError", pool._connectionParseErrorHandler);
      connection.on("message", pool._messageHandler);
      pool.availableConnections.push(connection);
      if (typeof callback === "function") {
        callback(null, connection);
      }
      _execute(pool)();
    });
  }
  function flushMonitoringOperations(queue) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].monitoring) {
        var workItem = queue[i];
        queue.splice(i, 1);
        workItem.cb(new MongoError({message: "no connection available for monitoring", driver: true}));
      }
    }
  }
  function _execute(self2) {
    return function() {
      if (self2.state === DESTROYED)
        return;
      if (self2.executing)
        return;
      self2.executing = true;
      if (self2.connectingConnections > 0) {
        self2.executing = false;
        return;
      }
      while (true) {
        const totalConnections = totalConnectionCount(self2);
        if (self2.availableConnections.length === 0) {
          flushMonitoringOperations(self2.queue);
          if (totalConnections < self2.options.size && self2.queue.length > 0) {
            createConnection(self2);
          }
          break;
        }
        if (self2.queue.length === 0) {
          break;
        }
        var connection = null;
        const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
        if (connections.length === 0) {
          connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
        } else {
          connection = connections[self2.connectionIndex++ % connections.length];
        }
        if (!connection.isConnected()) {
          removeConnection(self2, connection);
          flushMonitoringOperations(self2.queue);
          break;
        }
        var workItem = self2.queue.shift();
        if (workItem.monitoring) {
          var foundValidConnection = false;
          for (let i = 0; i < self2.availableConnections.length; i++) {
            if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
              foundValidConnection = true;
              connection = self2.availableConnections[i];
              break;
            }
          }
          if (!foundValidConnection) {
            self2.queue.unshift(workItem);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            setTimeout(() => _execute(self2)(), 10);
            break;
          }
        }
        if (totalConnections < self2.options.size) {
          if (connection.workItems.length > 0) {
            self2.queue.unshift(workItem);
            createConnection(self2);
            break;
          }
        }
        var buffer = workItem.buffer;
        if (workItem.monitoring) {
          moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
        }
        if (!workItem.noResponse) {
          connection.workItems.push(workItem);
        }
        if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
          connection.setSocketTimeout(workItem.socketTimeout);
        }
        var writeSuccessful = true;
        if (Array.isArray(buffer)) {
          for (let i = 0; i < buffer.length; i++) {
            writeSuccessful = connection.write(buffer[i]);
          }
        } else {
          writeSuccessful = connection.write(buffer);
        }
        if (workItem.noResponse && typeof workItem.cb === "function") {
          workItem.cb(null, null);
        }
        if (writeSuccessful === false) {
          self2.queue.unshift(workItem);
          removeConnection(self2, connection);
          flushMonitoringOperations(self2.queue);
          break;
        }
      }
      self2.executing = false;
    };
  }
  Pool._execute = _execute;
  module2.exports = Pool;
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS((exports2, module2) => {
  "use strict";
  var Query = require_commands().Query;
  var Msg = require_msg().Msg;
  var MongoError = require_error().MongoError;
  var getReadPreference = require_shared().getReadPreference;
  var isSharded = require_shared().isSharded;
  var databaseNamespace = require_shared().databaseNamespace;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var applySession = require_sessions().applySession;
  var MongoNetworkError = require_error().MongoNetworkError;
  var maxWireVersion = require_utils2().maxWireVersion;
  function isClientEncryptionEnabled(server) {
    const wireVersion = maxWireVersion(server);
    return wireVersion && server.autoEncrypter;
  }
  function command(server, ns, cmd, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (cmd == null) {
      return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
    }
    if (!isClientEncryptionEnabled(server)) {
      _command(server, ns, cmd, options, callback);
      return;
    }
    const wireVersion = maxWireVersion(server);
    if (typeof wireVersion !== "number" || wireVersion < 8) {
      callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
      return;
    }
    _cryptCommand(server, ns, cmd, options, callback);
  }
  function _command(server, ns, cmd, options, callback) {
    const bson = server.s.bson;
    const pool = server.s.pool;
    const readPreference = getReadPreference(cmd, options);
    const shouldUseOpMsg = supportsOpMsg(server);
    const session = options.session;
    let clusterTime = server.clusterTime;
    let finalCmd = Object.assign({}, cmd);
    if (hasSessionSupport(server) && session) {
      if (session.clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
        clusterTime = session.clusterTime;
      }
      const err = applySession(session, finalCmd, options);
      if (err) {
        return callback(err);
      }
    }
    if (clusterTime) {
      finalCmd.$clusterTime = clusterTime;
    }
    if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
      finalCmd = {
        $query: finalCmd,
        $readPreference: readPreference.toJSON()
      };
    }
    const commandOptions = Object.assign({
      command: true,
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false
    }, options);
    commandOptions.slaveOk = readPreference.slaveOk();
    const cmdNs = `${databaseNamespace(ns)}.$cmd`;
    const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
    const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
    const commandResponseHandler = inTransaction ? function(err) {
      if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
        err.addErrorLabel("TransientTransactionError");
      }
      if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
        session.transaction.unpinServer();
      }
      return callback.apply(null, arguments);
    } : callback;
    try {
      pool.write(message, commandOptions, commandResponseHandler);
    } catch (err) {
      commandResponseHandler(err);
    }
  }
  function hasSessionSupport(topology) {
    if (topology == null)
      return false;
    if (topology.description) {
      return topology.description.maxWireVersion >= 6;
    }
    return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
  }
  function supportsOpMsg(topologyOrServer) {
    const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
    if (description == null) {
      return false;
    }
    return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
  }
  function _cryptCommand(server, ns, cmd, options, callback) {
    const autoEncrypter = server.autoEncrypter;
    function commandResponseHandler(err, response) {
      if (err || response == null) {
        callback(err, response);
        return;
      }
      autoEncrypter.decrypt(response.result, options, (err2, decrypted) => {
        if (err2) {
          callback(err2, null);
          return;
        }
        response.result = decrypted;
        response.message.documents = [decrypted];
        callback(null, response);
      });
    }
    autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {
      if (err) {
        callback(err, null);
        return;
      }
      _command(server, ns, encrypted, options, commandResponseHandler);
    });
  }
  module2.exports = command;
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var collectionNamespace = require_shared().collectionNamespace;
  var command = require_command();
  function writeCommand(server, type, opsField, ns, ops, options, callback) {
    if (ops.length === 0)
      throw new MongoError(`${type} must contain at least one document`);
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const writeConcern = options.writeConcern;
    const writeCommand2 = {};
    writeCommand2[type] = collectionNamespace(ns);
    writeCommand2[opsField] = ops;
    writeCommand2.ordered = ordered;
    if (writeConcern && Object.keys(writeConcern).length > 0) {
      writeCommand2.writeConcern = writeConcern;
    }
    if (options.collation) {
      for (let i = 0; i < writeCommand2[opsField].length; i++) {
        if (!writeCommand2[opsField][i].collation) {
          writeCommand2[opsField][i].collation = options.collation;
        }
      }
    }
    if (options.bypassDocumentValidation === true) {
      writeCommand2.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    const commandOptions = Object.assign({
      checkKeys: type === "insert",
      numberToReturn: 1
    }, options);
    command(server, ns, writeCommand2, commandOptions, callback);
  }
  module2.exports = writeCommand;
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS((exports2, module2) => {
  "use strict";
  var KillCursor = require_commands().KillCursor;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var collectionNamespace = require_shared().collectionNamespace;
  var maxWireVersion = require_utils2().maxWireVersion;
  var command = require_command();
  function killCursors(server, ns, cursorState, callback) {
    callback = typeof callback === "function" ? callback : () => {
    };
    const cursorId = cursorState.cursorId;
    if (maxWireVersion(server) < 4) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const killCursor = new KillCursor(bson, ns, [cursorId]);
      const options2 = {
        immediateRelease: true,
        noResponse: true
      };
      if (typeof cursorState.session === "object") {
        options2.session = cursorState.session;
      }
      if (pool && pool.isConnected()) {
        try {
          pool.write(killCursor, options2, callback);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err, null);
          } else {
            console.warn(err);
          }
        }
      }
      return;
    }
    const killCursorCmd = {
      killCursors: collectionNamespace(ns),
      cursors: [cursorId]
    };
    const options = {};
    if (typeof cursorState.session === "object")
      options.session = cursorState.session;
    command(server, ns, killCursorCmd, options, (err, result) => {
      if (err) {
        return callback(err);
      }
      const response = result.message;
      if (response.cursorNotFound) {
        return callback(new MongoNetworkError("cursor killed or timed out"), null);
      }
      if (!Array.isArray(response.documents) || response.documents.length === 0) {
        return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
      }
      callback(null, response.documents[0]);
    });
  }
  module2.exports = killCursors;
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS((exports2, module2) => {
  "use strict";
  var GetMore = require_commands().GetMore;
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var collectionNamespace = require_shared().collectionNamespace;
  var maxWireVersion = require_utils2().maxWireVersion;
  var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
  var command = require_command();
  function getMore(server, ns, cursorState, batchSize, options, callback) {
    options = options || {};
    const wireVersion = maxWireVersion(server);
    function queryCallback(err, result) {
      if (err)
        return callback(err);
      const response = result.message;
      if (response.cursorNotFound) {
        return callback(new MongoNetworkError("cursor killed or timed out"), null);
      }
      if (wireVersion < 4) {
        const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
        cursorState.documents = response.documents;
        cursorState.cursorId = cursorId3;
        callback(null, null, response.connection);
        return;
      }
      if (response.documents[0].ok === 0) {
        return callback(new MongoError(response.documents[0]));
      }
      const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
      cursorState.documents = response.documents[0].cursor.nextBatch;
      cursorState.cursorId = cursorId2;
      callback(null, response.documents[0], response.connection);
    }
    if (wireVersion < 4) {
      const bson = server.s.bson;
      const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
      const queryOptions = applyCommonQueryOptions({}, cursorState);
      server.s.pool.write(getMoreOp, queryOptions, queryCallback);
      return;
    }
    const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
    const getMoreCmd = {
      getMore: cursorId,
      collection: collectionNamespace(ns),
      batchSize: Math.abs(batchSize)
    };
    if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
      getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
    }
    const commandOptions = Object.assign({
      returnFieldSelector: null,
      documentsReturnedIn: "nextBatch"
    }, options);
    if (cursorState.session) {
      commandOptions.session = cursorState.session;
    }
    command(server, ns, getMoreCmd, commandOptions, queryCallback);
  }
  module2.exports = getMore;
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS((exports2, module2) => {
  "use strict";
  var Query = require_commands().Query;
  var MongoError = require_error().MongoError;
  var getReadPreference = require_shared().getReadPreference;
  var collectionNamespace = require_shared().collectionNamespace;
  var isSharded = require_shared().isSharded;
  var maxWireVersion = require_utils2().maxWireVersion;
  var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
  var command = require_command();
  function query(server, ns, cmd, cursorState, options, callback) {
    options = options || {};
    if (cursorState.cursorId != null) {
      return callback();
    }
    if (cmd == null) {
      return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
    }
    if (maxWireVersion(server) < 4) {
      const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options);
      const queryOptions = applyCommonQueryOptions({}, cursorState);
      if (typeof query2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
      }
      server.s.pool.write(query2, queryOptions, callback);
      return;
    }
    const readPreference = getReadPreference(cmd, options);
    const findCmd = prepareFindCommand(server, ns, cmd, cursorState, options);
    cmd.virtual = false;
    const commandOptions = Object.assign({
      documentsReturnedIn: "firstBatch",
      numberToReturn: 1,
      slaveOk: readPreference.slaveOk()
    }, options);
    if (cmd.readPreference) {
      commandOptions.readPreference = readPreference;
    }
    if (cursorState.session) {
      commandOptions.session = cursorState.session;
    }
    command(server, ns, findCmd, commandOptions, callback);
  }
  function prepareFindCommand(server, ns, cmd, cursorState) {
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    let findCmd = {
      find: collectionNamespace(ns)
    };
    if (cmd.query) {
      if (cmd.query["$query"]) {
        findCmd.filter = cmd.query["$query"];
      } else {
        findCmd.filter = cmd.query;
      }
    }
    let sortValue = cmd.sort;
    if (Array.isArray(sortValue)) {
      const sortObject = {};
      if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
        let sortDirection = sortValue[1];
        if (sortDirection === "asc") {
          sortDirection = 1;
        } else if (sortDirection === "desc") {
          sortDirection = -1;
        }
        sortObject[sortValue[0]] = sortDirection;
      } else {
        for (let i = 0; i < sortValue.length; i++) {
          let sortDirection = sortValue[i][1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[i][0]] = sortDirection;
        }
      }
      sortValue = sortObject;
    }
    if (typeof cmd.allowDiskUse === "boolean") {
      findCmd.allowDiskUse = cmd.allowDiskUse;
    }
    if (cmd.sort)
      findCmd.sort = sortValue;
    if (cmd.fields)
      findCmd.projection = cmd.fields;
    if (cmd.hint)
      findCmd.hint = cmd.hint;
    if (cmd.skip)
      findCmd.skip = cmd.skip;
    if (cmd.limit)
      findCmd.limit = cmd.limit;
    if (cmd.limit < 0) {
      findCmd.limit = Math.abs(cmd.limit);
      findCmd.singleBatch = true;
    }
    if (typeof cmd.batchSize === "number") {
      if (cmd.batchSize < 0) {
        if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
          findCmd.limit = Math.abs(cmd.batchSize);
        }
        findCmd.singleBatch = true;
      }
      findCmd.batchSize = Math.abs(cmd.batchSize);
    }
    if (cmd.comment)
      findCmd.comment = cmd.comment;
    if (cmd.maxScan)
      findCmd.maxScan = cmd.maxScan;
    if (cmd.maxTimeMS)
      findCmd.maxTimeMS = cmd.maxTimeMS;
    if (cmd.min)
      findCmd.min = cmd.min;
    if (cmd.max)
      findCmd.max = cmd.max;
    findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
    findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
    if (cmd.snapshot)
      findCmd.snapshot = cmd.snapshot;
    if (cmd.tailable)
      findCmd.tailable = cmd.tailable;
    if (cmd.oplogReplay)
      findCmd.oplogReplay = cmd.oplogReplay;
    if (cmd.noCursorTimeout)
      findCmd.noCursorTimeout = cmd.noCursorTimeout;
    if (cmd.awaitData)
      findCmd.awaitData = cmd.awaitData;
    if (cmd.awaitdata)
      findCmd.awaitData = cmd.awaitdata;
    if (cmd.partial)
      findCmd.partial = cmd.partial;
    if (cmd.collation)
      findCmd.collation = cmd.collation;
    if (cmd.readConcern)
      findCmd.readConcern = cmd.readConcern;
    if (cmd.explain) {
      findCmd = {
        explain: findCmd
      };
    }
    return findCmd;
  }
  function prepareLegacyFindQuery(server, ns, cmd, cursorState, options) {
    options = options || {};
    const bson = server.s.bson;
    const readPreference = getReadPreference(cmd, options);
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    let numberToReturn = 0;
    if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
      numberToReturn = cursorState.limit;
    } else {
      numberToReturn = cursorState.batchSize;
    }
    const numberToSkip = cursorState.skip || 0;
    const findCmd = {};
    if (isSharded(server) && readPreference) {
      findCmd["$readPreference"] = readPreference.toJSON();
    }
    if (cmd.sort)
      findCmd["$orderby"] = cmd.sort;
    if (cmd.hint)
      findCmd["$hint"] = cmd.hint;
    if (cmd.snapshot)
      findCmd["$snapshot"] = cmd.snapshot;
    if (typeof cmd.returnKey !== "undefined")
      findCmd["$returnKey"] = cmd.returnKey;
    if (cmd.maxScan)
      findCmd["$maxScan"] = cmd.maxScan;
    if (cmd.min)
      findCmd["$min"] = cmd.min;
    if (cmd.max)
      findCmd["$max"] = cmd.max;
    if (typeof cmd.showDiskLoc !== "undefined")
      findCmd["$showDiskLoc"] = cmd.showDiskLoc;
    if (cmd.comment)
      findCmd["$comment"] = cmd.comment;
    if (cmd.maxTimeMS)
      findCmd["$maxTimeMS"] = cmd.maxTimeMS;
    if (cmd.explain) {
      numberToReturn = -Math.abs(cmd.limit || 0);
      findCmd["$explain"] = true;
    }
    findCmd["$query"] = cmd.query;
    if (cmd.readConcern && cmd.readConcern.level !== "local") {
      throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
    }
    if (cmd.readConcern) {
      cmd = Object.assign({}, cmd);
      delete cmd["readConcern"];
    }
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
    const query2 = new Query(bson, ns, findCmd, {
      numberToSkip,
      numberToReturn,
      pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
      checkKeys: false,
      returnFieldSelector: cmd.fields,
      serializeFunctions,
      ignoreUndefined
    });
    if (typeof cmd.tailable === "boolean")
      query2.tailable = cmd.tailable;
    if (typeof cmd.oplogReplay === "boolean")
      query2.oplogReplay = cmd.oplogReplay;
    if (typeof cmd.noCursorTimeout === "boolean")
      query2.noCursorTimeout = cmd.noCursorTimeout;
    if (typeof cmd.awaitData === "boolean")
      query2.awaitData = cmd.awaitData;
    if (typeof cmd.partial === "boolean")
      query2.partial = cmd.partial;
    query2.slaveOk = readPreference.slaveOk();
    return query2;
  }
  module2.exports = query;
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS((exports2, module2) => {
  "use strict";
  var writeCommand = require_write_command();
  module2.exports = {
    insert: function insert(server, ns, ops, options, callback) {
      writeCommand(server, "insert", "documents", ns, ops, options, callback);
    },
    update: function update(server, ns, ops, options, callback) {
      writeCommand(server, "update", "updates", ns, ops, options, callback);
    },
    remove: function remove(server, ns, ops, options, callback) {
      writeCommand(server, "delete", "deletes", ns, ops, options, callback);
    },
    killCursors: require_kill_cursors(),
    getMore: require_get_more(),
    query: require_query(),
    command: require_command()
  };
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
    NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS")
  };
  var OperationBase = class {
    constructor(options) {
      this.options = Object.assign({}, options);
    }
    hasAspect(aspect) {
      if (this.constructor.aspects == null) {
        return false;
      }
      return this.constructor.aspects.has(aspect);
    }
    set session(session) {
      Object.assign(this.options, {session});
    }
    get session() {
      return this.options.session;
    }
    clearSession() {
      delete this.options.session;
    }
    get canRetryRead() {
      return true;
    }
    execute() {
      throw new TypeError("`execute` must be implemented for OperationBase subclasses");
    }
  };
  function defineAspects(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  }
  module2.exports = {
    Aspect,
    defineAspects,
    OperationBase
  };
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_read_preference();
  var isRetryableError = require_error().isRetryableError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var isUnifiedTopology = require_utils2().isUnifiedTopology;
  function executeOperation(topology, operation, callback) {
    if (topology == null) {
      throw new TypeError("This method requires a valid topology instance");
    }
    if (!(operation instanceof OperationBase)) {
      throw new TypeError("This method requires a valid operation instance");
    }
    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
      return selectServerForSessionSupport(topology, operation, callback);
    }
    const Promise2 = topology.s.promiseLibrary;
    let session, owner;
    if (topology.hasSessionSupport()) {
      if (operation.session == null) {
        owner = Symbol();
        session = topology.startSession({owner});
        operation.session = session;
      } else if (operation.session.hasEnded) {
        throw new MongoError("Use of expired sessions is not permitted");
      }
    }
    let result;
    if (typeof callback !== "function") {
      result = new Promise2((resolve, reject) => {
        callback = (err, res) => {
          if (err)
            return reject(err);
          resolve(res);
        };
      });
    }
    function executeCallback(err, result2) {
      if (session && session.owner === owner) {
        session.endSession();
        if (operation.session === session) {
          operation.clearSession();
        }
      }
      callback(err, result2);
    }
    try {
      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
        executeWithServerSelection(topology, operation, executeCallback);
      } else {
        operation.execute(executeCallback);
      }
    } catch (e) {
      if (session && session.owner === owner) {
        session.endSession();
        if (operation.session === session) {
          operation.clearSession();
        }
      }
      throw e;
    }
    return result;
  }
  function supportsRetryableReads(server) {
    return maxWireVersion(server) >= 6;
  }
  function executeWithServerSelection(topology, operation, callback) {
    const readPreference = operation.readPreference || ReadPreference.primary;
    const inTransaction = operation.session && operation.session.inTransaction();
    if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
      callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
      return;
    }
    const serverSelectionOptions = {
      readPreference,
      session: operation.session
    };
    function callbackWithRetry(err, result) {
      if (err == null) {
        return callback(null, result);
      }
      if (!isRetryableError(err)) {
        return callback(err);
      }
      topology.selectServer(serverSelectionOptions, (err2, server) => {
        if (err2 || !supportsRetryableReads(server)) {
          callback(err2, null);
          return;
        }
        operation.execute(server, callback);
      });
    }
    topology.selectServer(serverSelectionOptions, (err, server) => {
      if (err) {
        callback(err, null);
        return;
      }
      const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
      if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
        operation.execute(server, callbackWithRetry);
        return;
      }
      operation.execute(server, callback);
    });
  }
  function selectServerForSessionSupport(topology, operation, callback) {
    const Promise2 = topology.s.promiseLibrary;
    let result;
    if (typeof callback !== "function") {
      result = new Promise2((resolve, reject) => {
        callback = (err, result2) => {
          if (err)
            return reject(err);
          resolve(result2);
        };
      });
    }
    topology.selectServer(ReadPreference.primaryPreferred, (err) => {
      if (err) {
        callback(err);
        return;
      }
      executeOperation(topology, operation, callback);
    });
    return result;
  }
  module2.exports = executeOperation;
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Logger = require_logger();
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var collationNotSupported = require_utils2().collationNotSupported;
  var ReadPreference = require_read_preference();
  var isUnifiedTopology = require_utils2().isUnifiedTopology;
  var executeOperation = require_execute_operation();
  var Readable = require("stream").Readable;
  var SUPPORTS = require_utils4().SUPPORTS;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var OperationBase = require_operation().OperationBase;
  var BSON2 = retrieveBSON();
  var Long2 = BSON2.Long;
  var CursorState = {
    INIT: 0,
    OPEN: 1,
    CLOSED: 2,
    GET_MORE: 3
  };
  function handleCallback(callback, err, result) {
    try {
      callback(err, result);
    } catch (err2) {
      process.nextTick(function() {
        throw err2;
      });
    }
  }
  var CoreCursor = class extends Readable {
    constructor(topology, ns, cmd, options) {
      super({objectMode: true});
      options = options || {};
      if (ns instanceof OperationBase) {
        this.operation = ns;
        ns = this.operation.ns.toString();
        options = this.operation.options;
        cmd = this.operation.cmd ? this.operation.cmd : {};
      }
      this.pool = null;
      this.server = null;
      this.disconnectHandler = options.disconnectHandler;
      this.bson = topology.s.bson;
      this.ns = ns;
      this.namespace = MongoDBNamespace.fromString(ns);
      this.cmd = cmd;
      this.options = options;
      this.topology = topology;
      this.cursorState = {
        cursorId: null,
        cmd,
        documents: options.documents || [],
        cursorIndex: 0,
        dead: false,
        killed: false,
        init: false,
        notified: false,
        limit: options.limit || cmd.limit || 0,
        skip: options.skip || cmd.skip || 0,
        batchSize: options.batchSize || cmd.batchSize || 1e3,
        currentLimit: 0,
        transforms: options.transforms,
        raw: options.raw || cmd && cmd.raw
      };
      if (typeof options.session === "object") {
        this.cursorState.session = options.session;
      }
      const topologyOptions = topology.s.options;
      if (typeof topologyOptions.promoteLongs === "boolean") {
        this.cursorState.promoteLongs = topologyOptions.promoteLongs;
      } else if (typeof options.promoteLongs === "boolean") {
        this.cursorState.promoteLongs = options.promoteLongs;
      }
      if (typeof topologyOptions.promoteValues === "boolean") {
        this.cursorState.promoteValues = topologyOptions.promoteValues;
      } else if (typeof options.promoteValues === "boolean") {
        this.cursorState.promoteValues = options.promoteValues;
      }
      if (typeof topologyOptions.promoteBuffers === "boolean") {
        this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
      } else if (typeof options.promoteBuffers === "boolean") {
        this.cursorState.promoteBuffers = options.promoteBuffers;
      }
      if (topologyOptions.reconnect) {
        this.cursorState.reconnect = topologyOptions.reconnect;
      }
      this.logger = Logger("Cursor", topologyOptions);
      if (typeof cmd === "number") {
        this.cursorState.cursorId = Long2.fromNumber(cmd);
        this.cursorState.lastCursorId = this.cursorState.cursorId;
      } else if (cmd instanceof Long2) {
        this.cursorState.cursorId = cmd;
        this.cursorState.lastCursorId = cmd;
      }
      if (this.operation) {
        this.operation.cursorState = this.cursorState;
      }
    }
    setCursorBatchSize(value) {
      this.cursorState.batchSize = value;
    }
    cursorBatchSize() {
      return this.cursorState.batchSize;
    }
    setCursorLimit(value) {
      this.cursorState.limit = value;
    }
    cursorLimit() {
      return this.cursorState.limit;
    }
    setCursorSkip(value) {
      this.cursorState.skip = value;
    }
    cursorSkip() {
      return this.cursorState.skip;
    }
    _next(callback) {
      nextFunction(this, callback);
    }
    clone() {
      return this.topology.cursor(this.ns, this.cmd, this.options);
    }
    isDead() {
      return this.cursorState.dead === true;
    }
    isKilled() {
      return this.cursorState.killed === true;
    }
    isNotified() {
      return this.cursorState.notified === true;
    }
    bufferedCount() {
      return this.cursorState.documents.length - this.cursorState.cursorIndex;
    }
    readBufferedDocuments(number) {
      const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
      const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
      let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
      if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
        for (let i = 0; i < elements.length; i++) {
          elements[i] = this.cursorState.transforms.doc(elements[i]);
        }
      }
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
        elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
        this.kill();
      }
      this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
      this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
      return elements;
    }
    kill(callback) {
      this.cursorState.dead = true;
      this.cursorState.killed = true;
      this.cursorState.documents = [];
      if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
        if (callback)
          callback(null, null);
        return;
      }
      this.server.killCursors(this.ns, this.cursorState, callback);
    }
    rewind() {
      if (this.cursorState.init) {
        if (!this.cursorState.dead) {
          this.kill();
        }
        this.cursorState.currentLimit = 0;
        this.cursorState.init = false;
        this.cursorState.dead = false;
        this.cursorState.killed = false;
        this.cursorState.notified = false;
        this.cursorState.documents = [];
        this.cursorState.cursorId = null;
        this.cursorState.cursorIndex = 0;
      }
    }
    _read() {
      if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
        return this.push(null);
      }
      this._next((err, result) => {
        if (err) {
          if (this.listeners("error") && this.listeners("error").length > 0) {
            this.emit("error", err);
          }
          if (!this.isDead())
            this.close();
          this.emit("end");
          return this.emit("finish");
        }
        if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
          return this.push(this.cursorState.streamOptions.transform(result));
        }
        this.push(result);
        if (result === null && this.isDead()) {
          this.once("end", () => {
            this.close();
            this.emit("finish");
          });
        }
      });
    }
    _endSession(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const session = this.cursorState.session;
      if (session && (options.force || session.owner === this)) {
        this.cursorState.session = void 0;
        if (this.operation) {
          this.operation.clearSession();
        }
        session.endSession(callback);
        return true;
      }
      if (callback) {
        callback();
      }
      return false;
    }
    _getMore(callback) {
      if (this.logger.isDebug()) {
        this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
      }
      let batchSize = this.cursorState.batchSize;
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
        batchSize = this.cursorState.limit - this.cursorState.currentLimit;
      }
      const cursorState = this.cursorState;
      this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
          this._endSession();
        }
        callback(err, result, conn);
      });
    }
    _initializeCursor(callback) {
      const cursor = this;
      if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
        cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
          if (err) {
            callback(err);
            return;
          }
          this._initializeCursor(callback);
        });
        return;
      }
      function done(err, result) {
        const cursorState = cursor.cursorState;
        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
          cursor._endSession();
        }
        if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
          return setCursorNotified(cursor, callback);
        }
        callback(err, result);
      }
      const queryCallback = (err, r) => {
        if (err) {
          return done(err);
        }
        const result = r.message;
        if (Array.isArray(result.documents) && result.documents.length === 1) {
          const document2 = result.documents[0];
          if (result.queryFailure) {
            return done(new MongoError(document2), null);
          }
          if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
            if (document2.$err || document2.errmsg) {
              return done(new MongoError(document2), null);
            }
            if (document2.cursor != null && typeof document2.cursor !== "string") {
              const id = document2.cursor.id;
              if (document2.cursor.ns) {
                cursor.ns = document2.cursor.ns;
              }
              cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
              cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
              cursor.cursorState.operationTime = document2.operationTime;
              if (Array.isArray(document2.cursor.firstBatch)) {
                cursor.cursorState.documents = document2.cursor.firstBatch;
              }
              return done(null, result);
            }
          }
        }
        const cursorId = result.cursorId || 0;
        cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
        cursor.cursorState.documents = result.documents;
        cursor.cursorState.lastCursorId = result.cursorId;
        if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
          cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
        }
        done(null, result);
      };
      if (cursor.operation) {
        if (cursor.logger.isDebug()) {
          cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
        }
        executeOperation(cursor.topology, cursor.operation, (err, result) => {
          if (err) {
            done(err);
            return;
          }
          cursor.server = cursor.operation.server;
          cursor.cursorState.init = true;
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          queryCallback(err, result);
        });
        return;
      }
      const serverSelectOptions = {};
      if (cursor.cursorState.session) {
        serverSelectOptions.session = cursor.cursorState.session;
      }
      if (cursor.operation) {
        serverSelectOptions.readPreference = cursor.operation.readPreference;
      } else if (cursor.options.readPreference) {
        serverSelectOptions.readPreference = cursor.options.readPreference;
      }
      return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
        if (err) {
          const disconnectHandler = cursor.disconnectHandler;
          if (disconnectHandler != null) {
            return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
          }
          return callback(err);
        }
        cursor.server = server;
        cursor.cursorState.init = true;
        if (collationNotSupported(cursor.server, cursor.cmd)) {
          return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
        }
        if (cursor.cursorState.cursorId != null) {
          return done();
        }
        if (cursor.logger.isDebug()) {
          cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
        }
        if (cursor.cmd.find != null) {
          server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
          return;
        }
        const commandOptions = Object.assign({session: cursor.cursorState.session}, cursor.options);
        server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
      });
    }
  };
  if (SUPPORTS.ASYNC_ITERATOR) {
    CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
  }
  function isConnectionDead(self2, callback) {
    if (self2.pool && self2.pool.isDestroyed()) {
      self2.cursorState.killed = true;
      const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
      _setCursorNotifiedImpl(self2, () => callback(err));
      return true;
    }
    return false;
  }
  function isCursorDeadButNotkilled(self2, callback) {
    if (self2.cursorState.dead && !self2.cursorState.killed) {
      self2.cursorState.killed = true;
      setCursorNotified(self2, callback);
      return true;
    }
    return false;
  }
  function isCursorDeadAndKilled(self2, callback) {
    if (self2.cursorState.dead && self2.cursorState.killed) {
      handleCallback(callback, new MongoError("cursor is dead"));
      return true;
    }
    return false;
  }
  function isCursorKilled(self2, callback) {
    if (self2.cursorState.killed) {
      setCursorNotified(self2, callback);
      return true;
    }
    return false;
  }
  function setCursorDeadAndNotified(self2, callback) {
    self2.cursorState.dead = true;
    setCursorNotified(self2, callback);
  }
  function setCursorNotified(self2, callback) {
    _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
  }
  function _setCursorNotifiedImpl(self2, callback) {
    self2.cursorState.notified = true;
    self2.cursorState.documents = [];
    self2.cursorState.cursorIndex = 0;
    if (self2.cursorState.session) {
      self2._endSession(callback);
      return;
    }
    return callback();
  }
  function nextFunction(self2, callback) {
    if (self2.cursorState.notified) {
      return callback(new Error("cursor is exhausted"));
    }
    if (isCursorKilled(self2, callback))
      return;
    if (isCursorDeadButNotkilled(self2, callback))
      return;
    if (isCursorDeadAndKilled(self2, callback))
      return;
    if (!self2.cursorState.init) {
      if (!self2.topology.isConnected(self2.options)) {
        if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
          return callback(new MongoError("no connection available"));
        }
        if (self2.disconnectHandler != null) {
          if (self2.topology.isDestroyed()) {
            return callback(new MongoError("Topology was destroyed"));
          }
          self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
          return;
        }
      }
      self2._initializeCursor((err, result) => {
        if (err || result === null) {
          callback(err, result);
          return;
        }
        nextFunction(self2, callback);
      });
      return;
    }
    if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
      self2.kill(() => setCursorDeadAndNotified(self2, callback));
    } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.topology.isDestroyed())
        return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
      if (isConnectionDead(self2, callback))
        return;
      self2._getMore(function(err, doc, connection) {
        if (err) {
          return handleCallback(callback, err);
        }
        self2.connection = connection;
        if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
          return handleCallback(callback, new MongoError({
            message: "No more documents in tailed cursor",
            tailable: self2.cmd.tailable,
            awaitData: self2.cmd.awaitData
          }));
        } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
          return nextFunction(self2, callback);
        }
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          return setCursorDeadAndNotified(self2, callback);
        }
        nextFunction(self2, callback);
      });
    } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
      return handleCallback(callback, new MongoError({
        message: "No more documents in tailed cursor",
        tailable: self2.cmd.tailable,
        awaitData: self2.cmd.awaitData
      }));
    } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
      setCursorDeadAndNotified(self2, callback);
    } else {
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
        return;
      }
      self2.cursorState.currentLimit += 1;
      let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
      if (!doc || doc.$err) {
        self2.kill(() => setCursorDeadAndNotified(self2, function() {
          handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
        }));
        return;
      }
      if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
        doc = self2.cursorState.transforms.doc(doc);
      }
      handleCallback(callback, null, doc);
    }
  }
  module2.exports = {
    CursorState,
    CoreCursor
  };
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter2 = require("events").EventEmitter;
  var ReadPreference = require_read_preference();
  var Logger = require_logger();
  var debugOptions = require_utils3().debugOptions;
  var retrieveBSON = require_utils3().retrieveBSON;
  var Pool = require_pool();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var wireProtocol = require_wireprotocol();
  var CoreCursor = require_cursor().CoreCursor;
  var sdam = require_shared2();
  var createCompressionInfo = require_shared2().createCompressionInfo;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var SessionMixins = require_shared2().SessionMixins;
  var relayEvents = require_utils2().relayEvents;
  var collationNotSupported = require_utils2().collationNotSupported;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var debugFields = [
    "reconnect",
    "reconnectTries",
    "reconnectInterval",
    "emitError",
    "cursorFactory",
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "checkServerIdentity",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "key",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "servername"
  ];
  var id = 0;
  var serverAccounting = false;
  var servers = {};
  var BSON2 = retrieveBSON();
  function topologyId(server) {
    return server.s.parent == null ? server.id : server.s.parent.id;
  }
  var Server = function(options) {
    options = options || {};
    EventEmitter2.call(this);
    this.id = id++;
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      logger: Logger("Server", options),
      Cursor: options.cursorFactory || CoreCursor,
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      pool: null,
      disconnectHandler: options.disconnectHandler,
      monitoring: typeof options.monitoring === "boolean" ? options.monitoring : true,
      inTopology: !!options.parent,
      monitoringInterval: typeof options.monitoringInterval === "number" ? options.monitoringInterval : 5e3,
      compression: {compressors: createCompressionInfo(options)},
      parent: options.parent
    };
    if (!this.s.parent) {
      this.s.clusterTime = null;
    }
    this.ismaster = null;
    this.lastIsMasterMS = -1;
    this.monitoringProcessId = null;
    this.initialConnect = true;
    this._type = "server";
    this.lastUpdateTime = 0;
    this.lastWriteDate = 0;
    this.staleness = 0;
  };
  inherits(Server, EventEmitter2);
  Object.assign(Server.prototype, SessionMixins);
  Object.defineProperty(Server.prototype, "type", {
    enumerable: true,
    get: function() {
      return this._type;
    }
  });
  Object.defineProperty(Server.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      if (!this.ismaster)
        return null;
      return this.ismaster.logicalSessionTimeoutMinutes || null;
    }
  });
  Object.defineProperty(Server.prototype, "clientMetadata", {
    enumerable: true,
    get: function() {
      return this.s.options.metadata;
    }
  });
  Object.defineProperty(Server.prototype, "clusterTime", {
    enumerable: true,
    set: function(clusterTime) {
      const settings = this.s.parent ? this.s.parent : this.s;
      resolveClusterTime(settings, clusterTime);
    },
    get: function() {
      const settings = this.s.parent ? this.s.parent : this.s;
      return settings.clusterTime || null;
    }
  });
  Server.enableServerAccounting = function() {
    serverAccounting = true;
    servers = {};
  };
  Server.disableServerAccounting = function() {
    serverAccounting = false;
  };
  Server.servers = function() {
    return servers;
  };
  Object.defineProperty(Server.prototype, "name", {
    enumerable: true,
    get: function() {
      return this.s.options.host + ":" + this.s.options.port;
    }
  });
  function disconnectHandler(self2, type, ns, cmd, options, callback) {
    if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options.monitoring) {
      self2.s.disconnectHandler.add(type, ns, cmd, options, callback);
      return true;
    }
    if (!self2.s.pool.isConnected()) {
      callback(new MongoError(f("no connection available to server %s", self2.name)));
      return true;
    }
  }
  function monitoringProcess(self2) {
    return function() {
      if (self2.s.pool.isDestroyed())
        return;
      self2.emit("monitoring", self2);
      var start = new Date().getTime();
      self2.command("admin.$cmd", {ismaster: true}, {
        socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
        monitoring: true
      }, (err, result) => {
        self2.lastIsMasterMS = new Date().getTime() - start;
        if (self2.s.pool.isDestroyed())
          return;
        if (result) {
          self2.ismaster = result.result;
        }
        self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
      });
    };
  }
  var eventHandler = function(self2, event) {
    return function(err, conn) {
      if (self2.s.logger.isInfo()) {
        var object = err instanceof MongoError ? JSON.stringify(err) : {};
        self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
      }
      if (event === "connect") {
        self2.initialConnect = false;
        self2.ismaster = conn.ismaster;
        self2.lastIsMasterMS = conn.lastIsMasterMS;
        if (conn.agreedCompressor) {
          self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
        }
        if (conn.zlibCompressionLevel) {
          self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
        }
        if (conn.ismaster.$clusterTime) {
          const $clusterTime = conn.ismaster.$clusterTime;
          self2.clusterTime = $clusterTime;
        }
        if (self2.ismaster.msg === "isdbgrid") {
          self2._type = "mongos";
        }
        if (self2.s.monitoring) {
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        }
        sdam.emitServerDescriptionChanged(self2, {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: sdam.getTopologyType(self2)
        });
        if (!self2.s.inTopology) {
          sdam.emitTopologyDescriptionChanged(self2, {
            topologyType: "Single",
            servers: [
              {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: sdam.getTopologyType(self2)
              }
            ]
          });
        }
        if (self2.s.logger.isInfo()) {
          self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
        }
        self2.emit("connect", self2);
      } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
        if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
          if (!self2.s.inTopology) {
            self2.emit("topologyOpening", {topologyId: self2.id});
          }
          delete servers[self2.id];
        }
        if (event === "close") {
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: "Unknown"
          });
        }
        if (event === "reconnectFailed") {
          self2.emit("reconnectFailed", err);
          if (self2.listeners("error").length > 0) {
            self2.emit("error", err);
          }
          return;
        }
        if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
          self2.initialConnect = false;
          return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
        }
        if (event === "reconnect") {
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          return self2.emit(event, self2);
        }
        self2.emit(event, err);
      }
    };
  };
  Server.prototype.connect = function(options) {
    var self2 = this;
    options = options || {};
    if (serverAccounting)
      servers[this.id] = this;
    if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
      throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
    }
    self2.s.pool = new Pool(this, Object.assign(self2.s.options, options, {bson: this.s.bson}));
    self2.s.pool.on("close", eventHandler(self2, "close"));
    self2.s.pool.on("error", eventHandler(self2, "error"));
    self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
    self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
    self2.s.pool.on("connect", eventHandler(self2, "connect"));
    self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
    self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
    relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
    if (!self2.s.inTopology) {
      this.emit("topologyOpening", {topologyId: topologyId(self2)});
    }
    self2.emit("serverOpening", {topologyId: topologyId(self2), address: self2.name});
    self2.s.pool.connect();
  };
  Server.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  Server.prototype.getDescription = function() {
    var ismaster = this.ismaster || {};
    var description = {
      type: sdam.getTopologyType(this),
      address: this.name
    };
    if (ismaster.hosts)
      description.hosts = ismaster.hosts;
    if (ismaster.arbiters)
      description.arbiters = ismaster.arbiters;
    if (ismaster.passives)
      description.passives = ismaster.passives;
    if (ismaster.setName)
      description.setName = ismaster.setName;
    return description;
  };
  Server.prototype.lastIsMaster = function() {
    return this.ismaster;
  };
  Server.prototype.unref = function() {
    this.s.pool.unref();
  };
  Server.prototype.isConnected = function() {
    if (!this.s.pool)
      return false;
    return this.s.pool.isConnected();
  };
  Server.prototype.isDestroyed = function() {
    if (!this.s.pool)
      return false;
    return this.s.pool.isDestroyed();
  };
  function basicWriteValidations(self2) {
    if (!self2.s.pool)
      return new MongoError("server instance is not connected");
    if (self2.s.pool.isDestroyed())
      return new MongoError("server instance pool was destroyed");
  }
  function basicReadValidations(self2, options) {
    basicWriteValidations(self2, options);
    if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
      throw new Error("readPreference must be an instance of ReadPreference");
    }
  }
  Server.prototype.command = function(ns, cmd, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicReadValidations(self2, options);
    if (result)
      return callback(result);
    options = Object.assign({}, options, {wireProtocolCommand: false});
    if (self2.s.logger.isDebug())
      self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
        ns,
        cmd,
        options: debugOptions(debugFields, options)
      }), self2.name));
    if (disconnectHandler(self2, "command", ns, cmd, options, callback))
      return;
    if (collationNotSupported(this, cmd)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    wireProtocol.command(self2, ns, cmd, options, callback);
  };
  Server.prototype.query = function(ns, cmd, cursorState, options, callback) {
    wireProtocol.query(this, ns, cmd, cursorState, options, callback);
  };
  Server.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {
    wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);
  };
  Server.prototype.killCursors = function(ns, cursorState, callback) {
    wireProtocol.killCursors(this, ns, cursorState, callback);
  };
  Server.prototype.insert = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "insert", ns, ops, options, callback))
      return;
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.insert(self2, ns, ops, options, callback);
  };
  Server.prototype.update = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "update", ns, ops, options, callback))
      return;
    if (collationNotSupported(this, options)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.update(self2, ns, ops, options, callback);
  };
  Server.prototype.remove = function(ns, ops, options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    var result = basicWriteValidations(self2, options);
    if (result)
      return callback(result);
    if (disconnectHandler(self2, "remove", ns, ops, options, callback))
      return;
    if (collationNotSupported(this, options)) {
      return callback(new MongoError(`server ${this.name} does not support collation`));
    }
    ops = Array.isArray(ops) ? ops : [ops];
    return wireProtocol.remove(self2, ns, ops, options, callback);
  };
  Server.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  Server.prototype.equals = function(server) {
    if (typeof server === "string")
      return this.name.toLowerCase() === server.toLowerCase();
    if (server.name)
      return this.name.toLowerCase() === server.name.toLowerCase();
    return false;
  };
  Server.prototype.connections = function() {
    return this.s.pool.allConnections();
  };
  Server.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector, selector = void 0;
    callback(null, this);
  };
  var listeners = ["close", "error", "timeout", "parseError", "connect"];
  Server.prototype.destroy = function(options, callback) {
    if (this._destroyed) {
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var self2 = this;
    if (serverAccounting)
      delete servers[this.id];
    if (this.monitoringProcessId) {
      clearTimeout(this.monitoringProcessId);
    }
    if (!self2.s.pool) {
      this._destroyed = true;
      if (typeof callback === "function")
        callback(null, null);
      return;
    }
    if (options.emitClose) {
      self2.emit("close", self2);
    }
    if (options.emitDestroy) {
      self2.emit("destroy", self2);
    }
    listeners.forEach(function(event) {
      self2.s.pool.removeAllListeners(event);
    });
    if (self2.listeners("serverClosed").length > 0)
      self2.emit("serverClosed", {topologyId: topologyId(self2), address: self2.name});
    if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
      self2.emit("topologyClosed", {topologyId: topologyId(self2)});
    }
    if (self2.s.logger.isDebug()) {
      self2.s.logger.debug(f("destroy called on server %s", self2.name));
    }
    this.s.pool.destroy(options.force, callback);
    this._destroyed = true;
  };
  module2.exports = Server;
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var diff = require_shared2().diff;
  var EventEmitter2 = require("events").EventEmitter;
  var Logger = require_logger();
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var Buffer2 = require_safe_buffer().Buffer;
  var TopologyType = {
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown"
  };
  var ServerType = {
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown"
  };
  var ReplSetState = function(options) {
    options = options || {};
    EventEmitter2.call(this);
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    this.setName = options.setName;
    this.set = {};
    this.id = options.id;
    this.setName = options.setName;
    this.logger = options.logger || Logger("ReplSet", options);
    this.index = 0;
    this.acceptableLatency = options.acceptableLatency || 15;
    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
    this.primary = null;
    this.secondaries = [];
    this.arbiters = [];
    this.passives = [];
    this.ghosts = [];
    this.unknownServers = [];
    this.set = {};
    this.maxElectionId = null;
    this.maxSetVersion = 0;
    this.replicasetDescription = {
      topologyType: "Unknown",
      servers: []
    };
    this.logicalSessionTimeoutMinutes = void 0;
  };
  inherits(ReplSetState, EventEmitter2);
  ReplSetState.prototype.hasPrimaryAndSecondary = function() {
    return this.primary != null && this.secondaries.length > 0;
  };
  ReplSetState.prototype.hasPrimaryOrSecondary = function() {
    return this.hasPrimary() || this.hasSecondary();
  };
  ReplSetState.prototype.hasPrimary = function() {
    return this.primary != null;
  };
  ReplSetState.prototype.hasSecondary = function() {
    return this.secondaries.length > 0;
  };
  ReplSetState.prototype.get = function(host) {
    var servers = this.allServers();
    for (var i = 0; i < servers.length; i++) {
      if (servers[i].name.toLowerCase() === host.toLowerCase()) {
        return servers[i];
      }
    }
    return null;
  };
  ReplSetState.prototype.allServers = function(options) {
    options = options || {};
    var servers = this.primary ? [this.primary] : [];
    servers = servers.concat(this.secondaries);
    if (!options.ignoreArbiters)
      servers = servers.concat(this.arbiters);
    servers = servers.concat(this.passives);
    return servers;
  };
  ReplSetState.prototype.destroy = function(options, callback) {
    const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
    if (this.primary)
      serversToDestroy.push(this.primary);
    let serverCount = serversToDestroy.length;
    const serverDestroyed = () => {
      serverCount--;
      if (serverCount > 0) {
        return;
      }
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.primary = null;
      emitTopologyDescriptionChanged(this);
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (serverCount === 0) {
      serverDestroyed();
      return;
    }
    serversToDestroy.forEach((server) => server.destroy(options, serverDestroyed));
  };
  ReplSetState.prototype.remove = function(server, options) {
    options = options || {};
    var serverName = server.name.toLowerCase();
    var servers = this.primary ? [this.primary] : [];
    servers = servers.concat(this.secondaries);
    servers = servers.concat(this.arbiters);
    servers = servers.concat(this.passives);
    for (var i = 0; i < servers.length; i++) {
      if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
        return;
      }
    }
    if (this.set[serverName]) {
      this.set[serverName].type = ServerType.Unknown;
      this.set[serverName].electionId = null;
      this.set[serverName].setName = null;
      this.set[serverName].setVersion = null;
    }
    var removeType = null;
    if (this.primary && this.primary.equals(server)) {
      this.primary = null;
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      removeType = "primary";
    }
    removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
    removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
    removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
    removeFrom(server, this.ghosts);
    removeFrom(server, this.unknownServers);
    this.unknownServers.push(serverName);
    if (removeType) {
      this.emit("left", removeType, server);
    }
  };
  var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
  ReplSetState.prototype.update = function(server) {
    var self2 = this;
    var ismaster = server.lastIsMaster();
    var serverName = server.name.toLowerCase();
    if (ismaster) {
      var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
      hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
      hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
      hosts = hosts.map(function(s) {
        return s.toLowerCase();
      });
      for (var i = 0; i < hosts.length; i++) {
        if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
          this.unknownServers.push(hosts[i].toLowerCase());
        }
        if (!this.set[hosts[i]]) {
          this.set[hosts[i]] = {
            type: ServerType.Unknown,
            electionId: null,
            setName: null,
            setVersion: null
          };
        }
      }
    }
    if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
      self2.set[serverName] = {
        type: ServerType.Unknown,
        setVersion: null,
        electionId: null,
        setName: null
      };
      self2.set[serverName].type = ServerType.Unknown;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      if (self2.unknownServers.indexOf(server.name) === -1) {
        self2.unknownServers.push(serverName);
      }
      return false;
    }
    if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
      if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
        self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
      } else {
        self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
      }
    }
    if (ismaster && ismaster.msg === "isdbgrid") {
      if (this.primary && this.primary.name === serverName) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      return false;
    }
    if (ismaster.isreplicaset) {
      self2.set[serverName] = {
        type: ServerType.RSGhost,
        setVersion: null,
        electionId: null,
        setName: ismaster.setName
      };
      if (this.primary && this.primary.name === serverName) {
        this.primary = null;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      return false;
    }
    if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
      self2.set[serverName] = {
        type: ServerType.RSOther,
        setVersion: null,
        electionId: null,
        setName: ismaster.setName
      };
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      return false;
    }
    if (ismaster && ismaster.ismaster && !ismaster.setName) {
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
      this.remove(server, {force: true});
      return false;
    }
    if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
      this.remove(server, {force: true});
      return false;
    }
    if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
      if (this.logger.isWarn()) {
        this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
      }
      delete this.set[serverName];
      removeFrom(server, self2.unknownServers);
      server.destroy({force: true});
      if (this.primary && !this.primary.equals(server)) {
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
      } else {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      if (!this.primary && ismaster.primary) {
        this.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setName: null,
          electionId: null,
          setVersion: null
        };
      }
      return false;
    }
    if (!this.primary && ismaster.ismaster && ismaster.setName) {
      var ismasterElectionId = server.lastIsMaster().electionId;
      if (this.setName && this.setName !== ismaster.setName) {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
      }
      if (!this.maxElectionId && ismasterElectionId) {
        this.maxElectionId = ismasterElectionId;
      } else if (this.maxElectionId && ismasterElectionId) {
        var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
        var ismasterSetVersion = server.lastIsMaster().setVersion;
        if (result === 1) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return false;
        } else if (result === 0 && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          }
        }
        this.maxSetVersion = ismasterSetVersion;
        this.maxElectionId = ismasterElectionId;
      }
      var normalizedHosts = ismaster.hosts.map(function(x) {
        return x.toLowerCase();
      });
      var locationIndex = normalizedHosts.indexOf(serverName);
      if (locationIndex !== -1) {
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
      } else {
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      }
      emitTopologyDescriptionChanged(self2);
      return true;
    } else if (ismaster.ismaster && ismaster.setName) {
      var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
      var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
      var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
      ismasterElectionId = server.lastIsMaster().electionId;
      ismasterSetVersion = server.lastIsMaster().setVersion;
      var ismasterSetName = server.lastIsMaster().setName;
      if (this.primary.equals(server) && currentSetName === ismasterSetName) {
        return false;
      }
      if (currentSetName && currentSetName !== ismasterSetName) {
        if (!this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (currentElectionId && ismasterElectionId) {
        result = compareObjectIds(currentElectionId, ismasterElectionId);
        if (result === 1) {
          return false;
        } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
          return false;
        }
      } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
        if (ismasterSetVersion < this.maxSetVersion) {
          return false;
        }
      }
      if (!this.maxElectionId && ismasterElectionId) {
        this.maxElectionId = ismasterElectionId;
      } else if (this.maxElectionId && ismasterElectionId) {
        result = compareObjectIds(this.maxElectionId, ismasterElectionId);
        if (result === 1) {
          return false;
        } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        } else {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        this.maxElectionId = ismasterElectionId;
        this.maxSetVersion = ismasterSetVersion;
      } else {
        this.maxSetVersion = ismasterSetVersion;
      }
      self2.set[self2.primary.name.toLowerCase()] = {
        type: ServerType.Unknown,
        setVersion: null,
        electionId: null,
        setName: null
      };
      self2.emit("left", "primary", this.primary);
      self2.primary.destroy({force: true});
      self2.primary = server;
      self2.set[serverName] = {
        type: ServerType.RSPrimary,
        setVersion: ismaster.setVersion,
        electionId: ismaster.electionId,
        setName: ismaster.setName
      };
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      removeFrom(server, self2.secondaries);
      removeFrom(server, self2.passives);
      self2.emit("joined", "primary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (!this.primary && ismaster.primary) {
      self2.set[ismaster.primary.toLowerCase()] = {
        type: ServerType.PossiblePrimary,
        setVersion: null,
        electionId: null,
        setName: null
      };
    }
    if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      if (this.primary && this.primary.name.toLowerCase() === serverName) {
        server.destroy({force: true});
        this.primary = null;
        self2.emit("left", "primary", server);
      }
      self2.emit("joined", "secondary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      self2.emit("joined", "arbiter", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
      addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      if (ismaster.setName)
        this.setName = ismaster.setName;
      removeFrom(server, self2.unknownServers);
      if (this.primary && this.primary.name.toLowerCase() === serverName) {
        server.destroy({force: true});
        this.primary = null;
        self2.emit("left", "primary", server);
      }
      self2.emit("joined", "secondary", server);
      emitTopologyDescriptionChanged(self2);
      return true;
    }
    if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
      self2.emit("left", "primary", this.primary);
      this.primary.destroy({force: true});
      this.primary = null;
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      return false;
    }
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    return false;
  };
  ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
    var max = 0;
    for (var i = 0; i < this.secondaries.length; i++) {
      max = Math.max(max, this.secondaries[i].lastWriteDate);
    }
    if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
      server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
    } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
      server.staleness = max - server.lastWriteDate + haInterval;
    }
  };
  ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
    for (var i = 0; i < this.secondaries.length; i++) {
      this.updateServerMaxStaleness(this.secondaries[i], haInterval);
    }
  };
  ReplSetState.prototype.pickServer = function(readPreference) {
    readPreference = readPreference || ReadPreference.primary;
    if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
      return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
    }
    var allservers = this.primary ? [this.primary] : [];
    allservers = allservers.concat(this.secondaries);
    if (readPreference.maxStalenessSeconds != null) {
      for (var i = 0; i < allservers.length; i++) {
        if (allservers[i].ismaster.maxWireVersion < 5) {
          return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
        }
      }
    }
    if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
      return pickNearest(this, readPreference);
    } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
      return pickNearestMaxStalenessSeconds(this, readPreference);
    }
    var secondaries = this.secondaries;
    if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
      return new MongoError("no secondary server available");
    }
    if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
      return new MongoError("no secondary or primary server available");
    }
    if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
      return new MongoError("no primary server available");
    }
    if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
      if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
        var server = pickNearest(this, readPreference);
        if (server) {
          return server;
        }
      } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
        server = pickNearestMaxStalenessSeconds(this, readPreference);
        if (server) {
          return server;
        }
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.primary;
      }
      return null;
    }
    if (readPreference.equals(ReadPreference.primaryPreferred)) {
      server = null;
      if (this.primary) {
        return this.primary;
      }
      if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
        server = pickNearest(this, readPreference);
      } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
        server = pickNearestMaxStalenessSeconds(this, readPreference);
      }
      if (server)
        return server;
    }
    return this.primary;
  };
  var filterByTags = function(readPreference, servers) {
    if (readPreference.tags == null)
      return servers;
    var filteredServers = [];
    var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
    for (var j = 0; j < tagsArray.length; j++) {
      var tags = tagsArray[j];
      for (var i = 0; i < servers.length; i++) {
        var serverTag = servers[i].lastIsMaster().tags || {};
        var found = true;
        for (var name in tags) {
          if (serverTag[name] !== tags[name]) {
            found = false;
          }
        }
        if (found) {
          filteredServers.push(servers[i]);
        }
      }
    }
    return filteredServers;
  };
  function pickNearestMaxStalenessSeconds(self2, readPreference) {
    var servers = [];
    var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
    if (maxStalenessMS < 90 * 1e3) {
      return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
    }
    if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    for (var i = 0; i < self2.secondaries.length; i++) {
      servers.push(self2.secondaries[i]);
    }
    if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    servers = filterByTags(readPreference, servers);
    servers = servers.filter(function(s) {
      return s.staleness <= maxStalenessMS;
    });
    servers.sort(function(a, b) {
      return a.lastIsMasterMS - b.lastIsMasterMS;
    });
    if (servers.length === 0) {
      return null;
    }
    self2.index = self2.index % servers.length;
    var server = servers[self2.index];
    self2.index = self2.index + 1;
    return server;
  }
  function pickNearest(self2, readPreference) {
    var servers = [];
    if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    for (var i = 0; i < self2.secondaries.length; i++) {
      servers.push(self2.secondaries[i]);
    }
    if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
      servers.push(self2.primary);
    }
    servers = filterByTags(readPreference, servers);
    servers.sort(function(a, b) {
      return a.lastIsMasterMS - b.lastIsMasterMS;
    });
    var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
    servers = servers.filter(function(s) {
      return s.lastIsMasterMS <= lowest + self2.acceptableLatency;
    });
    if (servers.length === 0) {
      return null;
    }
    self2.index = self2.index % servers.length;
    var server = servers[self2.index];
    self2.index = self2.index + 1;
    return server;
  }
  function inList(ismaster, server, list) {
    for (var i = 0; i < list.length; i++) {
      if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
        return true;
    }
    return false;
  }
  function addToList(self2, type, ismaster, server, list) {
    var serverName = server.name.toLowerCase();
    self2.set[serverName].type = type;
    self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
    self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
    self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
    list.push(server);
  }
  function compareObjectIds(id1, id2) {
    var a = Buffer2.from(id1.toHexString(), "hex");
    var b = Buffer2.from(id2.toHexString(), "hex");
    if (a === b) {
      return 0;
    }
    if (typeof Buffer2.compare === "function") {
      return Buffer2.compare(a, b);
    }
    var x = a.length;
    var y = b.length;
    var len = Math.min(x, y);
    for (var i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        break;
      }
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    return x < y ? -1 : y < x ? 1 : 0;
  }
  function removeFrom(server, list) {
    for (var i = 0; i < list.length; i++) {
      if (list[i].equals && list[i].equals(server)) {
        list.splice(i, 1);
        return true;
      } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
        list.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  function emitTopologyDescriptionChanged(self2) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      var topology = "Unknown";
      var setName = self2.setName;
      if (self2.hasPrimaryAndSecondary()) {
        topology = "ReplicaSetWithPrimary";
      } else if (!self2.hasPrimary() && self2.hasSecondary()) {
        topology = "ReplicaSetNoPrimary";
      }
      var description = {
        topologyType: topology,
        setName,
        servers: []
      };
      if (self2.hasPrimary()) {
        var desc = self2.primary.getDescription();
        desc.type = "RSPrimary";
        description.servers.push(desc);
      }
      description.servers = description.servers.concat(self2.secondaries.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSSecondary";
        return description2;
      }));
      description.servers = description.servers.concat(self2.arbiters.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSArbiter";
        return description2;
      }));
      description.servers = description.servers.concat(self2.passives.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "RSSecondary";
        return description2;
      }));
      var diffResult = diff(self2.replicasetDescription, description);
      var result = {
        topologyId: self2.id,
        previousDescription: self2.replicasetDescription,
        newDescription: description,
        diff: diffResult
      };
      self2.emit("topologyDescriptionChanged", result);
      self2.replicasetDescription = description;
    }
  }
  module2.exports = ReplSetState;
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter2 = require("events").EventEmitter;
  var ReadPreference = require_read_preference();
  var CoreCursor = require_cursor().CoreCursor;
  var retrieveBSON = require_utils3().retrieveBSON;
  var Logger = require_logger();
  var MongoError = require_error().MongoError;
  var Server = require_server();
  var ReplSetState = require_replset_state();
  var Timeout = require_shared2().Timeout;
  var Interval = require_shared2().Interval;
  var SessionMixins = require_shared2().SessionMixins;
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = retrieveBSON();
  var getMMAPError = require_shared2().getMMAPError;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var UNREFERENCED = "unreferenced";
  var DESTROYED = "destroyed";
  function stateTransition(self2, newState) {
    var legalTransitions = {
      disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
      connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
      connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
      unreferenced: [UNREFERENCED, DESTROYED],
      destroyed: [DESTROYED]
    };
    var legalStates = legalTransitions[self2.state];
    if (legalStates && legalStates.indexOf(newState) !== -1) {
      self2.state = newState;
    } else {
      self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
    }
  }
  var id = 1;
  var handlers = ["connect", "close", "error", "timeout", "parseError"];
  var ReplSet = function(seedlist, options) {
    var self2 = this;
    options = options || {};
    if (!Array.isArray(seedlist))
      throw new MongoError("seedlist must be an array");
    if (seedlist.length === 0)
      throw new MongoError("seedlist must contain at least one entry");
    seedlist.forEach(function(e) {
      if (typeof e.host !== "string" || typeof e.port !== "number")
        throw new MongoError("seedlist entry must contain a host and port");
    });
    EventEmitter2.call(this);
    this.id = id++;
    var localThresholdMS = options.localThresholdMS || 15;
    if (options.acceptableLatency)
      localThresholdMS = options.acceptableLatency;
    var logger = Logger("ReplSet", options);
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      Cursor: options.cursorFactory || CoreCursor,
      logger,
      seedlist,
      replicaSetState: new ReplSetState({
        id: this.id,
        setName: options.setName,
        acceptableLatency: localThresholdMS,
        heartbeatFrequencyMS: options.haInterval ? options.haInterval : 1e4,
        logger
      }),
      connectingServers: [],
      haInterval: options.haInterval ? options.haInterval : 1e4,
      minHeartbeatFrequencyMS: 500,
      disconnectHandler: options.disconnectHandler,
      index: 0,
      connectOptions: {},
      debug: typeof options.debug === "boolean" ? options.debug : false
    };
    this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
      self2.emit("topologyDescriptionChanged", r);
    });
    if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
      this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
    }
    var types = ["joined", "left"];
    types.forEach(function(x) {
      self2.s.replicaSetState.on(x, function(t, s) {
        self2.emit(x, t, s);
      });
    });
    this.initialConnectState = {
      connect: false,
      fullsetup: false,
      all: false
    };
    this.state = DISCONNECTED;
    this.haTimeoutId = null;
    this.ismaster = null;
    this.intervalIds = [];
    this.clusterTime = null;
  };
  inherits(ReplSet, EventEmitter2);
  Object.assign(ReplSet.prototype, SessionMixins);
  Object.defineProperty(ReplSet.prototype, "type", {
    enumerable: true,
    get: function() {
      return "replset";
    }
  });
  Object.defineProperty(ReplSet.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
    }
  });
  function rexecuteOperations(self2) {
    if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute();
    } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute({executePrimary: true});
    } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
      self2.s.disconnectHandler.execute({executeSecondary: true});
    }
  }
  function connectNewServers(self2, servers, callback) {
    if (servers.length === 0) {
      return callback();
    }
    var count = servers.length;
    var error = null;
    function done() {
      count = count - 1;
      if (count === 0) {
        callback(error);
      }
    }
    var _handleEvent = function(self3, event) {
      return function(err) {
        var _self = this;
        if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
          this.destroy({force: true});
          return done();
        }
        if (event === "connect") {
          var result = self3.s.replicaSetState.update(_self);
          if (result) {
            if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
              self3.ismaster = _self.lastIsMaster();
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            monitorServer(_self.lastIsMaster().me, self3, {});
            rexecuteOperations(self3);
          } else {
            _self.destroy({force: true});
          }
        } else if (event === "error") {
          error = err;
        }
        rexecuteOperations(self3);
        done();
      };
    };
    function execute(_server, i2) {
      setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return;
        }
        const existingServerIdx = self2.s.connectingServers.findIndex((s) => s.name === _server);
        if (existingServerIdx >= 0) {
          const connectingServer = self2.s.connectingServers[existingServerIdx];
          connectingServer.destroy({force: true});
          self2.s.connectingServers.splice(existingServerIdx, 1);
          return done();
        }
        var server = new Server(Object.assign({}, self2.s.options, {
          host: _server.split(":")[0],
          port: parseInt(_server.split(":")[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        server.once("connect", _handleEvent(self2, "connect"));
        server.once("close", _handleEvent(self2, "close"));
        server.once("timeout", _handleEvent(self2, "timeout"));
        server.once("error", _handleEvent(self2, "error"));
        server.once("parseError", _handleEvent(self2, "parseError"));
        server.on("serverOpening", (e) => self2.emit("serverOpening", e));
        server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
        server.on("serverClosed", (e) => self2.emit("serverClosed", e));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        self2.s.connectingServers.push(server);
        server.connect(self2.s.connectOptions);
      }, i2);
    }
    for (var i = 0; i < servers.length; i++) {
      execute(servers[i], i);
    }
  }
  var pingServer = function(self2, server, cb) {
    var start = new Date().getTime();
    emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: server.name});
    server.command("admin.$cmd", {
      ismaster: true
    }, {
      monitoring: true,
      socketTimeout: self2.s.options.connectionTimeout || 2e3
    }, function(err, r) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        server.destroy({force: true});
        return cb(err, r);
      }
      var latencyMS = new Date().getTime() - start;
      server.lastUpdateTime = now();
      if (err) {
        emitSDAMEvent(self2, "serverHeartbeatFailed", {
          durationMS: latencyMS,
          failure: err,
          connectionId: server.name
        });
        self2.s.replicaSetState.remove(server);
      } else {
        server.ismaster = r.result;
        if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
          server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
        }
        if (server.lastIsMasterMS === -1) {
          server.lastIsMasterMS = latencyMS;
        } else if (server.lastIsMasterMS) {
          server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
        }
        if (self2.s.replicaSetState.update(server)) {
          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
            self2.ismaster = server.lastIsMaster();
          }
        }
        emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
          durationMS: latencyMS,
          reply: r.result,
          connectionId: server.name
        });
      }
      self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
      cb(err, r);
    });
  };
  var monitorServer = function(host, self2, options) {
    if (!options.haInterval) {
      for (var i = 0; i < self2.intervalIds.length; i++) {
        if (self2.intervalIds[i].__host === host) {
          return;
        }
      }
    }
    var _process = options.haInterval ? Timeout : Interval;
    var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
    var intervalId = new _process(function() {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        intervalId.stop();
        return;
      }
      var _server = self2.s.replicaSetState.get(host);
      if (_server) {
        return pingServer(self2, _server, function(err) {
          if (err) {
            return;
          }
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            intervalId.stop();
            return;
          }
          self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
            return intervalId2.isRunning();
          });
          if (_process === Timeout) {
            if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
              self2.state = CONNECTED;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else {
            if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
              self2.state = CONNECTED;
              rexecuteOperations(self2);
              process.nextTick(function() {
                self2.emit("reconnect", self2);
              });
            }
          }
          if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
            self2.initialConnectState.fullsetup = true;
            self2.initialConnectState.all = true;
            process.nextTick(function() {
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            });
          }
        });
      }
    }, _haInterval);
    intervalId.start();
    intervalId.__host = host;
    self2.intervalIds.push(intervalId);
  };
  function topologyMonitor(self2, options) {
    if (self2.state === DESTROYED || self2.state === UNREFERENCED)
      return;
    options = options || {};
    var servers = Object.keys(self2.s.replicaSetState.set);
    var _process = options.haInterval ? Timeout : Interval;
    var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
    if (_process === Timeout) {
      return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return;
        }
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
          if (err) {
            return self2.emit("error", err);
          }
          self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
          return self2.destroy({force: true});
        } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          if (err) {
            return self2.emit("error", err);
          }
          self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
          return self2.destroy({force: true});
        }
        for (var i2 = 0; i2 < servers.length; i2++) {
          monitorServer(servers[i2], self2, options);
        }
      });
    } else {
      for (var i = 0; i < servers.length; i++) {
        monitorServer(servers[i], self2, options);
      }
    }
    function executeReconnect(self3) {
      return function() {
        if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
          return;
        }
        connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
          var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
          self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
        });
      };
    }
    var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
    self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
  }
  function addServerToList(list, server) {
    for (var i = 0; i < list.length; i++) {
      if (list[i].name.toLowerCase() === server.name.toLowerCase())
        return true;
    }
    list.push(server);
  }
  function handleEvent(self2, event) {
    return function() {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
      }
      self2.s.replicaSetState.remove(this);
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
        stateTransition(self2, DISCONNECTED);
      } else if (!self2.s.replicaSetState.hasPrimary()) {
        stateTransition(self2, DISCONNECTED);
      }
      addServerToList(self2.s.connectingServers, this);
    };
  }
  function shouldTriggerConnect(self2) {
    const isConnecting = self2.state === CONNECTING;
    const hasPrimary = self2.s.replicaSetState.hasPrimary();
    const hasSecondary = self2.s.replicaSetState.hasSecondary();
    const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
    const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
    return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
  }
  function handleInitialConnectEvent(self2, event) {
    return function() {
      var _this = this;
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
      }
      if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
        return this.destroy({force: true});
      }
      if (event === "connect") {
        var result = self2.s.replicaSetState.update(_this);
        if (result === true) {
          if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
            self2.ismaster = _this.lastIsMaster();
          }
          if (self2.s.logger.isDebug()) {
            self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
          }
          for (let i2 = 0; i2 < handlers.length; i2++) {
            _this.removeAllListeners(handlers[i2]);
          }
          _this.on("error", handleEvent(self2, "error"));
          _this.on("close", handleEvent(self2, "close"));
          _this.on("timeout", handleEvent(self2, "timeout"));
          _this.on("parseError", handleEvent(self2, "parseError"));
          if (shouldTriggerConnect(self2)) {
            self2.state = CONNECTED;
            self2.initialConnectState.connect = true;
            process.nextTick(function() {
              self2.emit("connect", self2);
            });
            topologyMonitor(self2, {});
          }
        } else if (result instanceof MongoError) {
          _this.destroy({force: true});
          self2.destroy({force: true});
          return self2.emit("error", result);
        } else {
          _this.destroy({force: true});
        }
      } else {
        self2.emit("failed", this);
        addServerToList(self2.s.connectingServers, this);
        self2.s.replicaSetState.remove(this);
      }
      if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
        self2.initialConnectState.fullsetup = true;
        self2.initialConnectState.all = true;
        process.nextTick(function() {
          self2.emit("fullsetup", self2);
          self2.emit("all", self2);
        });
      }
      for (var i = 0; i < self2.s.connectingServers.length; i++) {
        if (self2.s.connectingServers[i].equals(this)) {
          self2.s.connectingServers.splice(i, 1);
        }
      }
      if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
        topologyMonitor(self2, {haInterval: 1});
      }
    };
  }
  function connectServers(self2, servers) {
    self2.s.connectingServers = self2.s.connectingServers.concat(servers);
    var timeoutInterval = 0;
    function connect(server, timeoutInterval2) {
      setTimeout(function() {
        if (self2.s.replicaSetState.update(server)) {
          if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
            self2.ismaster = server.lastIsMaster();
          }
        }
        server.once("close", handleInitialConnectEvent(self2, "close"));
        server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
        server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
        server.once("error", handleInitialConnectEvent(self2, "error"));
        server.once("connect", handleInitialConnectEvent(self2, "connect"));
        server.on("serverOpening", (e) => self2.emit("serverOpening", e));
        server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
        server.on("serverClosed", (e) => self2.emit("serverClosed", e));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        server.connect(self2.s.connectOptions);
      }, timeoutInterval2);
    }
    while (servers.length > 0) {
      connect(servers.shift(), timeoutInterval++);
    }
  }
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  ReplSet.prototype.connect = function(options) {
    var self2 = this;
    this.s.connectOptions = options || {};
    stateTransition(this, CONNECTING);
    var servers = this.s.seedlist.map(function(x) {
      return new Server(Object.assign({}, self2.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self2
      }));
    });
    if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
      return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
    }
    emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
    connectServers(self2, servers);
  };
  ReplSet.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  ReplSet.prototype.destroy = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    let destroyCount = this.s.connectingServers.length + 1;
    const serverDestroyed = () => {
      destroyCount--;
      if (destroyCount > 0) {
        return;
      }
      emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
      stateTransition(this, DESTROYED);
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (this.haTimeoutId)
      clearTimeout(this.haTimeoutId);
    for (var i = 0; i < this.intervalIds.length; i++) {
      this.intervalIds[i].stop();
    }
    this.intervalIds = [];
    if (destroyCount === 0) {
      serverDestroyed();
      return;
    }
    this.s.replicaSetState.destroy(options, serverDestroyed);
    this.s.connectingServers.forEach(function(x) {
      x.destroy(options, serverDestroyed);
    });
  };
  ReplSet.prototype.unref = function() {
    stateTransition(this, UNREFERENCED);
    this.s.replicaSetState.allServers().forEach(function(x) {
      x.unref();
    });
    clearTimeout(this.haTimeoutId);
  };
  ReplSet.prototype.lastIsMaster = function() {
    if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
      return this.s.replicaSetState.secondaries[0].lastIsMaster();
    }
    return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
  };
  ReplSet.prototype.connections = function() {
    var servers = this.s.replicaSetState.allServers();
    var connections = [];
    for (var i = 0; i < servers.length; i++) {
      connections = connections.concat(servers[i].connections());
    }
    return connections;
  };
  ReplSet.prototype.isConnected = function(options) {
    options = options || {};
    if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
      return this.s.replicaSetState.hasSecondary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
      return this.s.replicaSetState.hasPrimary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
      return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
    }
    if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
      return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
    }
    if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
      return true;
    }
    return this.s.replicaSetState.hasPrimary();
  };
  ReplSet.prototype.isDestroyed = function() {
    return this.state === DESTROYED;
  };
  var SERVER_SELECTION_TIMEOUT_MS = 1e4;
  var SERVER_SELECTION_INTERVAL_MS = 1e3;
  ReplSet.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector;
    options = options || {};
    let readPreference;
    if (selector instanceof ReadPreference) {
      readPreference = selector;
    } else {
      readPreference = options.readPreference || ReadPreference.primary;
    }
    let lastError;
    const start = now();
    const _selectServer = () => {
      if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
        if (lastError != null) {
          callback(lastError, null);
        } else {
          callback(new MongoError("Server selection timed out"));
        }
        return;
      }
      const server = this.s.replicaSetState.pickServer(readPreference);
      if (server == null) {
        setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
        return;
      }
      if (!(server instanceof Server)) {
        lastError = server;
        setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", options.readPreference, server);
      callback(null, server);
    };
    _selectServer();
  };
  ReplSet.prototype.getServers = function() {
    return this.s.replicaSetState.allServers();
  };
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const self2 = args.self;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    if (self2.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction();
    if (!self2.s.replicaSetState.hasPrimary()) {
      if (self2.s.disconnectHandler) {
        return self2.s.disconnectHandler.add(op, ns, ops, options, callback);
      } else if (!willRetryWrite) {
        return callback(new MongoError("no primary server found"));
      }
    }
    const handler = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        err = getMMAPError(err);
        return callback(err);
      }
      if (willRetryWrite) {
        const newArgs = Object.assign({}, args, {retrying: true});
        return executeWriteOperation(newArgs, options, callback);
      }
      if (self2.s.replicaSetState.primary) {
        self2.s.replicaSetState.primary.destroy();
        self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, {force: true});
      }
      return callback(err);
    };
    if (callback.operationId) {
      handler.operationId = callback.operationId;
    }
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    self2.s.replicaSetState.primary[op](ns, ops, options, handler);
  }
  ReplSet.prototype.insert = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "insert", ns, ops}, options, callback);
  };
  ReplSet.prototype.update = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "update", ns, ops}, options, callback);
  };
  ReplSet.prototype.remove = function(ns, ops, options, callback) {
    executeWriteOperation({self: this, op: "remove", ns, ops}, options, callback);
  };
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  ReplSet.prototype.command = function(ns, cmd, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED)
      return callback(new MongoError(f("topology was destroyed")));
    var self2 = this;
    var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
    if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    }
    var server = this.s.replicaSetState.pickServer(readPreference);
    if (!(server instanceof Server))
      return callback(server);
    if (self2.s.debug)
      self2.emit("pickedServer", ReadPreference.primary, server);
    if (server == null) {
      return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
    }
    const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
    const cb = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        return callback(err);
      }
      if (willRetryWrite) {
        const newOptions = Object.assign({}, options, {retrying: true});
        return this.command(ns, cmd, newOptions, callback);
      }
      if (this.s.replicaSetState.primary) {
        this.s.replicaSetState.primary.destroy();
        this.s.replicaSetState.remove(this.s.replicaSetState.primary, {force: true});
      }
      return callback(err);
    };
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    server.command(ns, cmd, options, cb);
  };
  ReplSet.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  module2.exports = ReplSet;
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require("util").inherits;
  var f = require("util").format;
  var EventEmitter2 = require("events").EventEmitter;
  var CoreCursor = require_cursor().CoreCursor;
  var Logger = require_logger();
  var retrieveBSON = require_utils3().retrieveBSON;
  var MongoError = require_error().MongoError;
  var Server = require_server();
  var diff = require_shared2().diff;
  var cloneOptions = require_shared2().cloneOptions;
  var SessionMixins = require_shared2().SessionMixins;
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = retrieveBSON();
  var getMMAPError = require_shared2().getMMAPError;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
  var DISCONNECTED = "disconnected";
  var CONNECTING = "connecting";
  var CONNECTED = "connected";
  var UNREFERENCED = "unreferenced";
  var DESTROYING = "destroying";
  var DESTROYED = "destroyed";
  function stateTransition(self2, newState) {
    var legalTransitions = {
      disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
      connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
      connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
      unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
      destroyed: [DESTROYED]
    };
    var legalStates = legalTransitions[self2.state];
    if (legalStates && legalStates.indexOf(newState) !== -1) {
      self2.state = newState;
    } else {
      self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
    }
  }
  var id = 1;
  var handlers = ["connect", "close", "error", "timeout", "parseError"];
  var Mongos = function(seedlist, options) {
    options = options || {};
    this.id = id++;
    if (Array.isArray(seedlist)) {
      seedlist = seedlist.reduce((seeds, seed) => {
        if (seeds.find((s) => s.host === seed.host && s.port === seed.port)) {
          return seeds;
        }
        seeds.push(seed);
        return seeds;
      }, []);
    }
    this.s = {
      options: Object.assign({metadata: makeClientMetadata(options)}, options),
      bson: options.bson || new BSON2([
        BSON2.Binary,
        BSON2.Code,
        BSON2.DBRef,
        BSON2.Decimal128,
        BSON2.Double,
        BSON2.Int32,
        BSON2.Long,
        BSON2.Map,
        BSON2.MaxKey,
        BSON2.MinKey,
        BSON2.ObjectId,
        BSON2.BSONRegExp,
        BSON2.Symbol,
        BSON2.Timestamp
      ]),
      Cursor: options.cursorFactory || CoreCursor,
      logger: Logger("Mongos", options),
      seedlist,
      haInterval: options.haInterval ? options.haInterval : 1e4,
      disconnectHandler: options.disconnectHandler,
      index: 0,
      connectOptions: {},
      debug: typeof options.debug === "boolean" ? options.debug : false,
      localThresholdMS: options.localThresholdMS || 15
    };
    if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
      this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
    }
    this.state = DISCONNECTED;
    this.connectingProxies = [];
    this.connectedProxies = [];
    this.disconnectedProxies = [];
    this.index = 0;
    this.haTimeoutId = null;
    this.ismaster = null;
    this.topologyDescription = {
      topologyType: "Unknown",
      servers: []
    };
    this.clusterTime = null;
    EventEmitter2.call(this);
  };
  inherits(Mongos, EventEmitter2);
  Object.assign(Mongos.prototype, SessionMixins);
  Object.defineProperty(Mongos.prototype, "type", {
    enumerable: true,
    get: function() {
      return "mongos";
    }
  });
  Object.defineProperty(Mongos.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return BSON2.native ? "c++" : "js";
    }
  });
  Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      if (!this.ismaster)
        return null;
      return this.ismaster.logicalSessionTimeoutMinutes || null;
    }
  });
  function emitSDAMEvent(self2, event, description) {
    if (self2.listeners(event).length > 0) {
      self2.emit(event, description);
    }
  }
  var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
  function destroyServer(server, options, callback) {
    options = options || {};
    SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
    server.destroy(options, callback);
  }
  Mongos.prototype.connect = function(options) {
    var self2 = this;
    this.s.connectOptions = options || {};
    stateTransition(this, CONNECTING);
    var servers = this.s.seedlist.map(function(x) {
      const server = new Server(Object.assign({}, self2.s.options, x, options, {
        reconnect: false,
        monitoring: false,
        parent: self2
      }));
      relayEvents(server, self2, ["serverDescriptionChanged"]);
      return server;
    });
    emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
    connectProxies(self2, servers);
  };
  Mongos.prototype.auth = function(credentials, callback) {
    if (typeof callback === "function")
      callback(null, null);
  };
  function handleEvent(self2) {
    return function() {
      if (self2.state === DESTROYED || self2.state === DESTROYING) {
        return;
      }
      moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
      emitTopologyDescriptionChanged(self2);
      self2.emit("left", "mongos", this);
      self2.emit("serverClosed", {
        topologyId: self2.id,
        address: this.name
      });
    };
  }
  function handleInitialConnectEvent(self2, event) {
    return function() {
      var _this = this;
      if (self2.state === DESTROYED) {
        emitTopologyDescriptionChanged(self2);
        moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
        return this.destroy();
      }
      if (event === "connect") {
        self2.ismaster = _this.lastIsMaster();
        if (self2.ismaster.msg === "isdbgrid") {
          for (let i = 0; i < self2.connectedProxies.length; i++) {
            if (self2.connectedProxies[i].name === _this.name) {
              moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
              emitTopologyDescriptionChanged(self2);
              _this.destroy();
              return self2.emit("failed", _this);
            }
          }
          for (let i = 0; i < handlers.length; i++) {
            _this.removeAllListeners(handlers[i]);
          }
          _this.on("error", handleEvent(self2, "error"));
          _this.on("close", handleEvent(self2, "close"));
          _this.on("timeout", handleEvent(self2, "timeout"));
          _this.on("parseError", handleEvent(self2, "parseError"));
          moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
          self2.emit("joined", "mongos", _this);
        } else {
          if (self2.s.logger.isWarn()) {
            var message = "expected mongos proxy, but found replicaset member mongod for server %s";
            if (!self2.ismaster.hosts) {
              message = "expected mongos proxy, but found standalone mongod for server %s";
            }
            self2.s.logger.warn(f(message, _this.name));
          }
          _this.destroy(true);
          removeProxyFrom(self2.connectingProxies, _this);
          self2.emit("left", "server", _this);
          self2.emit("failed", _this);
        }
      } else {
        moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
        self2.emit("left", "mongos", this);
        self2.emit("failed", this);
      }
      emitTopologyDescriptionChanged(self2);
      if (self2.connectingProxies.length === 0) {
        if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
          stateTransition(self2, CONNECTED);
          self2.emit("connect", self2);
          self2.emit("fullsetup", self2);
          self2.emit("all", self2);
        } else if (self2.disconnectedProxies.length === 0) {
          if (self2.s.logger.isWarn()) {
            self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
          }
          return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
        }
        topologyMonitor(self2, {firstConnect: true});
      }
    };
  }
  function connectProxies(self2, servers) {
    self2.connectingProxies = self2.connectingProxies.concat(servers);
    var timeoutInterval = 0;
    function connect(server, timeoutInterval2) {
      setTimeout(function() {
        self2.emit("serverOpening", {
          topologyId: self2.id,
          address: server.name
        });
        emitTopologyDescriptionChanged(self2);
        server.once("close", handleInitialConnectEvent(self2, "close"));
        server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
        server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
        server.once("error", handleInitialConnectEvent(self2, "error"));
        server.once("connect", handleInitialConnectEvent(self2, "connect"));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        server.connect(self2.s.connectOptions);
      }, timeoutInterval2);
    }
    servers.forEach((server) => connect(server, timeoutInterval++));
  }
  function pickProxy(self2, session) {
    const transaction = session && session.transaction;
    if (transaction && transaction.server) {
      if (transaction.server.isConnected()) {
        return transaction.server;
      } else {
        transaction.unpinServer();
      }
    }
    var connectedProxies = self2.connectedProxies.slice(0);
    var lowerBoundLatency = Number.MAX_VALUE;
    for (var i = 0; i < connectedProxies.length; i++) {
      if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
        lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
      }
    }
    connectedProxies = connectedProxies.filter(function(server) {
      if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
        return true;
      }
    });
    let proxy;
    if (connectedProxies.length === 0) {
      proxy = self2.connectedProxies[0];
    } else {
      proxy = connectedProxies[self2.index % connectedProxies.length];
      self2.index = (self2.index + 1) % connectedProxies.length;
    }
    if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
      transaction.pinServer(proxy);
    }
    return proxy;
  }
  function moveServerFrom(from, to, proxy) {
    for (var i = 0; i < from.length; i++) {
      if (from[i].name === proxy.name) {
        from.splice(i, 1);
      }
    }
    for (i = 0; i < to.length; i++) {
      if (to[i].name === proxy.name) {
        to.splice(i, 1);
      }
    }
    to.push(proxy);
  }
  function removeProxyFrom(from, proxy) {
    for (var i = 0; i < from.length; i++) {
      if (from[i].name === proxy.name) {
        from.splice(i, 1);
      }
    }
  }
  function reconnectProxies(self2, proxies, callback) {
    var count = proxies.length;
    var _handleEvent = function(self3, event) {
      return function() {
        var _self = this;
        count = count - 1;
        if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
          moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
          return this.destroy();
        }
        if (event === "connect") {
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return _self.destroy();
          }
          for (var i2 = 0; i2 < handlers.length; i2++) {
            _self.removeAllListeners(handlers[i2]);
          }
          _self.on("error", handleEvent(self3, "error"));
          _self.on("close", handleEvent(self3, "close"));
          _self.on("timeout", handleEvent(self3, "timeout"));
          _self.on("parseError", handleEvent(self3, "parseError"));
          moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
          emitTopologyDescriptionChanged(self3);
          self3.emit("joined", "mongos", _self);
        } else {
          moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
          this.destroy();
        }
        if (count === 0) {
          callback();
        }
      };
    };
    if (count === 0) {
      return callback();
    }
    function execute(_server, i2) {
      setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        var server = new Server(Object.assign({}, self2.s.options, {
          host: _server.name.split(":")[0],
          port: parseInt(_server.name.split(":")[1], 10),
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        destroyServer(_server, {force: true});
        removeProxyFrom(self2.disconnectedProxies, _server);
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        self2.emit("serverOpening", {
          topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
          address: server.name
        });
        server.once("connect", _handleEvent(self2, "connect"));
        server.once("close", _handleEvent(self2, "close"));
        server.once("timeout", _handleEvent(self2, "timeout"));
        server.once("error", _handleEvent(self2, "error"));
        server.once("parseError", _handleEvent(self2, "parseError"));
        relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
        self2.connectingProxies.push(server);
        server.connect(self2.s.connectOptions);
      }, i2);
    }
    for (var i = 0; i < proxies.length; i++) {
      execute(proxies[i], i);
    }
  }
  function topologyMonitor(self2, options) {
    options = options || {};
    if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
      return;
    }
    self2.haTimeoutId = setTimeout(function() {
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      if (self2.isConnected() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      }
      var proxies = self2.connectedProxies.slice(0);
      var count = proxies.length;
      function pingServer(_self, _server, cb) {
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", {connectionId: _server.name});
        _server.command("admin.$cmd", {
          ismaster: true
        }, {
          monitoring: true,
          socketTimeout: self2.s.options.connectionTimeout || 2e3
        }, function(err, r) {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            _server.destroy();
            return cb(err, r);
          }
          var latencyMS = new Date().getTime() - start;
          if (err) {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: _server.name
            });
            moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
          } else {
            _server.ismaster = r.result;
            _server.lastIsMasterMS = latencyMS;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: _server.name
            });
          }
          cb(err, r);
        });
      }
      if (proxies.length === 0) {
        if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
          self2.emit("error", new MongoError("no mongos proxy available"));
        } else {
          self2.emit("close", self2);
        }
        return reconnectProxies(self2, self2.disconnectedProxies, function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          if (self2.state === CONNECTING && options.firstConnect) {
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.isConnected()) {
            self2.emit("reconnect", self2);
          } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
            self2.emit("close", self2);
          }
          topologyMonitor(self2);
        });
      }
      for (var i = 0; i < proxies.length; i++) {
        pingServer(self2, proxies[i], function() {
          count = count - 1;
          if (count === 0) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            reconnectProxies(self2, self2.disconnectedProxies, function() {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              topologyMonitor(self2);
            });
          }
        });
      }
    }, self2.s.haInterval);
  }
  Mongos.prototype.lastIsMaster = function() {
    return this.ismaster;
  };
  Mongos.prototype.unref = function() {
    stateTransition(this, UNREFERENCED);
    var proxies = this.connectedProxies.concat(this.connectingProxies);
    proxies.forEach(function(x) {
      x.unref();
    });
    clearTimeout(this.haTimeoutId);
  };
  Mongos.prototype.destroy = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    stateTransition(this, DESTROYING);
    if (this.haTimeoutId) {
      clearTimeout(this.haTimeoutId);
    }
    const proxies = this.connectedProxies.concat(this.connectingProxies);
    let serverCount = proxies.length;
    const serverDestroyed = () => {
      serverCount--;
      if (serverCount > 0) {
        return;
      }
      emitTopologyDescriptionChanged(this);
      emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
      stateTransition(this, DESTROYED);
      if (typeof callback === "function") {
        callback(null, null);
      }
    };
    if (serverCount === 0) {
      serverDestroyed();
      return;
    }
    proxies.forEach((server) => {
      this.emit("serverClosed", {
        topologyId: this.id,
        address: server.name
      });
      destroyServer(server, options, serverDestroyed);
      moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
    });
  };
  Mongos.prototype.isConnected = function() {
    return this.connectedProxies.length > 0;
  };
  Mongos.prototype.isDestroyed = function() {
    return this.state === DESTROYED;
  };
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const self2 = args.self;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    let server = pickProxy(self2, options.session);
    if (!server)
      return callback(new MongoError("no mongos proxy available"));
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction();
    const handler = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
        err = getMMAPError(err);
        return callback(err);
      }
      server = pickProxy(self2, options.session);
      if (!server) {
        return callback(err);
      }
      const newArgs = Object.assign({}, args, {retrying: true});
      return executeWriteOperation(newArgs, options, callback);
    };
    if (callback.operationId) {
      handler.operationId = callback.operationId;
    }
    if (willRetryWrite) {
      options.session.incrementTransactionNumber();
      options.willRetryWrite = willRetryWrite;
    }
    server[op](ns, ops, options, handler);
  }
  Mongos.prototype.insert = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("insert", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "insert", ns, ops}, options, callback);
  };
  Mongos.prototype.update = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("update", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "update", ns, ops}, options, callback);
  };
  Mongos.prototype.remove = function(ns, ops, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    if (!this.isConnected() && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("remove", ns, ops, options, callback);
    }
    if (!this.isConnected()) {
      return callback(new MongoError("no mongos proxy available"));
    }
    executeWriteOperation({self: this, op: "remove", ns, ops}, options, callback);
  };
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  Mongos.prototype.command = function(ns, cmd, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {}, options = options || {};
    }
    if (this.state === DESTROYED) {
      return callback(new MongoError(f("topology was destroyed")));
    }
    var self2 = this;
    var server = pickProxy(self2, options.session);
    if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
      return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
    }
    if (server == null) {
      return callback(new MongoError("no mongos proxy available"));
    }
    var clonedOptions = cloneOptions(options);
    clonedOptions.topology = self2;
    const willRetryWrite = !options.retrying && options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
    const cb = (err, result) => {
      if (!err)
        return callback(null, result);
      if (!legacyIsRetryableWriteError(err, self2)) {
        return callback(err);
      }
      if (willRetryWrite) {
        const newOptions = Object.assign({}, clonedOptions, {retrying: true});
        return this.command(ns, cmd, newOptions, callback);
      }
      return callback(err);
    };
    if (willRetryWrite) {
      clonedOptions.session.incrementTransactionNumber();
      clonedOptions.willRetryWrite = willRetryWrite;
    }
    server.command(ns, cmd, clonedOptions, cb);
  };
  Mongos.prototype.cursor = function(ns, cmd, options) {
    options = options || {};
    const topology = options.topology || this;
    var FinalCursor = options.cursorFactory || this.s.Cursor;
    return new FinalCursor(topology, ns, cmd, options);
  };
  Mongos.prototype.selectServer = function(selector, options, callback) {
    if (typeof selector === "function" && typeof callback === "undefined")
      callback = selector, selector = void 0, options = {};
    if (typeof options === "function")
      callback = options, options = selector, selector = void 0;
    options = options || {};
    const server = pickProxy(this, options.session);
    if (server == null) {
      callback(new MongoError("server selection failed"));
      return;
    }
    if (this.s.debug)
      this.emit("pickedServer", null, server);
    callback(null, server);
  };
  Mongos.prototype.connections = function() {
    var connections = [];
    for (var i = 0; i < this.connectedProxies.length; i++) {
      connections = connections.concat(this.connectedProxies[i].connections());
    }
    return connections;
  };
  function emitTopologyDescriptionChanged(self2) {
    if (self2.listeners("topologyDescriptionChanged").length > 0) {
      var topology = "Unknown";
      if (self2.connectedProxies.length > 0) {
        topology = "Sharded";
      }
      var description = {
        topologyType: topology,
        servers: []
      };
      var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
      description.servers = description.servers.concat(proxies.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "Unknown";
        return description2;
      }));
      description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
        var description2 = x.getDescription();
        description2.type = "Mongos";
        return description2;
      }));
      var diffResult = diff(self2.topologyDescription, description);
      var result = {
        topologyId: self2.id,
        previousDescription: self2.topologyDescription,
        newDescription: description,
        diff: diffResult
      };
      if (diffResult.servers.length > 0) {
        self2.emit("topologyDescriptionChanged", result);
      }
      self2.topologyDescription = description;
    }
  }
  module2.exports = Mongos;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports2, module2) => {
  "use strict";
  function Denque(array, options) {
    var options = options || {};
    this._head = 0;
    this._tail = 0;
    this._capacity = options.capacity;
    this._capacityMask = 3;
    this._list = new Array(4);
    if (Array.isArray(array)) {
      this._fromArray(array);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return void 0;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return void 0;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (item === void 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return void 0;
    var item = this._list[head];
    this._list[head] = void 0;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (item === void 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return void 0;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = void 0;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return void 0;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index; k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index; k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return void 0;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0; k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index; k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index); k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return void 0;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0; k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i; k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0; k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0; k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    for (var i = 0; i < array.length; i++)
      this.push(array[i]);
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy) {
    var newArray = [];
    var list = this._list;
    var len = list.length;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head; i < len; i++)
        newArray.push(list[i]);
      for (i = 0; i < this._tail; i++)
        newArray.push(list[i]);
    } else {
      for (i = this._head; i < this._tail; i++)
        newArray.push(list[i]);
    }
    return newArray;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head) {
      this._list = this._copyArray(true);
      this._head = 0;
    }
    this._tail = this._list.length;
    this._list.length *= 2;
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  module2.exports = Denque;
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS((exports2, module2) => {
  "use strict";
  var ServerDescriptionChangedEvent = class {
    constructor(topologyId, address, previousDescription, newDescription) {
      Object.assign(this, {topologyId, address, previousDescription, newDescription});
    }
  };
  var ServerOpeningEvent = class {
    constructor(topologyId, address) {
      Object.assign(this, {topologyId, address});
    }
  };
  var ServerClosedEvent = class {
    constructor(topologyId, address) {
      Object.assign(this, {topologyId, address});
    }
  };
  var TopologyDescriptionChangedEvent = class {
    constructor(topologyId, previousDescription, newDescription) {
      Object.assign(this, {topologyId, previousDescription, newDescription});
    }
  };
  var TopologyOpeningEvent = class {
    constructor(topologyId) {
      Object.assign(this, {topologyId});
    }
  };
  var TopologyClosedEvent = class {
    constructor(topologyId) {
      Object.assign(this, {topologyId});
    }
  };
  var ServerHeartbeatStartedEvent = class {
    constructor(connectionId) {
      Object.assign(this, {connectionId});
    }
  };
  var ServerHeartbeatSucceededEvent = class {
    constructor(duration, reply, connectionId) {
      Object.assign(this, {connectionId, duration, reply});
    }
  };
  var ServerHeartbeatFailedEvent = class {
    constructor(duration, failure, connectionId) {
      Object.assign(this, {connectionId, duration, failure});
    }
  };
  module2.exports = {
    ServerDescriptionChangedEvent,
    ServerOpeningEvent,
    ServerClosedEvent,
    TopologyDescriptionChangedEvent,
    TopologyOpeningEvent,
    TopologyClosedEvent,
    ServerHeartbeatStartedEvent,
    ServerHeartbeatSucceededEvent,
    ServerHeartbeatFailedEvent
  };
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util = require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module2.exports = util.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer2().Buffer;
  var util = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module2.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node3 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = require_stream();
  var Buffer2 = require_safe_buffer2().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream();
  var Buffer2 = require_safe_buffer2().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = require("util");
  var debug3 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug3 = debugUtil.debuglog("stream");
  } else {
    debug3 = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug3("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug3("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug3("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug3("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug3("reading or ended", doRead);
    } else if (doRead) {
      debug3("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug3("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug3("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug3("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug3("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug3("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug3("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug3("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug3("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug3("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug3("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug3("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug3("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug3("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug3("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug3("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug3("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug3("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug3("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug3("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug3("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug3("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug3("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug3("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var Duplex = require_stream_duplex();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS((exports2, module2) => {
  "use strict";
  var DuplexStream = require_readable().Duplex;
  var util = require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  function BufferList(callback) {
    if (!(this instanceof BufferList))
      return new BufferList(callback);
    this._bufs = [];
    this.length = 0;
    if (typeof callback == "function") {
      this._callback = callback;
      var piper = function piper2(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
    } else {
      this.append(callback);
    }
    DuplexStream.call(this);
  }
  util.inherits(BufferList, DuplexStream);
  BufferList.prototype._offset = function _offset(offset) {
    var tot = 0, i = 0, _t;
    if (offset === 0)
      return [0, 0];
    for (; i < this._bufs.length; i++) {
      _t = tot + this._bufs[i].length;
      if (offset < _t || i == this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    var bufferId = blOffset[0];
    var offset = blOffset[1];
    for (var i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.append = function append(buf) {
    var i = 0;
    if (Buffer2.isBuffer(buf)) {
      this._appendBuffer(buf);
    } else if (Array.isArray(buf)) {
      for (; i < buf.length; i++)
        this.append(buf[i]);
    } else if (buf instanceof BufferList) {
      for (; i < buf._bufs.length; i++)
        this.append(buf._bufs[i]);
    } else if (buf != null) {
      if (typeof buf == "number")
        buf = buf.toString();
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback == "function")
      callback();
  };
  BufferList.prototype._read = function _read(size) {
    if (!this.length)
      return this.push(null);
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferList.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return void 0;
    }
    var offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start == "number" && start < 0)
      start += this.length;
    if (typeof end == "number" && end < 0)
      end += this.length;
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart != "number" || srcStart < 0)
      srcStart = 0;
    if (typeof srcEnd != "number" || srcEnd > this.length)
      srcEnd = this.length;
    if (srcStart >= this.length)
      return dst || Buffer2.alloc(0);
    if (srcEnd <= 0)
      return dst || Buffer2.alloc(0);
    var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
    if (srcStart === 0 && srcEnd == this.length) {
      if (!copy2) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy2)
      dst = Buffer2.allocUnsafe(len);
    for (i = off[0]; i < this._bufs.length; i++) {
      l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start)
        start = 0;
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0)
      start += this.length;
    if (end < 0)
      end += this.length;
    if (start === end) {
      return new BufferList();
    }
    var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] == 0)
      buffers.pop();
    else
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    if (startOffset[1] != 0)
      buffers[0] = buffers[0].slice(startOffset[1]);
    return new BufferList(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    var i = 0, copy = new BufferList();
    for (; i < this._bufs.length; i++)
      copy.append(this._bufs[i]);
    return copy;
  };
  BufferList.prototype.destroy = function destroy() {
    this._bufs.length = 0;
    this.length = 0;
    this.push(null);
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (search instanceof BufferList) {
      search = search.slice();
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    var blOffset = this._offset(offset);
    var blIndex = blOffset[0];
    var buffOffset = blOffset[1];
    for (blIndex; blIndex < this._bufs.length; blIndex++) {
      var buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        var availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          var nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          var revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    var methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (var m in methods) {
      (function(m2) {
        if (methods[m2] === null) {
          BufferList.prototype[m2] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m2](0, byteLength);
          };
        } else {
          BufferList.prototype[m2] = function(offset) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        }
      })(m);
    }
  })();
  module2.exports = BufferList;
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Duplex = require("stream").Duplex;
  var BufferList = require_bl();
  var MongoParseError = require_error().MongoParseError;
  var decompress = require_compression().decompress;
  var Response = require_commands().Response;
  var BinMsg = require_msg().BinMsg;
  var MongoError = require_error().MongoError;
  var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
  var OP_MSG = require_shared().opcodes.OP_MSG;
  var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
  var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
  var opcodes = require_shared().opcodes;
  var compress = require_compression().compress;
  var compressorIDs = require_compression().compressorIDs;
  var uncompressibleCommands = require_compression().uncompressibleCommands;
  var Msg = require_msg().Msg;
  var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
  var kBuffer = Symbol("buffer");
  var MessageStream = class extends Duplex {
    constructor(options) {
      options = options || {};
      super(options);
      this.bson = options.bson;
      this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
      this[kBuffer] = new BufferList();
    }
    _write(chunk, _, callback) {
      const buffer = this[kBuffer];
      buffer.append(chunk);
      processIncomingData(this, callback);
    }
    _read() {
      return;
    }
    writeCommand(command, operationDescription) {
      const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        const data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      }
      const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress({options: operationDescription}, messageToBeCompressed, (err, compressedMessage) => {
        if (err) {
          operationDescription.cb(err, null);
          return;
        }
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      });
    }
  };
  function canCompress(command) {
    const commandDoc = command instanceof Msg ? command.command : command.query;
    const commandName = Object.keys(commandDoc)[0];
    return !uncompressibleCommands.has(commandName);
  }
  function processIncomingData(stream, callback) {
    const buffer = stream[kBuffer];
    if (buffer.length < 4) {
      callback();
      return;
    }
    const sizeOfMessage = buffer.readInt32LE(0);
    if (sizeOfMessage < 0) {
      callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
      return;
    }
    if (sizeOfMessage > stream.maxBsonMessageSize) {
      callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
      return;
    }
    if (sizeOfMessage > buffer.length) {
      callback();
      return;
    }
    const message = buffer.slice(0, sizeOfMessage);
    buffer.consume(sizeOfMessage);
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
    const responseOptions = stream.responseOptions;
    if (messageHeader.opCode !== OP_COMPRESSED) {
      const messageBody = message.slice(MESSAGE_HEADER_SIZE);
      stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
      return;
    }
    messageHeader.fromCompressed = true;
    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
    decompress(compressorID, compressedBuffer, (err, messageBody) => {
      if (err) {
        callback(err);
        return;
      }
      if (messageBody.length !== messageHeader.length) {
        callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
        return;
      }
      stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
      if (buffer.length >= 4) {
        processIncomingData(stream, callback);
      } else {
        callback();
      }
    });
  }
  module2.exports = MessageStream;
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports2, module2) => {
  "use strict";
  var parseServerType = require_server_description().parseServerType;
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "__nodejs_mock_server__"
  ];
  var StreamDescription = class {
    constructor(address, options) {
      this.address = address;
      this.type = parseServerType(null);
      this.minWireVersion = void 0;
      this.maxWireVersion = void 0;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48e6;
      this.maxWriteBatchSize = 1e5;
      this.compressors = options && options.compression && Array.isArray(options.compression.compressors) ? options.compression.compressors : [];
    }
    receiveResponse(response) {
      this.type = parseServerType(response);
      RESPONSE_FIELDS.forEach((field) => {
        if (typeof response[field] !== "undefined") {
          this[field] = response[field];
        }
      });
      if (response.compression) {
        this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
      }
    }
  };
  module2.exports = {
    StreamDescription
  };
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events");
  var MessageStream = require_message_stream();
  var MongoError = require_error().MongoError;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var MongoWriteConcernError = require_error().MongoWriteConcernError;
  var CommandResult = require_command_result();
  var StreamDescription = require_stream_description().StreamDescription;
  var wp = require_wireprotocol();
  var apm = require_apm();
  var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
  var uuidV4 = require_utils2().uuidV4;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var kStream = Symbol("stream");
  var kQueue = Symbol("queue");
  var kMessageStream = Symbol("messageStream");
  var kGeneration = Symbol("generation");
  var kLastUseTime = Symbol("lastUseTime");
  var kClusterTime = Symbol("clusterTime");
  var kDescription = Symbol("description");
  var kIsMaster = Symbol("ismaster");
  var kAutoEncrypter = Symbol("autoEncrypter");
  var Connection = class extends EventEmitter2 {
    constructor(stream, options) {
      super(options);
      this.id = options.id;
      this.address = streamIdentifier(stream);
      this.bson = options.bson;
      this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      this.host = options.host || "localhost";
      this.port = options.port || 27017;
      this.monitorCommands = typeof options.monitorCommands === "boolean" ? options.monitorCommands : false;
      this.closed = false;
      this.destroyed = false;
      this[kDescription] = new StreamDescription(this.address, options);
      this[kGeneration] = options.generation;
      this[kLastUseTime] = now();
      if (options.autoEncrypter) {
        this[kAutoEncrypter] = options.autoEncrypter;
      }
      this[kQueue] = new Map();
      this[kMessageStream] = new MessageStream(options);
      this[kMessageStream].on("message", messageHandler(this));
      this[kStream] = stream;
      stream.on("error", () => {
      });
      stream.on("close", () => {
        if (this.closed) {
          return;
        }
        this.closed = true;
        this[kQueue].forEach((op) => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`)));
        this[kQueue].clear();
        this.emit("close");
      });
      stream.on("timeout", () => {
        if (this.closed) {
          return;
        }
        stream.destroy();
        this.closed = true;
        this[kQueue].forEach((op) => op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
          beforeHandshake: this[kIsMaster] == null
        })));
        this[kQueue].clear();
        this.emit("close");
      });
      stream.pipe(this[kMessageStream]);
      this[kMessageStream].pipe(stream);
    }
    get description() {
      return this[kDescription];
    }
    get ismaster() {
      return this[kIsMaster];
    }
    set ismaster(response) {
      this[kDescription].receiveResponse(response);
      this[kIsMaster] = response;
    }
    get generation() {
      return this[kGeneration] || 0;
    }
    get idleTime() {
      return calculateDurationInMs(this[kLastUseTime]);
    }
    get clusterTime() {
      return this[kClusterTime];
    }
    get stream() {
      return this[kStream];
    }
    markAvailable() {
      this[kLastUseTime] = now();
    }
    destroy(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = Object.assign({force: false}, options);
      if (this[kStream] == null || this.destroyed) {
        this.destroyed = true;
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      if (options.force) {
        this[kStream].destroy();
        this.destroyed = true;
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      this[kStream].end((err) => {
        this.destroyed = true;
        if (typeof callback === "function") {
          callback(err);
        }
      });
    }
    command(ns, cmd, options, callback) {
      wp.command(makeServerTrampoline(this), ns, cmd, options, callback);
    }
    query(ns, cmd, cursorState, options, callback) {
      wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);
    }
    getMore(ns, cursorState, batchSize, options, callback) {
      wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);
    }
    killCursors(ns, cursorState, callback) {
      wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
    }
    insert(ns, ops, options, callback) {
      wp.insert(makeServerTrampoline(this), ns, ops, options, callback);
    }
    update(ns, ops, options, callback) {
      wp.update(makeServerTrampoline(this), ns, ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      wp.remove(makeServerTrampoline(this), ns, ops, options, callback);
    }
  };
  function makeServerTrampoline(connection) {
    const server = {
      description: connection.description,
      clusterTime: connection[kClusterTime],
      s: {
        bson: connection.bson,
        pool: {write: write.bind(connection), isConnected: () => true}
      }
    };
    if (connection[kAutoEncrypter]) {
      server.autoEncrypter = connection[kAutoEncrypter];
    }
    return server;
  }
  function messageHandler(conn) {
    return function messageHandler2(message) {
      conn.emit("message", message);
      if (!conn[kQueue].has(message.responseTo)) {
        return;
      }
      const operationDescription = conn[kQueue].get(message.responseTo);
      const callback = operationDescription.cb;
      conn[kQueue].delete(message.responseTo);
      if (message.moreToCome) {
        conn[kQueue].set(message.requestId, operationDescription);
      } else if (operationDescription.socketTimeoutOverride) {
        conn[kStream].setTimeout(conn.socketTimeout);
      }
      try {
        message.parse(operationDescription);
      } catch (err) {
        callback(new MongoError(err));
        return;
      }
      if (message.documents[0]) {
        const document2 = message.documents[0];
        const session = operationDescription.session;
        if (session) {
          updateSessionFromResponse(session, document2);
        }
        if (document2.$clusterTime) {
          conn[kClusterTime] = document2.$clusterTime;
          conn.emit("clusterTimeReceived", document2.$clusterTime);
        }
        if (operationDescription.command) {
          if (document2.writeConcernError) {
            callback(new MongoWriteConcernError(document2.writeConcernError, document2));
            return;
          }
          if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
            callback(new MongoError(document2));
            return;
          }
        }
      }
      callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
    };
  }
  function streamIdentifier(stream) {
    if (typeof stream.address === "function") {
      return `${stream.remoteAddress}:${stream.remotePort}`;
    }
    return uuidV4().toString("hex");
  }
  function write(command, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    options = options || {};
    const operationDescription = {
      requestId: command.requestId,
      cb: callback,
      session: options.session,
      fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false,
      noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
      documentsReturnedIn: options.documentsReturnedIn,
      command: !!options.command,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      raw: typeof options.raw === "boolean" ? options.raw : false
    };
    if (this[kDescription] && this[kDescription].compressor) {
      operationDescription.agreedCompressor = this[kDescription].compressor;
      if (this[kDescription].zlibCompressionLevel) {
        operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
      }
    }
    if (typeof options.socketTimeout === "number") {
      operationDescription.socketTimeoutOverride = true;
      this[kStream].setTimeout(options.socketTimeout);
    }
    if (this.monitorCommands) {
      this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
      operationDescription.started = now();
      operationDescription.cb = (err, reply) => {
        if (err) {
          this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
        } else {
          if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
          } else {
            this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
          }
        }
        if (typeof callback === "function") {
          callback(err, reply);
        }
      };
    }
    if (!operationDescription.noResponse) {
      this[kQueue].set(operationDescription.requestId, operationDescription);
    }
    try {
      this[kMessageStream].writeCommand(command, operationDescription);
    } catch (e) {
      if (!operationDescription.noResponse) {
        this[kQueue].delete(operationDescription.requestId);
        operationDescription.cb(e);
        return;
      }
    }
    if (operationDescription.noResponse) {
      operationDescription.cb();
    }
  }
  module2.exports = {
    Connection
  };
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_error().MongoError;
  var PoolClosedError = class extends MongoError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.name = "MongoPoolClosedError";
      this.address = pool.address;
    }
  };
  var WaitQueueTimeoutError = class extends MongoError {
    constructor(pool) {
      super("Timed out while checking out a connection from connection pool");
      this.name = "MongoWaitQueueTimeoutError";
      this.address = pool.address;
    }
  };
  module2.exports = {
    PoolClosedError,
    WaitQueueTimeoutError
  };
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS((exports2, module2) => {
  "use strict";
  var ConnectionPoolMonitoringEvent = class {
    constructor(pool) {
      this.time = new Date();
      this.address = pool.address;
    }
  };
  var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.options = pool.options;
    }
  };
  var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason) {
      super(pool);
      this.connectionId = connection.id;
      this.reason = reason || "unknown";
    }
  };
  var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason) {
      super(pool);
      this.reason = reason;
    }
  };
  var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.connectionId = connection.id;
    }
  };
  var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
    }
  };
  var CMAP_EVENT_NAMES = [
    "connectionPoolCreated",
    "connectionPoolClosed",
    "connectionCreated",
    "connectionReady",
    "connectionClosed",
    "connectionCheckOutStarted",
    "connectionCheckOutFailed",
    "connectionCheckedOut",
    "connectionCheckedIn",
    "connectionPoolCleared"
  ];
  module2.exports = {
    CMAP_EVENT_NAMES,
    ConnectionPoolCreatedEvent,
    ConnectionPoolClosedEvent,
    ConnectionCreatedEvent,
    ConnectionReadyEvent,
    ConnectionClosedEvent,
    ConnectionCheckOutStartedEvent,
    ConnectionCheckOutFailedEvent,
    ConnectionCheckedOutEvent,
    ConnectionCheckedInEvent,
    ConnectionPoolClearedEvent
  };
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter2 = require("events").EventEmitter;
  var Logger = require_logger();
  var makeCounter = require_utils4().makeCounter;
  var MongoError = require_error().MongoError;
  var Connection = require_connection2().Connection;
  var eachAsync = require_utils2().eachAsync;
  var connect = require_connect();
  var relayEvents = require_utils2().relayEvents;
  var errors = require_errors();
  var PoolClosedError = errors.PoolClosedError;
  var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
  var events = require_events2();
  var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
  var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
  var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
  var ConnectionReadyEvent = events.ConnectionReadyEvent;
  var ConnectionClosedEvent = events.ConnectionClosedEvent;
  var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
  var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
  var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
  var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
  var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
  var kLogger = Symbol("logger");
  var kConnections = Symbol("connections");
  var kPermits = Symbol("permits");
  var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
  var kGeneration = Symbol("generation");
  var kConnectionCounter = Symbol("connectionCounter");
  var kCancellationToken = Symbol("cancellationToken");
  var kWaitQueue = Symbol("waitQueue");
  var kCancelled = Symbol("cancelled");
  var VALID_POOL_OPTIONS = new Set([
    "ssl",
    "bson",
    "connectionType",
    "monitorCommands",
    "socketTimeout",
    "credentials",
    "compression",
    "host",
    "port",
    "localAddress",
    "localPort",
    "family",
    "hints",
    "lookup",
    "path",
    "ca",
    "cert",
    "sigalgs",
    "ciphers",
    "clientCertEngine",
    "crl",
    "dhparam",
    "ecdhCurve",
    "honorCipherOrder",
    "key",
    "privateKeyEngine",
    "privateKeyIdentifier",
    "maxVersion",
    "minVersion",
    "passphrase",
    "pfx",
    "secureOptions",
    "secureProtocol",
    "sessionIdContext",
    "allowHalfOpen",
    "rejectUnauthorized",
    "pskCallback",
    "ALPNProtocols",
    "servername",
    "checkServerIdentity",
    "session",
    "minDHSize",
    "secureContext",
    "maxPoolSize",
    "minPoolSize",
    "maxIdleTimeMS",
    "waitQueueTimeoutMS"
  ]);
  function resolveOptions(options, defaults) {
    const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
      if (Object.prototype.hasOwnProperty.call(options, key)) {
        obj[key] = options[key];
      }
      return obj;
    }, {});
    return Object.freeze(Object.assign({}, defaults, newOptions));
  }
  var ConnectionPool = class extends EventEmitter2 {
    constructor(options) {
      super();
      options = options || {};
      this.closed = false;
      this.options = resolveOptions(options, {
        connectionType: Connection,
        maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : 100,
        minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : 0,
        maxIdleTimeMS: typeof options.maxIdleTimeMS === "number" ? options.maxIdleTimeMS : 0,
        waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === "number" ? options.waitQueueTimeoutMS : 0,
        autoEncrypter: options.autoEncrypter,
        metadata: options.metadata
      });
      if (options.minSize > options.maxSize) {
        throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
      }
      this[kLogger] = Logger("ConnectionPool", options);
      this[kConnections] = new Denque();
      this[kPermits] = this.options.maxPoolSize;
      this[kMinPoolSizeTimer] = void 0;
      this[kGeneration] = 0;
      this[kConnectionCounter] = makeCounter(1);
      this[kCancellationToken] = new EventEmitter2();
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kWaitQueue] = new Denque();
      process.nextTick(() => {
        this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
        ensureMinPoolSize(this);
      });
    }
    get address() {
      return `${this.options.host}:${this.options.port}`;
    }
    get generation() {
      return this[kGeneration];
    }
    get totalConnectionCount() {
      return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
    }
    get availableConnectionCount() {
      return this[kConnections].length;
    }
    get waitQueueSize() {
      return this[kWaitQueue].length;
    }
    checkOut(callback) {
      this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
      if (this.closed) {
        this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
        callback(new PoolClosedError(this));
        return;
      }
      const waitQueueMember = {callback};
      const pool = this;
      const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = setTimeout(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = void 0;
          pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
          waitQueueMember.callback(new WaitQueueTimeoutError(pool));
        }, waitQueueTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(() => processWaitQueue(this));
    }
    checkIn(connection) {
      const poolClosed = this.closed;
      const stale = connectionIsStale(this, connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].push(connection);
      }
      this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        destroyConnection(this, connection, reason);
      }
      process.nextTick(() => processWaitQueue(this));
    }
    clear() {
      this[kGeneration] += 1;
      this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
    }
    close(options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      options = Object.assign({force: false}, options);
      if (this.closed) {
        return callback();
      }
      this[kCancellationToken].emit("cancel");
      while (this.waitQueueSize) {
        const waitQueueMember = this[kWaitQueue].pop();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(new MongoError("connection pool closed"));
        }
      }
      if (this[kMinPoolSizeTimer]) {
        clearTimeout(this[kMinPoolSizeTimer]);
      }
      if (typeof this[kConnectionCounter].return === "function") {
        this[kConnectionCounter].return();
      }
      this.closed = true;
      eachAsync(this[kConnections].toArray(), (conn, cb) => {
        this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy(options, cb);
      }, (err) => {
        this[kConnections].clear();
        this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
        callback(err);
      });
    }
    withConnection(fn, callback) {
      this.checkOut((err, conn) => {
        fn(err, conn, (fnErr, result) => {
          if (typeof callback === "function") {
            if (fnErr) {
              callback(fnErr);
            } else {
              callback(void 0, result);
            }
          }
          if (conn) {
            this.checkIn(conn);
          }
        });
      });
    }
  };
  function ensureMinPoolSize(pool) {
    if (pool.closed || pool.options.minPoolSize === 0) {
      return;
    }
    const minPoolSize = pool.options.minPoolSize;
    for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
      createConnection(pool);
    }
    pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
  }
  function connectionIsStale(pool, connection) {
    return connection.generation !== pool[kGeneration];
  }
  function connectionIsIdle(pool, connection) {
    return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
  }
  function createConnection(pool, callback) {
    const connectOptions = Object.assign({
      id: pool[kConnectionCounter].next().value,
      generation: pool[kGeneration]
    }, pool.options);
    pool[kPermits]--;
    connect(connectOptions, pool[kCancellationToken], (err, connection) => {
      if (err) {
        pool[kPermits]++;
        pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
        if (typeof callback === "function") {
          callback(err);
        }
        return;
      }
      if (pool.closed) {
        connection.destroy({force: true});
        return;
      }
      relayEvents(connection, pool, [
        "commandStarted",
        "commandFailed",
        "commandSucceeded",
        "clusterTimeReceived"
      ]);
      pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
      connection.markAvailable();
      pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
      if (typeof callback === "function") {
        callback(void 0, connection);
        return;
      }
      pool[kConnections].push(connection);
      process.nextTick(() => processWaitQueue(pool));
    });
  }
  function destroyConnection(pool, connection, reason) {
    pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
    pool[kPermits]++;
    process.nextTick(() => connection.destroy());
  }
  function processWaitQueue(pool) {
    if (pool.closed) {
      return;
    }
    while (pool.waitQueueSize) {
      const waitQueueMember = pool[kWaitQueue].peekFront();
      if (waitQueueMember[kCancelled]) {
        pool[kWaitQueue].shift();
        continue;
      }
      if (!pool.availableConnectionCount) {
        break;
      }
      const connection = pool[kConnections].shift();
      const isStale = connectionIsStale(pool, connection);
      const isIdle = connectionIsIdle(pool, connection);
      if (!isStale && !isIdle && !connection.closed) {
        pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
        clearTimeout(waitQueueMember.timer);
        pool[kWaitQueue].shift();
        waitQueueMember.callback(void 0, connection);
        return;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      destroyConnection(pool, connection, reason);
    }
    const maxPoolSize = pool.options.maxPoolSize;
    if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
      createConnection(pool, (err, connection) => {
        const waitQueueMember = pool[kWaitQueue].shift();
        if (waitQueueMember == null || waitQueueMember[kCancelled]) {
          if (err == null) {
            pool[kConnections].push(connection);
          }
          return;
        }
        if (err) {
          pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
        } else {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(err, connection);
      });
      return;
    }
  }
  module2.exports = {
    ConnectionPool
  };
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var EventEmitter2 = require("events");
  var connect = require_connect();
  var Connection = require_connection2().Connection;
  var common = require_common2();
  var makeStateMachine = require_utils2().makeStateMachine;
  var MongoNetworkError = require_error().MongoNetworkError;
  var BSON2 = require_utils3().retrieveBSON();
  var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var now = require_utils4().now;
  var sdamEvents = require_events();
  var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
  var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
  var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
  var kServer = Symbol("server");
  var kMonitorId = Symbol("monitorId");
  var kConnection = Symbol("connection");
  var kCancellationToken = Symbol("cancellationToken");
  var kRTTPinger = Symbol("rttPinger");
  var kRoundTripTime = Symbol("roundTripTime");
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = makeStateMachine({
    [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
    [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
  function isInCloseState(monitor) {
    return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
  }
  var Monitor = class extends EventEmitter2 {
    constructor(server, options) {
      super(options);
      this[kServer] = server;
      this[kConnection] = void 0;
      this[kCancellationToken] = new EventEmitter2();
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kMonitorId] = null;
      this.s = {
        state: STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 1e4,
        heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === "number" ? options.heartbeatFrequencyMS : 1e4,
        minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === "number" ? options.minHeartbeatFrequencyMS : 500
      });
      const connectOptions = Object.assign({
        id: "<monitor>",
        host: server.description.host,
        port: server.description.port,
        bson: server.s.bson,
        connectionType: Connection
      }, server.s.options, this.options, {
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      });
      delete connectOptions.credentials;
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this[kMonitorId].wake();
    }
    reset() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, STATE_CLOSED);
    }
  };
  function resetMonitorState(monitor) {
    stateTransition(monitor, STATE_CLOSING);
    if (monitor[kMonitorId]) {
      monitor[kMonitorId].stop();
      monitor[kMonitorId] = null;
    }
    if (monitor[kRTTPinger]) {
      monitor[kRTTPinger].close();
      monitor[kRTTPinger] = void 0;
    }
    monitor[kCancellationToken].emit("cancel");
    if (monitor[kMonitorId]) {
      clearTimeout(monitor[kMonitorId]);
      monitor[kMonitorId] = void 0;
    }
    if (monitor[kConnection]) {
      monitor[kConnection].destroy({force: true});
    }
  }
  function checkServer(monitor, callback) {
    let start = now();
    monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
    function failureHandler(err) {
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({force: true});
        monitor[kConnection] = void 0;
      }
      monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
      monitor.emit("resetServer", err);
      monitor.emit("resetConnectionPool");
      callback(err);
    }
    if (monitor[kConnection] != null && !monitor[kConnection].closed) {
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const topologyVersion = monitor[kServer].description.topologyVersion;
      const isAwaitable = topologyVersion != null;
      const cmd = isAwaitable ? {ismaster: true, maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion)} : {ismaster: true};
      const options = isAwaitable ? {socketTimeout: connectTimeoutMS + maxAwaitTimeMS, exhaustAllowed: true} : {socketTimeout: connectTimeoutMS};
      if (isAwaitable && monitor[kRTTPinger] == null) {
        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
      }
      monitor[kConnection].command("admin.$cmd", cmd, options, (err, result) => {
        if (err) {
          failureHandler(err);
          return;
        }
        const isMaster = result.result;
        const duration = isAwaitable ? monitor[kRTTPinger].roundTripTime : calculateDurationInMs(start);
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
        if (isAwaitable && isMaster.topologyVersion) {
          monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
          start = now();
        } else {
          if (monitor[kRTTPinger]) {
            monitor[kRTTPinger].close();
            monitor[kRTTPinger] = void 0;
          }
          callback(void 0, isMaster);
        }
      });
      return;
    }
    connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
      if (conn && isInCloseState(monitor)) {
        conn.destroy({force: true});
        return;
      }
      if (err) {
        monitor[kConnection] = void 0;
        if (!(err instanceof MongoNetworkError)) {
          monitor.emit("resetConnectionPool");
        }
        failureHandler(err);
        return;
      }
      monitor[kConnection] = conn;
      monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
      callback(void 0, conn.ismaster);
    });
  }
  function monitorServer(monitor) {
    return (callback) => {
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback();
      }
      process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
      checkServer(monitor, (err, isMaster) => {
        if (err) {
          if (monitor[kServer].description.type === ServerType.Unknown) {
            monitor.emit("resetServer", err);
            return done();
          }
        }
        if (isMaster && isMaster.topologyVersion) {
          setTimeout(() => {
            if (!isInCloseState(monitor)) {
              monitor[kMonitorId].wake();
            }
          });
        }
        done();
      });
    };
  }
  function makeTopologyVersion(tv) {
    return {
      processId: tv.processId,
      counter: BSON2.Long.fromNumber(tv.counter)
    };
  }
  var RTTPinger = class {
    constructor(cancellationToken, options) {
      this[kConnection] = null;
      this[kCancellationToken] = cancellationToken;
      this[kRoundTripTime] = 0;
      this.closed = false;
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this[kRoundTripTime];
    }
    close() {
      this.closed = true;
      clearTimeout(this[kMonitorId]);
      this[kMonitorId] = void 0;
      if (this[kConnection]) {
        this[kConnection].destroy({force: true});
      }
    }
  };
  function measureRoundTripTime(rttPinger, options) {
    const start = now();
    const cancellationToken = rttPinger[kCancellationToken];
    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    if (rttPinger.closed) {
      return;
    }
    function measureAndReschedule(conn) {
      if (rttPinger.closed) {
        conn.destroy({force: true});
        return;
      }
      if (rttPinger[kConnection] == null) {
        rttPinger[kConnection] = conn;
      }
      rttPinger[kRoundTripTime] = calculateDurationInMs(start);
      rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
    }
    if (rttPinger[kConnection] == null) {
      connect(options, cancellationToken, (err, conn) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule(conn);
      });
      return;
    }
    rttPinger[kConnection].command("admin.$cmd", {ismaster: 1}, (err) => {
      if (err) {
        rttPinger[kConnection] = void 0;
        rttPinger[kRoundTripTime] = 0;
        return;
      }
      measureAndReschedule();
    });
  }
  module2.exports = {
    Monitor
  };
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events");
  var ConnectionPool = require_connection_pool().ConnectionPool;
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var MongoError = require_error().MongoError;
  var relayEvents = require_utils2().relayEvents;
  var BSON2 = require_utils3().retrieveBSON();
  var Logger = require_logger();
  var ServerDescription = require_server_description().ServerDescription;
  var compareTopologyVersion = require_server_description().compareTopologyVersion;
  var ReadPreference = require_read_preference();
  var Monitor = require_monitor().Monitor;
  var MongoNetworkError = require_error().MongoNetworkError;
  var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
  var collationNotSupported = require_utils2().collationNotSupported;
  var debugOptions = require_utils3().debugOptions;
  var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
  var isRetryableWriteError = require_error().isRetryableWriteError;
  var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
  var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
  var maxWireVersion = require_utils2().maxWireVersion;
  var makeStateMachine = require_utils2().makeStateMachine;
  var common = require_common2();
  var ServerType = common.ServerType;
  var isTransactionCommand = require_transactions().isTransactionCommand;
  var DEBUG_FIELDS = [
    "reconnect",
    "reconnectTries",
    "reconnectInterval",
    "emitError",
    "cursorFactory",
    "host",
    "port",
    "size",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectionTimeout",
    "checkServerIdentity",
    "socketTimeout",
    "ssl",
    "ca",
    "crl",
    "cert",
    "key",
    "rejectUnauthorized",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "servername"
  ];
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CONNECTING = common.STATE_CONNECTING;
  var STATE_CONNECTED = common.STATE_CONNECTED;
  var stateTransition = makeStateMachine({
    [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
    [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
    [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
    [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
  });
  var kMonitor = Symbol("monitor");
  var Server = class extends EventEmitter2 {
    constructor(description, options, topology) {
      super();
      this.s = {
        description,
        options,
        logger: Logger("Server", options),
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        state: STATE_CLOSED,
        credentials: options.credentials,
        topology
      };
      const poolOptions = Object.assign({host: this.description.host, port: this.description.port, bson: this.s.bson}, options);
      this.s.pool = new ConnectionPool(poolOptions);
      relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
      this.s.pool.on("clusterTimeReceived", (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      this[kMonitor] = new Monitor(this, this.s.options);
      relayEvents(this[kMonitor], this, [
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "monitoring"
      ]);
      this[kMonitor].on("resetConnectionPool", () => {
        this.s.pool.clear();
      });
      this[kMonitor].on("resetServer", (error) => markServerUnknown(this, error));
      this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
        this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
        }));
        if (this.s.state === STATE_CONNECTING) {
          stateTransition(this, STATE_CONNECTED);
          this.emit("connect", this);
        }
      });
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return null;
    }
    connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }
      stateTransition(this, STATE_CONNECTING);
      this[kMonitor].connect();
    }
    destroy(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, {force: false}, options);
      if (this.s.state === STATE_CLOSED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CLOSING);
      this[kMonitor].close();
      this.s.pool.close(options, (err) => {
        stateTransition(this, STATE_CLOSED);
        this.emit("closed");
        if (typeof callback === "function") {
          callback(err);
        }
      });
    }
    requestCheck() {
      this[kMonitor].requestCheck();
    }
    command(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      const error = basicReadValidations(this, options);
      if (error) {
        return callback(error);
      }
      options = Object.assign({}, options, {wireProtocolCommand: false});
      if (this.s.logger.isDebug()) {
        this.s.logger.debug(`executing command [${JSON.stringify({
          ns,
          cmd,
          options: debugOptions(DEBUG_FIELDS, options)
        })}] against ${this.name}`);
      }
      if (collationNotSupported(this, cmd)) {
        callback(new MongoError(`server ${this.name} does not support collation`));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));
      }, callback);
    }
    query(ns, cmd, cursorState, options, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));
      }, callback);
    }
    getMore(ns, cursorState, batchSize, options, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, conn, null, options, cb));
      }, callback);
    }
    killCursors(ns, cursorState, callback) {
      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        if (typeof callback === "function") {
          callback(new MongoError("server is closed"));
        }
        return;
      }
      this.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(this, err);
          return cb(err);
        }
        conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
      }, callback);
    }
    insert(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "insert", ns, ops}, options, callback);
    }
    update(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "update", ns, ops}, options, callback);
    }
    remove(ns, ops, options, callback) {
      executeWriteOperation({server: this, op: "remove", ns, ops}, options, callback);
    }
  };
  Object.defineProperty(Server.prototype, "clusterTime", {
    get: function() {
      return this.s.topology.clusterTime;
    },
    set: function(clusterTime) {
      this.s.topology.clusterTime = clusterTime;
    }
  });
  function supportsRetryableWrites(server) {
    return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
  }
  function calculateRoundTripTime(oldRtt, duration) {
    if (oldRtt === -1) {
      return duration;
    }
    const alpha = 0.2;
    return alpha * duration + (1 - alpha) * oldRtt;
  }
  function basicReadValidations(server, options) {
    if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
      return new MongoError("readPreference must be an instance of ReadPreference");
    }
  }
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const server = args.server;
    const op = args.op;
    const ns = args.ns;
    const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
    if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
      callback(new MongoError("server is closed"));
      return;
    }
    if (collationNotSupported(server, options)) {
      callback(new MongoError(`server ${server.name} does not support collation`));
      return;
    }
    const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
    if (unacknowledgedWrite || maxWireVersion(server) < 5) {
      if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
        callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
        return;
      }
    }
    server.s.pool.withConnection((err, conn, cb) => {
      if (err) {
        markServerUnknown(server, err);
        return cb(err);
      }
      conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));
    }, callback);
  }
  function markServerUnknown(server, error) {
    if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {
      server[kMonitor].reset();
    }
    server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
      error,
      topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion
    }));
  }
  function connectionIsStale(pool, connection) {
    return connection.generation !== pool.generation;
  }
  function shouldHandleStateChangeError(server, err) {
    const etv = err.topologyVersion;
    const stv = server.description.topologyVersion;
    return compareTopologyVersion(stv, etv) < 0;
  }
  function inActiveTransaction(session, cmd) {
    return session && session.inTransaction() && !isTransactionCommand(cmd);
  }
  function makeOperationHandler(server, connection, cmd, options, callback) {
    const session = options && options.session;
    return function handleOperationResult(err, result) {
      if (err && !connectionIsStale(server.s.pool, connection)) {
        if (err instanceof MongoNetworkError) {
          if (session && !session.hasEnded) {
            session.serverSession.isDirty = true;
          }
          if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
            err.addErrorLabel("RetryableWriteError");
          }
          if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
            markServerUnknown(server, err);
            server.s.pool.clear();
          }
        } else {
          if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
            err.addErrorLabel("RetryableWriteError");
          }
          if (isSDAMUnrecoverableError(err)) {
            if (shouldHandleStateChangeError(server, err)) {
              if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                server.s.pool.clear();
              }
              markServerUnknown(server, err);
              process.nextTick(() => server.requestCheck());
            }
          }
        }
      }
      callback(err, result);
    };
  }
  module2.exports = {
    Server
  };
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports2, module2) => {
  "use strict";
  var Logger = require_logger();
  var EventEmitter2 = require("events").EventEmitter;
  var dns = require("dns");
  function matchesParentDomain(srvAddress, parentDomain) {
    const regex = /^.*?\./;
    const srv = `.${srvAddress.replace(regex, "")}`;
    const parent = `.${parentDomain.replace(regex, "")}`;
    return srv.endsWith(parent);
  }
  var SrvPollingEvent = class {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    addresses() {
      return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
    }
  };
  var SrvPoller = class extends EventEmitter2 {
    constructor(options) {
      super();
      if (!options || !options.srvHost) {
        throw new TypeError("options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.rescanSrvIntervalMS = 6e4;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
      this.logger = Logger("srvPoller", options);
      this.haMode = false;
      this.generation = 0;
      this._timeout = null;
    }
    get srvAddress() {
      return `_mongodb._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        clearTimeout(this._timeout);
        this.generation += 1;
        this._timeout = null;
      }
    }
    schedule() {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(() => this._poll(), this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
    }
    failure(message, obj) {
      this.logger.warn(message, obj);
      this.haMode = true;
      this.schedule();
    }
    parentDomainMismatch(srvRecord) {
      this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
    }
    _poll() {
      const generation = this.generation;
      dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
        if (generation !== this.generation) {
          return;
        }
        if (err) {
          this.failure("DNS error", err);
          return;
        }
        const finalAddresses = [];
        srvRecords.forEach((record) => {
          if (matchesParentDomain(record.name, this.srvHost)) {
            finalAddresses.push(record);
          } else {
            this.parentDomainMismatch(record);
          }
        });
        if (!finalAddresses.length) {
          this.failure("No valid addresses found at host");
          return;
        }
        this.success(finalAddresses);
      });
    }
  };
  module2.exports.SrvPollingEvent = SrvPollingEvent;
  module2.exports.SrvPoller = SrvPoller;
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS((exports2, module2) => {
  "use strict";
  var ServerType = require_common2().ServerType;
  var TopologyType = require_common2().TopologyType;
  var ReadPreference = require_read_preference();
  var MongoError = require_error().MongoError;
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  function writableServerSelector() {
    return function(topologyDescription, servers) {
      return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
    };
  }
  function maxStalenessReducer(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
    if (maxStaleness < maxStalenessVariance) {
      throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1e3;
        if (staleness <= readPreference.maxStalenessSeconds)
          result.push(server);
        return result;
      }, []);
    }
    if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1e3;
        if (staleness <= readPreference.maxStalenessSeconds)
          result.push(server);
        return result;
      }, []);
    }
    return servers;
  }
  function tagSetMatch(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  }
  function tagSetReducer(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i = 0; i < readPreference.tags.length; ++i) {
      const tagSet = readPreference.tags[i];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  }
  function latencyWindowReducer(topologyDescription, servers) {
    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  }
  function primaryFilter(server) {
    return server.type === ServerType.RSPrimary;
  }
  function secondaryFilter(server) {
    return server.type === ServerType.RSSecondary;
  }
  function nearestFilter(server) {
    return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
  }
  function knownFilter(server) {
    return server.type !== ServerType.Unknown;
  }
  function readPreferenceServerSelector(readPreference) {
    if (!readPreference.isValid()) {
      throw new TypeError("Invalid read preference specified");
    }
    return function(topologyDescription, servers) {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  }
  module2.exports = {
    writableServerSelector,
    readPreferenceServerSelector
  };
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter2 = require("events");
  var ServerDescription = require_server_description().ServerDescription;
  var ServerType = require_common2().ServerType;
  var TopologyDescription = require_topology_description().TopologyDescription;
  var TopologyType = require_common2().TopologyType;
  var events = require_events();
  var Server = require_server2().Server;
  var relayEvents = require_utils2().relayEvents;
  var ReadPreference = require_read_preference();
  var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
  var CoreCursor = require_cursor().CoreCursor;
  var deprecate = require("util").deprecate;
  var BSON2 = require_utils3().retrieveBSON();
  var createCompressionInfo = require_shared2().createCompressionInfo;
  var ClientSession = require_sessions().ClientSession;
  var MongoError = require_error().MongoError;
  var MongoServerSelectionError = require_error().MongoServerSelectionError;
  var resolveClusterTime = require_shared2().resolveClusterTime;
  var SrvPoller = require_srv_polling().SrvPoller;
  var getMMAPError = require_shared2().getMMAPError;
  var makeStateMachine = require_utils2().makeStateMachine;
  var eachAsync = require_utils2().eachAsync;
  var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
  var ServerSessionPool = require_sessions().ServerSessionPool;
  var makeClientMetadata = require_utils2().makeClientMetadata;
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var compareTopologyVersion = require_server_description().compareTopologyVersion;
  var common = require_common2();
  var drainTimerQueue = common.drainTimerQueue;
  var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
  var serverSelection = require_server_selection();
  var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
  var writableServerSelector = serverSelection.writableServerSelector;
  var globalTopologyCounter = 0;
  var SERVER_RELAY_EVENTS = [
    "serverHeartbeatStarted",
    "serverHeartbeatSucceeded",
    "serverHeartbeatFailed",
    "commandStarted",
    "commandSucceeded",
    "commandFailed",
    "monitoring"
  ].concat(CMAP_EVENT_NAMES);
  var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
  var STATE_CLOSING = common.STATE_CLOSING;
  var STATE_CLOSED = common.STATE_CLOSED;
  var STATE_CONNECTING = common.STATE_CONNECTING;
  var STATE_CONNECTED = common.STATE_CONNECTED;
  var stateTransition = makeStateMachine({
    [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
    [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
    [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
    [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
  });
  var DEPRECATED_OPTIONS = new Set([
    "autoReconnect",
    "reconnectTries",
    "reconnectInterval",
    "bufferMaxEntries"
  ]);
  var kCancelled = Symbol("cancelled");
  var kWaitQueue = Symbol("waitQueue");
  var Topology = class extends EventEmitter2 {
    constructor(seedlist, options) {
      super();
      if (typeof options === "undefined" && typeof seedlist !== "string") {
        options = seedlist;
        seedlist = [];
        if (options.host) {
          seedlist.push({host: options.host, port: options.port});
        }
      }
      seedlist = seedlist || [];
      if (typeof seedlist === "string") {
        seedlist = parseStringSeedlist(seedlist);
      }
      options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);
      options = Object.freeze(Object.assign(options, {
        metadata: makeClientMetadata(options),
        compression: {compressors: createCompressionInfo(options)}
      }));
      DEPRECATED_OPTIONS.forEach((optionName) => {
        if (options[optionName]) {
          emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
      const topologyType = topologyTypeFromSeedlist(seedlist, options);
      const topologyId = globalTopologyCounter++;
      const serverDescriptions = seedlist.reduce((result, seed) => {
        if (seed.domain_socket)
          seed.host = seed.domain_socket;
        const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
        result.set(address, new ServerDescription(address));
        return result;
      }, new Map());
      this[kWaitQueue] = new Denque();
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: STATE_CLOSED,
        description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, null, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        Cursor: options.cursorFactory || CoreCursor,
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        servers: new Map(),
        sessionPool: new ServerSessionPool(this),
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise,
        credentials: options.credentials,
        clusterTime: null,
        connectionTimers: new Set()
      };
      if (options.srvHost) {
        this.s.srvPoller = options.srvPoller || new SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          logger: options.logger,
          loggerLevel: options.loggerLevel
        });
        this.s.detectTopologyDescriptionChange = (ev) => {
          const previousType = ev.previousDescription.type;
          const newType = ev.newDescription.type;
          if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
            this.s.handleSrvPolling = srvPollingHandler(this);
            this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
            this.s.srvPoller.start();
          }
        };
        this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
      }
      this.setMaxListeners(Infinity);
    }
    get description() {
      return this.s.description;
    }
    get parserType() {
      return BSON2.native ? "c++" : "js";
    }
    connect(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.state === STATE_CONNECTED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CONNECTING);
      this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
      this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
      connectServers(this, Array.from(this.s.description.servers.values()));
      ReadPreference.translate(options);
      const readPreference = options.readPreference || ReadPreference.primary;
      const connectHandler = (err) => {
        if (err) {
          this.close();
          if (typeof callback === "function") {
            callback(err);
          } else {
            this.emit("error", err);
          }
          return;
        }
        stateTransition(this, STATE_CONNECTED);
        this.emit("open", err, this);
        this.emit("connect", this);
        if (typeof callback === "function")
          callback(err, this);
      };
      if (this.s.credentials) {
        this.command("admin.$cmd", {ping: 1}, {readPreference}, connectHandler);
        return;
      }
      this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);
    }
    close(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (typeof options === "boolean") {
        options = {force: options};
      }
      options = options || {};
      if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, STATE_CLOSING);
      drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
      drainTimerQueue(this.s.connectionTimers);
      if (this.s.srvPoller) {
        this.s.srvPoller.stop();
        if (this.s.handleSrvPolling) {
          this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
          delete this.s.handleSrvPolling;
        }
      }
      if (this.s.detectTopologyDescriptionChange) {
        this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        delete this.s.detectTopologyDescriptionChange;
      }
      this.s.sessions.forEach((session) => session.endSession());
      this.s.sessionPool.endAllPooledSessions(() => {
        eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options, cb), (err) => {
          this.s.servers.clear();
          this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
          stateTransition(this, STATE_CLOSED);
          this.emit("close");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      });
    }
    selectServer(selector, options, callback) {
      if (typeof options === "function") {
        callback = options;
        if (typeof selector !== "function") {
          options = selector;
          let readPreference;
          if (selector instanceof ReadPreference) {
            readPreference = selector;
          } else if (typeof selector === "string") {
            readPreference = new ReadPreference(selector);
          } else {
            ReadPreference.translate(options);
            readPreference = options.readPreference || ReadPreference.primary;
          }
          selector = readPreferenceServerSelector(readPreference);
        } else {
          options = {};
        }
      }
      options = Object.assign({}, {serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS}, options);
      const isSharded = this.description.type === TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        callback(void 0, transaction.server);
        return;
      }
      let serverSelector = selector;
      if (typeof selector === "object") {
        const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
        serverSelector = readPreferenceServerSelector(readPreference);
      }
      const waitQueueMember = {
        serverSelector,
        transaction,
        callback
      };
      const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
      if (serverSelectionTimeoutMS) {
        waitQueueMember.timer = setTimeout(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = void 0;
          const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
          waitQueueMember.callback(timeoutError);
        }, serverSelectionTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    }
    shouldCheckForSessionSupport() {
      if (this.description.type === TopologyType.Single) {
        return !this.description.hasKnownServers;
      }
      return !this.description.hasDataBearingServers;
    }
    hasSessionSupport() {
      return this.description.logicalSessionTimeoutMinutes != null;
    }
    startSession(options, clientOptions) {
      const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
      session.once("ended", () => {
        this.s.sessions.delete(session);
      });
      this.s.sessions.add(session);
      return session;
    }
    endSessions(sessions, callback) {
      if (!Array.isArray(sessions)) {
        sessions = [sessions];
      }
      this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred, noResponse: true}, () => {
        if (typeof callback === "function")
          callback();
      });
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        resolveClusterTime(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit("error", new MongoError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
      }
      updateServers(this, serverDescription);
      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback) {
      if (typeof credentials === "function")
        callback = credentials, credentials = null;
      if (typeof callback === "function")
        callback(null, true);
    }
    logout(callback) {
      if (typeof callback === "function")
        callback(null, true);
    }
    insert(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "insert", ns, ops}, options, callback);
    }
    update(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "update", ns, ops}, options, callback);
    }
    remove(ns, ops, options, callback) {
      executeWriteOperation({topology: this, op: "remove", ns, ops}, options, callback);
    }
    command(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      ReadPreference.translate(options);
      const readPreference = options.readPreference || ReadPreference.primary;
      this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
        if (err) {
          callback(err);
          return;
        }
        const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(this) && !options.session.inTransaction() && isWriteCommand(cmd);
        const cb = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            return callback(err2);
          }
          if (willRetryWrite) {
            const newOptions = Object.assign({}, options, {retrying: true});
            return this.command(ns, cmd, newOptions, callback);
          }
          return callback(err2);
        };
        if (willRetryWrite) {
          options.session.incrementTransactionNumber();
          options.willRetryWrite = willRetryWrite;
        }
        server.command(ns, cmd, options, cb);
      });
    }
    cursor(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      const CursorClass = options.cursorFactory || this.s.Cursor;
      ReadPreference.translate(options);
      return new CursorClass(topology, ns, cmd, options);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === STATE_CLOSED;
    }
    unref() {
      console.log("not implemented: `unref`");
    }
    lastIsMaster() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
      const result = sd || {maxWireVersion: this.description.commonWireVersion};
      return result;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get bson() {
      return this.s.bson;
    }
  };
  Object.defineProperty(Topology.prototype, "clusterTime", {
    enumerable: true,
    get: function() {
      return this.s.clusterTime;
    },
    set: function(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  });
  Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
  var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
  function isWriteCommand(command) {
    return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
  }
  function isStaleServerDescription(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription.topologyVersion;
    return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  }
  function destroyServer(server, topology, options, callback) {
    options = options || {};
    LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
    server.destroy(options, () => {
      topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
      SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
      if (typeof callback === "function") {
        callback();
      }
    });
  }
  function parseStringSeedlist(seedlist) {
    return seedlist.split(",").map((seed) => ({
      host: seed.split(":")[0],
      port: seed.split(":")[1] || 27017
    }));
  }
  function topologyTypeFromSeedlist(seedlist, options) {
    if (options.directConnection) {
      return TopologyType.Single;
    }
    const replicaSet = options.replicaSet || options.setName || options.rs_name;
    if (replicaSet == null) {
      return TopologyType.Unknown;
    }
    return TopologyType.ReplicaSetNoPrimary;
  }
  function randomSelection(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
  function createAndConnectServer(topology, serverDescription, connectDelay) {
    topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new Server(serverDescription, topology.s.options, topology);
    relayEvents(server, topology, SERVER_RELAY_EVENTS);
    server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
    if (connectDelay) {
      const connectTimer = setTimeout(() => {
        clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
        server.connect();
      }, connectDelay);
      topology.s.connectionTimers.add(connectTimer);
      return server;
    }
    server.connect();
    return server;
  }
  function connectServers(topology, serverDescriptions) {
    topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
      const server = createAndConnectServer(topology, serverDescription);
      servers.set(serverDescription.address, server);
      return servers;
    }, new Map());
  }
  function updateServers(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      server.s.description = incomingServerDescription;
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      destroyServer(server, topology);
    }
  }
  function executeWriteOperation(args, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const topology = args.topology;
    const op = args.op;
    const ns = args.ns;
    const ops = args.ops;
    const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(topology) && !options.session.inTransaction();
    topology.selectServer(writableServerSelector(), options, (err, server) => {
      if (err) {
        callback(err, null);
        return;
      }
      const handler = (err2, result) => {
        if (!err2)
          return callback(null, result);
        if (!shouldRetryOperation(err2)) {
          err2 = getMMAPError(err2);
          return callback(err2);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, {retrying: true});
          return executeWriteOperation(newArgs, options, callback);
        }
        return callback(err2);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options, handler);
    });
  }
  function shouldRetryOperation(err) {
    return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
  }
  function srvPollingHandler(topology) {
    return function handleSrvPolling(ev) {
      const previousTopologyDescription = topology.s.description;
      topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
      if (topology.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(topology);
      topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
    };
  }
  function drainWaitQueue(queue, err) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      clearTimeout(waitQueueMember.timer);
      if (!waitQueueMember[kCancelled]) {
        waitQueueMember.callback(err);
      }
    }
  }
  function processWaitQueue(topology) {
    if (topology.s.state === STATE_CLOSED) {
      drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
      return;
    }
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology[kWaitQueue].length;
    for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
      const waitQueueMember = topology[kWaitQueue].shift();
      if (waitQueueMember[kCancelled]) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
      } catch (e) {
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(e);
        continue;
      }
      if (selectedDescriptions.length === 0) {
        topology[kWaitQueue].push(waitQueueMember);
        continue;
      }
      const selectedServerDescription = randomSelection(selectedDescriptions);
      const selectedServer = topology.s.servers.get(selectedServerDescription.address);
      const transaction = waitQueueMember.transaction;
      const isSharded = topology.description.type === TopologyType.Sharded;
      if (isSharded && transaction && transaction.isActive) {
        transaction.pinServer(selectedServer);
      }
      clearTimeout(waitQueueMember.timer);
      waitQueueMember.callback(void 0, selectedServer);
    }
    if (topology[kWaitQueue].length > 0) {
      topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
    }
  }
  module2.exports = {
    Topology
  };
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS((exports2, module2) => {
  "use strict";
  var URL = require("url");
  var qs = require("querystring");
  var dns = require("dns");
  var MongoParseError = require_error().MongoParseError;
  var ReadPreference = require_read_preference();
  var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
  function matchesParentDomain(srvAddress, parentDomain) {
    const regex = /^.*?\./;
    const srv = `.${srvAddress.replace(regex, "")}`;
    const parent = `.${parentDomain.replace(regex, "")}`;
    return srv.endsWith(parent);
  }
  function parseSrvConnectionString(uri, options, callback) {
    const result = URL.parse(uri, true);
    if (options.directConnection || options.directconnection) {
      return callback(new MongoParseError("directConnection not supported with SRV URI"));
    }
    if (result.hostname.split(".").length < 3) {
      return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
    }
    result.domainLength = result.hostname.split(".").length;
    if (result.pathname && result.pathname.match(",")) {
      return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
    }
    if (result.port) {
      return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
    }
    const lookupAddress = result.host;
    dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
      if (err)
        return callback(err);
      if (addresses.length === 0) {
        return callback(new MongoParseError("No addresses found at host"));
      }
      for (let i = 0; i < addresses.length; i++) {
        if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
          return callback(new MongoParseError("Server record does not share hostname with parent URI"));
        }
      }
      result.protocol = "mongodb";
      result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
      if (!("ssl" in options) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
        result.query.ssl = true;
      }
      dns.resolveTxt(lookupAddress, (err2, record) => {
        if (err2) {
          if (err2.code !== "ENODATA") {
            return callback(err2);
          }
          record = null;
        }
        if (record) {
          if (record.length > 1) {
            return callback(new MongoParseError("Multiple text records not allowed"));
          }
          record = qs.parse(record[0].join(""));
          if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
            return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
          }
          result.query = Object.assign({}, record, result.query);
        }
        result.search = qs.stringify(result.query);
        const finalString = URL.format(result);
        parseConnectionString(finalString, options, (err3, ret) => {
          if (err3) {
            callback(err3);
            return;
          }
          callback(null, Object.assign({}, ret, {srvHost: lookupAddress}));
        });
      });
    });
  }
  function parseQueryStringItemValue(key, value) {
    if (Array.isArray(value)) {
      value = value.filter((v, idx) => value.indexOf(v) === idx);
      if (value.length === 1)
        value = value[0];
    } else if (value.indexOf(":") > 0) {
      value = value.split(",").reduce((result, pair) => {
        const parts = pair.split(":");
        result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
        return result;
      }, {});
    } else if (value.indexOf(",") > 0) {
      value = value.split(",").map((v) => {
        return parseQueryStringItemValue(key, v);
      });
    } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
      value = value.toLowerCase() === "true";
    } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
      const numericValue = parseFloat(value);
      if (!Number.isNaN(numericValue)) {
        value = parseFloat(value);
      }
    }
    return value;
  }
  var BOOLEAN_OPTIONS = new Set([
    "slaveok",
    "slave_ok",
    "sslvalidate",
    "fsync",
    "safe",
    "retrywrites",
    "j"
  ]);
  var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
  var AUTH_MECHANISMS = new Set([
    "GSSAPI",
    "MONGODB-AWS",
    "MONGODB-X509",
    "MONGODB-CR",
    "DEFAULT",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256",
    "PLAIN"
  ]);
  var CASE_TRANSLATION = {
    replicaset: "replicaSet",
    connecttimeoutms: "connectTimeoutMS",
    sockettimeoutms: "socketTimeoutMS",
    maxpoolsize: "maxPoolSize",
    minpoolsize: "minPoolSize",
    maxidletimems: "maxIdleTimeMS",
    waitqueuemultiple: "waitQueueMultiple",
    waitqueuetimeoutms: "waitQueueTimeoutMS",
    wtimeoutms: "wtimeoutMS",
    readconcern: "readConcern",
    readconcernlevel: "readConcernLevel",
    readpreference: "readPreference",
    maxstalenessseconds: "maxStalenessSeconds",
    readpreferencetags: "readPreferenceTags",
    authsource: "authSource",
    authmechanism: "authMechanism",
    authmechanismproperties: "authMechanismProperties",
    gssapiservicename: "gssapiServiceName",
    localthresholdms: "localThresholdMS",
    serverselectiontimeoutms: "serverSelectionTimeoutMS",
    serverselectiontryonce: "serverSelectionTryOnce",
    heartbeatfrequencyms: "heartbeatFrequencyMS",
    retrywrites: "retryWrites",
    uuidrepresentation: "uuidRepresentation",
    zlibcompressionlevel: "zlibCompressionLevel",
    tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
    tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
    tlsinsecure: "tlsInsecure",
    tlscafile: "tlsCAFile",
    tlscertificatekeyfile: "tlsCertificateKeyFile",
    tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
    wtimeout: "wTimeoutMS",
    j: "journal",
    directconnection: "directConnection"
  };
  function applyConnectionStringOption(obj, key, value, options) {
    if (key === "journal") {
      key = "j";
    } else if (key === "wtimeoutms") {
      key = "wtimeout";
    }
    if (BOOLEAN_OPTIONS.has(key)) {
      value = value === "true" || value === true;
    } else if (key === "appname") {
      value = decodeURIComponent(value);
    } else if (key === "readconcernlevel") {
      obj["readConcernLevel"] = value;
      key = "readconcern";
      value = {level: value};
    }
    if (key === "compressors") {
      value = Array.isArray(value) ? value : [value];
      if (!value.every((c) => c === "snappy" || c === "zlib")) {
        throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
      }
    }
    if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
      throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
    }
    if (key === "readpreference" && !ReadPreference.isValid(value)) {
      throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
    }
    if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
      throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
    }
    if (key === "compressors" || key === "zlibcompressionlevel") {
      obj.compression = obj.compression || {};
      obj = obj.compression;
    }
    if (key === "authmechanismproperties") {
      if (typeof value.SERVICE_NAME === "string")
        obj.gssapiServiceName = value.SERVICE_NAME;
      if (typeof value.SERVICE_REALM === "string")
        obj.gssapiServiceRealm = value.SERVICE_REALM;
      if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
        obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
      }
    }
    if (key === "readpreferencetags") {
      value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
    }
    if (options.caseTranslate && CASE_TRANSLATION[key]) {
      obj[CASE_TRANSLATION[key]] = value;
      return;
    }
    obj[key] = value;
  }
  var USERNAME_REQUIRED_MECHANISMS = new Set([
    "GSSAPI",
    "MONGODB-CR",
    "PLAIN",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256"
  ]);
  function splitArrayOfMultipleReadPreferenceTags(value) {
    const parsedTags = [];
    for (let i = 0; i < value.length; i++) {
      parsedTags[i] = {};
      value[i].split(",").forEach((individualTag) => {
        const splitTag = individualTag.split(":");
        parsedTags[i][splitTag[0]] = splitTag[1];
      });
    }
    return parsedTags;
  }
  function applyAuthExpectations(parsed) {
    if (parsed.options == null) {
      return;
    }
    const options = parsed.options;
    const authSource = options.authsource || options.authSource;
    if (authSource != null) {
      parsed.auth = Object.assign({}, parsed.auth, {db: authSource});
    }
    const authMechanism = options.authmechanism || options.authMechanism;
    if (authMechanism != null) {
      if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
        throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
      }
      if (authMechanism === "GSSAPI") {
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "MONGODB-AWS") {
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "MONGODB-X509") {
        if (parsed.auth && parsed.auth.password != null) {
          throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
        }
        if (authSource != null && authSource !== "$external") {
          throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
        }
        parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
      }
      if (authMechanism === "PLAIN") {
        if (parsed.auth && parsed.auth.db == null) {
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
      }
    }
    if (parsed.auth && parsed.auth.db == null) {
      parsed.auth = Object.assign({}, parsed.auth, {db: "admin"});
    }
    return parsed;
  }
  function parseQueryString(query, options) {
    const result = {};
    let parsedQueryString = qs.parse(query);
    checkTLSOptions(parsedQueryString);
    for (const key in parsedQueryString) {
      const value = parsedQueryString[key];
      if (value === "" || value == null) {
        throw new MongoParseError("Incomplete key value pair for option");
      }
      const normalizedKey = key.toLowerCase();
      const parsedValue = parseQueryStringItemValue(normalizedKey, value);
      applyConnectionStringOption(result, normalizedKey, parsedValue, options);
    }
    if (result.wtimeout && result.wtimeoutms) {
      delete result.wtimeout;
      console.warn("Unsupported option `wtimeout` specified");
    }
    return Object.keys(result).length ? result : null;
  }
  function translateTLSOptions(queryString) {
    if (queryString.tls) {
      queryString.ssl = queryString.tls;
    }
    if (queryString.tlsInsecure) {
      queryString.checkServerIdentity = false;
      queryString.sslValidate = false;
    } else {
      Object.assign(queryString, {
        checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
        sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
      });
    }
    if (queryString.tlsCAFile) {
      queryString.ssl = true;
      queryString.sslCA = queryString.tlsCAFile;
    }
    if (queryString.tlsCertificateKeyFile) {
      queryString.ssl = true;
      if (queryString.tlsCertificateFile) {
        queryString.sslCert = queryString.tlsCertificateFile;
        queryString.sslKey = queryString.tlsCertificateKeyFile;
      } else {
        queryString.sslKey = queryString.tlsCertificateKeyFile;
        queryString.sslCert = queryString.tlsCertificateKeyFile;
      }
    }
    if (queryString.tlsCertificateKeyFilePassword) {
      queryString.ssl = true;
      queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
    }
    return queryString;
  }
  function checkTLSOptions(queryString) {
    const queryStringKeys = Object.keys(queryString);
    if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
      throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
    }
    const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
    const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
    if (tlsValue != null && sslValue != null) {
      if (tlsValue !== sslValue) {
        throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
      }
    }
  }
  function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
    const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
    let optionValue;
    if (Array.isArray(queryString[optionName])) {
      optionValue = queryString[optionName][0];
    } else {
      optionValue = queryString[optionName];
    }
    if (queryStringHasTLSOption) {
      if (Array.isArray(queryString[optionName])) {
        const firstValue = queryString[optionName][0];
        queryString[optionName].forEach((tlsValue) => {
          if (tlsValue !== firstValue) {
            throw new MongoParseError(`All values of ${optionName} must be the same.`);
          }
        });
      }
    }
    return optionValue;
  }
  var PROTOCOL_MONGODB = "mongodb";
  var PROTOCOL_MONGODB_SRV = "mongodb+srv";
  var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
  function parseConnectionString(uri, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, {caseTranslate: true}, options);
    try {
      URL.parse(uri);
    } catch (e) {
      return callback(new MongoParseError("URI malformed, cannot be parsed"));
    }
    const cap = uri.match(HOSTS_RX);
    if (!cap) {
      return callback(new MongoParseError("Invalid connection string"));
    }
    const protocol = cap[1];
    if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
      return callback(new MongoParseError("Invalid protocol provided"));
    }
    const dbAndQuery = cap[4].split("?");
    const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
    const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
    let parsedOptions;
    try {
      parsedOptions = parseQueryString(query, options);
    } catch (parseError) {
      return callback(parseError);
    }
    parsedOptions = Object.assign({}, parsedOptions, options);
    if (protocol === PROTOCOL_MONGODB_SRV) {
      return parseSrvConnectionString(uri, parsedOptions, callback);
    }
    const auth = {username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null};
    if (parsedOptions.auth) {
      if (parsedOptions.auth.username)
        auth.username = parsedOptions.auth.username;
      if (parsedOptions.auth.user)
        auth.username = parsedOptions.auth.user;
      if (parsedOptions.auth.password)
        auth.password = parsedOptions.auth.password;
    } else {
      if (parsedOptions.username)
        auth.username = parsedOptions.username;
      if (parsedOptions.user)
        auth.username = parsedOptions.user;
      if (parsedOptions.password)
        auth.password = parsedOptions.password;
    }
    if (cap[4].split("?")[0].indexOf("@") !== -1) {
      return callback(new MongoParseError("Unescaped slash in userinfo section"));
    }
    const authorityParts = cap[3].split("@");
    if (authorityParts.length > 2) {
      return callback(new MongoParseError("Unescaped at-sign in authority section"));
    }
    if (authorityParts[0] == null || authorityParts[0] === "") {
      return callback(new MongoParseError("No username provided in authority section"));
    }
    if (authorityParts.length > 1) {
      const authParts = authorityParts.shift().split(":");
      if (authParts.length > 2) {
        return callback(new MongoParseError("Unescaped colon in authority section"));
      }
      if (authParts[0] === "") {
        return callback(new MongoParseError("Invalid empty username provided"));
      }
      if (!auth.username)
        auth.username = qs.unescape(authParts[0]);
      if (!auth.password)
        auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
    }
    let hostParsingError = null;
    const hosts = authorityParts.shift().split(",").map((host) => {
      let parsedHost = URL.parse(`mongodb://${host}`);
      if (parsedHost.path === "/:") {
        hostParsingError = new MongoParseError("Double colon in host identifier");
        return null;
      }
      if (host.match(/\.sock/)) {
        parsedHost.hostname = qs.unescape(host);
        parsedHost.port = null;
      }
      if (Number.isNaN(parsedHost.port)) {
        hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
        return;
      }
      const result2 = {
        host: parsedHost.hostname,
        port: parsedHost.port ? parseInt(parsedHost.port) : 27017
      };
      if (result2.port === 0) {
        hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
        return;
      }
      if (result2.port > 65535) {
        hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
        return;
      }
      if (result2.port < 0) {
        hostParsingError = new MongoParseError("Invalid port (negative number)");
        return;
      }
      return result2;
    }).filter((host) => !!host);
    if (hostParsingError) {
      return callback(hostParsingError);
    }
    if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
      return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
    }
    const directConnection = !!parsedOptions.directConnection;
    if (directConnection && hosts.length !== 1) {
      return callback(new MongoParseError("directConnection option requires exactly one host"));
    }
    const result = {
      hosts,
      auth: auth.db || auth.username ? auth : null,
      options: Object.keys(parsedOptions).length ? parsedOptions : null
    };
    if (result.auth && result.auth.db) {
      result.defaultDatabase = result.auth.db;
    } else {
      result.defaultDatabase = "test";
    }
    result.options = translateTLSOptions(result.options);
    try {
      applyAuthExpectations(result);
    } catch (authError) {
      return callback(authError);
    }
    callback(null, result);
  }
  module2.exports = parseConnectionString;
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS((exports2, module2) => {
  "use strict";
  var BSON2 = require_bson2();
  var require_optional = require_require_optional();
  var EJSON = require_utils2().retrieveEJSON();
  try {
    const BSONNative = require_optional("bson-ext");
    if (BSONNative) {
      BSON2 = BSONNative;
    }
  } catch (err) {
  }
  module2.exports = {
    MongoError: require_error().MongoError,
    MongoNetworkError: require_error().MongoNetworkError,
    MongoParseError: require_error().MongoParseError,
    MongoTimeoutError: require_error().MongoTimeoutError,
    MongoServerSelectionError: require_error().MongoServerSelectionError,
    MongoWriteConcernError: require_error().MongoWriteConcernError,
    Connection: require_connection(),
    Server: require_server(),
    ReplSet: require_replset(),
    Mongos: require_mongos(),
    Logger: require_logger(),
    Cursor: require_cursor().CoreCursor,
    ReadPreference: require_read_preference(),
    Sessions: require_sessions(),
    BSON: BSON2,
    EJSON,
    Topology: require_topology().Topology,
    Query: require_commands().Query,
    MongoCredentials: require_mongo_credentials().MongoCredentials,
    defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
    MongoCR: require_mongocr(),
    X509: require_x509(),
    Plain: require_plain(),
    GSSAPI: require_gssapi(),
    ScramSHA1: require_scram().ScramSHA1,
    ScramSHA256: require_scram().ScramSHA256,
    parseConnectionString: require_uri_parser()
  };
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events").EventEmitter;
  var Instrumentation = class extends EventEmitter2 {
    constructor() {
      super();
    }
    instrument(MongoClient2, callback) {
      this.$MongoClient = MongoClient2;
      const $prototypeConnect = this.$prototypeConnect = MongoClient2.prototype.connect;
      const instrumentation = this;
      MongoClient2.prototype.connect = function(callback2) {
        this.s.options.monitorCommands = true;
        this.on("commandStarted", (event) => instrumentation.emit("started", event));
        this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
        this.on("commandFailed", (event) => instrumentation.emit("failed", event));
        return $prototypeConnect.call(this, callback2);
      };
      if (typeof callback === "function")
        callback(null, this);
    }
    uninstrument() {
      this.$MongoClient.prototype.connect = this.$prototypeConnect;
    }
  };
  module2.exports = Instrumentation;
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS((exports2, module2) => {
  "use strict";
  var MongoNetworkError = require_core().MongoNetworkError;
  var GET_MORE_RESUMABLE_CODES = new Set([
    6,
    7,
    89,
    91,
    189,
    262,
    9001,
    10107,
    11600,
    11602,
    13435,
    13436,
    63,
    150,
    13388,
    234,
    133,
    43
  ]);
  function isResumableError(error, wireVersion) {
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion >= 9) {
      if (error.code === 43) {
        return true;
      }
      return error.hasErrorLabel("ResumableChangeStreamError");
    }
    return GET_MORE_RESUMABLE_CODES.has(error.code);
  }
  module2.exports = {GET_MORE_RESUMABLE_CODES, isResumableError};
});

// node_modules/mongodb/lib/constants.js
var require_constants3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
    SYSTEM_INDEX_COLLECTION: "system.indexes",
    SYSTEM_PROFILE_COLLECTION: "system.profile",
    SYSTEM_USER_COLLECTION: "system.users",
    SYSTEM_COMMAND_COLLECTION: "$cmd",
    SYSTEM_JS_COLLECTION: "system.js"
  };
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core().BSON.Code;
  var debugOptions = require_utils4().debugOptions;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var parseIndexOptions = require_utils4().parseIndexOptions;
  var ReadPreference = require_core().ReadPreference;
  var toError = require_utils4().toError;
  var CONSTANTS = require_constants3();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var debugFields = [
    "authSource",
    "w",
    "wtimeout",
    "j",
    "native_parser",
    "forceServerObjectId",
    "serializeFunctions",
    "raw",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bufferMaxEntries",
    "numberOfRetries",
    "retryMiliSeconds",
    "readPreference",
    "pkFactory",
    "parentDb",
    "promiseLibrary",
    "noListener"
  ];
  function createIndex(db, name, fieldOrSpec, options, callback) {
    let finalOptions = Object.assign({}, {readPreference: ReadPreference.PRIMARY}, options);
    finalOptions = applyWriteConcern(finalOptions, {db}, options);
    if (finalOptions.writeConcern && typeof callback !== "function") {
      throw MongoError.create({
        message: "Cannot use a writeConcern without a provided callback",
        driver: true
      });
    }
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
      if (err == null)
        return handleCallback(callback, err, result);
      if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
        return handleCallback(callback, err, result);
      }
      const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
      finalOptions.checkKeys = false;
      db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
        if (callback == null)
          return;
        if (err2)
          return handleCallback(callback, err2);
        if (result2 == null)
          return handleCallback(callback, null, null);
        if (result2.result.writeErrors)
          return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
        handleCallback(callback, null, doc.name);
      });
    });
  }
  function createListener(db, e, object) {
    function listener(err) {
      if (object.listeners(e).length > 0) {
        object.emit(e, err, db);
        for (let i = 0; i < db.s.children.length; i++) {
          db.s.children[i].emit(e, err, db.s.children[i]);
        }
      }
    }
    return listener;
  }
  function ensureIndex(db, name, fieldOrSpec, options, callback) {
    const finalOptions = applyWriteConcern({}, {db}, options);
    const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
    const index_name = selector.name;
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    finalOptions.readPreference = ReadPreference.PRIMARY;
    indexInformation(db, name, finalOptions, (err, indexInformation2) => {
      if (err != null && err.code !== 26)
        return handleCallback(callback, err, null);
      if (indexInformation2 == null || !indexInformation2[index_name]) {
        createIndex(db, name, fieldOrSpec, options, callback);
      } else {
        if (typeof callback === "function")
          return handleCallback(callback, null, index_name);
      }
    });
  }
  function evaluate(db, code, parameters, options, callback) {
    let finalCode = code;
    let finalParameters = [];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    if (!(finalCode && finalCode._bsontype === "Code"))
      finalCode = new Code2(finalCode);
    if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
      finalParameters = [parameters];
    } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
      finalParameters = parameters;
    }
    let cmd = {$eval: finalCode, args: finalParameters};
    if (options["nolock"]) {
      cmd["nolock"] = options["nolock"];
    }
    options.readPreference = new ReadPreference(ReadPreference.PRIMARY);
    executeCommand(db, cmd, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result && result.ok === 1)
        return handleCallback(callback, null, result.retval);
      if (result)
        return handleCallback(callback, MongoError.create({message: `eval failed: ${result.errmsg}`, driver: true}), null);
      handleCallback(callback, err, result);
    });
  }
  function executeCommand(db, command, options, callback) {
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    const dbName = options.dbName || options.authdb || db.databaseName;
    options.readPreference = ReadPreference.resolve(db, options);
    if (db.s.logger.isDebug())
      db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
    db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options, (err, result) => {
      if (err)
        return handleCallback(callback, err);
      if (options.full)
        return handleCallback(callback, null, result);
      handleCallback(callback, null, result.result);
    });
  }
  function executeDbAdminCommand(db, command, options, callback) {
    const namespace = new MongoDBNamespace("admin", "$cmd");
    db.s.topology.command(namespace, command, options, (err, result) => {
      if (db.serverConfig && db.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      if (err)
        return handleCallback(callback, err);
      handleCallback(callback, null, result.result);
    });
  }
  function indexInformation(db, name, options, callback) {
    const full = options["full"] == null ? false : options["full"];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    function processResults(indexes) {
      let info = {};
      for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        info[index.name] = [];
        for (let name2 in index.key) {
          info[index.name].push([name2, index.key[name2]]);
        }
      }
      return info;
    }
    db.collection(name).listIndexes(options).toArray((err, indexes) => {
      if (err)
        return callback(toError(err));
      if (!Array.isArray(indexes))
        return handleCallback(callback, null, []);
      if (full)
        return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
  }
  function profilingInfo(db, options, callback) {
    try {
      db.collection("system.profile").find({}, options).toArray(callback);
    } catch (err) {
      return callback(err, null);
    }
  }
  function validateDatabaseName(databaseName) {
    if (typeof databaseName !== "string")
      throw MongoError.create({message: "database name must be a string", driver: true});
    if (databaseName.length === 0)
      throw MongoError.create({message: "database name cannot be the empty string", driver: true});
    if (databaseName === "$external")
      return;
    const invalidChars = [" ", ".", "$", "/", "\\"];
    for (let i = 0; i < invalidChars.length; i++) {
      if (databaseName.indexOf(invalidChars[i]) !== -1)
        throw MongoError.create({
          message: "database names cannot contain the character '" + invalidChars[i] + "'",
          driver: true
        });
    }
  }
  function createCreateIndexCommand(db, name, fieldOrSpec, options) {
    const indexParameters = parseIndexOptions(fieldOrSpec);
    const fieldHash = indexParameters.fieldHash;
    const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
    const selector = {
      ns: db.s.namespace.withCollection(name).toString(),
      key: fieldHash,
      name: indexName
    };
    const finalUnique = options == null || typeof options === "object" ? false : options;
    options = options == null || typeof options === "boolean" ? {} : options;
    const keysToOmit = Object.keys(selector);
    for (let optionName in options) {
      if (keysToOmit.indexOf(optionName) === -1) {
        selector[optionName] = options[optionName];
      }
    }
    if (selector["unique"] == null)
      selector["unique"] = finalUnique;
    const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
    for (let i = 0; i < removeKeys.length; i++) {
      delete selector[removeKeys[i]];
    }
    return selector;
  }
  function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {
    const indexParameters = parseIndexOptions(fieldOrSpec);
    const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
    const indexes = [{name: indexName, key: indexParameters.fieldHash}];
    const keysToOmit = Object.keys(indexes[0]).concat([
      "writeConcern",
      "w",
      "wtimeout",
      "j",
      "fsync",
      "readPreference",
      "session"
    ]);
    for (let optionName in options) {
      if (keysToOmit.indexOf(optionName) === -1) {
        indexes[0][optionName] = options[optionName];
      }
    }
    const capabilities = db.s.topology.capabilities();
    if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
      const error = new MongoError("server/primary/mongos does not support collation");
      error.code = 67;
      return callback(error);
    }
    const cmd = applyWriteConcern({createIndexes: name, indexes}, {db}, options);
    options.readPreference = ReadPreference.PRIMARY;
    executeCommand(db, cmd, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result.ok === 0)
        return handleCallback(callback, toError(result), null);
      handleCallback(callback, null, indexName);
    });
  }
  module2.exports = {
    createListener,
    createIndex,
    ensureIndex,
    evaluate,
    executeCommand,
    executeDbAdminCommand,
    indexInformation,
    profilingInfo,
    validateDatabaseName
  };
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS((exports2, module2) => {
  "use strict";
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var ReadPreference = require_core().ReadPreference;
  var toError = require_utils4().toError;
  var CursorState = require_cursor().CursorState;
  function buildCountCommand(collectionOrCursor, query, options) {
    const skip = options.skip;
    const limit = options.limit;
    let hint = options.hint;
    const maxTimeMS = options.maxTimeMS;
    query = query || {};
    const cmd = {
      count: options.collectionName,
      query
    };
    if (collectionOrCursor.s.numberOfRetries) {
      if (collectionOrCursor.options.hint) {
        hint = collectionOrCursor.options.hint;
      } else if (collectionOrCursor.cmd.hint) {
        hint = collectionOrCursor.cmd.hint;
      }
      decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
    } else {
      decorateWithCollation(cmd, collectionOrCursor, options);
    }
    if (typeof skip === "number")
      cmd.skip = skip;
    if (typeof limit === "number")
      cmd.limit = limit;
    if (typeof maxTimeMS === "number")
      cmd.maxTimeMS = maxTimeMS;
    if (hint)
      cmd.hint = hint;
    decorateWithReadConcern(cmd, collectionOrCursor);
    return cmd;
  }
  function deleteCallback(err, r, callback) {
    if (callback == null)
      return;
    if (err && callback)
      return callback(err);
    if (r == null)
      return callback(null, {result: {ok: 1}});
    r.deletedCount = r.result.n;
    if (callback)
      callback(null, r);
  }
  function findAndModify(coll, query, sort, doc, options, callback) {
    const queryObject = {
      findAndModify: coll.collectionName,
      query
    };
    sort = formattedOrderClause(sort);
    if (sort) {
      queryObject.sort = sort;
    }
    queryObject.new = options.new ? true : false;
    queryObject.remove = options.remove ? true : false;
    queryObject.upsert = options.upsert ? true : false;
    const projection = options.projection || options.fields;
    if (projection) {
      queryObject.fields = projection;
    }
    if (options.arrayFilters) {
      queryObject.arrayFilters = options.arrayFilters;
      delete options.arrayFilters;
    }
    if (doc && !options.remove) {
      queryObject.update = doc;
    }
    if (options.maxTimeMS)
      queryObject.maxTimeMS = options.maxTimeMS;
    options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    options.checkKeys = false;
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (finalOptions.writeConcern) {
      queryObject.writeConcern = finalOptions.writeConcern;
    }
    if (finalOptions.bypassDocumentValidation === true) {
      queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
    }
    finalOptions.readPreference = ReadPreference.primary;
    try {
      decorateWithCollation(queryObject, coll, finalOptions);
    } catch (err) {
      return callback(err, null);
    }
    executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      return handleCallback(callback, null, result);
    });
  }
  function indexInformation(db, name, options, callback) {
    const full = options["full"] == null ? false : options["full"];
    if (db.serverConfig && db.serverConfig.isDestroyed())
      return callback(new MongoError("topology was destroyed"));
    function processResults(indexes) {
      let info = {};
      for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        info[index.name] = [];
        for (let name2 in index.key) {
          info[index.name].push([name2, index.key[name2]]);
        }
      }
      return info;
    }
    db.collection(name).listIndexes(options).toArray((err, indexes) => {
      if (err)
        return callback(toError(err));
      if (!Array.isArray(indexes))
        return handleCallback(callback, null, []);
      if (full)
        return handleCallback(callback, null, indexes);
      handleCallback(callback, null, processResults(indexes));
    });
  }
  function prepareDocs(coll, docs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docs;
    }
    return docs.map((doc) => {
      if (forceServerObjectId !== true && doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    });
  }
  function nextObject(cursor, callback) {
    if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
      return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
    }
    if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
      try {
        cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
      } catch (err) {
        return handleCallback(callback, err);
      }
    }
    cursor._next((err, doc) => {
      cursor.s.state = CursorState.OPEN;
      if (err)
        return handleCallback(callback, err);
      handleCallback(callback, null, doc);
    });
  }
  function insertDocuments(coll, docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    docs = Array.isArray(docs) ? docs : [docs];
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (finalOptions.keepGoing === true)
      finalOptions.ordered = false;
    finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    docs = prepareDocs(coll, docs, options);
    coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors)
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      result.ops = docs;
      handleCallback(callback, null, result);
    });
  }
  function removeDocuments(coll, selector, options, callback) {
    if (typeof options === "function") {
      callback = options, options = {};
    } else if (typeof selector === "function") {
      callback = selector;
      options = {};
      selector = {};
    }
    options = options || {};
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    if (selector == null)
      selector = {};
    const op = {q: selector, limit: 0};
    if (options.single) {
      op.limit = 1;
    } else if (finalOptions.retryWrites) {
      finalOptions.retryWrites = false;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    try {
      decorateWithCollation(finalOptions, coll, options);
    } catch (err) {
      return callback(err, null);
    }
    coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors) {
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      }
      handleCallback(callback, null, result);
    });
  }
  function updateDocuments(coll, selector, document2, options, callback) {
    if (typeof options === "function")
      callback = options, options = null;
    if (options == null)
      options = {};
    if (!(typeof callback === "function"))
      callback = null;
    if (selector == null || typeof selector !== "object")
      return callback(toError("selector must be a valid JavaScript object"));
    if (document2 == null || typeof document2 !== "object")
      return callback(toError("document must be a valid JavaScript object"));
    let finalOptions = Object.assign({}, options);
    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
    finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
    finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
    const op = {q: selector, u: document2};
    op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
    op.multi = options.multi !== void 0 ? !!options.multi : false;
    if (options.hint) {
      op.hint = options.hint;
    }
    if (finalOptions.arrayFilters) {
      op.arrayFilters = finalOptions.arrayFilters;
      delete finalOptions.arrayFilters;
    }
    if (finalOptions.retryWrites && op.multi) {
      finalOptions.retryWrites = false;
    }
    try {
      decorateWithCollation(finalOptions, coll, options);
    } catch (err) {
      return callback(err, null);
    }
    coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, null, null);
      if (result.result.code)
        return handleCallback(callback, toError(result.result));
      if (result.result.writeErrors)
        return handleCallback(callback, toError(result.result.writeErrors[0]));
      handleCallback(callback, null, result);
    });
  }
  function updateCallback(err, r, callback) {
    if (callback == null)
      return;
    if (err)
      return callback(err);
    if (r == null)
      return callback(null, {result: {ok: 1}});
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    callback(null, r);
  }
  module2.exports = {
    buildCountCommand,
    deleteCallback,
    findAndModify,
    indexInformation,
    nextObject,
    prepareDocs,
    insertDocuments,
    removeDocuments,
    updateDocuments,
    updateCallback
  };
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core().BSON.Code;
  var createIndexDb = require_db_ops().createIndex;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var ensureIndexDb = require_db_ops().ensureIndex;
  var evaluate = require_db_ops().evaluate;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var indexInformationDb = require_db_ops().indexInformation;
  var Long2 = require_core().BSON.Long;
  var MongoError = require_core().MongoError;
  var ReadPreference = require_core().ReadPreference;
  var insertDocuments = require_common_functions().insertDocuments;
  var updateDocuments = require_common_functions().updateDocuments;
  var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
  function createIndex(coll, fieldOrSpec, options, callback) {
    createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
  }
  function createIndexes(coll, indexSpecs, options, callback) {
    const capabilities = coll.s.topology.capabilities();
    for (let i = 0; i < indexSpecs.length; i++) {
      if (indexSpecs[i].name == null) {
        const keys = [];
        if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        for (let name in indexSpecs[i].key) {
          keys.push(`${name}_${indexSpecs[i].key[name]}`);
        }
        indexSpecs[i].name = keys.join("_");
      }
    }
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    executeCommand(coll.s.db, {
      createIndexes: coll.collectionName,
      indexes: indexSpecs
    }, options, callback);
  }
  function ensureIndex(coll, fieldOrSpec, options, callback) {
    ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
  }
  function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {
    if (command) {
      const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
      const selector = {
        group: {
          ns: coll.collectionName,
          $reduce: reduceFunction,
          cond: condition,
          initial,
          out: "inline"
        }
      };
      if (finalize != null)
        selector.group["finalize"] = finalize;
      if (typeof keys === "function" || keys && keys._bsontype === "Code") {
        selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
      } else {
        const hash = {};
        keys.forEach((key) => {
          hash[key] = 1;
        });
        selector.group.key = hash;
      }
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      decorateWithReadConcern(selector, coll, options);
      try {
        decorateWithCollation(selector, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, selector, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result.retval);
      });
    } else {
      const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
      scope.ns = coll.collectionName;
      scope.keys = keys;
      scope.condition = condition;
      scope.initial = initial;
      const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
      evaluate(coll.s.db, new Code2(groupfn, scope), null, options, (err, results) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, results.result || results);
      });
    }
  }
  function indexes(coll, options, callback) {
    options = Object.assign({}, {full: true}, options);
    indexInformationDb(coll.s.db, coll.collectionName, options, callback);
  }
  function indexExists(coll, indexes2, options, callback) {
    indexInformation(coll, options, (err, indexInformation2) => {
      if (err != null)
        return handleCallback(callback, err, null);
      if (!Array.isArray(indexes2))
        return handleCallback(callback, null, indexInformation2[indexes2] != null);
      for (let i = 0; i < indexes2.length; i++) {
        if (indexInformation2[indexes2[i]] == null) {
          return handleCallback(callback, null, false);
        }
      }
      return handleCallback(callback, null, true);
    });
  }
  function indexInformation(coll, options, callback) {
    indexInformationDb(coll.s.db, coll.collectionName, options, callback);
  }
  function parallelCollectionScan(coll, options, callback) {
    const commandObject = {
      parallelCollectionScan: coll.collectionName,
      numCursors: options.numCursors
    };
    decorateWithReadConcern(commandObject, coll, options);
    const raw = options.raw;
    delete options["raw"];
    executeCommand(coll.s.db, commandObject, options, (err, result) => {
      if (err)
        return handleCallback(callback, err, null);
      if (result == null)
        return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
      options = Object.assign({explicitlyIgnoreSession: true}, options);
      const cursors = [];
      if (raw)
        options.raw = raw;
      for (let i = 0; i < result.cursors.length; i++) {
        const rawId = result.cursors[i].cursor.id;
        const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
        cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));
      }
      handleCallback(callback, null, cursors);
    });
  }
  function save(coll, doc, options, callback) {
    const finalOptions = applyWriteConcern(Object.assign({}, options), {db: coll.s.db, collection: coll}, options);
    if (doc._id != null) {
      finalOptions.upsert = true;
      return updateDocuments(coll, {_id: doc._id}, doc, finalOptions, callback);
    }
    insertDocuments(coll, [doc], finalOptions, (err, result) => {
      if (callback == null)
        return;
      if (doc == null)
        return handleCallback(callback, null, null);
      if (err)
        return handleCallback(callback, err, null);
      handleCallback(callback, null, result);
    });
  }
  module2.exports = {
    createIndex,
    createIndexes,
    ensureIndex,
    group,
    indexes,
    indexExists,
    indexInformation,
    parallelCollectionScan,
    save
  };
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS((exports2, module2) => {
  "use strict";
  var buildCountCommand = require_collection_ops().buildCountCommand;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var push = Array.prototype.push;
  var CursorState = require_cursor().CursorState;
  function count(cursor, applySkipLimit, opts, callback) {
    if (applySkipLimit) {
      if (typeof cursor.cursorSkip() === "number")
        opts.skip = cursor.cursorSkip();
      if (typeof cursor.cursorLimit() === "number")
        opts.limit = cursor.cursorLimit();
    }
    if (opts.readPreference) {
      cursor.setReadPreference(opts.readPreference);
    }
    if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
      opts.maxTimeMS = cursor.cmd.maxTimeMS;
    }
    let options = {};
    options.skip = opts.skip;
    options.limit = opts.limit;
    options.hint = opts.hint;
    options.maxTimeMS = opts.maxTimeMS;
    options.collectionName = cursor.namespace.collection;
    let command;
    try {
      command = buildCountCommand(cursor, cursor.cmd.query, options);
    } catch (err) {
      return callback(err);
    }
    cursor.server = cursor.topology.s.coreTopology;
    cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
      callback(err, result ? result.result.n : null);
    });
  }
  function each(cursor, callback) {
    if (!callback)
      throw MongoError.create({message: "callback is mandatory", driver: true});
    if (cursor.isNotified())
      return;
    if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
      return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
    }
    if (cursor.s.state === CursorState.INIT) {
      cursor.s.state = CursorState.OPEN;
    }
    let fn = null;
    if (cursor.bufferedCount() > 0) {
      while (fn = loop(cursor, callback))
        fn(cursor, callback);
      each(cursor, callback);
    } else {
      cursor.next((err, item) => {
        if (err)
          return handleCallback(callback, err);
        if (item == null) {
          return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, null));
        }
        if (handleCallback(callback, null, item) === false)
          return;
        each(cursor, callback);
      });
    }
  }
  function loop(cursor, callback) {
    if (cursor.bufferedCount() === 0)
      return;
    cursor._next(callback);
    return loop;
  }
  function toArray(cursor, callback) {
    const items = [];
    cursor.rewind();
    cursor.s.state = CursorState.INIT;
    const fetchDocs = () => {
      cursor._next((err, doc) => {
        if (err) {
          return handleCallback(callback, err);
        }
        if (doc == null) {
          return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, items));
        }
        items.push(doc);
        if (cursor.bufferedCount() > 0) {
          let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
          if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
            docs = docs.map(cursor.s.transforms.doc);
          }
          push.apply(items, docs);
        }
        fetchDocs();
      });
    };
    fetchDocs();
  }
  module2.exports = {count, each, toArray};
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports2, module2) => {
  "use strict";
  var buildCountCommand = require_common_functions().buildCountCommand;
  var OperationBase = require_operation().OperationBase;
  var CountOperation = class extends OperationBase {
    constructor(cursor, applySkipLimit, options) {
      super(options);
      this.cursor = cursor;
      this.applySkipLimit = applySkipLimit;
    }
    execute(callback) {
      const cursor = this.cursor;
      const applySkipLimit = this.applySkipLimit;
      const options = this.options;
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          options.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          options.limit = cursor.cursorLimit();
      }
      if (options.readPreference) {
        cursor.setReadPreference(options.readPreference);
      }
      if (typeof options.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        options.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let finalOptions = {};
      finalOptions.skip = options.skip;
      finalOptions.limit = options.limit;
      finalOptions.hint = options.hint;
      finalOptions.maxTimeMS = options.maxTimeMS;
      finalOptions.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
  };
  module2.exports = CountOperation;
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS((exports2, module2) => {
  "use strict";
  var Transform = require("stream").Transform;
  var PassThrough = require("stream").PassThrough;
  var deprecate = require("util").deprecate;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core().ReadPreference;
  var MongoError = require_core().MongoError;
  var CoreCursor = require_cursor().CoreCursor;
  var CursorState = require_cursor().CursorState;
  var Map2 = require_core().BSON.Map;
  var maybePromise = require_utils4().maybePromise;
  var executeOperation = require_execute_operation();
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var each = require_cursor_ops().each;
  var CountOperation = require_count();
  var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
  var fields = ["numberOfRetries", "tailableRetryInterval"];
  var Cursor = class extends CoreCursor {
    constructor(topology, ns, cmd, options) {
      super(topology, ns, cmd, options);
      if (this.operation) {
        options = this.operation.options;
      }
      const numberOfRetries = options.numberOfRetries || 5;
      const tailableRetryInterval = options.tailableRetryInterval || 500;
      const currentNumberOfRetries = numberOfRetries;
      const promiseLibrary = options.promiseLibrary || Promise;
      this.s = {
        numberOfRetries,
        tailableRetryInterval,
        currentNumberOfRetries,
        state: CursorState.INIT,
        promiseLibrary,
        explicitlyIgnoreSession: !!options.explicitlyIgnoreSession
      };
      if (!options.explicitlyIgnoreSession && options.session) {
        this.cursorState.session = options.session;
      }
      if (this.options.noCursorTimeout === true) {
        this.addCursorFlag("noCursorTimeout", true);
      }
      let batchSize = 1e3;
      if (this.cmd.cursor && this.cmd.cursor.batchSize) {
        batchSize = this.cmd.cursor.batchSize;
      } else if (options.cursor && options.cursor.batchSize) {
        batchSize = options.cursor.batchSize;
      } else if (typeof options.batchSize === "number") {
        batchSize = options.batchSize;
      }
      this.setCursorBatchSize(batchSize);
    }
    get readPreference() {
      if (this.operation) {
        return this.operation.readPreference;
      }
      return this.options.readPreference;
    }
    get sortValue() {
      return this.cmd.sort;
    }
    _initializeCursor(callback) {
      if (this.operation && this.operation.session != null) {
        this.cursorState.session = this.operation.session;
      } else {
        if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
          this.cursorState.session = this.topology.startSession({owner: this});
          if (this.operation) {
            this.operation.session = this.cursorState.session;
          }
        }
      }
      super._initializeCursor(callback);
    }
    hasNext(callback) {
      if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        if (cursor.isNotified()) {
          return cb(null, false);
        }
        cursor._next((err, doc) => {
          if (err)
            return cb(err);
          if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
            return cb(null, false);
          }
          cursor.s.state = CursorState.OPEN;
          cursor.cursorState.cursorIndex--;
          if (cursor.cursorState.limit > 0) {
            cursor.cursorState.currentLimit--;
          }
          cb(null, true);
        });
      });
    }
    next(callback) {
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
          cb(MongoError.create({message: "Cursor is closed", driver: true}));
          return;
        }
        if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
          try {
            cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
          } catch (err) {
            return cb(err);
          }
        }
        cursor._next((err, doc) => {
          if (err)
            return cb(err);
          cursor.s.state = CursorState.OPEN;
          cb(null, doc);
        });
      });
    }
    filter(filter) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.query = filter;
      return this;
    }
    maxScan(maxScan) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxScan = maxScan;
      return this;
    }
    hint(hint) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.hint = hint;
      return this;
    }
    min(min) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.min = min;
      return this;
    }
    max(max) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.max = max;
      return this;
    }
    returnKey(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.returnKey = value;
      return this;
    }
    showRecordId(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.showDiskLoc = value;
      return this;
    }
    snapshot(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.snapshot = value;
      return this;
    }
    setCursorOption(field, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (fields.indexOf(field) === -1) {
        throw MongoError.create({
          message: `option ${field} is not a supported option ${fields}`,
          driver: true
        });
      }
      this.s[field] = value;
      if (field === "numberOfRetries")
        this.s.currentNumberOfRetries = value;
      return this;
    }
    addCursorFlag(flag, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (flags.indexOf(flag) === -1) {
        throw MongoError.create({
          message: `flag ${flag} is not a supported flag ${flags}`,
          driver: true
        });
      }
      if (typeof value !== "boolean") {
        throw MongoError.create({message: `flag ${flag} must be a boolean value`, driver: true});
      }
      this.cmd[flag] = value;
      return this;
    }
    addQueryModifier(name, value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (name[0] !== "$") {
        throw MongoError.create({message: `${name} is not a valid query modifier`, driver: true});
      }
      const field = name.substr(1);
      this.cmd[field] = value;
      if (field === "orderby")
        this.cmd.sort = this.cmd[field];
      return this;
    }
    comment(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.comment = value;
      return this;
    }
    maxAwaitTimeMS(value) {
      if (typeof value !== "number") {
        throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxAwaitTimeMS = value;
      return this;
    }
    maxTimeMS(value) {
      if (typeof value !== "number") {
        throw MongoError.create({message: "maxTimeMS must be a number", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.maxTimeMS = value;
      return this;
    }
    project(value) {
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      this.cmd.fields = value;
      return this;
    }
    sort(keyOrList, direction) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver: true});
      }
      if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      let order = keyOrList;
      if (Array.isArray(order) && Array.isArray(order[0])) {
        order = new Map2(order.map((x) => {
          const value = [x[0], null];
          if (x[1] === "asc") {
            value[1] = 1;
          } else if (x[1] === "desc") {
            value[1] = -1;
          } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
            value[1] = x[1];
          } else {
            throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
          }
          return value;
        }));
      }
      if (direction != null) {
        order = [[keyOrList, direction]];
      }
      this.cmd.sort = order;
      return this;
    }
    batchSize(value) {
      if (this.options.tailable) {
        throw MongoError.create({
          message: "Tailable cursor doesn't support batchSize",
          driver: true
        });
      }
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      this.cmd.batchSize = value;
      this.setCursorBatchSize(value);
      return this;
    }
    collation(value) {
      this.cmd.collation = value;
      return this;
    }
    limit(value) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support limit", driver: true});
      }
      if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "limit requires an integer", driver: true});
      }
      this.cmd.limit = value;
      this.setCursorLimit(value);
      return this;
    }
    skip(value) {
      if (this.options.tailable) {
        throw MongoError.create({message: "Tailable cursor doesn't support skip", driver: true});
      }
      if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "skip requires an integer", driver: true});
      }
      this.cmd.skip = value;
      this.setCursorSkip(value);
      return this;
    }
    each(callback) {
      this.rewind();
      this.s.state = CursorState.INIT;
      each(this, callback);
    }
    forEach(iterator, callback) {
      this.rewind();
      this.s.state = CursorState.INIT;
      if (typeof callback === "function") {
        each(this, (err, doc) => {
          if (err) {
            callback(err);
            return false;
          }
          if (doc != null) {
            iterator(doc);
            return true;
          }
          if (doc == null && callback) {
            const internalCallback = callback;
            callback = null;
            internalCallback(null);
            return false;
          }
        });
      } else {
        return new this.s.promiseLibrary((fulfill, reject) => {
          each(this, (err, doc) => {
            if (err) {
              reject(err);
              return false;
            } else if (doc == null) {
              fulfill(null);
              return false;
            } else {
              iterator(doc);
              return true;
            }
          });
        });
      }
    }
    setReadPreference(readPreference) {
      if (this.s.state !== CursorState.INIT) {
        throw MongoError.create({
          message: "cannot change cursor readPreference after cursor has been accessed",
          driver: true
        });
      }
      if (readPreference instanceof ReadPreference) {
        this.options.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.options.readPreference = new ReadPreference(readPreference);
      } else {
        throw new TypeError("Invalid read preference: " + readPreference);
      }
      return this;
    }
    toArray(callback) {
      if (this.options.tailable) {
        throw MongoError.create({
          message: "Tailable cursor cannot be converted to array",
          driver: true
        });
      }
      return maybePromise(this, callback, (cb) => {
        const cursor = this;
        const items = [];
        cursor.rewind();
        cursor.s.state = CursorState.INIT;
        const fetchDocs = () => {
          cursor._next((err, doc) => {
            if (err) {
              return handleCallback(cb, err);
            }
            if (doc == null) {
              return cursor.close({skipKillCursors: true}, () => handleCallback(cb, null, items));
            }
            items.push(doc);
            if (cursor.bufferedCount() > 0) {
              let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
              Array.prototype.push.apply(items, docs);
            }
            fetchDocs();
          });
        };
        fetchDocs();
      });
    }
    count(applySkipLimit, opts, callback) {
      if (this.cmd.query == null)
        throw MongoError.create({
          message: "count can only be used with find command",
          driver: true
        });
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      if (typeof applySkipLimit === "function") {
        callback = applySkipLimit;
        applySkipLimit = true;
      }
      if (this.cursorState.session) {
        opts = Object.assign({}, opts, {session: this.cursorState.session});
      }
      const countOperation = new CountOperation(this, applySkipLimit, opts);
      return executeOperation(this.topology, countOperation, callback);
    }
    close(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, {skipKillCursors: false}, options);
      return maybePromise(this, callback, (cb) => {
        this.s.state = CursorState.CLOSED;
        if (!options.skipKillCursors) {
          this.kill();
        }
        this._endSession(() => {
          this.emit("close");
          cb(null, this);
        });
      });
    }
    map(transform) {
      if (this.cursorState.transforms && this.cursorState.transforms.doc) {
        const oldTransform = this.cursorState.transforms.doc;
        this.cursorState.transforms.doc = (doc) => {
          return transform(oldTransform(doc));
        };
      } else {
        this.cursorState.transforms = {doc: transform};
      }
      return this;
    }
    isClosed() {
      return this.isDead();
    }
    destroy(err) {
      if (err)
        this.emit("error", err);
      this.pause();
      this.close();
    }
    stream(options) {
      this.cursorState.streamOptions = options || {};
      return this;
    }
    transformStream(options) {
      const streamOptions = options || {};
      if (typeof streamOptions.transform === "function") {
        const stream = new Transform({
          objectMode: true,
          transform: function(chunk, encoding, callback) {
            this.push(streamOptions.transform(chunk));
            callback();
          }
        });
        return this.pipe(stream);
      }
      return this.pipe(new PassThrough({objectMode: true}));
    }
    explain(callback) {
      if (this.operation && this.operation.cmd == null) {
        this.operation.options.explain = true;
        this.operation.fullResponse = false;
        return executeOperation(this.topology, this.operation, callback);
      }
      this.cmd.explain = true;
      if (this.cmd.readConcern) {
        delete this.cmd["readConcern"];
      }
      return maybePromise(this, callback, (cb) => {
        CoreCursor.prototype._next.apply(this, [cb]);
      });
    }
    getLogger() {
      return this.logger;
    }
  };
  Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
  deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
  deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
  deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
  module2.exports = Cursor;
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_core().ReadPreference;
  var ReadConcern = require_read_concern();
  var WriteConcern = require_write_concern();
  var maxWireVersion = require_utils2().maxWireVersion;
  var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
  var MongoError = require_error().MongoError;
  var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
  var CommandOperationV2 = class extends OperationBase {
    constructor(parent, options, operationOptions) {
      super(options);
      this.ns = parent.s.namespace.withCollection("$cmd");
      const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
      this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
      this.readConcern = resolveReadConcern(propertyProvider, this.options);
      this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
      this.explain = false;
      if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
        this.fullResponse = true;
      }
      this.options.readPreference = this.readPreference;
      if (parent.s.logger) {
        this.logger = parent.s.logger;
      } else if (parent.s.db && parent.s.db.logger) {
        this.logger = parent.s.db.logger;
      }
    }
    executeCommand(server, cmd, callback) {
      this.server = server;
      const options = this.options;
      const serverWireVersion = maxWireVersion(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
        Object.assign(cmd, {readConcern: this.readConcern});
      }
      if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
        return;
      }
      if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
        if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
          Object.assign(cmd, {writeConcern: this.writeConcern});
        }
        if (options.collation && typeof options.collation === "object") {
          Object.assign(cmd, {collation: options.collation});
        }
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment === "string") {
        cmd.comment = options.comment;
      }
      if (this.logger && this.logger.isDebug()) {
        this.logger.debug(`executing command ${JSON.stringify(cmd)} against ${this.ns}`);
      }
      server.command(this.ns.toString(), cmd, this.options, (err, result) => {
        if (err) {
          callback(err, null);
          return;
        }
        if (this.fullResponse) {
          callback(null, result);
          return;
        }
        callback(null, result.result);
      });
    }
  };
  function resolveWriteConcern(parent, options) {
    return WriteConcern.fromOptions(options) || parent && parent.writeConcern;
  }
  function resolveReadConcern(parent, options) {
    return ReadConcern.fromOptions(options) || parent && parent.readConcern;
  }
  module2.exports = CommandOperationV2;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var MongoError = require_core().MongoError;
  var maxWireVersion = require_utils2().maxWireVersion;
  var ReadPreference = require_core().ReadPreference;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
  var AggregateOperation = class extends CommandOperationV2 {
    constructor(parent, pipeline, options) {
      super(parent, options, {fullResponse: true});
      this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline;
      this.hasWriteStage = false;
      if (typeof options.out === "string") {
        this.pipeline = this.pipeline.concat({$out: options.out});
        this.hasWriteStage = true;
      } else if (pipeline.length > 0) {
        const finalStage = pipeline[pipeline.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.readPreference = ReadPreference.primary;
      }
      if (options.explain && (this.readConcern || this.writeConcern)) {
        throw new MongoError('"explain" cannot be used on an aggregate call with readConcern/writeConcern');
      }
      if (options.cursor != null && typeof options.cursor !== "object") {
        throw new MongoError("cursor options must be an object");
      }
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    execute(server, callback) {
      const options = this.options;
      const serverWireVersion = maxWireVersion(server);
      const command = {aggregate: this.target, pipeline: this.pipeline};
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = null;
      }
      if (serverWireVersion >= 5) {
        if (this.hasWriteStage && this.writeConcern) {
          Object.assign(command, {writeConcern: this.writeConcern});
        }
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (options.explain) {
        options.full = false;
        command.explain = options.explain;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      super.executeCommand(server, command, callback);
    }
  };
  defineAspects(AggregateOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = AggregateOperation;
});

// node_modules/mongodb/lib/bulk/common.js
var require_common3 = __commonJS((exports2, module2) => {
  "use strict";
  var Long2 = require_core().BSON.Long;
  var MongoError = require_core().MongoError;
  var ObjectID2 = require_core().BSON.ObjectID;
  var BSON2 = require_core().BSON;
  var MongoWriteConcernError = require_core().MongoWriteConcernError;
  var toError = require_utils4().toError;
  var handleCallback = require_utils4().handleCallback;
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var isPromiseLike = require_utils4().isPromiseLike;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var maxWireVersion = require_utils2().maxWireVersion;
  var WRITE_CONCERN_ERROR = 64;
  var INSERT = 1;
  var UPDATE = 2;
  var REMOVE = 3;
  var bson = new BSON2([
    BSON2.Binary,
    BSON2.Code,
    BSON2.DBRef,
    BSON2.Decimal128,
    BSON2.Double,
    BSON2.Int32,
    BSON2.Long,
    BSON2.Map,
    BSON2.MaxKey,
    BSON2.MinKey,
    BSON2.ObjectId,
    BSON2.BSONRegExp,
    BSON2.Symbol,
    BSON2.Timestamp
  ]);
  var Batch = class {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  };
  var BulkWriteResult = class {
    constructor(bulkResult) {
      this.result = bulkResult;
    }
    get ok() {
      return this.result.ok;
    }
    get nInserted() {
      return this.result.nInserted;
    }
    get nUpserted() {
      return this.result.nUpserted;
    }
    get nMatched() {
      return this.result.nMatched;
    }
    get nModified() {
      return this.result.nModified;
    }
    get nRemoved() {
      return this.result.nRemoved;
    }
    getInsertedIds() {
      return this.result.insertedIds;
    }
    getUpsertedIds() {
      return this.result.upserted;
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      if (index < this.result.writeErrors.length) {
        return this.result.writeErrors[index];
      }
      return null;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getLastOp() {
      return this.result.lastOp;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return null;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
          const err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg;
          if (i === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({errmsg, code: WRITE_CONCERN_ERROR});
      }
    }
    toJSON() {
      return this.result;
    }
    toString() {
      return `BulkWriteResult(${this.toJSON(this.result)})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  };
  var WriteConcernError = class {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    toJSON() {
      return {code: this.err.code, errmsg: this.err.errmsg};
    }
    toString() {
      return `WriteConcernError(${this.err.errmsg})`;
    }
  };
  var WriteError = class {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return {code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op};
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  };
  function mergeBatchResults(batch, bulkResult, err, result) {
    if (err) {
      result = err;
    } else if (result && result.result) {
      result = result.result;
    } else if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (result.opTime || result.lastOp) {
      const opTime = result.lastOp || result.opTime;
      let lastOpTS = null;
      let lastOpT = null;
      if (opTime && opTime._bsontype === "Timestamp") {
        if (bulkResult.lastOp == null) {
          bulkResult.lastOp = opTime;
        } else if (opTime.greaterThan(bulkResult.lastOp)) {
          bulkResult.lastOp = opTime;
        }
      } else {
        if (bulkResult.lastOp) {
          lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
          lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
        }
        const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
        const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
        if (bulkResult.lastOp == null) {
          bulkResult.lastOp = opTime;
        } else if (opTimeTS.greaterThan(lastOpTS)) {
          bulkResult.lastOp = opTime;
        } else if (opTimeTS.equals(lastOpTS)) {
          if (opTimeT.greaterThan(lastOpT)) {
            bulkResult.lastOp = opTime;
          }
        }
      }
    }
    if (batch.batchType === INSERT && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (batch.batchType === REMOVE && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i = 0; i < result.upserted.length; i++) {
        bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex,
          _id: result.upserted[i]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (batch.batchType === UPDATE && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = null;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i = 0; i < result.writeErrors.length; i++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i].index],
          code: result.writeErrors[i].code,
          errmsg: result.writeErrors[i].errmsg,
          op: batch.operations[result.writeErrors[i].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  }
  function executeCommands(bulkOperation, options, callback) {
    if (bulkOperation.s.batches.length === 0) {
      return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
    }
    const batch = bulkOperation.s.batches.shift();
    function resultHandler(err, result) {
      if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
        return handleCallback(callback, err);
      }
      if (err)
        err.ok = 0;
      if (err instanceof MongoWriteConcernError) {
        return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
      }
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
      const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
      if (mergeResult != null) {
        return handleCallback(callback, null, writeResult);
      }
      if (bulkOperation.handleWriteError(callback, writeResult))
        return;
      executeCommands(bulkOperation, options, callback);
    }
    bulkOperation.finalOptionsHandler({options, batch, resultHandler}, callback);
  }
  function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
    mergeBatchResults(batch, bulkResult, null, err.result);
    const wrappedWriteConcernError = new WriteConcernError({
      errmsg: err.result.writeConcernError.errmsg,
      code: err.result.writeConcernError.result
    });
    return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
  }
  var BulkWriteError = class extends MongoError {
    constructor(error, result) {
      const message = error.err || error.errmsg || error.errMessage || error;
      super(message);
      Object.assign(this, error);
      this.name = "BulkWriteError";
      this.result = result;
    }
  };
  var FindOperators = class {
    constructor(bulkOperation) {
      this.s = bulkOperation.s;
    }
    update(updateDocument) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: updateDocument,
        multi: true,
        upsert
      };
      if (updateDocument.hint) {
        document2.hint = updateDocument.hint;
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    updateOne(updateDocument) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: updateDocument,
        multi: false,
        upsert
      };
      if (updateDocument.hint) {
        document2.hint = updateDocument.hint;
      }
      if (!hasAtomicOperators(updateDocument)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    replaceOne(replacement) {
      const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
      const document2 = {
        q: this.s.currentOp.selector,
        u: replacement,
        multi: false,
        upsert
      };
      if (replacement.hint) {
        document2.hint = replacement.hint;
      }
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not use atomic operators");
      }
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, UPDATE, document2);
    }
    upsert() {
      this.s.currentOp.upsert = true;
      return this;
    }
    deleteOne() {
      const document2 = {
        q: this.s.currentOp.selector,
        limit: 1
      };
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, REMOVE, document2);
    }
    delete() {
      const document2 = {
        q: this.s.currentOp.selector,
        limit: 0
      };
      this.s.currentOp = null;
      return this.s.options.addToOperationsList(this, REMOVE, document2);
    }
    removeOne() {
      return this.deleteOne();
    }
    remove() {
      return this.delete();
    }
  };
  var BulkOperationBase = class {
    constructor(topology, collection, options, isOrdered) {
      this.isOrdered = isOrdered;
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = null;
      const bson2 = topology.bson;
      const isMaster = topology.lastIsMaster();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
      finalOptions = applyWriteConcern(finalOptions, {collection}, options);
      const writeConcern = finalOptions.writeConcern;
      const promiseLibrary = options.promiseLibrary || Promise;
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: null,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: null,
        currentUpdateBatch: null,
        currentRemoveBatch: null,
        batches: [],
        writeConcern,
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        bson: bson2,
        topology,
        options: finalOptions,
        currentOp,
        executed,
        collection,
        promiseLibrary,
        err: null,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : true
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document2) {
      if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
        document2._id = new ObjectID2();
      return this.s.options.addToOperationsList(this, INSERT, document2);
    }
    find(selector) {
      if (!selector) {
        throw toError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      const key = Object.keys(op)[0];
      const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
      if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
        op[key].multi = op.updateOne || op.replaceOne ? false : true;
        return this.s.options.addToOperationsList(this, UPDATE, op[key]);
      }
      if (op.updateOne || op.updateMany || op.replaceOne) {
        if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        const multi = op.updateOne || op.replaceOne ? false : true;
        const operation = {
          q: op[key].filter,
          u: op[key].update || op[key].replacement,
          multi
        };
        if (op[key].hint) {
          operation.hint = op[key].hint;
        }
        if (this.isOrdered) {
          operation.upsert = op[key].upsert ? true : false;
          if (op.collation)
            operation.collation = op.collation;
        } else {
          if (op[key].upsert)
            operation.upsert = true;
        }
        if (op[key].arrayFilters) {
          if (maxWireVersion(this.s.topology) < 6) {
            throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
          }
          operation.arrayFilters = op[key].arrayFilters;
        }
        return this.s.options.addToOperationsList(this, UPDATE, operation);
      }
      if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
        op[key].limit = op.removeOne ? 1 : 0;
        return this.s.options.addToOperationsList(this, REMOVE, op[key]);
      }
      if (op.deleteOne || op.deleteMany) {
        const limit = op.deleteOne ? 1 : 0;
        const operation = {q: op[key].filter, limit};
        if (op[key].hint) {
          operation.hint = op[key].hint;
        }
        if (this.isOrdered) {
          if (op.collation)
            operation.collation = op.collation;
        }
        return this.s.options.addToOperationsList(this, REMOVE, operation);
      }
      if (op.insertOne && op.insertOne.document == null) {
        if (forceServerObjectId !== true && op.insertOne._id == null)
          op.insertOne._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
      } else if (op.insertOne && op.insertOne.document) {
        if (forceServerObjectId !== true && op.insertOne.document._id == null)
          op.insertOne.document._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
      }
      if (op.insertMany) {
        for (let i = 0; i < op.insertMany.length; i++) {
          if (forceServerObjectId !== true && op.insertMany[i]._id == null)
            op.insertMany[i]._id = new ObjectID2();
          this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
        }
        return;
      }
      throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
    }
    _handleEarlyError(err, callback) {
      if (typeof callback === "function") {
        callback(err, null);
        return;
      }
      return this.s.promiseLibrary.reject(err);
    }
    bulkExecute(_writeConcern, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (typeof _writeConcern === "function") {
        callback = _writeConcern;
      } else if (_writeConcern && typeof _writeConcern === "object") {
        this.s.writeConcern = _writeConcern;
      }
      if (this.s.executed) {
        const executedError = toError("batch cannot be re-executed");
        return this._handleEarlyError(executedError, callback);
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        const emptyBatchError = toError("Invalid Operation, no operations specified");
        return this._handleEarlyError(emptyBatchError, callback);
      }
      return {options, callback};
    }
    execute(_writeConcern, options, callback) {
      const ret = this.bulkExecute(_writeConcern, options, callback);
      if (!ret || isPromiseLike(ret)) {
        return ret;
      }
      options = ret.options;
      callback = ret.callback;
      return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);
    }
    finalOptionsHandler(config, callback) {
      const finalOptions = Object.assign({ordered: this.isOrdered}, config.options);
      if (this.s.writeConcern != null) {
        finalOptions.writeConcern = this.s.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation !== true) {
        delete finalOptions.bypassDocumentValidation;
      }
      if (this.operationId) {
        config.resultHandler.operationId = this.operationId;
      }
      if (this.s.options.serializeFunctions) {
        finalOptions.serializeFunctions = true;
      }
      if (this.s.options.ignoreUndefined) {
        finalOptions.ignoreUndefined = true;
      }
      if (this.s.bypassDocumentValidation === true) {
        finalOptions.bypassDocumentValidation = true;
      }
      if (this.s.checkKeys === false) {
        finalOptions.checkKeys = false;
      }
      if (finalOptions.retryWrites) {
        if (config.batch.batchType === UPDATE) {
          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
        }
        if (config.batch.batchType === REMOVE) {
          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
        }
      }
      try {
        if (config.batch.batchType === INSERT) {
          this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        } else if (config.batch.batchType === UPDATE) {
          this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        } else if (config.batch.batchType === REMOVE) {
          this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
        }
      } catch (err) {
        err.ok = 0;
        handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
      }
    }
    handleWriteError(callback, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        handleCallback(callback, new BulkWriteError(toError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }), writeResult), null);
        return true;
      }
      if (writeResult.getWriteConcernError()) {
        handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
        return true;
      }
    }
  };
  Object.defineProperty(BulkOperationBase.prototype, "length", {
    enumerable: true,
    get: function() {
      return this.s.currentIndex;
    }
  });
  module2.exports = {
    Batch,
    BulkOperationBase,
    bson,
    INSERT,
    UPDATE,
    REMOVE,
    BulkWriteError
  };
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common3();
  var BulkOperationBase = common.BulkOperationBase;
  var Batch = common.Batch;
  var bson = common.bson;
  var utils2 = require_utils4();
  var toError = utils2.toError;
  function addToOperationsList(bulkOperation, docType, document2) {
    const bsonSize = bson.calculateObjectSize(document2, {
      checkKeys: false,
      ignoreUndefined: false
    });
    if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
      throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
    bulkOperation.s.currentBatch = null;
    if (docType === common.INSERT) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
    } else if (docType === common.UPDATE) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
    } else if (docType === common.REMOVE) {
      bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
    }
    const maxKeySize = bulkOperation.s.maxKeySize;
    if (bulkOperation.s.currentBatch == null)
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
      bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    }
    if (Array.isArray(document2)) {
      throw toError("operation passed in cannot be an Array");
    }
    bulkOperation.s.currentBatch.operations.push(document2);
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
    if (docType === common.INSERT) {
      bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
      bulkOperation.s.bulkResult.insertedIds.push({
        index: bulkOperation.s.bulkResult.insertedIds.length,
        _id: document2._id
      });
    } else if (docType === common.UPDATE) {
      bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
    } else if (docType === common.REMOVE) {
      bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
    }
    bulkOperation.s.currentBatch.size += 1;
    bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
    return bulkOperation;
  }
  var UnorderedBulkOperation = class extends BulkOperationBase {
    constructor(topology, collection, options) {
      options = options || {};
      options = Object.assign(options, {addToOperationsList});
      super(topology, collection, options, false);
    }
    handleWriteError(callback, writeResult) {
      if (this.s.batches.length) {
        return false;
      }
      return super.handleWriteError(callback, writeResult);
    }
  };
  function initializeUnorderedBulkOp(topology, collection, options) {
    return new UnorderedBulkOperation(topology, collection, options);
  }
  initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
  module2.exports = initializeUnorderedBulkOp;
  module2.exports.Bulk = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common3();
  var BulkOperationBase = common.BulkOperationBase;
  var Batch = common.Batch;
  var bson = common.bson;
  var utils2 = require_utils4();
  var toError = utils2.toError;
  function addToOperationsList(bulkOperation, docType, document2) {
    const bsonSize = bson.calculateObjectSize(document2, {
      checkKeys: false,
      ignoreUndefined: false
    });
    if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
      throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
    if (bulkOperation.s.currentBatch == null)
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
    const maxKeySize = bulkOperation.s.maxKeySize;
    if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
      bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
      bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatchSize = 0;
      bulkOperation.s.currentBatchSizeBytes = 0;
    }
    if (docType === common.INSERT) {
      bulkOperation.s.bulkResult.insertedIds.push({
        index: bulkOperation.s.currentIndex,
        _id: document2._id
      });
    }
    if (Array.isArray(document2)) {
      throw toError("operation passed in cannot be an Array");
    }
    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
    bulkOperation.s.currentBatch.operations.push(document2);
    bulkOperation.s.currentBatchSize += 1;
    bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
    bulkOperation.s.currentIndex += 1;
    return bulkOperation;
  }
  var OrderedBulkOperation = class extends BulkOperationBase {
    constructor(topology, collection, options) {
      options = options || {};
      options = Object.assign(options, {addToOperationsList});
      super(topology, collection, options, true);
    }
  };
  function initializeOrderedBulkOp(topology, collection, options) {
    return new OrderedBulkOperation(topology, collection, options);
  }
  initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
  module2.exports = initializeOrderedBulkOp;
  module2.exports.Bulk = OrderedBulkOperation;
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_core().MongoError;
  var Cursor = require_cursor2();
  var CursorState = require_cursor().CursorState;
  var AggregationCursor = class extends Cursor {
    constructor(topology, operation, options) {
      super(topology, operation, options);
    }
    batchSize(value) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      this.operation.options.batchSize = value;
      this.setCursorBatchSize(value);
      return this;
    }
    geoNear(document2) {
      this.operation.addToPipeline({$geoNear: document2});
      return this;
    }
    group(document2) {
      this.operation.addToPipeline({$group: document2});
      return this;
    }
    limit(value) {
      this.operation.addToPipeline({$limit: value});
      return this;
    }
    match(document2) {
      this.operation.addToPipeline({$match: document2});
      return this;
    }
    maxTimeMS(value) {
      this.operation.options.maxTimeMS = value;
      return this;
    }
    out(destination) {
      this.operation.addToPipeline({$out: destination});
      return this;
    }
    project(document2) {
      this.operation.addToPipeline({$project: document2});
      return this;
    }
    lookup(document2) {
      this.operation.addToPipeline({$lookup: document2});
      return this;
    }
    redact(document2) {
      this.operation.addToPipeline({$redact: document2});
      return this;
    }
    skip(value) {
      this.operation.addToPipeline({$skip: value});
      return this;
    }
    sort(document2) {
      this.operation.addToPipeline({$sort: document2});
      return this;
    }
    unwind(field) {
      this.operation.addToPipeline({$unwind: field});
      return this;
    }
    getLogger() {
      return this.logger;
    }
  };
  AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
  module2.exports = AggregationCursor;
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_core().ReadPreference;
  var MongoError = require_core().MongoError;
  var Cursor = require_cursor2();
  var CursorState = require_cursor().CursorState;
  var CommandCursor = class extends Cursor {
    constructor(topology, ns, cmd, options) {
      super(topology, ns, cmd, options);
    }
    setReadPreference(readPreference) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (this.s.state !== CursorState.INIT) {
        throw MongoError.create({
          message: "cannot change cursor readPreference after cursor has been accessed",
          driver: true
        });
      }
      if (readPreference instanceof ReadPreference) {
        this.options.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.options.readPreference = new ReadPreference(readPreference);
      } else {
        throw new TypeError("Invalid read preference: " + readPreference);
      }
      return this;
    }
    batchSize(value) {
      if (this.s.state === CursorState.CLOSED || this.isDead()) {
        throw MongoError.create({message: "Cursor is closed", driver: true});
      }
      if (typeof value !== "number") {
        throw MongoError.create({message: "batchSize requires an integer", driver: true});
      }
      if (this.cmd.cursor) {
        this.cmd.cursor.batchSize = value;
      }
      this.setCursorBatchSize(value);
      return this;
    }
    maxTimeMS(value) {
      if (this.topology.lastIsMaster().minWireVersion > 2) {
        this.cmd.maxTimeMS = value;
      }
      return this;
    }
    getLogger() {
      return this.logger;
    }
  };
  CommandCursor.prototype.get = CommandCursor.prototype.toArray;
  module2.exports = CommandCursor;
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports2, module2) => {
  "use strict";
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var MongoError = require_core().MongoError;
  var OperationBase = require_operation().OperationBase;
  var BulkWriteOperation = class extends OperationBase {
    constructor(collection, operations, options) {
      super(options);
      this.collection = collection;
      this.operations = operations;
    }
    execute(callback) {
      const coll = this.collection;
      const operations = this.operations;
      let options = this.options;
      if (coll.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = coll.s.options.ignoreUndefined;
      }
      const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options);
      let collation = false;
      try {
        for (let i = 0; i < operations.length; i++) {
          const key = Object.keys(operations[i])[0];
          if (operations[i][key].collation) {
            collation = true;
          }
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback(err, null);
      }
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options);
      const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
      const capabilities = coll.s.topology.capabilities();
      if (collation && capabilities && !capabilities.commandsTakeCollation) {
        return callback(new MongoError("server/primary/mongos does not support collation"));
      }
      bulk.execute(writeCon, finalOptions, (err, r) => {
        if (!r && err) {
          return callback(err, null);
        }
        r.insertedCount = r.nInserted;
        r.matchedCount = r.nMatched;
        r.modifiedCount = r.nModified || 0;
        r.deletedCount = r.nRemoved;
        r.upsertedCount = r.getUpsertedIds().length;
        r.upsertedIds = {};
        r.insertedIds = {};
        r.n = r.insertedCount;
        const inserted = r.getInsertedIds();
        for (let i = 0; i < inserted.length; i++) {
          r.insertedIds[inserted[i].index] = inserted[i]._id;
        }
        const upserted = r.getUpsertedIds();
        for (let i = 0; i < upserted.length; i++) {
          r.upsertedIds[upserted[i].index] = upserted[i]._id;
        }
        callback(null, r);
      });
    }
  };
  module2.exports = BulkWriteOperation;
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS((exports2, module2) => {
  "use strict";
  var AggregateOperation = require_aggregate();
  var CountDocumentsOperation = class extends AggregateOperation {
    constructor(collection, query, options) {
      const pipeline = [{$match: query}];
      if (typeof options.skip === "number") {
        pipeline.push({$skip: options.skip});
      }
      if (typeof options.limit === "number") {
        pipeline.push({$limit: options.limit});
      }
      pipeline.push({$group: {_id: 1, n: {$sum: 1}}});
      super(collection, pipeline, options);
    }
    execute(server, callback) {
      super.execute(server, (err, result) => {
        if (err) {
          callback(err, null);
          return;
        }
        const response = result.result;
        if (response.cursor == null || response.cursor.firstBatch == null) {
          callback(null, 0);
          return;
        }
        const docs = response.cursor.firstBatch;
        callback(null, docs.length ? docs[0].n : 0);
      });
    }
  };
  module2.exports = CountDocumentsOperation;
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var MongoError = require_core().MongoError;
  var parseIndexOptions = require_utils4().parseIndexOptions;
  var maxWireVersion = require_utils2().maxWireVersion;
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);
  var CreateIndexesOperation = class extends CommandOperationV2 {
    constructor(parent, collection, indexes, options) {
      super(parent, options);
      this.collection = collection;
      if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
        this.onlyReturnNameOfCreatedIndex = true;
        const indexParameters = parseIndexOptions(indexes);
        const name = typeof options.name === "string" ? options.name : indexParameters.name;
        const indexSpec = {name, key: indexParameters.fieldHash};
        for (let optionName in options) {
          if (VALID_INDEX_OPTIONS.has(optionName)) {
            indexSpec[optionName] = options[optionName];
          }
        }
        this.indexes = [indexSpec];
        return;
      }
      this.indexes = indexes;
    }
    execute(server, callback) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = maxWireVersion(server);
      for (let i = 0; i < indexes.length; i++) {
        if (indexes[i].collation && serverWireVersion < 5) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (indexes[i].name == null) {
          const keys = [];
          for (let name in indexes[i].key) {
            keys.push(`${name}_${indexes[i].key[name]}`);
          }
          indexes[i].name = keys.join("_");
        }
      }
      const cmd = {createIndexes: this.collection, indexes};
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
          return;
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = void 0;
      super.executeCommand(server, cmd, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
      });
    }
  };
  defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
  module2.exports = CreateIndexesOperation;
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var deleteCallback = require_common_functions().deleteCallback;
  var removeDocuments = require_common_functions().removeDocuments;
  var DeleteManyOperation = class extends OperationBase {
    constructor(collection, filter, options) {
      super(options);
      this.collection = collection;
      this.filter = filter;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const options = this.options;
      options.single = false;
      removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
    }
  };
  module2.exports = DeleteManyOperation;
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var deleteCallback = require_common_functions().deleteCallback;
  var removeDocuments = require_common_functions().removeDocuments;
  var DeleteOneOperation = class extends OperationBase {
    constructor(collection, filter, options) {
      super(options);
      this.collection = collection;
      this.filter = filter;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const options = this.options;
      options.single = true;
      removeDocuments(coll, filter, options, (err, r) => deleteCallback(err, r, callback));
    }
  };
  module2.exports = DeleteOneOperation;
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var DistinctOperation = class extends CommandOperationV2 {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    execute(server, callback) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      decorateWithReadConcern(cmd, coll, options);
      try {
        decorateWithCollation(cmd, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      super.executeCommand(server, cmd, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, this.options.full ? result : result.values);
      });
    }
  };
  defineAspects(DistinctOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = DistinctOperation;
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var OperationBase = require_operation().OperationBase;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var debugOptions = require_utils4().debugOptions;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var ReadPreference = require_core().ReadPreference;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var debugFields = [
    "authSource",
    "w",
    "wtimeout",
    "j",
    "native_parser",
    "forceServerObjectId",
    "serializeFunctions",
    "raw",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bufferMaxEntries",
    "numberOfRetries",
    "retryMiliSeconds",
    "readPreference",
    "pkFactory",
    "parentDb",
    "promiseLibrary",
    "noListener"
  ];
  var CommandOperation = class extends OperationBase {
    constructor(db, options, collection, command) {
      super(options);
      if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
        if (collection != null) {
          this.options.readPreference = ReadPreference.resolve(collection, options);
        } else {
          this.options.readPreference = ReadPreference.resolve(db, options);
        }
      } else {
        if (collection != null) {
          applyWriteConcern(this.options, {db, coll: collection}, this.options);
        } else {
          applyWriteConcern(this.options, {db}, this.options);
        }
        this.options.readPreference = ReadPreference.primary;
      }
      this.db = db;
      if (command != null) {
        this.command = command;
      }
      if (collection != null) {
        this.collection = collection;
      }
    }
    _buildCommand() {
      if (this.command != null) {
        return this.command;
      }
    }
    execute(callback) {
      const db = this.db;
      const options = Object.assign({}, this.options);
      if (db.serverConfig && db.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      let command;
      try {
        command = this._buildCommand();
      } catch (e) {
        return callback(e);
      }
      const dbName = options.dbName || options.authdb || db.databaseName;
      if (this.hasAspect(Aspect.WRITE_OPERATION)) {
        if (options.writeConcern && (!options.session || !options.session.inTransaction())) {
          command.writeConcern = options.writeConcern;
        }
      }
      if (db.s.logger.isDebug()) {
        db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
      }
      const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
      db.s.topology.command(namespace, command, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
  };
  module2.exports = CommandOperation;
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var handleCallback = require_utils4().handleCallback;
  var DropOperation = class extends CommandOperation {
    constructor(db, options) {
      const finalOptions = Object.assign({}, options, db.s.options);
      if (options.session) {
        finalOptions.session = options.session;
      }
      super(db, finalOptions);
    }
    execute(callback) {
      super.execute((err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (result.ok)
          return handleCallback(callback, null, true);
        handleCallback(callback, null, false);
      });
    }
  };
  defineAspects(DropOperation, Aspect.WRITE_OPERATION);
  var DropCollectionOperation = class extends DropOperation {
    constructor(db, name, options) {
      super(db, options);
      this.name = name;
      this.namespace = `${db.namespace}.${name}`;
    }
    _buildCommand() {
      return {drop: this.name};
    }
  };
  var DropDatabaseOperation = class extends DropOperation {
    _buildCommand() {
      return {dropDatabase: 1};
    }
  };
  module2.exports = {
    DropOperation,
    DropCollectionOperation,
    DropDatabaseOperation
  };
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperation = require_command2();
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var handleCallback = require_utils4().handleCallback;
  var DropIndexOperation = class extends CommandOperation {
    constructor(collection, indexName, options) {
      super(collection.s.db, options, collection);
      this.collection = collection;
      this.indexName = indexName;
    }
    _buildCommand() {
      const collection = this.collection;
      const indexName = this.indexName;
      const options = this.options;
      let cmd = {dropIndexes: collection.collectionName, index: indexName};
      cmd = applyWriteConcern(cmd, {db: collection.s.db, collection}, options);
      return cmd;
    }
    execute(callback) {
      super.execute((err, result) => {
        if (typeof callback !== "function")
          return;
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
  };
  defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
  module2.exports = DropIndexOperation;
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var DropIndexOperation = require_drop_index();
  var handleCallback = require_utils4().handleCallback;
  var DropIndexesOperation = class extends DropIndexOperation {
    constructor(collection, options) {
      super(collection, "*", options);
    }
    execute(callback) {
      super.execute((err) => {
        if (err)
          return handleCallback(callback, err, false);
        handleCallback(callback, null, true);
      });
    }
  };
  defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
  module2.exports = DropIndexesOperation;
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
    constructor(collection, query, options) {
      if (typeof options === "undefined") {
        options = query;
        query = void 0;
      }
      super(collection, options);
      this.collectionName = collection.s.namespace.collection;
      if (query) {
        this.query = query;
      }
    }
    execute(server, callback) {
      const options = this.options;
      const cmd = {count: this.collectionName};
      if (this.query) {
        cmd.query = this.query;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (options.hint) {
        cmd.hint = options.hint;
      }
      super.executeCommand(server, cmd, (err, response) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, response.n);
      });
    }
  };
  defineAspects(EstimatedDocumentCountOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = EstimatedDocumentCountOperation;
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var ReadPreference = require_core().ReadPreference;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error().MongoError;
  var FindOperation = class extends OperationBase {
    constructor(collection, ns, command, options) {
      super(options);
      this.ns = ns;
      this.cmd = command;
      this.readPreference = ReadPreference.resolve(collection, this.options);
    }
    execute(server, callback) {
      this.server = server;
      if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
        callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
        return;
      }
      const cursorState = this.cursorState || {};
      server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
    }
  };
  defineAspects(FindOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = FindOperation;
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS((exports2, module2) => {
  "use strict";
  var handleCallback = require_utils4().handleCallback;
  var OperationBase = require_operation().OperationBase;
  var toError = require_utils4().toError;
  var FindOneOperation = class extends OperationBase {
    constructor(collection, query, options) {
      super(options);
      this.collection = collection;
      this.query = query;
    }
    execute(callback) {
      const coll = this.collection;
      const query = this.query;
      const options = this.options;
      try {
        const cursor = coll.find(query, options).limit(-1).batchSize(1);
        cursor.next((err, item) => {
          if (err != null)
            return handleCallback(callback, toError(err), null);
          handleCallback(callback, null, item);
        });
      } catch (e) {
        callback(e);
      }
    }
  };
  module2.exports = FindOneOperation;
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var applyRetryableWrites = require_utils4().applyRetryableWrites;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var executeCommand = require_db_ops().executeCommand;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core().ReadPreference;
  var maxWireVersion = require_utils2().maxWireVersion;
  var MongoError = require_error2().MongoError;
  var FindAndModifyOperation = class extends OperationBase {
    constructor(collection, query, sort, doc, options) {
      super(options);
      this.collection = collection;
      this.query = query;
      this.sort = sort;
      this.doc = doc;
    }
    execute(callback) {
      const coll = this.collection;
      const query = this.query;
      const sort = formattedOrderClause(this.sort);
      const doc = this.doc;
      let options = this.options;
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options.new ? true : false;
      queryObject.remove = options.remove ? true : false;
      queryObject.upsert = options.upsert ? true : false;
      const projection = options.projection || options.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options.arrayFilters) {
        queryObject.arrayFilters = options.arrayFilters;
      }
      if (doc && !options.remove) {
        queryObject.update = doc;
      }
      if (options.maxTimeMS)
        queryObject.maxTimeMS = options.maxTimeMS;
      options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      options.checkKeys = false;
      options = applyRetryableWrites(options, coll.s.db);
      options = applyWriteConcern(options, {db: coll.s.db, collection: coll}, options);
      if (options.writeConcern) {
        queryObject.writeConcern = options.writeConcern;
      }
      if (options.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      options.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.hint) {
        const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
        if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
          callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
          return;
        }
        queryObject.hint = options.hint;
      }
      executeCommand(coll.s.db, queryObject, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
  };
  module2.exports = FindAndModifyOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.remove = true;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      super(collection, filter, finalOptions.sort, null, finalOptions);
    }
  };
  module2.exports = FindOneAndDeleteOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.update = true;
      finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
      finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new TypeError("Replacement parameter must be an object");
      }
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, finalOptions.sort, replacement, finalOptions);
    }
  };
  module2.exports = FindOneAndReplaceOperation;
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS((exports2, module2) => {
  "use strict";
  var FindAndModifyOperation = require_find_and_modify();
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      const finalOptions = Object.assign({}, options);
      finalOptions.fields = options.projection;
      finalOptions.update = true;
      finalOptions.new = typeof options.returnOriginal === "boolean" ? !options.returnOriginal : false;
      finalOptions.upsert = typeof options.upsert === "boolean" ? options.upsert : false;
      if (filter == null || typeof filter !== "object") {
        throw new TypeError("Filter parameter must be an object");
      }
      if (update == null || typeof update !== "object") {
        throw new TypeError("Update parameter must be an object");
      }
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      super(collection, filter, finalOptions.sort, update, finalOptions);
    }
  };
  module2.exports = FindOneAndUpdateOperation;
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var OperationBase = require_operation().OperationBase;
  var decorateCommand = require_utils4().decorateCommand;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var ReadPreference = require_core().ReadPreference;
  var toError = require_utils4().toError;
  var GeoHaystackSearchOperation = class extends OperationBase {
    constructor(collection, x, y, options) {
      super(options);
      this.collection = collection;
      this.x = x;
      this.y = y;
    }
    execute(callback) {
      const coll = this.collection;
      const x = this.x;
      const y = this.y;
      let options = this.options;
      let commandObject = {
        geoSearch: coll.collectionName,
        near: [x, y]
      };
      commandObject = decorateCommand(commandObject, options, ["readPreference", "session"]);
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      decorateWithReadConcern(commandObject, coll, options);
      executeCommand(coll.s.db, commandObject, options, (err, res) => {
        if (err)
          return handleCallback(callback, err);
        if (res.err || res.errmsg)
          handleCallback(callback, toError(res));
        handleCallback(callback, null, res);
      });
    }
  };
  defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
  module2.exports = GeoHaystackSearchOperation;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var indexInformation = require_common_functions().indexInformation;
  var IndexesOperation = class extends OperationBase {
    constructor(collection, options) {
      super(options);
      this.collection = collection;
    }
    execute(callback) {
      const coll = this.collection;
      let options = this.options;
      options = Object.assign({}, {full: true}, options);
      indexInformation(coll.s.db, coll.collectionName, options, callback);
    }
  };
  module2.exports = IndexesOperation;
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var indexInformationDb = require_db_ops().indexInformation;
  var IndexExistsOperation = class extends OperationBase {
    constructor(collection, indexes, options) {
      super(options);
      this.collection = collection;
      this.indexes = indexes;
    }
    execute(callback) {
      const coll = this.collection;
      const indexes = this.indexes;
      const options = this.options;
      indexInformationDb(coll.s.db, coll.collectionName, options, (err, indexInformation) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, indexInformation[indexes] != null);
        for (let i = 0; i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
  };
  module2.exports = IndexExistsOperation;
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var indexInformation = require_common_functions().indexInformation;
  var IndexInformationOperation = class extends OperationBase {
    constructor(db, name, options) {
      super(options);
      this.db = db;
      this.name = name;
    }
    execute(callback) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      indexInformation(db, name, options, callback);
    }
  };
  module2.exports = IndexInformationOperation;
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var BulkWriteOperation = require_bulk_write();
  var MongoError = require_core().MongoError;
  var prepareDocs = require_common_functions().prepareDocs;
  var InsertManyOperation = class extends OperationBase {
    constructor(collection, docs, options) {
      super(options);
      this.collection = collection;
      this.docs = docs;
    }
    execute(callback) {
      const coll = this.collection;
      let docs = this.docs;
      const options = this.options;
      if (!Array.isArray(docs)) {
        return callback(MongoError.create({message: "docs parameter must be an array of documents", driver: true}));
      }
      options["serializeFunctions"] = options["serializeFunctions"] || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options);
      const operations = [
        {
          insertMany: docs
        }
      ];
      const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);
      bulkWriteOperation.execute((err, result) => {
        if (err)
          return callback(err, null);
        callback(null, mapInsertManyResults(docs, result));
      });
    }
  };
  function mapInsertManyResults(docs, r) {
    const finalResult = {
      result: {ok: 1, n: r.insertedCount},
      ops: docs,
      insertedCount: r.insertedCount,
      insertedIds: r.insertedIds
    };
    if (r.getLastOp()) {
      finalResult.result.opTime = r.getLastOp();
    }
    return finalResult;
  }
  module2.exports = InsertManyOperation;
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS((exports2, module2) => {
  "use strict";
  var MongoError = require_core().MongoError;
  var OperationBase = require_operation().OperationBase;
  var insertDocuments = require_common_functions().insertDocuments;
  var InsertOneOperation = class extends OperationBase {
    constructor(collection, doc, options) {
      super(options);
      this.collection = collection;
      this.doc = doc;
    }
    execute(callback) {
      const coll = this.collection;
      const doc = this.doc;
      const options = this.options;
      if (Array.isArray(doc)) {
        return callback(MongoError.create({message: "doc parameter must be an object", driver: true}));
      }
      insertDocuments(coll, [doc], options, (err, r) => {
        if (callback == null)
          return;
        if (err && callback)
          return callback(err);
        if (r == null)
          return callback(null, {result: {ok: 1}});
        r.insertedCount = r.result.n;
        r.insertedId = doc._id;
        if (callback)
          callback(null, r);
      });
    }
  };
  module2.exports = InsertOneOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var OptionsOperation = class extends OperationBase {
    constructor(collection, options) {
      super(options);
      this.collection = collection;
    }
    execute(callback) {
      const coll = this.collection;
      const opts = this.options;
      coll.s.db.listCollections({name: coll.collectionName}, opts).toArray((err, collections) => {
        if (err)
          return handleCallback(callback, err);
        if (collections.length === 0) {
          return handleCallback(callback, MongoError.create({message: `collection ${coll.namespace} not found`, driver: true}));
        }
        handleCallback(callback, err, collections[0].options || null);
      });
    }
  };
  module2.exports = OptionsOperation;
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports2, module2) => {
  "use strict";
  var OptionsOperation = require_options_operation();
  var handleCallback = require_utils4().handleCallback;
  var IsCappedOperation = class extends OptionsOperation {
    constructor(collection, options) {
      super(collection, options);
    }
    execute(callback) {
      super.execute((err, document2) => {
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, !!(document2 && document2.capped));
      });
    }
  };
  module2.exports = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var maxWireVersion = require_utils2().maxWireVersion;
  var LIST_INDEXES_WIRE_VERSION = 3;
  var ListIndexesOperation = class extends CommandOperationV2 {
    constructor(collection, options) {
      super(collection, options, {fullResponse: true});
      this.collectionNamespace = collection.s.namespace;
    }
    execute(server, callback) {
      const serverWireVersion = maxWireVersion(server);
      if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
        const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
        const collectionNS = this.collectionNamespace.toString();
        server.query(systemIndexesNS, {query: {ns: collectionNS}}, {}, this.options, callback);
        return;
      }
      const cursor = this.options.batchSize ? {batchSize: this.options.batchSize} : {};
      super.executeCommand(server, {listIndexes: this.collectionNamespace.collection, cursor}, callback);
    }
  };
  defineAspects(ListIndexesOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListIndexesOperation;
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var crypto = require("crypto");
  var handleCallback = require_utils4().handleCallback;
  var toError = require_utils4().toError;
  var AddUserOperation = class extends CommandOperation {
    constructor(db, username, password, options) {
      super(db, options);
      this.username = username;
      this.password = password;
    }
    _buildCommand() {
      const db = this.db;
      const username = this.username;
      const password = this.password;
      const options = this.options;
      let roles = [];
      if (Array.isArray(options.roles))
        roles = options.roles;
      if (typeof options.roles === "string")
        roles = [options.roles];
      if (roles.length === 0) {
        console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
      }
      if ((db.databaseName.toLowerCase() === "admin" || options.dbName === "admin") && !Array.isArray(options.roles)) {
        roles = ["root"];
      } else if (!Array.isArray(options.roles)) {
        roles = ["dbOwner"];
      }
      const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
      let userPassword = password;
      if (!digestPassword) {
        const md5 = crypto.createHash("md5");
        md5.update(username + ":mongo:" + password);
        userPassword = md5.digest("hex");
      }
      const command = {
        createUser: username,
        customData: options.customData || {},
        roles,
        digestPassword
      };
      if (typeof password === "string") {
        command.pwd = userPassword;
      }
      return command;
    }
    execute(callback) {
      const options = this.options;
      if (options.digestPassword != null) {
        return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
      }
      super.execute((err, r) => {
        if (!err) {
          return handleCallback(callback, err, r);
        }
        return handleCallback(callback, err, null);
      });
    }
  };
  defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
  module2.exports = AddUserOperation;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var collection;
  function loadCollection() {
    if (!collection) {
      collection = require_collection();
    }
    return collection;
  }
  var CollectionsOperation = class extends OperationBase {
    constructor(db, options) {
      super(options);
      this.db = db;
    }
    execute(callback) {
      const db = this.db;
      let options = this.options;
      let Collection2 = loadCollection();
      options = Object.assign({}, options, {nameOnly: true});
      db.listCollections({}, options).toArray((err, documents) => {
        if (err != null)
          return handleCallback(callback, err, null);
        documents = documents.filter((doc) => {
          return doc.name.indexOf("$") === -1;
        });
        handleCallback(callback, null, documents.map((d) => {
          return new Collection2(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);
        }));
      });
    }
  };
  module2.exports = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var defineAspects = require_operation().defineAspects;
  var Aspect = require_operation().Aspect;
  var RunCommandOperation = class extends CommandOperationV2 {
    constructor(parent, command, options) {
      super(parent, options);
      this.command = command;
    }
    execute(server, callback) {
      const command = this.command;
      this.executeCommand(server, command, callback);
    }
  };
  defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
  module2.exports = RunCommandOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperation = require_command2();
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var loadCollection = require_dynamic_loaders().loadCollection;
  var MongoError = require_core().MongoError;
  var ReadPreference = require_core().ReadPreference;
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "j",
    "fsync",
    "autoIndexId",
    "strict",
    "serializeFunctions",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern"
  ]);
  var CreateCollectionOperation = class extends CommandOperation {
    constructor(db, name, options) {
      super(db, options);
      this.name = name;
    }
    _buildCommand() {
      const name = this.name;
      const options = this.options;
      const cmd = {create: name};
      for (let n in options) {
        if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
          cmd[n] = options[n];
        }
      }
      return cmd;
    }
    execute(callback) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const Collection2 = loadCollection();
      let listCollectionOptions = Object.assign({nameOnly: true, strict: false}, options);
      listCollectionOptions = applyWriteConcern(listCollectionOptions, {db}, listCollectionOptions);
      function done(err) {
        if (err) {
          return callback(err);
        }
        try {
          callback(null, new Collection2(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));
        } catch (err2) {
          callback(err2);
        }
      }
      const strictMode = listCollectionOptions.strict;
      if (strictMode) {
        db.listCollections({name}, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
          if (err) {
            return callback(err);
          }
          if (collections.length > 0) {
            return callback(new MongoError(`Collection ${name} already exists. Currently in strict mode.`));
          }
          super.execute(done);
        });
        return;
      }
      super.execute(done);
    }
  };
  defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
  module2.exports = CreateCollectionOperation;
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var handleCallback = require_utils4().handleCallback;
  var MongoError = require_core().MongoError;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ExecuteDbAdminCommandOperation = class extends OperationBase {
    constructor(db, selector, options) {
      super(options);
      this.db = db;
      this.selector = selector;
    }
    execute(callback) {
      const db = this.db;
      const selector = this.selector;
      const options = this.options;
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, selector, options, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
  };
  module2.exports = ExecuteDbAdminCommandOperation;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var maxWireVersion = require_utils2().maxWireVersion;
  var CONSTANTS = require_constants3();
  var LIST_COLLECTIONS_WIRE_VERSION = 3;
  function listCollectionsTransforms(databaseName) {
    const matching = `${databaseName}.`;
    return {
      doc: (doc) => {
        const index = doc.name.indexOf(matching);
        if (doc.name && index === 0) {
          doc.name = doc.name.substr(index + matching.length);
        }
        return doc;
      }
    };
  }
  var ListCollectionsOperation = class extends CommandOperationV2 {
    constructor(db, filter, options) {
      super(db, options, {fullResponse: true});
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    execute(server, callback) {
      if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
        let filter = this.filter;
        const databaseName = this.db.s.namespace.db;
        if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
          filter = Object.assign({}, filter);
          filter.name = this.db.s.namespace.withCollection(filter.name).toString();
        }
        if (filter == null) {
          filter.name = `/${databaseName}/`;
        }
        if (filter.name) {
          filter = {$and: [{name: filter.name}, {name: /^((?!\$).)*$/}]};
        } else {
          filter = {name: /^((?!\$).)*$/};
        }
        const transforms = listCollectionsTransforms(databaseName);
        server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, {query: filter}, {batchSize: this.batchSize || 1e3}, {}, (err, result) => {
          if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
            result.message.documents = result.message.documents.map(transforms.doc);
          }
          callback(err, result);
        });
        return;
      }
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? {batchSize: this.batchSize} : {},
        nameOnly: this.nameOnly
      };
      return super.executeCommand(server, command, callback);
    }
  };
  defineAspects(ListCollectionsOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListCollectionsOperation;
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var ProfilingLevelOperation = class extends CommandOperation {
    constructor(db, command, options) {
      super(db, options);
    }
    _buildCommand() {
      const command = {profile: -1};
      return command;
    }
    execute(callback) {
      super.execute((err, doc) => {
        if (err == null && doc.ok === 1) {
          const was = doc.was;
          if (was === 0)
            return callback(null, "off");
          if (was === 1)
            return callback(null, "slow_only");
          if (was === 2)
            return callback(null, "all");
          return callback(new Error("Error: illegal profiling level value " + was), null);
        } else {
          err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        }
      });
    }
  };
  module2.exports = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var handleCallback = require_utils4().handleCallback;
  var WriteConcern = require_write_concern();
  var RemoveUserOperation = class extends CommandOperation {
    constructor(db, username, options) {
      const commandOptions = {};
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern != null) {
        commandOptions.writeConcern = writeConcern;
      }
      if (options.dbName) {
        commandOptions.dbName = options.dbName;
      }
      if (typeof options.maxTimeMS === "number") {
        commandOptions.maxTimeMS = options.maxTimeMS;
      }
      super(db, commandOptions);
      this.username = username;
    }
    _buildCommand() {
      const username = this.username;
      const command = {dropUser: username};
      return command;
    }
    execute(callback) {
      super.execute((err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, err, result.ok ? true : false);
      });
    }
  };
  defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
  module2.exports = RemoveUserOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var checkCollectionName = require_utils4().checkCollectionName;
  var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
  var handleCallback = require_utils4().handleCallback;
  var loadCollection = require_dynamic_loaders().loadCollection;
  var toError = require_utils4().toError;
  var RenameOperation = class extends OperationBase {
    constructor(collection, newName, options) {
      super(options);
      this.collection = collection;
      this.newName = newName;
    }
    execute(callback) {
      const coll = this.collection;
      const newName = this.newName;
      const options = this.options;
      let Collection2 = loadCollection();
      checkCollectionName(newName);
      const renameCollection = coll.namespace;
      const toCollection = coll.s.namespace.withCollection(newName).toString();
      const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
      const cmd = {renameCollection, to: toCollection, dropTarget};
      applyWriteConcern(cmd, {db: coll.s.db, collection: coll}, options);
      executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => {
        if (err)
          return handleCallback(callback, err, null);
        if (doc.errmsg)
          return handleCallback(callback, toError(doc), null);
        try {
          return handleCallback(callback, null, new Collection2(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
        } catch (err2) {
          return handleCallback(callback, toError(err2), null);
        }
      });
    }
  };
  module2.exports = RenameOperation;
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var levelValues = new Set(["off", "slow_only", "all"]);
  var SetProfilingLevelOperation = class extends CommandOperation {
    constructor(db, level, options) {
      let profile = 0;
      if (level === "off") {
        profile = 0;
      } else if (level === "slow_only") {
        profile = 1;
      } else if (level === "all") {
        profile = 2;
      }
      super(db, options);
      this.level = level;
      this.profile = profile;
    }
    _buildCommand() {
      const profile = this.profile;
      const command = {profile};
      return command;
    }
    execute(callback) {
      const level = this.level;
      if (!levelValues.has(level)) {
        return callback(new Error("Error: illegal profiling level value " + level));
      }
      super.execute((err, doc) => {
        if (err == null && doc.ok === 1)
          return callback(null, level);
        return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
      });
    }
  };
  module2.exports = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperation = require_command2();
  var ValidateCollectionOperation = class extends CommandOperation {
    constructor(admin, collectionName, options) {
      let command = {validate: collectionName};
      const keys = Object.keys(options);
      for (let i = 0; i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
          command[keys[i]] = options[keys[i]];
        }
      }
      super(admin.s.db, options, null, command);
      this.collectionName = collectionName;
    }
    execute(callback) {
      const collectionName = this.collectionName;
      super.execute((err, doc) => {
        if (err != null)
          return callback(err, null);
        if (doc.ok === 0)
          return callback(new Error("Error with validate command"), null);
        if (doc.result != null && doc.result.constructor !== String)
          return callback(new Error("Error with validation data"), null);
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
          return callback(new Error("Error: invalid collection " + collectionName), null);
        if (doc.valid != null && !doc.valid)
          return callback(new Error("Error: invalid collection " + collectionName), null);
        return callback(null, doc);
      });
    }
  };
  module2.exports = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports2, module2) => {
  "use strict";
  var CommandOperationV2 = require_command_v2();
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ListDatabasesOperation = class extends CommandOperationV2 {
    constructor(db, options) {
      super(db, options);
      this.ns = new MongoDBNamespace("admin", "$cmd");
    }
    execute(server, callback) {
      const cmd = {listDatabases: 1};
      if (this.options.nameOnly) {
        cmd.nameOnly = Number(cmd.nameOnly);
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      super.executeCommand(server, cmd, callback);
    }
  };
  defineAspects(ListDatabasesOperation, [
    Aspect.READ_OPERATION,
    Aspect.RETRYABLE,
    Aspect.EXECUTE_WITH_SELECTION
  ]);
  module2.exports = ListDatabasesOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var AddUserOperation = require_add_user();
  var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
  var RemoveUserOperation = require_remove_user();
  var ValidateCollectionOperation = require_validate_collection();
  var ListDatabasesOperation = require_list_databases();
  var executeOperation = require_execute_operation();
  function Admin(db, topology, promiseLibrary) {
    if (!(this instanceof Admin))
      return new Admin(db, topology);
    this.s = {
      db,
      topology,
      promiseLibrary
    };
  }
  Admin.prototype.command = function(command, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options);
    return executeOperation(this.s.db.s.topology, commandOperation, callback);
  };
  Admin.prototype.buildInfo = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {buildinfo: 1};
    const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
  };
  Admin.prototype.serverInfo = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {buildinfo: 1};
    const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
  };
  Admin.prototype.serverStatus = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {serverStatus: 1}, options);
    return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
  };
  Admin.prototype.ping = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const cmd = {ping: 1};
    const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
    return executeOperation(this.s.db.s.topology, pingOperation, callback);
  };
  Admin.prototype.addUser = function(username, password, options, callback) {
    const args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    if (typeof username === "string" && password != null && typeof password === "object") {
      options = password;
      password = null;
    }
    options = args.length ? args.shift() : {};
    options = Object.assign({}, options);
    options = applyWriteConcern(options, {db: this.s.db});
    options.dbName = "admin";
    const addUserOperation = new AddUserOperation(this.s.db, username, password, options);
    return executeOperation(this.s.db.s.topology, addUserOperation, callback);
  };
  Admin.prototype.removeUser = function(username, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    options = Object.assign({}, options);
    options = applyWriteConcern(options, {db: this.s.db});
    options.dbName = "admin";
    const removeUserOperation = new RemoveUserOperation(this.s.db, username, options);
    return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
  };
  Admin.prototype.validateCollection = function(collectionName, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options);
    return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
  };
  Admin.prototype.listDatabases = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options), callback);
  };
  Admin.prototype.replSetGetStatus = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {replSetGetStatus: 1}, options);
    return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
  };
  module2.exports = Admin;
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter2 = require("events").EventEmitter;
  var inherits = require("util").inherits;
  var getSingleProperty = require_utils4().getSingleProperty;
  var CommandCursor = require_command_cursor();
  var handleCallback = require_utils4().handleCallback;
  var filterOptions = require_utils4().filterOptions;
  var toError = require_utils4().toError;
  var ReadPreference = require_core().ReadPreference;
  var MongoError = require_core().MongoError;
  var ObjectID2 = require_core().ObjectID;
  var Logger = require_core().Logger;
  var Collection2 = require_collection();
  var mergeOptionsAndWriteConcern = require_utils4().mergeOptionsAndWriteConcern;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var ChangeStream = require_change_stream();
  var deprecate = require("util").deprecate;
  var deprecateOptions = require_utils4().deprecateOptions;
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var CONSTANTS = require_constants3();
  var WriteConcern = require_write_concern();
  var ReadConcern = require_read_concern();
  var AggregationCursor = require_aggregation_cursor();
  var createListener = require_db_ops().createListener;
  var ensureIndex = require_db_ops().ensureIndex;
  var evaluate = require_db_ops().evaluate;
  var profilingInfo = require_db_ops().profilingInfo;
  var validateDatabaseName = require_db_ops().validateDatabaseName;
  var AggregateOperation = require_aggregate();
  var AddUserOperation = require_add_user();
  var CollectionsOperation = require_collections();
  var CommandOperation = require_command2();
  var RunCommandOperation = require_run_command();
  var CreateCollectionOperation = require_create_collection();
  var CreateIndexesOperation = require_create_indexes();
  var DropCollectionOperation = require_drop().DropCollectionOperation;
  var DropDatabaseOperation = require_drop().DropDatabaseOperation;
  var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
  var IndexInformationOperation = require_index_information();
  var ListCollectionsOperation = require_list_collections();
  var ProfilingLevelOperation = require_profiling_level();
  var RemoveUserOperation = require_remove_user();
  var RenameOperation = require_rename();
  var SetProfilingLevelOperation = require_set_profiling_level();
  var executeOperation = require_execute_operation();
  var legalOptionNames = [
    "w",
    "wtimeout",
    "fsync",
    "j",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "bufferMaxEntries",
    "authSource",
    "ignoreUndefined",
    "promoteLongs",
    "promiseLibrary",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "parentDb",
    "noListener",
    "loggerLevel",
    "logger",
    "promoteBuffers",
    "promoteLongs",
    "promoteValues",
    "compression",
    "retryWrites"
  ];
  function Db(databaseName, topology, options) {
    options = options || {};
    if (!(this instanceof Db))
      return new Db(databaseName, topology, options);
    EventEmitter2.call(this);
    const promiseLibrary = options.promiseLibrary || Promise;
    options = filterOptions(options, legalOptionNames);
    options.promiseLibrary = promiseLibrary;
    this.s = {
      dbCache: {},
      children: [],
      topology,
      options,
      logger: Logger("Db", options),
      bson: topology ? topology.bson : null,
      readPreference: ReadPreference.fromOptions(options),
      bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : -1,
      parentDb: options.parentDb || null,
      pkFactory: options.pkFactory || ObjectID2,
      nativeParser: options.nativeParser || options.native_parser,
      promiseLibrary,
      noListener: typeof options.noListener === "boolean" ? options.noListener : false,
      readConcern: ReadConcern.fromOptions(options),
      writeConcern: WriteConcern.fromOptions(options),
      namespace: new MongoDBNamespace(databaseName)
    };
    validateDatabaseName(databaseName);
    getSingleProperty(this, "serverConfig", this.s.topology);
    getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
    getSingleProperty(this, "databaseName", this.s.namespace.db);
    if (options.parentDb)
      return;
    if (this.s.noListener)
      return;
    topology.on("error", createListener(this, "error", this));
    topology.on("timeout", createListener(this, "timeout", this));
    topology.on("close", createListener(this, "close", this));
    topology.on("parseError", createListener(this, "parseError", this));
    topology.once("open", createListener(this, "open", this));
    topology.once("fullsetup", createListener(this, "fullsetup", this));
    topology.once("all", createListener(this, "all", this));
    topology.on("reconnect", createListener(this, "reconnect", this));
  }
  inherits(Db, EventEmitter2);
  Object.defineProperty(Db.prototype, "topology", {
    enumerable: true,
    get: function() {
      return this.s.topology;
    }
  });
  Object.defineProperty(Db.prototype, "options", {
    enumerable: true,
    get: function() {
      return this.s.options;
    }
  });
  Object.defineProperty(Db.prototype, "slaveOk", {
    enumerable: true,
    get: function() {
      if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
        return true;
      }
      return false;
    }
  });
  Object.defineProperty(Db.prototype, "readConcern", {
    enumerable: true,
    get: function() {
      return this.s.readConcern;
    }
  });
  Object.defineProperty(Db.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      if (this.s.readPreference == null) {
        return ReadPreference.primary;
      }
      return this.s.readPreference;
    }
  });
  Object.defineProperty(Db.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(Db.prototype, "namespace", {
    enumerable: true,
    get: function() {
      return this.s.namespace.toString();
    }
  });
  Db.prototype.command = function(command, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    const commandOperation = new RunCommandOperation(this, command, options);
    return executeOperation(this.s.topology, commandOperation, callback);
  };
  Db.prototype.aggregate = function(pipeline, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options == null && callback == null) {
      options = {};
    }
    const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  };
  Db.prototype.admin = function() {
    const Admin = require_admin();
    return new Admin(this, this.s.topology, this.s.promiseLibrary);
  };
  var collectionKeys = [
    "pkFactory",
    "readPreference",
    "serializeFunctions",
    "strict",
    "readConcern",
    "ignoreUndefined",
    "promoteValues",
    "promoteBuffers",
    "promoteLongs"
  ];
  Db.prototype.collection = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options = Object.assign({}, options);
    options.promiseLibrary = this.s.promiseLibrary;
    options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
    if (this.s.options.ignoreUndefined) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);
    if (options == null || !options.strict) {
      try {
        const collection = new Collection2(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options);
        if (callback)
          callback(null, collection);
        return collection;
      } catch (err) {
        if (err instanceof MongoError && callback)
          return callback(err);
        throw err;
      }
    }
    if (typeof callback !== "function") {
      throw toError(`A callback is required in strict mode. While getting collection ${name}`);
    }
    if (this.serverConfig && this.serverConfig.isDestroyed()) {
      return callback(new MongoError("topology was destroyed"));
    }
    const listCollectionOptions = Object.assign({}, options, {nameOnly: true});
    this.listCollections({name}, listCollectionOptions).toArray((err, collections) => {
      if (err != null)
        return handleCallback(callback, err, null);
      if (collections.length === 0)
        return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);
      try {
        return handleCallback(callback, null, new Collection2(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options));
      } catch (err2) {
        return handleCallback(callback, err2, null);
      }
    });
  };
  Db.prototype.createCollection = deprecateOptions({
    name: "Db.createCollection",
    deprecatedOptions: ["autoIndexId", "strict"],
    optionsIndex: 1
  }, function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
    options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
    const createCollectionOperation = new CreateCollectionOperation(this, name, options);
    return executeOperation(this.s.topology, createCollectionOperation, callback);
  });
  Db.prototype.stats = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const commandObject = {dbStats: true};
    if (options["scale"] != null)
      commandObject["scale"] = options["scale"];
    if (options.readPreference == null && this.s.readPreference) {
      options.readPreference = this.s.readPreference;
    }
    const statsOperation = new CommandOperation(this, options, null, commandObject);
    return executeOperation(this.s.topology, statsOperation, callback);
  };
  Db.prototype.listCollections = function(filter, options) {
    filter = filter || {};
    options = options || {};
    return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options), options);
  };
  Db.prototype.eval = deprecate(function(code, parameters, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    parameters = args.length ? args.shift() : parameters;
    options = args.length ? args.shift() || {} : {};
    return executeLegacyOperation(this.s.topology, evaluate, [
      this,
      code,
      parameters,
      options,
      callback
    ]);
  }, "Db.eval is deprecated as of MongoDB version 3.2");
  Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    options.new_collection = true;
    const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options);
    return executeOperation(this.s.topology, renameOperation, callback);
  };
  Db.prototype.dropCollection = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropCollectionOperation = new DropCollectionOperation(this, name, options);
    return executeOperation(this.s.topology, dropCollectionOperation, callback);
  };
  Db.prototype.dropDatabase = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropDatabaseOperation = new DropDatabaseOperation(this, options);
    return executeOperation(this.s.topology, dropDatabaseOperation, callback);
  };
  Db.prototype.collections = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const collectionsOperation = new CollectionsOperation(this, options);
    return executeOperation(this.s.topology, collectionsOperation, callback);
  };
  Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    options.readPreference = ReadPreference.resolve(this, options);
    const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options);
    return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
  };
  Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, ensureIndex, [
      this,
      name,
      fieldOrSpec,
      options,
      callback
    ]);
  }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
  Db.prototype.addChild = function(db) {
    if (this.s.parentDb)
      return this.s.parentDb.addChild(db);
    this.s.children.push(db);
  };
  Db.prototype.addUser = function(username, password, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (typeof username === "string" && password != null && typeof password === "object") {
      options = password;
      password = null;
    }
    const addUserOperation = new AddUserOperation(this, username, password, options);
    return executeOperation(this.s.topology, addUserOperation, callback);
  };
  Db.prototype.removeUser = function(username, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const removeUserOperation = new RemoveUserOperation(this, username, options);
    return executeOperation(this.s.topology, removeUserOperation, callback);
  };
  Db.prototype.setProfilingLevel = function(level, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options);
    return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
  };
  Db.prototype.profilingInfo = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, profilingInfo, [this, options, callback]);
  }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
  Db.prototype.profilingLevel = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const profilingLevelOperation = new ProfilingLevelOperation(this, options);
    return executeOperation(this.s.topology, profilingLevelOperation, callback);
  };
  Db.prototype.indexInformation = function(name, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexInformationOperation = new IndexInformationOperation(this, name, options);
    return executeOperation(this.s.topology, indexInformationOperation, callback);
  };
  Db.prototype.unref = function() {
    this.s.topology.unref();
  };
  Db.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  Db.prototype.getLogger = function() {
    return this.s.logger;
  };
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  module2.exports = Db;
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS((exports2, module2) => {
  "use strict";
  var collection;
  var cursor;
  var db;
  function loadCollection() {
    if (!collection) {
      collection = require_collection();
    }
    return collection;
  }
  function loadCursor() {
    if (!cursor) {
      cursor = require_cursor2();
    }
    return cursor;
  }
  function loadDb() {
    if (!db) {
      db = require_db();
    }
    return db;
  }
  module2.exports = {
    loadCollection,
    loadCursor,
    loadDb
  };
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS((exports2, module2) => {
  "use strict";
  var applyWriteConcern = require_utils4().applyWriteConcern;
  var Code2 = require_core().BSON.Code;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var executeCommand = require_db_ops().executeCommand;
  var handleCallback = require_utils4().handleCallback;
  var isObject = require_utils4().isObject;
  var loadDb = require_dynamic_loaders().loadDb;
  var OperationBase = require_operation().OperationBase;
  var ReadPreference = require_core().ReadPreference;
  var toError = require_utils4().toError;
  var exclusionList = [
    "readPreference",
    "session",
    "bypassDocumentValidation",
    "w",
    "wtimeout",
    "j",
    "writeConcern"
  ];
  var MapReduceOperation = class extends OperationBase {
    constructor(collection, map, reduce, options) {
      super(options);
      this.collection = collection;
      this.map = map;
      this.reduce = reduce;
    }
    execute(callback) {
      const coll = this.collection;
      const map = this.map;
      const reduce = this.reduce;
      let options = this.options;
      const mapCommandHash = {
        mapReduce: coll.collectionName,
        map,
        reduce
      };
      for (let n in options) {
        if (n === "scope") {
          mapCommandHash[n] = processScope(options[n]);
        } else {
          if (exclusionList.indexOf(n) === -1) {
            mapCommandHash[n] = options[n];
          }
        }
      }
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(coll, options);
      if (options.readPreference !== false && options.readPreference !== "primary" && options["out"] && options["out"].inline !== 1 && options["out"] !== "inline") {
        options.readPreference = "primary";
        applyWriteConcern(mapCommandHash, {db: coll.s.db, collection: coll}, options);
      } else {
        decorateWithReadConcern(mapCommandHash, coll, options);
      }
      if (options.bypassDocumentValidation === true) {
        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      try {
        decorateWithCollation(mapCommandHash, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (result.ok !== 1 || result.err || result.errmsg) {
          return handleCallback(callback, toError(result));
        }
        const stats = {};
        if (result.timeMillis)
          stats["processtime"] = result.timeMillis;
        if (result.counts)
          stats["counts"] = result.counts;
        if (result.timing)
          stats["timing"] = result.timing;
        if (result.results) {
          if (options["verbose"] == null || !options["verbose"]) {
            return handleCallback(callback, null, result.results);
          }
          return handleCallback(callback, null, {results: result.results, stats});
        }
        let collection = null;
        if (result.result != null && typeof result.result === "object") {
          const doc = result.result;
          let Db = loadDb();
          collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
        } else {
          collection = coll.s.db.collection(result.result);
        }
        if (options["verbose"] == null || !options["verbose"]) {
          return handleCallback(callback, err, collection);
        }
        handleCallback(callback, err, {collection, stats});
      });
    }
  };
  function processScope(scope) {
    if (!isObject(scope) || scope._bsontype === "ObjectID") {
      return scope;
    }
    const keys = Object.keys(scope);
    let key;
    const new_scope = {};
    for (let i = keys.length - 1; i >= 0; i--) {
      key = keys[i];
      if (typeof scope[key] === "function") {
        new_scope[key] = new Code2(String(scope[key]));
      } else {
        new_scope[key] = processScope(scope[key]);
      }
    }
    return new_scope;
  }
  module2.exports = MapReduceOperation;
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var defineAspects = require_operation().defineAspects;
  var CommandOperationV2 = require_command_v2();
  var serverType = require_common2().serverType;
  var ServerType = require_common2().ServerType;
  var MongoError = require_core().MongoError;
  var ReIndexOperation = class extends CommandOperationV2 {
    constructor(collection, options) {
      super(collection, options);
      this.collectionName = collection.collectionName;
    }
    execute(server, callback) {
      if (serverType(server) !== ServerType.Standalone) {
        callback(new MongoError(`reIndex can only be executed on standalone servers.`));
        return;
      }
      super.executeCommand(server, {reIndex: this.collectionName}, (err, result) => {
        if (err) {
          callback(err);
          return;
        }
        callback(null, !!result.ok);
      });
    }
  };
  defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
  module2.exports = ReIndexOperation;
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var ReplaceOneOperation = class extends OperationBase {
    constructor(collection, filter, replacement, options) {
      super(options);
      if (hasAtomicOperators(replacement)) {
        throw new TypeError("Replacement document must not contain atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.replacement = replacement;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const replacement = this.replacement;
      const options = this.options;
      options.multi = false;
      updateDocuments(coll, filter, replacement, options, (err, r) => replaceCallback(err, r, replacement, callback));
    }
  };
  function replaceCallback(err, r, doc, callback) {
    if (callback == null)
      return;
    if (err && callback)
      return callback(err);
    if (r == null)
      return callback(null, {result: {ok: 1}});
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if (callback)
      callback(null, r);
  }
  module2.exports = ReplaceOneOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports2, module2) => {
  "use strict";
  var Aspect = require_operation().Aspect;
  var CommandOperation = require_command2();
  var defineAspects = require_operation().defineAspects;
  var StatsOperation = class extends CommandOperation {
    constructor(collection, options) {
      super(collection.s.db, options, collection);
    }
    _buildCommand() {
      const collection = this.collection;
      const options = this.options;
      const command = {
        collStats: collection.collectionName
      };
      if (options["scale"] != null) {
        command["scale"] = options["scale"];
      }
      return command;
    }
  };
  defineAspects(StatsOperation, Aspect.READ_OPERATION);
  module2.exports = StatsOperation;
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateCallback = require_common_functions().updateCallback;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var UpdateManyOperation = class extends OperationBase {
    constructor(collection, filter, update, options) {
      super(options);
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.update = update;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const update = this.update;
      const options = this.options;
      options.multi = true;
      updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
    }
  };
  module2.exports = UpdateManyOperation;
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS((exports2, module2) => {
  "use strict";
  var OperationBase = require_operation().OperationBase;
  var updateDocuments = require_common_functions().updateDocuments;
  var hasAtomicOperators = require_utils4().hasAtomicOperators;
  var UpdateOneOperation = class extends OperationBase {
    constructor(collection, filter, update, options) {
      super(options);
      if (!hasAtomicOperators(update)) {
        throw new TypeError("Update document requires atomic operators");
      }
      this.collection = collection;
      this.filter = filter;
      this.update = update;
    }
    execute(callback) {
      const coll = this.collection;
      const filter = this.filter;
      const update = this.update;
      const options = this.options;
      options.multi = false;
      updateDocuments(coll, filter, update, options, (err, r) => updateCallback(err, r, callback));
    }
  };
  function updateCallback(err, r, callback) {
    if (callback == null)
      return;
    if (err)
      return callback(err);
    if (r == null)
      return callback(null, {result: {ok: 1}});
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    callback(null, r);
  }
  module2.exports = UpdateOneOperation;
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS((exports2, module2) => {
  "use strict";
  var deprecate = require("util").deprecate;
  var deprecateOptions = require_utils4().deprecateOptions;
  var checkCollectionName = require_utils4().checkCollectionName;
  var ObjectID2 = require_core().BSON.ObjectID;
  var MongoError = require_core().MongoError;
  var normalizeHintField = require_utils4().normalizeHintField;
  var decorateCommand = require_utils4().decorateCommand;
  var decorateWithCollation = require_utils4().decorateWithCollation;
  var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
  var formattedOrderClause = require_utils4().formattedOrderClause;
  var ReadPreference = require_core().ReadPreference;
  var unordered = require_unordered();
  var ordered = require_ordered();
  var ChangeStream = require_change_stream();
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var WriteConcern = require_write_concern();
  var ReadConcern = require_read_concern();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var AggregationCursor = require_aggregation_cursor();
  var CommandCursor = require_command_cursor();
  var ensureIndex = require_collection_ops().ensureIndex;
  var group = require_collection_ops().group;
  var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
  var removeDocuments = require_common_functions().removeDocuments;
  var save = require_collection_ops().save;
  var updateDocuments = require_common_functions().updateDocuments;
  var AggregateOperation = require_aggregate();
  var BulkWriteOperation = require_bulk_write();
  var CountDocumentsOperation = require_count_documents();
  var CreateIndexesOperation = require_create_indexes();
  var DeleteManyOperation = require_delete_many();
  var DeleteOneOperation = require_delete_one();
  var DistinctOperation = require_distinct();
  var DropCollectionOperation = require_drop().DropCollectionOperation;
  var DropIndexOperation = require_drop_index();
  var DropIndexesOperation = require_drop_indexes();
  var EstimatedDocumentCountOperation = require_estimated_document_count();
  var FindOperation = require_find();
  var FindOneOperation = require_find_one();
  var FindAndModifyOperation = require_find_and_modify();
  var FindOneAndDeleteOperation = require_find_one_and_delete();
  var FindOneAndReplaceOperation = require_find_one_and_replace();
  var FindOneAndUpdateOperation = require_find_one_and_update();
  var GeoHaystackSearchOperation = require_geo_haystack_search();
  var IndexesOperation = require_indexes();
  var IndexExistsOperation = require_index_exists();
  var IndexInformationOperation = require_index_information();
  var InsertManyOperation = require_insert_many();
  var InsertOneOperation = require_insert_one();
  var IsCappedOperation = require_is_capped();
  var ListIndexesOperation = require_list_indexes();
  var MapReduceOperation = require_map_reduce();
  var OptionsOperation = require_options_operation();
  var RenameOperation = require_rename();
  var ReIndexOperation = require_re_index();
  var ReplaceOneOperation = require_replace_one();
  var StatsOperation = require_stats();
  var UpdateManyOperation = require_update_many();
  var UpdateOneOperation = require_update_one();
  var executeOperation = require_execute_operation();
  var mergeKeys = ["ignoreUndefined"];
  function Collection2(db, topology, dbName, name, pkFactory, options) {
    checkCollectionName(name);
    const internalHint = null;
    const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
    const serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
    const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
    const promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
    const promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
    const promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
    const collectionHint = null;
    const namespace = new MongoDBNamespace(dbName, name);
    const promiseLibrary = options.promiseLibrary || Promise;
    pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
    this.s = {
      pkFactory,
      db,
      topology,
      options,
      namespace,
      readPreference: ReadPreference.fromOptions(options),
      slaveOk,
      serializeFunctions,
      raw,
      promoteLongs,
      promoteValues,
      promoteBuffers,
      internalHint,
      collectionHint,
      promiseLibrary,
      readConcern: ReadConcern.fromOptions(options),
      writeConcern: WriteConcern.fromOptions(options)
    };
  }
  Object.defineProperty(Collection2.prototype, "dbName", {
    enumerable: true,
    get: function() {
      return this.s.namespace.db;
    }
  });
  Object.defineProperty(Collection2.prototype, "collectionName", {
    enumerable: true,
    get: function() {
      return this.s.namespace.collection;
    }
  });
  Object.defineProperty(Collection2.prototype, "namespace", {
    enumerable: true,
    get: function() {
      return this.s.namespace.toString();
    }
  });
  Object.defineProperty(Collection2.prototype, "readConcern", {
    enumerable: true,
    get: function() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
  });
  Object.defineProperty(Collection2.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
  });
  Object.defineProperty(Collection2.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(Collection2.prototype, "hint", {
    enumerable: true,
    get: function() {
      return this.s.collectionHint;
    },
    set: function(v) {
      this.s.collectionHint = normalizeHintField(v);
    }
  });
  var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
  Collection2.prototype.find = deprecateOptions({
    name: "collection.find",
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  }, function(query, options, callback) {
    if (typeof callback === "object") {
      console.warn("Third parameter to `find()` must be a callback or undefined");
    }
    let selector = query;
    if (typeof callback !== "function") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      } else if (options == null) {
        callback = typeof selector === "function" ? selector : void 0;
        selector = typeof selector === "object" ? selector : void 0;
      }
    }
    selector = selector == null ? {} : selector;
    const object = selector;
    if (Buffer.isBuffer(object)) {
      const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
      if (object_size !== object.length) {
        const error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
        error.name = "MongoError";
        throw error;
      }
    }
    if (selector != null && selector._bsontype === "ObjectID") {
      selector = {_id: selector};
    }
    if (!options)
      options = {};
    let projection = options.projection || options.fields;
    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
      projection = projection.length ? projection.reduce((result, field) => {
        result[field] = 1;
        return result;
      }, {}) : {_id: 1};
    }
    let newOptions = Object.assign({}, options);
    for (let key in this.s.options) {
      if (mergeKeys.indexOf(key) !== -1) {
        newOptions[key] = this.s.options[key];
      }
    }
    newOptions.skip = options.skip ? options.skip : 0;
    newOptions.limit = options.limit ? options.limit : 0;
    newOptions.raw = typeof options.raw === "boolean" ? options.raw : this.s.raw;
    newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
    newOptions.timeout = typeof options.timeout === "undefined" ? void 0 : options.timeout;
    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
    newOptions.readPreference = ReadPreference.resolve(this, newOptions);
    if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
      newOptions.slaveOk = true;
    }
    if (selector != null && typeof selector !== "object") {
      throw MongoError.create({message: "query selector must be an object", driver: true});
    }
    const findCommand = {
      find: this.s.namespace.toString(),
      limit: newOptions.limit,
      skip: newOptions.skip,
      query: selector
    };
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (typeof newOptions.awaitdata === "boolean") {
      newOptions.awaitData = newOptions.awaitdata;
    }
    if (typeof newOptions.timeout === "boolean")
      newOptions.noCursorTimeout = newOptions.timeout;
    decorateCommand(findCommand, newOptions, ["session", "collation"]);
    if (projection)
      findCommand.fields = projection;
    newOptions.db = this.s.db;
    newOptions.promiseLibrary = this.s.promiseLibrary;
    if (newOptions.raw == null && typeof this.s.raw === "boolean")
      newOptions.raw = this.s.raw;
    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
      newOptions.promoteLongs = this.s.promoteLongs;
    if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
      newOptions.promoteValues = this.s.promoteValues;
    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
      newOptions.promoteBuffers = this.s.promoteBuffers;
    if (findCommand.sort) {
      findCommand.sort = formattedOrderClause(findCommand.sort);
    }
    decorateWithReadConcern(findCommand, this, options);
    try {
      decorateWithCollation(findCommand, this, options);
    } catch (err) {
      if (typeof callback === "function")
        return callback(err, null);
      throw err;
    }
    const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  });
  Collection2.prototype.insertOne = function(doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const insertOneOperation = new InsertOneOperation(this, doc, options);
    return executeOperation(this.s.topology, insertOneOperation, callback);
  };
  Collection2.prototype.insertMany = function(docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {ordered: true};
    const insertManyOperation = new InsertManyOperation(this, docs, options);
    return executeOperation(this.s.topology, insertManyOperation, callback);
  };
  Collection2.prototype.bulkWrite = function(operations, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {ordered: true};
    if (!Array.isArray(operations)) {
      throw MongoError.create({message: "operations must be an array of documents", driver: true});
    }
    const bulkWriteOperation = new BulkWriteOperation(this, operations, options);
    return executeOperation(this.s.topology, bulkWriteOperation, callback);
  };
  Collection2.prototype.insert = deprecate(function(docs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {ordered: false};
    docs = !Array.isArray(docs) ? [docs] : docs;
    if (options.keepGoing === true) {
      options.ordered = false;
    }
    return this.insertMany(docs, options, callback);
  }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
  Collection2.prototype.updateOne = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.replaceOne = function(filter, doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options), callback);
  };
  Collection2.prototype.updateMany = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.update = deprecate(function(selector, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, updateDocuments, [
      this,
      selector,
      update,
      options,
      callback
    ]);
  }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
  Collection2.prototype.deleteOne = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const deleteOneOperation = new DeleteOneOperation(this, filter, options);
    return executeOperation(this.s.topology, deleteOneOperation, callback);
  };
  Collection2.prototype.removeOne = Collection2.prototype.deleteOne;
  Collection2.prototype.deleteMany = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options);
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    const deleteManyOperation = new DeleteManyOperation(this, filter, options);
    return executeOperation(this.s.topology, deleteManyOperation, callback);
  };
  Collection2.prototype.removeMany = Collection2.prototype.deleteMany;
  Collection2.prototype.remove = deprecate(function(selector, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, removeDocuments, [
      this,
      selector,
      options,
      callback
    ]);
  }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
  Collection2.prototype.save = deprecate(function(doc, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.s.options.ignoreUndefined) {
      options = Object.assign({}, options);
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);
  }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
  Collection2.prototype.findOne = deprecateOptions({
    name: "collection.find",
    deprecatedOptions: DEPRECATED_FIND_OPTIONS,
    optionsIndex: 1
  }, function(query, options, callback) {
    if (typeof callback === "object") {
      console.warn("Third parameter to `findOne()` must be a callback or undefined");
    }
    if (typeof query === "function")
      callback = query, query = {}, options = {};
    if (typeof options === "function")
      callback = options, options = {};
    query = query || {};
    options = options || {};
    const findOneOperation = new FindOneOperation(this, query, options);
    return executeOperation(this.s.topology, findOneOperation, callback);
  });
  Collection2.prototype.rename = function(newName, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = Object.assign({}, options, {readPreference: ReadPreference.PRIMARY});
    const renameOperation = new RenameOperation(this, newName, options);
    return executeOperation(this.s.topology, renameOperation, callback);
  };
  Collection2.prototype.drop = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options);
    return executeOperation(this.s.topology, dropCollectionOperation, callback);
  };
  Collection2.prototype.options = function(opts, callback) {
    if (typeof opts === "function")
      callback = opts, opts = {};
    opts = opts || {};
    const optionsOperation = new OptionsOperation(this, opts);
    return executeOperation(this.s.topology, optionsOperation, callback);
  };
  Collection2.prototype.isCapped = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const isCappedOperation = new IsCappedOperation(this, options);
    return executeOperation(this.s.topology, isCappedOperation, callback);
  };
  Collection2.prototype.createIndex = function(fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Collection2.prototype.createIndexes = function(indexSpecs, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    if (typeof options.maxTimeMS !== "number")
      delete options.maxTimeMS;
    const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options);
    return executeOperation(this.s.topology, createIndexesOperation, callback);
  };
  Collection2.prototype.dropIndex = function(indexName, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    options.readPreference = ReadPreference.PRIMARY;
    const dropIndexOperation = new DropIndexOperation(this, indexName, options);
    return executeOperation(this.s.topology, dropIndexOperation, callback);
  };
  Collection2.prototype.dropIndexes = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options ? Object.assign({}, options) : {};
    if (typeof options.maxTimeMS !== "number")
      delete options.maxTimeMS;
    const dropIndexesOperation = new DropIndexesOperation(this, options);
    return executeOperation(this.s.topology, dropIndexesOperation, callback);
  };
  Collection2.prototype.dropAllIndexes = deprecate(Collection2.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
  Collection2.prototype.reIndex = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const reIndexOperation = new ReIndexOperation(this, options);
    return executeOperation(this.s.topology, reIndexOperation, callback);
  }, "collection.reIndex is deprecated. Use db.command instead.");
  Collection2.prototype.listIndexes = function(options) {
    const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options), options);
    return cursor;
  };
  Collection2.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.s.topology, ensureIndex, [
      this,
      fieldOrSpec,
      options,
      callback
    ]);
  }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
  Collection2.prototype.indexExists = function(indexes, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexExistsOperation = new IndexExistsOperation(this, indexes, options);
    return executeOperation(this.s.topology, indexExistsOperation, callback);
  };
  Collection2.prototype.indexInformation = function(options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options);
    return executeOperation(this.s.topology, indexInformationOperation, callback);
  };
  Collection2.prototype.count = deprecate(function(query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    query = args.length ? args.shift() || {} : {};
    options = args.length ? args.shift() || {} : {};
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options), callback);
  }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
  Collection2.prototype.estimatedDocumentCount = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);
    return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
  };
  Collection2.prototype.countDocuments = function(query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    query = args.length ? args.shift() || {} : {};
    options = args.length ? args.shift() || {} : {};
    const countDocumentsOperation = new CountDocumentsOperation(this, query, options);
    return executeOperation(this.s.topology, countDocumentsOperation, callback);
  };
  Collection2.prototype.distinct = function(key, query, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    const queryOption = args.length ? args.shift() || {} : {};
    const optionsOption = args.length ? args.shift() || {} : {};
    const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
    return executeOperation(this.s.topology, distinctOperation, callback);
  };
  Collection2.prototype.indexes = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    const indexesOperation = new IndexesOperation(this, options);
    return executeOperation(this.s.topology, indexesOperation, callback);
  };
  Collection2.prototype.stats = function(options, callback) {
    const args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const statsOperation = new StatsOperation(this, options);
    return executeOperation(this.s.topology, statsOperation, callback);
  };
  Collection2.prototype.findOneAndDelete = function(filter, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options), callback);
  };
  Collection2.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options), callback);
  };
  Collection2.prototype.findOneAndUpdate = function(filter, update, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options), callback);
  };
  Collection2.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
  Collection2.prototype._findAndModify = _findAndModify;
  function _findAndModify(query, sort, doc, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    sort = args.length ? args.shift() || [] : [];
    doc = args.length ? args.shift() : null;
    options = args.length ? args.shift() || {} : {};
    options = Object.assign({}, options);
    options.readPreference = ReadPreference.PRIMARY;
    return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options), callback);
  }
  Collection2.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    sort = args.length ? args.shift() || [] : [];
    options = args.length ? args.shift() || {} : {};
    options.remove = true;
    return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options), callback);
  }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
  Collection2.prototype.aggregate = function(pipeline, options, callback) {
    if (Array.isArray(pipeline)) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (options == null && callback == null) {
        options = {};
      }
    } else {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      const opts = args[args.length - 1];
      options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
      pipeline = args;
    }
    const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
    if (typeof callback === "function") {
      callback(null, cursor);
      return;
    }
    return cursor;
  };
  Collection2.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  Collection2.prototype.parallelCollectionScan = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {numCursors: 1};
    options.numCursors = options.numCursors || 1;
    options.batchSize = options.batchSize || 1e3;
    options = Object.assign({}, options);
    options.readPreference = ReadPreference.resolve(this, options);
    options.promiseLibrary = this.s.promiseLibrary;
    if (options.session) {
      options.session = void 0;
    }
    return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {skipSessions: true});
  }, "parallelCollectionScan is deprecated in MongoDB v4.1");
  Collection2.prototype.geoHaystackSearch = deprecate(function(x, y, options, callback) {
    const args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() || {} : {};
    const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);
    return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
  }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
  Collection2.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options, callback) {
    const args = Array.prototype.slice.call(arguments, 3);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    reduce = args.length ? args.shift() : null;
    finalize = args.length ? args.shift() : null;
    command = args.length ? args.shift() : null;
    options = args.length ? args.shift() || {} : {};
    if (!(typeof finalize === "function")) {
      command = finalize;
      finalize = null;
    }
    if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
      keys = Object.keys(keys);
    }
    if (typeof reduce === "function") {
      reduce = reduce.toString();
    }
    if (typeof finalize === "function") {
      finalize = finalize.toString();
    }
    command = command == null ? true : command;
    return executeLegacyOperation(this.s.topology, group, [
      this,
      keys,
      condition,
      initial,
      reduce,
      finalize,
      command,
      options,
      callback
    ]);
  }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
  Collection2.prototype.mapReduce = function(map, reduce, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    if (options.out == null) {
      throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
    }
    if (typeof map === "function") {
      map = map.toString();
    }
    if (typeof reduce === "function") {
      reduce = reduce.toString();
    }
    if (typeof options.finalize === "function") {
      options.finalize = options.finalize.toString();
    }
    const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);
    return executeOperation(this.s.topology, mapReduceOperation, callback);
  };
  Collection2.prototype.initializeUnorderedBulkOp = function(options) {
    options = options || {};
    if (options.ignoreUndefined == null) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options.promiseLibrary = this.s.promiseLibrary;
    return unordered(this.s.topology, this, options);
  };
  Collection2.prototype.initializeOrderedBulkOp = function(options) {
    options = options || {};
    if (options.ignoreUndefined == null) {
      options.ignoreUndefined = this.s.options.ignoreUndefined;
    }
    options.promiseLibrary = this.s.promiseLibrary;
    return ordered(this.s.topology, this, options);
  };
  Collection2.prototype.getLogger = function() {
    return this.s.db.s.logger;
  };
  module2.exports = Collection2;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Denque = require_denque();
  var EventEmitter2 = require("events");
  var isResumableError = require_error2().isResumableError;
  var MongoError = require_core().MongoError;
  var Cursor = require_cursor2();
  var relayEvents = require_utils2().relayEvents;
  var maxWireVersion = require_utils2().maxWireVersion;
  var maybePromise = require_utils4().maybePromise;
  var now = require_utils4().now;
  var calculateDurationInMs = require_utils4().calculateDurationInMs;
  var AggregateOperation = require_aggregate();
  var kResumeQueue = Symbol("resumeQueue");
  var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
  var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var ChangeStream = class extends EventEmitter2 {
    constructor(parent, pipeline, options) {
      super();
      const Collection2 = require_collection();
      const Db = require_db();
      const MongoClient2 = require_mongo_client();
      this.pipeline = pipeline || [];
      this.options = options || {};
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (parent instanceof Collection2) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
        this.topology = parent.s.db.serverConfig;
      } else if (parent instanceof Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
        this.topology = parent.serverConfig;
      } else if (parent instanceof MongoClient2) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
        this.topology = parent.topology;
      } else {
        throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
      }
      this.promiseLibrary = parent.s.promiseLibrary;
      if (!this.options.readPreference && parent.s.readPreference) {
        this.options.readPreference = parent.s.readPreference;
      }
      this[kResumeQueue] = new Denque();
      this.cursor = createChangeStreamCursor(this, options);
      this.closed = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this.cursor.on("data", (change) => processNewChange(this, change));
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this.cursor.removeAllListeners("data");
        }
      });
    }
    get resumeToken() {
      return this.cursor.resumeToken;
    }
    hasNext(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        getCursor(this, (err, cursor) => {
          if (err)
            return cb(err);
          cursor.hasNext(cb);
        });
      });
    }
    next(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        getCursor(this, (err, cursor) => {
          if (err)
            return cb(err);
          cursor.next((error, change) => {
            if (error) {
              this[kResumeQueue].push(() => this.next(cb));
              processError(this, error, cb);
              return;
            }
            processNewChange(this, change, cb);
          });
        });
      });
    }
    isClosed() {
      return this.closed || this.cursor && this.cursor.isClosed();
    }
    close(callback) {
      return maybePromise(this.parent, callback, (cb) => {
        if (this.closed)
          return cb();
        this.closed = true;
        if (!this.cursor)
          return cb();
        const cursor = this.cursor;
        return cursor.close((err) => {
          ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
          this.cursor = void 0;
          return cb(err);
        });
      });
    }
    pipe(destination, options) {
      if (!this.pipeDestinations) {
        this.pipeDestinations = [];
      }
      this.pipeDestinations.push(destination);
      return this.cursor.pipe(destination, options);
    }
    unpipe(destination) {
      if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
        this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
      }
      return this.cursor.unpipe(destination);
    }
    stream(options) {
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    pause() {
      return this.cursor.pause();
    }
    resume() {
      return this.cursor.resume();
    }
  };
  var ChangeStreamCursor = class extends Cursor {
    constructor(topology, operation, options) {
      super(topology, operation, options);
      options = options || {};
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit("resumeTokenChanged", token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const result = {};
      for (const optionName of CURSOR_OPTIONS) {
        if (this.options[optionName])
          result[optionName] = this.options[optionName];
      }
      if (this.resumeToken || this.startAtOperationTime) {
        ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
        if (this.resumeToken) {
          const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
          result[resumeKey] = this.resumeToken;
        } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
          result.startAtOperationTime = this.startAtOperationTime;
        }
      }
      return result;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
        this.resumeToken = this.cursorState.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(batchName, response) {
      const cursor = response.cursor;
      if (cursor.postBatchResumeToken) {
        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
        if (cursor[batchName].length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
    _initializeCursor(callback) {
      super._initializeCursor((err, result) => {
        if (err || result == null) {
          callback(err, result);
          return;
        }
        const response = result.documents[0];
        if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
          this.startAtOperationTime = response.operationTime;
        }
        this._processBatch("firstBatch", response);
        this.emit("init", result);
        this.emit("response");
        callback(err, result);
      });
    }
    _getMore(callback) {
      super._getMore((err, response) => {
        if (err) {
          callback(err);
          return;
        }
        this._processBatch("nextBatch", response);
        this.emit("more", response);
        this.emit("response");
        callback(err, response);
      });
    }
  };
  function createChangeStreamCursor(self2, options) {
    const changeStreamStageOptions = {fullDocument: options.fullDocument || "default"};
    applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);
    if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
      changeStreamStageOptions.allChangesForCluster = true;
    }
    const pipeline = [{$changeStream: changeStreamStageOptions}].concat(self2.pipeline);
    const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);
    const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline, options), cursorOptions);
    relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
    if (self2.listenerCount("change") > 0) {
      changeStreamCursor.on("data", function(change) {
        processNewChange(self2, change);
      });
    }
    changeStreamCursor.on("error", function(error) {
      processError(self2, error);
    });
    if (self2.pipeDestinations) {
      const cursorStream = changeStreamCursor.stream(self2.streamOptions);
      for (let pipeDestination of self2.pipeDestinations) {
        cursorStream.pipe(pipeDestination);
      }
    }
    return changeStreamCursor;
  }
  function applyKnownOptions(target, source, optionNames) {
    optionNames.forEach((name) => {
      if (source[name]) {
        target[name] = source[name];
      }
    });
    return target;
  }
  var SELECTION_TIMEOUT = 3e4;
  function waitForTopologyConnected(topology, options, callback) {
    setTimeout(() => {
      if (options && options.start == null) {
        options.start = now();
      }
      const start = options.start || now();
      const timeout = options.timeout || SELECTION_TIMEOUT;
      const readPreference = options.readPreference;
      if (topology.isConnected({readPreference})) {
        return callback();
      }
      if (calculateDurationInMs(start) > timeout) {
        return callback(new MongoError("Timed out waiting for connection"));
      }
      waitForTopologyConnected(topology, options, callback);
    }, 500);
  }
  function processNewChange(changeStream, change, callback) {
    const cursor = changeStream.cursor;
    if (change == null) {
      changeStream.closed = true;
    }
    if (changeStream.closed) {
      if (callback)
        callback(new MongoError("ChangeStream is closed"));
      return;
    }
    if (change && !change._id) {
      const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
      if (!callback)
        return changeStream.emit("error", noResumeTokenError);
      return callback(noResumeTokenError);
    }
    cursor.cacheResumeToken(change._id);
    changeStream.options.startAtOperationTime = void 0;
    if (!callback)
      return changeStream.emit("change", change);
    return callback(void 0, change);
  }
  function processError(changeStream, error, callback) {
    const topology = changeStream.topology;
    const cursor = changeStream.cursor;
    if (changeStream.closed) {
      if (callback)
        callback(new MongoError("ChangeStream is closed"));
      return;
    }
    function resumeWithCursor(newCursor) {
      changeStream.cursor = newCursor;
      processResumeQueue(changeStream);
    }
    function unresumableError(err) {
      if (!callback) {
        changeStream.emit("error", err);
        changeStream.emit("close");
      }
      processResumeQueue(changeStream, err);
      changeStream.closed = true;
    }
    if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {
      changeStream.cursor = void 0;
      ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
      cursor.close();
      waitForTopologyConnected(topology, {readPreference: cursor.options.readPreference}, (err) => {
        if (err)
          return unresumableError(err);
        const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
        if (!callback)
          return resumeWithCursor(newCursor);
        newCursor.hasNext((err2) => {
          if (err2)
            return unresumableError(err2);
          resumeWithCursor(newCursor);
        });
      });
      return;
    }
    if (!callback)
      return changeStream.emit("error", error);
    return callback(error);
  }
  function getCursor(changeStream, callback) {
    if (changeStream.isClosed()) {
      callback(new MongoError("ChangeStream is closed."));
      return;
    }
    if (changeStream.cursor) {
      callback(void 0, changeStream.cursor);
      return;
    }
    changeStream[kResumeQueue].push(callback);
  }
  function processResumeQueue(changeStream, err) {
    while (changeStream[kResumeQueue].length) {
      const request = changeStream[kResumeQueue].pop();
      if (changeStream.isClosed() && !err) {
        request(new MongoError("Change Stream is not open."));
        return;
      }
      request(err, changeStream.cursor);
    }
  }
  module2.exports = ChangeStream;
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS((exports2) => {
  "use strict";
  var EventEmitter2 = require("events");
  var MongoError = require_core().MongoError;
  var f = require("util").format;
  var ReadPreference = require_core().ReadPreference;
  var ClientSession = require_core().Sessions.ClientSession;
  var Store = function(topology, storeOptions) {
    var self2 = this;
    var storedOps = [];
    storeOptions = storeOptions || {force: false, bufferMaxEntries: -1};
    this.s = {
      storedOps,
      storeOptions,
      topology
    };
    Object.defineProperty(this, "length", {
      enumerable: true,
      get: function() {
        return self2.s.storedOps.length;
      }
    });
  };
  Store.prototype.add = function(opType, ns, ops, options, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({message: "db closed by application", driver: true}));
    }
    if (this.s.storeOptions.bufferMaxEntries === 0) {
      return callback(MongoError.create({
        message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
        driver: true
      }));
    }
    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      return;
    }
    this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback});
  };
  Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({message: "db closed by application", driver: true}));
    }
    if (this.s.storeOptions.bufferMaxEntries === 0) {
      return callback(MongoError.create({
        message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
        driver: true
      }));
    }
    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      return;
    }
    this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback});
  };
  Store.prototype.flush = function(err) {
    while (this.s.storedOps.length > 0) {
      this.s.storedOps.shift().c(err || MongoError.create({message: f("no connection available for operation"), driver: true}));
    }
  };
  var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
  var secondaryOptions = ["secondary", "secondaryPreferred"];
  Store.prototype.execute = function(options) {
    options = options || {};
    var ops = this.s.storedOps;
    this.s.storedOps = [];
    var executePrimary = typeof options.executePrimary === "boolean" ? options.executePrimary : true;
    var executeSecondary = typeof options.executeSecondary === "boolean" ? options.executeSecondary : true;
    while (ops.length > 0) {
      var op = ops.shift();
      if (op.t === "cursor") {
        if (executePrimary && executeSecondary) {
          op.o[op.m].apply(op.o, op.p);
        } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
          op.o[op.m].apply(op.o, op.p);
        } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
          op.o[op.m].apply(op.o, op.p);
        }
      } else if (op.t === "auth") {
        this.s.topology[op.t].apply(this.s.topology, op.o);
      } else {
        if (executePrimary && executeSecondary) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        }
      }
    }
  };
  Store.prototype.all = function() {
    return this.s.storedOps;
  };
  var ServerCapabilities = function(ismaster) {
    var setup_get_property = function(object, name, value) {
      Object.defineProperty(object, name, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var aggregationCursor = false;
    var writeCommands = false;
    var textSearch = false;
    var authCommands = false;
    var listCollections = false;
    var listIndexes = false;
    var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
    var commandsTakeWriteConcern = false;
    var commandsTakeCollation = false;
    if (ismaster.minWireVersion >= 0) {
      textSearch = true;
    }
    if (ismaster.maxWireVersion >= 1) {
      aggregationCursor = true;
      authCommands = true;
    }
    if (ismaster.maxWireVersion >= 2) {
      writeCommands = true;
    }
    if (ismaster.maxWireVersion >= 3) {
      listCollections = true;
      listIndexes = true;
    }
    if (ismaster.maxWireVersion >= 5) {
      commandsTakeWriteConcern = true;
      commandsTakeCollation = true;
    }
    if (ismaster.minWireVersion == null) {
      ismaster.minWireVersion = 0;
    }
    if (ismaster.maxWireVersion == null) {
      ismaster.maxWireVersion = 0;
    }
    setup_get_property(this, "hasAggregationCursor", aggregationCursor);
    setup_get_property(this, "hasWriteCommands", writeCommands);
    setup_get_property(this, "hasTextSearch", textSearch);
    setup_get_property(this, "hasAuthCommands", authCommands);
    setup_get_property(this, "hasListCollectionsCommand", listCollections);
    setup_get_property(this, "hasListIndexesCommand", listIndexes);
    setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
    setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
    setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
    setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
    setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
  };
  var TopologyBase = class extends EventEmitter2 {
    constructor() {
      super();
      this.setMaxListeners(Infinity);
    }
    hasSessionSupport() {
      return this.logicalSessionTimeoutMinutes != null;
    }
    startSession(options, clientOptions) {
      const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
      session.once("ended", () => {
        this.s.sessions.delete(session);
      });
      this.s.sessions.add(session);
      return session;
    }
    endSessions(sessions, callback) {
      return this.s.coreTopology.endSessions(sessions, callback);
    }
    get clientMetadata() {
      return this.s.coreTopology.s.options.metadata;
    }
    capabilities() {
      if (this.s.sCapabilities)
        return this.s.sCapabilities;
      if (this.s.coreTopology.lastIsMaster() == null)
        return null;
      this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
      return this.s.sCapabilities;
    }
    command(ns, cmd, options, callback) {
      this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options), callback);
    }
    insert(ns, ops, options, callback) {
      this.s.coreTopology.insert(ns.toString(), ops, options, callback);
    }
    update(ns, ops, options, callback) {
      this.s.coreTopology.update(ns.toString(), ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      this.s.coreTopology.remove(ns.toString(), ops, options, callback);
    }
    isConnected(options) {
      options = options || {};
      options = ReadPreference.translate(options);
      return this.s.coreTopology.isConnected(options);
    }
    isDestroyed() {
      return this.s.coreTopology.isDestroyed();
    }
    cursor(ns, cmd, options) {
      options = options || {};
      options = ReadPreference.translate(options);
      options.disconnectHandler = this.s.store;
      options.topology = this;
      return this.s.coreTopology.cursor(ns, cmd, options);
    }
    lastIsMaster() {
      return this.s.coreTopology.lastIsMaster();
    }
    selectServer(selector, options, callback) {
      return this.s.coreTopology.selectServer(selector, options, callback);
    }
    unref() {
      return this.s.coreTopology.unref();
    }
    connections() {
      return this.s.coreTopology.connections();
    }
    close(forceClosed, callback) {
      this.s.sessions.forEach((session) => session.endSession());
      if (this.s.sessionPool) {
        this.s.sessionPool.endAllPooledSessions();
      }
      if (forceClosed === true) {
        this.s.storeOptions.force = forceClosed;
        this.s.store.flush();
      }
      this.s.coreTopology.destroy({
        force: typeof forceClosed === "boolean" ? forceClosed : false
      }, callback);
    }
  };
  Object.defineProperty(TopologyBase.prototype, "bson", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.bson;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "parserType", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.parserType;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.logicalSessionTimeoutMinutes;
    }
  });
  Object.defineProperty(TopologyBase.prototype, "type", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.type;
    }
  });
  exports2.Store = Store;
  exports2.ServerCapabilities = ServerCapabilities;
  exports2.TopologyBase = TopologyBase;
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS((exports2, module2) => {
  "use strict";
  var Topology = require_core().Topology;
  var ServerCapabilities = require_topology_base().ServerCapabilities;
  var Cursor = require_cursor2();
  var translateOptions = require_utils4().translateOptions;
  var NativeTopology = class extends Topology {
    constructor(servers, options) {
      options = options || {};
      let clonedOptions = Object.assign({}, {
        cursorFactory: Cursor,
        reconnect: false,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : typeof options.poolSize === "number" ? options.poolSize : 10,
        minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : typeof options.minSize === "number" ? options.minSize : 0,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      super(servers, clonedOptions);
    }
    capabilities() {
      if (this.s.sCapabilities)
        return this.s.sCapabilities;
      if (this.lastIsMaster() == null)
        return null;
      this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
      return this.s.sCapabilities;
    }
    command(ns, cmd, options, callback) {
      super.command(ns.toString(), cmd, options, callback);
    }
    insert(ns, ops, options, callback) {
      super.insert(ns.toString(), ops, options, callback);
    }
    update(ns, ops, options, callback) {
      super.update(ns.toString(), ops, options, callback);
    }
    remove(ns, ops, options, callback) {
      super.remove(ns.toString(), ops, options, callback);
    }
  };
  module2.exports = NativeTopology;
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS((exports2, module2) => {
  "use strict";
  var CServer = require_core().Server;
  var Cursor = require_cursor2();
  var TopologyBase = require_topology_base().TopologyBase;
  var Store = require_topology_base().Store;
  var MongoError = require_core().MongoError;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "acceptableLatencyMS",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCRL",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "family",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "reconnectInterval",
    "monitoring",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "compression",
    "promiseLibrary",
    "monitorCommands"
  ];
  var Server = class extends TopologyBase {
    constructor(host, port, options) {
      super();
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      const promiseLibrary = options.promiseLibrary;
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      if (host.indexOf("/") !== -1) {
        if (port != null && typeof port === "object") {
          options = port;
          port = null;
        }
      } else if (port == null) {
        throw MongoError.create({message: "port must be specified", driver: true});
      }
      var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        host,
        port,
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      this.s = {
        coreTopology: new CServer(clonedOptions),
        sCapabilities: null,
        clonedOptions,
        reconnect: clonedOptions.reconnect,
        emitError: clonedOptions.emitError,
        poolSize: clonedOptions.size,
        storeOptions,
        store,
        host,
        port,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: promiseLibrary || Promise
      };
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = this.s.clonedOptions;
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var connectErrorHandler = function() {
        return function(err) {
          var events = ["timeout", "error", "close"];
          events.forEach(function(e) {
            self2.s.coreTopology.removeListener(e, connectHandlers[e]);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          try {
            callback(err);
          } catch (err2) {
            process.nextTick(function() {
              throw err2;
            });
          }
        };
      };
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var reconnectHandler = function() {
        self2.emit("reconnect", self2);
        self2.s.store.execute();
      };
      var reconnectFailedHandler = function(err) {
        self2.emit("reconnectFailed", err);
        self2.s.store.flush(err);
      };
      var destroyHandler = function() {
        self2.s.store.flush();
      };
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var connectHandler = function() {
        ["timeout", "error", "close", "destroy"].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("timeout", errorHandler("timeout"));
        self2.s.coreTopology.once("error", errorHandler("error"));
        self2.s.coreTopology.on("close", errorHandler("close"));
        self2.s.coreTopology.on("destroy", destroyHandler);
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var connectHandlers = {
        timeout: connectErrorHandler("timeout"),
        error: connectErrorHandler("error"),
        close: connectErrorHandler("close")
      };
      [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed"
      ].forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      self2.s.coreTopology.once("timeout", connectHandlers.timeout);
      self2.s.coreTopology.once("error", connectHandlers.error);
      self2.s.coreTopology.once("close", connectHandlers.close);
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.on("reconnect", reconnectHandler);
      self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
      self2.s.coreTopology.on("monitoring", relay("monitoring"));
      self2.s.coreTopology.connect(_options);
    }
  };
  Object.defineProperty(Server.prototype, "poolSize", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.connections().length;
    }
  });
  Object.defineProperty(Server.prototype, "autoReconnect", {
    enumerable: true,
    get: function() {
      return this.s.reconnect;
    }
  });
  Object.defineProperty(Server.prototype, "host", {
    enumerable: true,
    get: function() {
      return this.s.host;
    }
  });
  Object.defineProperty(Server.prototype, "port", {
    enumerable: true,
    get: function() {
      return this.s.port;
    }
  });
  module2.exports = Server;
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS((exports2, module2) => {
  "use strict";
  var TopologyBase = require_topology_base().TopologyBase;
  var MongoError = require_core().MongoError;
  var CMongos = require_core().Mongos;
  var Cursor = require_cursor2();
  var Server = require_server3();
  var Store = require_topology_base().Store;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "acceptableLatencyMS",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCRL",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "promiseLibrary",
    "monitorCommands"
  ];
  var Mongos = class extends TopologyBase {
    constructor(servers, options) {
      super();
      options = options || {};
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      var seedlist = servers.map(function(x) {
        return {host: x.host, port: x.port};
      });
      var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      this.s = {
        coreTopology: new CMongos(seedlist, clonedOptions),
        sCapabilities: null,
        debug: clonedOptions.debug,
        storeOptions,
        clonedOptions,
        store,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise
      };
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = {};
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var connectErrorHandler = function() {
        return function(err) {
          var events2 = ["timeout", "error", "close"];
          events2.forEach(function(e) {
            self2.removeListener(e, connectErrorHandler);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          self2.close(true);
          try {
            callback(err);
          } catch (err2) {
            process.nextTick(function() {
              throw err2;
            });
          }
        };
      };
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var reconnectHandler = function() {
        self2.emit("reconnect");
        self2.s.store.execute();
      };
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var connectHandler = function() {
        var events2 = ["timeout", "error", "close", "fullsetup"];
        events2.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("timeout", errorHandler("timeout"));
        self2.s.coreTopology.on("error", errorHandler("error"));
        self2.s.coreTopology.on("close", errorHandler("close"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2);
        });
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var events = [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed"
      ];
      events.forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
      self2.s.coreTopology.once("error", connectErrorHandler("error"));
      self2.s.coreTopology.once("close", connectErrorHandler("close"));
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.on("joined", relay("joined"));
      self2.s.coreTopology.on("left", relay("left"));
      self2.s.coreTopology.on("reconnect", reconnectHandler);
      self2.s.coreTopology.connect(_options);
    }
  };
  Object.defineProperty(Mongos.prototype, "haInterval", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.haInterval;
    }
  });
  module2.exports = Mongos;
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS((exports2, module2) => {
  "use strict";
  var Server = require_server3();
  var Cursor = require_cursor2();
  var MongoError = require_core().MongoError;
  var TopologyBase = require_topology_base().TopologyBase;
  var Store = require_topology_base().Store;
  var CReplSet = require_core().ReplSet;
  var MAX_JS_INT = require_utils4().MAX_JS_INT;
  var translateOptions = require_utils4().translateOptions;
  var filterOptions = require_utils4().filterOptions;
  var mergeOptions = require_utils4().mergeOptions;
  var legalOptionNames = [
    "ha",
    "haInterval",
    "replicaSet",
    "rs_name",
    "secondaryAcceptableLatencyMS",
    "connectWithNoPrimary",
    "poolSize",
    "ssl",
    "checkServerIdentity",
    "sslValidate",
    "sslCA",
    "sslCert",
    "ciphers",
    "ecdhCurve",
    "sslCRL",
    "sslKey",
    "sslPass",
    "socketOptions",
    "bufferMaxEntries",
    "store",
    "auto_reconnect",
    "autoReconnect",
    "emitError",
    "keepAlive",
    "keepAliveInitialDelay",
    "noDelay",
    "connectTimeoutMS",
    "socketTimeoutMS",
    "strategy",
    "debug",
    "family",
    "loggerLevel",
    "logger",
    "reconnectTries",
    "appname",
    "domainsEnabled",
    "servername",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "maxStalenessSeconds",
    "promiseLibrary",
    "minSize",
    "monitorCommands"
  ];
  var ReplSet = class extends TopologyBase {
    constructor(servers, options) {
      super();
      options = options || {};
      var self2 = this;
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self2, storeOptions);
      var seedlist = servers.map(function(x) {
        return {host: x.host, port: x.port};
      });
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: false,
        emitError: typeof options.emitError === "boolean" ? options.emitError : true,
        size: typeof options.poolSize === "number" ? options.poolSize : 5,
        monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      var coreTopology = new CReplSet(seedlist, clonedOptions);
      coreTopology.on("reconnect", function() {
        self2.emit("reconnect");
        store.execute();
      });
      this.s = {
        coreTopology,
        sCapabilities: null,
        tag: options.tag,
        storeOptions,
        clonedOptions,
        store,
        options,
        sessionPool: null,
        sessions: new Set(),
        promiseLibrary: options.promiseLibrary || Promise
      };
      if (clonedOptions.debug) {
        Object.defineProperty(this, "replset", {
          enumerable: true,
          get: function() {
            return coreTopology;
          }
        });
      }
    }
    connect(_options, callback) {
      var self2 = this;
      if (typeof _options === "function")
        callback = _options, _options = {};
      if (_options == null)
        _options = {};
      if (!(typeof callback === "function"))
        callback = null;
      _options = Object.assign({}, this.s.clonedOptions, _options);
      self2.s.options = _options;
      self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
      var errorHandler = function(event) {
        return function(err) {
          if (event !== "error") {
            self2.emit(event, err);
          }
        };
      };
      var events = [
        "timeout",
        "error",
        "close",
        "serverOpening",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "serverClosed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "joined",
        "left",
        "ping",
        "ha"
      ];
      events.forEach(function(e) {
        self2.s.coreTopology.removeAllListeners(e);
      });
      var relay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server);
        };
      };
      var replsetRelay = function(event) {
        return function(t, server) {
          self2.emit(event, t, server.lastIsMaster(), server);
        };
      };
      var relayHa = function(t, state) {
        self2.emit("ha", t, state);
        if (t === "start") {
          self2.emit("ha_connect", t, state);
        } else if (t === "end") {
          self2.emit("ha_ismaster", t, state);
        }
      };
      self2.s.coreTopology.on("joined", replsetRelay("joined"));
      self2.s.coreTopology.on("left", relay("left"));
      self2.s.coreTopology.on("ping", relay("ping"));
      self2.s.coreTopology.on("ha", relayHa);
      self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
      self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
      self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
      self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
      self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
      self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
      self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
      self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
      self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
      self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
      self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
      self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
      self2.s.coreTopology.on("fullsetup", function() {
        self2.emit("fullsetup", self2, self2);
      });
      self2.s.coreTopology.on("all", function() {
        self2.emit("all", null, self2);
      });
      var connectHandler = function() {
        self2.s.coreTopology.once("timeout", errorHandler("timeout"));
        self2.s.coreTopology.once("error", errorHandler("error"));
        self2.s.coreTopology.once("close", errorHandler("close"));
        self2.emit("open", null, self2);
        try {
          callback(null, self2);
        } catch (err) {
          process.nextTick(function() {
            throw err;
          });
        }
      };
      var connectErrorHandler = function() {
        return function(err) {
          ["timeout", "error", "close"].forEach(function(e) {
            self2.s.coreTopology.removeListener(e, connectErrorHandler);
          });
          self2.s.coreTopology.removeListener("connect", connectErrorHandler);
          self2.s.coreTopology.destroy();
          try {
            callback(err);
          } catch (err2) {
            if (!self2.s.coreTopology.isConnected())
              process.nextTick(function() {
                throw err2;
              });
          }
        };
      };
      self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
      self2.s.coreTopology.once("error", connectErrorHandler("error"));
      self2.s.coreTopology.once("close", connectErrorHandler("close"));
      self2.s.coreTopology.once("connect", connectHandler);
      self2.s.coreTopology.connect(_options);
    }
    close(forceClosed, callback) {
      ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
      super.close(forceClosed, callback);
    }
  };
  Object.defineProperty(ReplSet.prototype, "haInterval", {
    enumerable: true,
    get: function() {
      return this.s.coreTopology.s.haInterval;
    }
  });
  module2.exports = ReplSet;
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS((exports2, module2) => {
  "use strict";
  var ReadPreference = require_core().ReadPreference;
  var parser = require("url");
  var f = require("util").format;
  var Logger = require_core().Logger;
  var dns = require("dns");
  var ReadConcern = require_read_concern();
  module2.exports = function(url, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    let result;
    try {
      result = parser.parse(url, true);
    } catch (e) {
      return callback(new Error("URL malformed, cannot be parsed"));
    }
    if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
      return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
    }
    if (result.protocol === "mongodb:") {
      return parseHandler(url, options, callback);
    }
    if (result.hostname.split(".").length < 3) {
      return callback(new Error("URI does not have hostname, domain name and tld"));
    }
    result.domainLength = result.hostname.split(".").length;
    if (result.pathname && result.pathname.match(",")) {
      return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
    }
    if (result.port) {
      return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
    }
    let srvAddress = `_mongodb._tcp.${result.host}`;
    dns.resolveSrv(srvAddress, function(err, addresses) {
      if (err)
        return callback(err);
      if (addresses.length === 0) {
        return callback(new Error("No addresses found at host"));
      }
      for (let i = 0; i < addresses.length; i++) {
        if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
          return callback(new Error("Server record does not share hostname with parent URI"));
        }
      }
      let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
      let connectionStrings = addresses.map(function(address, i) {
        if (i === 0)
          return `${base}${address.name}:${address.port}`;
        else
          return `${address.name}:${address.port}`;
      });
      let connectionString = connectionStrings.join(",") + "/";
      let connectionStringOptions = [];
      if (result.path) {
        let defaultDb = result.path.slice(1);
        if (defaultDb.indexOf("?") !== -1) {
          defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
        }
        connectionString += defaultDb;
      }
      if (!options.ssl && !result.search) {
        connectionStringOptions.push("ssl=true");
      } else if (!options.ssl && result.search && !result.search.match("ssl")) {
        connectionStringOptions.push("ssl=true");
      }
      if (result.search) {
        connectionStringOptions.push(result.search.replace("?", ""));
      }
      dns.resolveTxt(result.host, function(err2, record) {
        if (err2 && err2.code !== "ENODATA")
          return callback(err2);
        if (err2 && err2.code === "ENODATA")
          record = null;
        if (record) {
          if (record.length > 1) {
            return callback(new Error("Multiple text records not allowed"));
          }
          record = record[0];
          if (record.length > 1)
            record = record.join("");
          else
            record = record[0];
          if (!record.includes("authSource") && !record.includes("replicaSet")) {
            return callback(new Error("Text record must only set `authSource` or `replicaSet`"));
          }
          connectionStringOptions.push(record);
        }
        if (connectionStringOptions.length) {
          connectionString += `?${connectionStringOptions.join("&")}`;
        }
        parseHandler(connectionString, options, callback);
      });
    });
  };
  function matchesParentDomain(srvAddress, parentDomain) {
    let regex = /^.*?\./;
    let srv = `.${srvAddress.replace(regex, "")}`;
    let parent = `.${parentDomain.replace(regex, "")}`;
    if (srv.endsWith(parent))
      return true;
    else
      return false;
  }
  function parseHandler(address, options, callback) {
    let result, err;
    try {
      result = parseConnectionString(address, options);
    } catch (e) {
      err = e;
    }
    return err ? callback(err, null) : callback(null, result);
  }
  function parseConnectionString(url, options) {
    let connection_part = "";
    let auth_part = "";
    let query_string_part = "";
    let dbName = "admin";
    let result = parser.parse(url, true);
    if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
      throw new Error("No hostname or hostnames provided in connection string");
    }
    if (result.port === "0") {
      throw new Error("Invalid port (zero) with hostname");
    }
    if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
      throw new Error("Invalid port (larger than 65535) with hostname");
    }
    if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
      throw new Error("Missing delimiting slash between hosts and options");
    }
    if (result.query) {
      for (let name in result.query) {
        if (name.indexOf("::") !== -1) {
          throw new Error("Double colon in host identifier");
        }
        if (result.query[name] === "") {
          throw new Error("Query parameter " + name + " is an incomplete value pair");
        }
      }
    }
    if (result.auth) {
      let parts = result.auth.split(":");
      if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
        throw new Error("Username with password containing an unescaped colon");
      }
      if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
        throw new Error("Username containing an unescaped at-sign");
      }
    }
    let clean = url.split("?").shift();
    let strings = clean.split(",");
    let hosts = [];
    for (let i = 0; i < strings.length; i++) {
      let hostString = strings[i];
      if (hostString.indexOf("mongodb") !== -1) {
        if (hostString.indexOf("@") !== -1) {
          hosts.push(hostString.split("@").pop());
        } else {
          hosts.push(hostString.substr("mongodb://".length));
        }
      } else if (hostString.indexOf("/") !== -1) {
        hosts.push(hostString.split("/").shift());
      } else if (hostString.indexOf("/") === -1) {
        hosts.push(hostString.trim());
      }
    }
    for (let i = 0; i < hosts.length; i++) {
      let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
      if (r.path && r.path.indexOf(".sock") !== -1)
        continue;
      if (r.path && r.path.indexOf(":") !== -1) {
        if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
          throw new Error("Slash in host identifier");
        } else {
          throw new Error("Double colon in host identifier");
        }
      }
    }
    if (url.indexOf("?") !== -1) {
      query_string_part = url.substr(url.indexOf("?") + 1);
      connection_part = url.substring("mongodb://".length, url.indexOf("?"));
    } else {
      connection_part = url.substring("mongodb://".length);
    }
    if (connection_part.indexOf("@") !== -1) {
      auth_part = connection_part.split("@")[0];
      connection_part = connection_part.split("@")[1];
    }
    if (connection_part.split("/").length > 2) {
      throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
    }
    if (connection_part.indexOf(".sock") !== -1) {
      if (connection_part.indexOf(".sock/") !== -1) {
        dbName = connection_part.split(".sock/")[1];
        if (dbName.indexOf("/") !== -1) {
          if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
      }
    } else if (connection_part.indexOf("/") !== -1) {
      if (connection_part.split("/").length > 2) {
        if (connection_part.split("/")[2].length === 0) {
          throw new Error("Illegal trailing backslash after database name");
        }
        throw new Error("More than 1 database name in URL");
      }
      dbName = connection_part.split("/")[1];
      connection_part = connection_part.split("/")[0];
    }
    connection_part = decodeURIComponent(connection_part);
    let object = {};
    let authPart = auth_part || "";
    let auth = authPart.split(":", 2);
    let user = decodeURIComponent(auth[0]);
    if (auth[0] !== encodeURIComponent(user)) {
      throw new Error("Username contains an illegal unescaped character");
    }
    auth[0] = user;
    if (auth[1]) {
      let pass = decodeURIComponent(auth[1]);
      if (auth[1] !== encodeURIComponent(pass)) {
        throw new Error("Password contains an illegal unescaped character");
      }
      auth[1] = pass;
    }
    if (auth.length === 2)
      object.auth = {user: auth[0], password: auth[1]};
    if (options && options.auth != null)
      object.auth = options.auth;
    let hostPart;
    let urlOptions;
    let servers;
    let compression;
    let serverOptions = {socketOptions: {}};
    let dbOptions = {read_preference_tags: []};
    let replSetServersOptions = {socketOptions: {}};
    let mongosOptions = {socketOptions: {}};
    object.server_options = serverOptions;
    object.db_options = dbOptions;
    object.rs_options = replSetServersOptions;
    object.mongos_options = mongosOptions;
    if (url.match(/\.sock/)) {
      let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
      if (domainSocket.indexOf("@") !== -1)
        domainSocket = domainSocket.split("@")[1];
      domainSocket = decodeURIComponent(domainSocket);
      servers = [{domain_socket: domainSocket}];
    } else {
      hostPart = connection_part;
      let deduplicatedServers = {};
      servers = hostPart.split(",").map(function(h) {
        let _host, _port, ipv6match;
        if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
          _host = ipv6match[1];
          _port = parseInt(ipv6match[2], 10) || 27017;
        } else {
          let hostPort = h.split(":", 2);
          _host = hostPort[0] || "localhost";
          _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
          if (_host.indexOf("?") !== -1)
            _host = _host.split(/\?/)[0];
        }
        if (deduplicatedServers[_host + "_" + _port])
          return null;
        deduplicatedServers[_host + "_" + _port] = 1;
        return {host: _host, port: _port};
      }).filter(function(x) {
        return x != null;
      });
    }
    object.dbName = dbName || "admin";
    urlOptions = (query_string_part || "").split(/[&;]/);
    urlOptions.forEach(function(opt) {
      if (!opt)
        return;
      var splitOpt = opt.split("="), name = splitOpt[0], value = splitOpt[1];
      switch (name) {
        case "slaveOk":
        case "slave_ok":
          serverOptions.slave_ok = value === "true";
          dbOptions.slaveOk = value === "true";
          break;
        case "maxPoolSize":
        case "poolSize":
          serverOptions.poolSize = parseInt(value, 10);
          replSetServersOptions.poolSize = parseInt(value, 10);
          break;
        case "appname":
          object.appname = decodeURIComponent(value);
          break;
        case "autoReconnect":
        case "auto_reconnect":
          serverOptions.auto_reconnect = value === "true";
          break;
        case "ssl":
          if (value === "prefer") {
            serverOptions.ssl = value;
            replSetServersOptions.ssl = value;
            mongosOptions.ssl = value;
            break;
          }
          serverOptions.ssl = value === "true";
          replSetServersOptions.ssl = value === "true";
          mongosOptions.ssl = value === "true";
          break;
        case "sslValidate":
          serverOptions.sslValidate = value === "true";
          replSetServersOptions.sslValidate = value === "true";
          mongosOptions.sslValidate = value === "true";
          break;
        case "replicaSet":
        case "rs_name":
          replSetServersOptions.rs_name = value;
          break;
        case "reconnectWait":
          replSetServersOptions.reconnectWait = parseInt(value, 10);
          break;
        case "retries":
          replSetServersOptions.retries = parseInt(value, 10);
          break;
        case "readSecondary":
        case "read_secondary":
          replSetServersOptions.read_secondary = value === "true";
          break;
        case "fsync":
          dbOptions.fsync = value === "true";
          break;
        case "journal":
          dbOptions.j = value === "true";
          break;
        case "safe":
          dbOptions.safe = value === "true";
          break;
        case "nativeParser":
        case "native_parser":
          dbOptions.native_parser = value === "true";
          break;
        case "readConcernLevel":
          dbOptions.readConcern = new ReadConcern(value);
          break;
        case "connectTimeoutMS":
          serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          break;
        case "socketTimeoutMS":
          serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          break;
        case "w":
          dbOptions.w = parseInt(value, 10);
          if (isNaN(dbOptions.w))
            dbOptions.w = value;
          break;
        case "authSource":
          dbOptions.authSource = value;
          break;
        case "gssapiServiceName":
          dbOptions.gssapiServiceName = value;
          break;
        case "authMechanism":
          if (value === "GSSAPI") {
            if (object.auth == null) {
              let urlDecodeAuthPart = decodeURIComponent(authPart);
              if (urlDecodeAuthPart.indexOf("@") === -1)
                throw new Error("GSSAPI requires a provided principal");
              object.auth = {user: urlDecodeAuthPart, password: null};
            } else {
              object.auth.user = decodeURIComponent(object.auth.user);
            }
          } else if (value === "MONGODB-X509") {
            object.auth = {user: decodeURIComponent(authPart)};
          }
          if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
            throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
          dbOptions.authMechanism = value;
          break;
        case "authMechanismProperties":
          {
            let values = value.split(",");
            let o = {};
            values.forEach(function(x) {
              let v = x.split(":");
              o[v[0]] = v[1];
            });
            dbOptions.authMechanismProperties = o;
            if (typeof o.SERVICE_NAME === "string")
              dbOptions.gssapiServiceName = o.SERVICE_NAME;
            if (typeof o.SERVICE_REALM === "string")
              dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
            if (typeof o.CANONICALIZE_HOST_NAME === "string")
              dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
          }
          break;
        case "wtimeoutMS":
          dbOptions.wtimeout = parseInt(value, 10);
          break;
        case "readPreference":
          if (!ReadPreference.isValid(value))
            throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
          dbOptions.readPreference = value;
          break;
        case "maxStalenessSeconds":
          dbOptions.maxStalenessSeconds = parseInt(value, 10);
          break;
        case "readPreferenceTags":
          {
            value = decodeURIComponent(value);
            let tagObject = {};
            if (value == null || value === "") {
              dbOptions.read_preference_tags.push(tagObject);
              break;
            }
            let tags = value.split(/,/);
            for (let i = 0; i < tags.length; i++) {
              let parts = tags[i].trim().split(/:/);
              tagObject[parts[0]] = parts[1];
            }
            dbOptions.read_preference_tags.push(tagObject);
          }
          break;
        case "compressors":
          {
            compression = serverOptions.compression || {};
            let compressors = value.split(",");
            if (!compressors.every(function(compressor) {
              return compressor === "snappy" || compressor === "zlib";
            })) {
              throw new Error("Compressors must be at least one of snappy or zlib");
            }
            compression.compressors = compressors;
            serverOptions.compression = compression;
          }
          break;
        case "zlibCompressionLevel":
          {
            compression = serverOptions.compression || {};
            let zlibCompressionLevel = parseInt(value, 10);
            if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
              throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
            }
            compression.zlibCompressionLevel = zlibCompressionLevel;
            serverOptions.compression = compression;
          }
          break;
        case "retryWrites":
          dbOptions.retryWrites = value === "true";
          break;
        case "minSize":
          dbOptions.minSize = parseInt(value, 10);
          break;
        default:
          {
            let logger = Logger("URL Parser");
            logger.warn(`${name} is not supported as a connection string option`);
          }
          break;
      }
    });
    if (dbOptions.read_preference_tags.length === 0) {
      dbOptions.read_preference_tags = null;
    }
    if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
      throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
    if (!dbOptions.readPreference) {
      dbOptions.readPreference = "primary";
    }
    dbOptions = Object.assign(dbOptions, options);
    object.servers = servers;
    return object;
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS((exports2, module2) => {
  "use strict";
  var deprecate = require("util").deprecate;
  var Logger = require_core().Logger;
  var MongoCredentials = require_core().MongoCredentials;
  var MongoError = require_core().MongoError;
  var Mongos = require_mongos2();
  var NativeTopology = require_native_topology();
  var parse = require_core().parseConnectionString;
  var ReadConcern = require_read_concern();
  var ReadPreference = require_core().ReadPreference;
  var ReplSet = require_replset2();
  var Server = require_server3();
  var ServerSessionPool = require_core().Sessions.ServerSessionPool;
  var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
  var fs = require("fs");
  var BSON2 = require_utils3().retrieveBSON();
  var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
  var client;
  function loadClient() {
    if (!client) {
      client = require_mongo_client();
    }
    return client;
  }
  var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
  var AUTH_MECHANISM_INTERNAL_MAP = {
    DEFAULT: "default",
    PLAIN: "plain",
    GSSAPI: "gssapi",
    "MONGODB-CR": "mongocr",
    "MONGODB-X509": "x509",
    "MONGODB-AWS": "mongodb-aws",
    "SCRAM-SHA-1": "scram-sha-1",
    "SCRAM-SHA-256": "scram-sha-256"
  };
  var monitoringEvents = [
    "timeout",
    "close",
    "serverOpening",
    "serverDescriptionChanged",
    "serverHeartbeatStarted",
    "serverHeartbeatSucceeded",
    "serverHeartbeatFailed",
    "serverClosed",
    "topologyOpening",
    "topologyClosed",
    "topologyDescriptionChanged",
    "commandStarted",
    "commandSucceeded",
    "commandFailed",
    "joined",
    "left",
    "ping",
    "ha",
    "all",
    "fullsetup",
    "open"
  ];
  var VALID_AUTH_MECHANISMS = new Set([
    "DEFAULT",
    "PLAIN",
    "GSSAPI",
    "MONGODB-CR",
    "MONGODB-X509",
    "MONGODB-AWS",
    "SCRAM-SHA-1",
    "SCRAM-SHA-256"
  ]);
  var validOptionNames = [
    "poolSize",
    "ssl",
    "sslValidate",
    "sslCA",
    "sslCert",
    "sslKey",
    "sslPass",
    "sslCRL",
    "autoReconnect",
    "noDelay",
    "keepAlive",
    "keepAliveInitialDelay",
    "connectTimeoutMS",
    "family",
    "socketTimeoutMS",
    "reconnectTries",
    "reconnectInterval",
    "ha",
    "haInterval",
    "replicaSet",
    "secondaryAcceptableLatencyMS",
    "acceptableLatencyMS",
    "connectWithNoPrimary",
    "authSource",
    "w",
    "wtimeout",
    "j",
    "forceServerObjectId",
    "serializeFunctions",
    "ignoreUndefined",
    "raw",
    "bufferMaxEntries",
    "readPreference",
    "pkFactory",
    "promiseLibrary",
    "readConcern",
    "maxStalenessSeconds",
    "loggerLevel",
    "logger",
    "promoteValues",
    "promoteBuffers",
    "promoteLongs",
    "domainsEnabled",
    "checkServerIdentity",
    "validateOptions",
    "appname",
    "auth",
    "user",
    "password",
    "authMechanism",
    "compression",
    "fsync",
    "readPreferenceTags",
    "numberOfRetries",
    "auto_reconnect",
    "minSize",
    "monitorCommands",
    "retryWrites",
    "retryReads",
    "useNewUrlParser",
    "useUnifiedTopology",
    "serverSelectionTimeoutMS",
    "useRecoveryToken",
    "autoEncryption",
    "driverInfo",
    "tls",
    "tlsInsecure",
    "tlsinsecure",
    "tlsAllowInvalidCertificates",
    "tlsAllowInvalidHostnames",
    "tlsCAFile",
    "tlsCertificateFile",
    "tlsCertificateKeyFile",
    "tlsCertificateKeyFilePassword",
    "minHeartbeatFrequencyMS",
    "heartbeatFrequencyMS",
    "directConnection",
    "appName",
    "maxPoolSize",
    "minPoolSize",
    "maxIdleTimeMS",
    "waitQueueTimeoutMS"
  ];
  var ignoreOptionNames = ["native_parser"];
  var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
  function validOptions(options) {
    const _validOptions = validOptionNames.concat(legacyOptionNames);
    for (const name in options) {
      if (ignoreOptionNames.indexOf(name) !== -1) {
        continue;
      }
      if (_validOptions.indexOf(name) === -1) {
        if (options.validateOptions) {
          return new MongoError(`option ${name} is not supported`);
        } else {
          console.warn(`the options [${name}] is not supported`);
        }
      }
      if (legacyOptionNames.indexOf(name) !== -1) {
        console.warn(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
      }
    }
  }
  var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
    obj[name.toLowerCase()] = name;
    return obj;
  }, {});
  function addListeners(mongoClient, topology) {
    topology.on("authenticated", createListener(mongoClient, "authenticated"));
    topology.on("error", createListener(mongoClient, "error"));
    topology.on("timeout", createListener(mongoClient, "timeout"));
    topology.on("close", createListener(mongoClient, "close"));
    topology.on("parseError", createListener(mongoClient, "parseError"));
    topology.once("open", createListener(mongoClient, "open"));
    topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
    topology.once("all", createListener(mongoClient, "all"));
    topology.on("reconnect", createListener(mongoClient, "reconnect"));
  }
  function assignTopology(client2, topology) {
    client2.topology = topology;
    if (!(topology instanceof NativeTopology)) {
      topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
    }
  }
  function clearAllEvents(topology) {
    monitoringEvents.forEach((event) => topology.removeAllListeners(event));
  }
  function collectEvents(mongoClient, topology) {
    let MongoClient2 = loadClient();
    const collectedEvents = [];
    if (mongoClient instanceof MongoClient2) {
      monitoringEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          if (event === "open") {
            collectedEvents.push({event, object1: mongoClient});
          } else {
            collectedEvents.push({event, object1, object2});
          }
        });
      });
    }
    return collectedEvents;
  }
  function resolveTLSOptions(options) {
    if (options.tls == null) {
      return;
    }
    ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
      if (options[optionName]) {
        options[optionName] = fs.readFileSync(options[optionName]);
      }
    });
  }
  var emitDeprecationForNonUnifiedTopology = deprecate(() => {
  }, "current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
  function connect(mongoClient, url, options, callback) {
    options = Object.assign({}, options);
    if (callback == null) {
      throw new Error("no callback function provided");
    }
    let didRequestAuthentication = false;
    const logger = Logger("MongoClient", options);
    if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
      return connectWithUrl(mongoClient, url, options, connectCallback);
    }
    const useNewUrlParser = options.useNewUrlParser !== false;
    const parseFn = useNewUrlParser ? parse : legacyParse;
    const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
    parseFn(url, options, (err, _object) => {
      if (err)
        return callback(err);
      const object = transform(_object);
      const _finalOptions = createUnifiedOptions(object, options);
      if (_finalOptions.socketTimeoutMS == null)
        _finalOptions.socketTimeoutMS = 0;
      if (_finalOptions.connectTimeoutMS == null)
        _finalOptions.connectTimeoutMS = 1e4;
      if (_finalOptions.retryWrites == null)
        _finalOptions.retryWrites = true;
      if (_finalOptions.useRecoveryToken == null)
        _finalOptions.useRecoveryToken = true;
      if (_finalOptions.readPreference == null)
        _finalOptions.readPreference = "primary";
      if (_finalOptions.db_options && _finalOptions.db_options.auth) {
        delete _finalOptions.db_options.auth;
      }
      if (_finalOptions.journal != null) {
        _finalOptions.j = _finalOptions.journal;
        _finalOptions.journal = void 0;
      }
      resolveTLSOptions(_finalOptions);
      mongoClient.s.options = _finalOptions;
      if (object.servers.length === 0) {
        return callback(new Error("connection string must contain at least one seed host"));
      }
      if (_finalOptions.auth && !_finalOptions.credentials) {
        try {
          didRequestAuthentication = true;
          _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
        } catch (err2) {
          return callback(err2);
        }
      }
      if (_finalOptions.useUnifiedTopology) {
        return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
      }
      emitDeprecationForNonUnifiedTopology();
      if (_finalOptions.replicaSet || _finalOptions.rs_name) {
        return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
      } else if (object.servers.length > 1) {
        return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
      } else {
        return createServer(mongoClient, _finalOptions, connectCallback);
      }
    });
    function connectCallback(err, topology) {
      const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
      if (err && err.message === "no mongos proxies found in seed list") {
        if (logger.isWarn()) {
          logger.warn(warningMessage);
        }
        return callback(new MongoError(warningMessage));
      }
      if (didRequestAuthentication) {
        mongoClient.emit("authenticated", null, true);
      }
      callback(err, topology);
    }
  }
  function connectWithUrl(mongoClient, url, options, connectCallback) {
    assignTopology(mongoClient, url);
    addListeners(mongoClient, url);
    relayEvents(mongoClient, url);
    let finalOptions = Object.assign({}, options);
    if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
      finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);
    }
    const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
    if (isDoingAuth && !finalOptions.credentials) {
      try {
        finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
      } catch (err) {
        return connectCallback(err, url);
      }
    }
    return url.connect(finalOptions, connectCallback);
  }
  function createListener(mongoClient, event) {
    const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
    return (v1, v2) => {
      if (eventSet.has(event)) {
        return mongoClient.emit(event, mongoClient);
      }
      mongoClient.emit(event, v1, v2);
    };
  }
  function createServer(mongoClient, options, callback) {
    options.promiseLibrary = mongoClient.s.promiseLibrary;
    const servers = translateOptions(options);
    const server = servers[0];
    const collectedEvents = collectEvents(mongoClient, server);
    server.connect(options, (err, topology) => {
      if (err) {
        server.close(true);
        return callback(err);
      }
      clearAllEvents(server);
      relayEvents(mongoClient, server);
      addListeners(mongoClient, server);
      const ismaster = topology.lastIsMaster();
      assignTopology(mongoClient, topology);
      if (ismaster && ismaster.msg === "isdbgrid") {
        topology.close();
        return createTopology(mongoClient, "mongos", options, callback);
      }
      replayEvents(mongoClient, collectedEvents);
      callback(err, topology);
    });
  }
  var DEPRECATED_UNIFIED_EVENTS = new Set([
    "reconnect",
    "reconnectFailed",
    "attemptReconnect",
    "joined",
    "left",
    "ping",
    "ha",
    "all",
    "fullsetup",
    "open"
  ]);
  function registerDeprecatedEventNotifiers(client2) {
    client2.on("newListener", (eventName) => {
      if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
        emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
      }
    });
  }
  function createTopology(mongoClient, topologyType, options, callback) {
    options.promiseLibrary = mongoClient.s.promiseLibrary;
    const translationOptions = {};
    if (topologyType === "unified")
      translationOptions.createServers = false;
    const servers = translateOptions(options, translationOptions);
    if (options.autoEncryption != null) {
      let AutoEncrypter;
      try {
        require.resolve("mongodb-client-encryption");
      } catch (err) {
        callback(new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project"));
        return;
      }
      try {
        let mongodbClientEncryption = require("mongodb-client-encryption");
        if (typeof mongodbClientEncryption.extension !== "function") {
          callback(new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`"));
        }
        AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
      } catch (err) {
        callback(err);
        return;
      }
      const mongoCryptOptions = Object.assign({
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ])
      }, options.autoEncryption);
      options.autoEncrypter = new AutoEncrypter(mongoClient, mongoCryptOptions);
    }
    let topology;
    if (topologyType === "mongos") {
      topology = new Mongos(servers, options);
    } else if (topologyType === "replicaset") {
      topology = new ReplSet(servers, options);
    } else if (topologyType === "unified") {
      topology = new NativeTopology(options.servers, options);
      registerDeprecatedEventNotifiers(mongoClient);
    }
    addListeners(mongoClient, topology);
    relayEvents(mongoClient, topology);
    assignTopology(mongoClient, topology);
    if (options.autoEncrypter) {
      options.autoEncrypter.init((err) => {
        if (err) {
          callback(err);
          return;
        }
        topology.connect(options, (err2) => {
          if (err2) {
            topology.close(true);
            callback(err2);
            return;
          }
          callback(void 0, topology);
        });
      });
      return;
    }
    topology.connect(options, (err) => {
      if (err) {
        topology.close(true);
        return callback(err);
      }
      callback(void 0, topology);
      return;
    });
  }
  function createUnifiedOptions(finalOptions, options) {
    const childOptions = [
      "mongos",
      "server",
      "db",
      "replset",
      "db_options",
      "server_options",
      "rs_options",
      "mongos_options"
    ];
    const noMerge = ["readconcern", "compression", "autoencryption"];
    for (const name in options) {
      if (noMerge.indexOf(name.toLowerCase()) !== -1) {
        finalOptions[name] = options[name];
      } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
        finalOptions = mergeOptions(finalOptions, options[name], false);
      } else {
        if (options[name] && typeof options[name] === "object" && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
          finalOptions = mergeOptions(finalOptions, options[name], true);
        } else {
          finalOptions[name] = options[name];
        }
      }
    }
    return finalOptions;
  }
  function generateCredentials(client2, username, password, options) {
    options = Object.assign({}, options);
    const source = options.authSource || options.authdb || options.dbName;
    const authMechanismRaw = options.authMechanism || "DEFAULT";
    const authMechanism = authMechanismRaw.toUpperCase();
    const mechanismProperties = options.authMechanismProperties;
    if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
      throw MongoError.create({
        message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
        driver: true
      });
    }
    return new MongoCredentials({
      mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
      mechanismProperties,
      source,
      username,
      password
    });
  }
  function legacyTransformUrlOptions(object) {
    return mergeOptions(createUnifiedOptions({}, object), object, false);
  }
  function mergeOptions(target, source, flatten) {
    for (const name in source) {
      if (source[name] && typeof source[name] === "object" && flatten) {
        target = mergeOptions(target, source[name], flatten);
      } else {
        target[name] = source[name];
      }
    }
    return target;
  }
  function relayEvents(mongoClient, topology) {
    const serverOrCommandEvents = [
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "serverOpening",
      "serverClosed",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "joined",
      "left",
      "ping",
      "ha"
    ].concat(CMAP_EVENT_NAMES);
    serverOrCommandEvents.forEach((event) => {
      topology.on(event, (object1, object2) => {
        mongoClient.emit(event, object1, object2);
      });
    });
  }
  function replayEvents(mongoClient, events) {
    for (let i = 0; i < events.length; i++) {
      mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
    }
  }
  function transformUrlOptions(_object) {
    let object = Object.assign({servers: _object.hosts}, _object.options);
    for (let name in object) {
      const camelCaseName = LEGACY_OPTIONS_MAP[name];
      if (camelCaseName) {
        object[camelCaseName] = object[name];
      }
    }
    const hasUsername = _object.auth && _object.auth.username;
    const hasAuthMechanism = _object.options && _object.options.authMechanism;
    if (hasUsername || hasAuthMechanism) {
      object.auth = Object.assign({}, _object.auth);
      if (object.auth.db) {
        object.authSource = object.authSource || object.auth.db;
      }
      if (object.auth.username) {
        object.auth.user = object.auth.username;
      }
    }
    if (_object.defaultDatabase) {
      object.dbName = _object.defaultDatabase;
    }
    if (object.maxPoolSize) {
      object.poolSize = object.maxPoolSize;
    }
    if (object.readConcernLevel) {
      object.readConcern = new ReadConcern(object.readConcernLevel);
    }
    if (object.wTimeoutMS) {
      object.wtimeout = object.wTimeoutMS;
    }
    if (_object.srvHost) {
      object.srvHost = _object.srvHost;
    }
    return object;
  }
  function translateOptions(options, translationOptions) {
    translationOptions = Object.assign({}, {createServers: true}, translationOptions);
    if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
      options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
    }
    if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
      options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
    }
    if (options.maxStalenessSeconds) {
      options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
    }
    if (options.socketTimeoutMS == null)
      options.socketTimeoutMS = 0;
    if (options.connectTimeoutMS == null)
      options.connectTimeoutMS = 1e4;
    if (!translationOptions.createServers) {
      return;
    }
    return options.servers.map((serverObj) => {
      return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);
    });
  }
  module2.exports = {validOptions, connect};
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports2, module2) => {
  "use strict";
  var ChangeStream = require_change_stream();
  var Db = require_db();
  var EventEmitter2 = require("events").EventEmitter;
  var inherits = require("util").inherits;
  var MongoError = require_core().MongoError;
  var deprecate = require("util").deprecate;
  var WriteConcern = require_write_concern();
  var MongoDBNamespace = require_utils4().MongoDBNamespace;
  var ReadPreference = require_read_preference();
  var maybePromise = require_utils4().maybePromise;
  var NativeTopology = require_native_topology();
  var connect = require_connect2().connect;
  var validOptions = require_connect2().validOptions;
  function MongoClient2(url, options) {
    if (!(this instanceof MongoClient2))
      return new MongoClient2(url, options);
    EventEmitter2.call(this);
    this.s = {
      url,
      options: options || {},
      promiseLibrary: options && options.promiseLibrary || Promise,
      dbCache: new Map(),
      sessions: new Set(),
      writeConcern: WriteConcern.fromOptions(options),
      readPreference: ReadPreference.fromOptions(options) || ReadPreference.primary,
      namespace: new MongoDBNamespace("admin")
    };
  }
  inherits(MongoClient2, EventEmitter2);
  Object.defineProperty(MongoClient2.prototype, "writeConcern", {
    enumerable: true,
    get: function() {
      return this.s.writeConcern;
    }
  });
  Object.defineProperty(MongoClient2.prototype, "readPreference", {
    enumerable: true,
    get: function() {
      return this.s.readPreference;
    }
  });
  MongoClient2.prototype.connect = function(callback) {
    if (typeof callback === "string") {
      throw new TypeError("`connect` only accepts a callback");
    }
    const client = this;
    return maybePromise(this, callback, (cb) => {
      const err = validOptions(client.s.options);
      if (err)
        return cb(err);
      connect(client, client.s.url, client.s.options, (err2) => {
        if (err2)
          return cb(err2);
        cb(null, client);
      });
    });
  };
  MongoClient2.prototype.logout = deprecate(function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    if (typeof callback === "function")
      callback(null, true);
  }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
  MongoClient2.prototype.close = function(force, callback) {
    if (typeof force === "function") {
      callback = force;
      force = false;
    }
    const client = this;
    return maybePromise(this, callback, (cb) => {
      const completeClose = (err) => {
        client.emit("close", client);
        if (!(client.topology instanceof NativeTopology)) {
          for (const item of client.s.dbCache) {
            item[1].emit("close", client);
          }
        }
        client.removeAllListeners("close");
        cb(err);
      };
      if (client.topology == null) {
        completeClose();
        return;
      }
      client.topology.close(force, (err) => {
        const autoEncrypter = client.topology.s.options.autoEncrypter;
        if (!autoEncrypter) {
          completeClose(err);
          return;
        }
        autoEncrypter.teardown(force, (err2) => completeClose(err || err2));
      });
    });
  };
  MongoClient2.prototype.db = function(dbName, options) {
    options = options || {};
    if (!dbName) {
      dbName = this.s.options.dbName;
    }
    const finalOptions = Object.assign({}, this.s.options, options);
    if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
      return this.s.dbCache.get(dbName);
    }
    finalOptions.promiseLibrary = this.s.promiseLibrary;
    if (!this.topology) {
      throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
    }
    const db = new Db(dbName, this.topology, finalOptions);
    this.s.dbCache.set(dbName, db);
    return db;
  };
  MongoClient2.prototype.isConnected = function(options) {
    options = options || {};
    if (!this.topology)
      return false;
    return this.topology.isConnected(options);
  };
  MongoClient2.connect = function(url, options, callback) {
    const args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : null;
    options = options || {};
    const mongoClient = new MongoClient2(url, options);
    return mongoClient.connect(callback);
  };
  MongoClient2.prototype.startSession = function(options) {
    options = Object.assign({explicit: true}, options);
    if (!this.topology) {
      throw new MongoError("Must connect to a server before calling this method");
    }
    if (!this.topology.hasSessionSupport()) {
      throw new MongoError("Current topology does not support sessions");
    }
    return this.topology.startSession(options, this.s.options);
  };
  MongoClient2.prototype.withSession = function(options, operation) {
    if (typeof options === "function")
      operation = options, options = void 0;
    const session = this.startSession(options);
    let cleanupHandler = (err, result, opts) => {
      cleanupHandler = () => {
        throw new ReferenceError("cleanupHandler was called too many times");
      };
      opts = Object.assign({throw: true}, opts);
      session.endSession();
      if (err) {
        if (opts.throw)
          throw err;
        return Promise.reject(err);
      }
    };
    try {
      const result = operation(session);
      return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, {throw: true}));
    } catch (err) {
      return cleanupHandler(err, null, {throw: false});
    }
  };
  MongoClient2.prototype.watch = function(pipeline, options) {
    pipeline = pipeline || [];
    options = options || {};
    if (!Array.isArray(pipeline)) {
      options = pipeline;
      pipeline = [];
    }
    return new ChangeStream(this, pipeline, options);
  };
  MongoClient2.prototype.getLogger = function() {
    return this.s.options.logger;
  };
  module2.exports = MongoClient2;
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS((exports2, module2) => {
  "use strict";
  var Binary2 = require_core().BSON.Binary;
  var ObjectID2 = require_core().BSON.ObjectID;
  var Buffer2 = require_safe_buffer().Buffer;
  var Chunk = function(file, mongoObject, writeConcern) {
    if (!(this instanceof Chunk))
      return new Chunk(file, mongoObject);
    this.file = file;
    var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
    this.writeConcern = writeConcern || {w: 1};
    this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
    this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
    this.data = new Binary2();
    if (typeof mongoObjectFinal.data === "string") {
      var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
      buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
      this.data = new Binary2(buffer);
    } else if (Array.isArray(mongoObjectFinal.data)) {
      buffer = Buffer2.alloc(mongoObjectFinal.data.length);
      var data = mongoObjectFinal.data.join("");
      buffer.write(data, 0, data.length, "binary");
      this.data = new Binary2(buffer);
    } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
      this.data = mongoObjectFinal.data;
    } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
      throw Error("Illegal chunk format");
    }
    this.internalPosition = 0;
  };
  Chunk.prototype.write = function(data, callback) {
    this.data.write(data, this.internalPosition, data.length, "binary");
    this.internalPosition = this.data.length();
    if (callback != null)
      return callback(null, this);
    return this;
  };
  Chunk.prototype.read = function(length) {
    length = length == null || length === 0 ? this.length() : length;
    if (this.length() - this.internalPosition + 1 >= length) {
      var data = this.data.read(this.internalPosition, length);
      this.internalPosition = this.internalPosition + length;
      return data;
    } else {
      return "";
    }
  };
  Chunk.prototype.readSlice = function(length) {
    if (this.length() - this.internalPosition >= length) {
      var data = null;
      if (this.data.buffer != null) {
        data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
      } else {
        data = Buffer2.alloc(length);
        length = this.data.readInto(data, this.internalPosition);
      }
      this.internalPosition = this.internalPosition + length;
      return data;
    } else {
      return null;
    }
  };
  Chunk.prototype.eof = function() {
    return this.internalPosition === this.length() ? true : false;
  };
  Chunk.prototype.getc = function() {
    return this.read(1);
  };
  Chunk.prototype.rewind = function() {
    this.internalPosition = 0;
    this.data = new Binary2();
  };
  Chunk.prototype.save = function(options, callback) {
    var self2 = this;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    self2.file.chunkCollection(function(err, collection) {
      if (err)
        return callback(err);
      var writeOptions = {upsert: true};
      for (var name in options)
        writeOptions[name] = options[name];
      for (name in self2.writeConcern)
        writeOptions[name] = self2.writeConcern[name];
      if (self2.data.length() > 0) {
        self2.buildMongoObject(function(mongoObject) {
          var options2 = {forceServerObjectId: true};
          for (var name2 in self2.writeConcern) {
            options2[name2] = self2.writeConcern[name2];
          }
          collection.replaceOne({_id: self2.objectId}, mongoObject, writeOptions, function(err2) {
            callback(err2, self2);
          });
        });
      } else {
        callback(null, self2);
      }
    });
  };
  Chunk.prototype.buildMongoObject = function(callback) {
    var mongoObject = {
      files_id: this.file.fileId,
      n: this.chunkNumber,
      data: this.data
    };
    if (this.objectId != null)
      mongoObject._id = this.objectId;
    callback(mongoObject);
  };
  Chunk.prototype.length = function() {
    return this.data.length();
  };
  Object.defineProperty(Chunk.prototype, "position", {
    enumerable: true,
    get: function() {
      return this.internalPosition;
    },
    set: function(value) {
      this.internalPosition = value;
    }
  });
  Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
  module2.exports = Chunk;
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS((exports2, module2) => {
  "use strict";
  var Chunk = require_chunk();
  var ObjectID2 = require_core().BSON.ObjectID;
  var ReadPreference = require_core().ReadPreference;
  var Buffer2 = require_safe_buffer().Buffer;
  var fs = require("fs");
  var f = require("util").format;
  var util = require("util");
  var MongoError = require_core().MongoError;
  var inherits = util.inherits;
  var Duplex = require("stream").Duplex;
  var shallowClone = require_utils4().shallowClone;
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var deprecate = require("util").deprecate;
  var REFERENCE_BY_FILENAME = 0;
  var REFERENCE_BY_ID = 1;
  var deprecationFn = deprecate(() => {
  }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
  var GridStore = function GridStore2(db, id, filename, mode, options) {
    deprecationFn();
    if (!(this instanceof GridStore2))
      return new GridStore2(db, id, filename, mode, options);
    this.db = db;
    if (typeof options === "undefined")
      options = {};
    if (typeof mode === "undefined") {
      mode = filename;
      filename = void 0;
    } else if (typeof mode === "object") {
      options = mode;
      mode = filename;
      filename = void 0;
    }
    if (id && id._bsontype === "ObjectID") {
      this.referenceBy = REFERENCE_BY_ID;
      this.fileId = id;
      this.filename = filename;
    } else if (typeof filename === "undefined") {
      this.referenceBy = REFERENCE_BY_FILENAME;
      this.filename = id;
      if (mode.indexOf("w") != null) {
        this.fileId = new ObjectID2();
      }
    } else {
      this.referenceBy = REFERENCE_BY_ID;
      this.fileId = id;
      this.filename = filename;
    }
    this.mode = mode == null ? "r" : mode;
    this.options = options || {};
    this.isOpen = false;
    this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
    this.position = 0;
    this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
    this.writeConcern = _getWriteConcern(db, this.options);
    this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
    var promiseLibrary = this.options.promiseLibrary || Promise;
    this.promiseLibrary = promiseLibrary;
    Object.defineProperty(this, "chunkSize", {
      enumerable: true,
      get: function() {
        return this.internalChunkSize;
      },
      set: function(value) {
        if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
          this.internalChunkSize = this.internalChunkSize;
        } else {
          this.internalChunkSize = value;
        }
      }
    });
    Object.defineProperty(this, "md5", {
      enumerable: true,
      get: function() {
        return this.internalMd5;
      }
    });
    Object.defineProperty(this, "chunkNumber", {
      enumerable: true,
      get: function() {
        return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
      }
    });
  };
  GridStore.prototype.open = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
      throw MongoError.create({message: "Illegal mode " + this.mode, driver: true});
    }
    return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {
      skipSessions: true
    });
  };
  var open = function(self2, options, callback) {
    var writeConcern = _getWriteConcern(self2.db, self2.options);
    if (self2.mode === "w" || self2.mode === "w+") {
      var collection = self2.collection();
      collection.ensureIndex([["filename", 1]], writeConcern, function() {
        var chunkCollection = self2.chunkCollection();
        var chunkIndexOptions = shallowClone(writeConcern);
        chunkIndexOptions.unique = true;
        chunkCollection.ensureIndex([
          ["files_id", 1],
          ["n", 1]
        ], chunkIndexOptions, function() {
          _open(self2, writeConcern, function(err, r) {
            if (err)
              return callback(err);
            self2.isOpen = true;
            callback(err, r);
          });
        });
      });
    } else {
      _open(self2, writeConcern, function(err, r) {
        if (err)
          return callback(err);
        self2.isOpen = true;
        callback(err, r);
      });
    }
  };
  GridStore.prototype.eof = function() {
    return this.position === this.length ? true : false;
  };
  GridStore.prototype.getc = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {
      skipSessions: true
    });
  };
  var getc = function(self2, options, callback) {
    if (self2.eof()) {
      callback(null, null);
    } else if (self2.currentChunk.eof()) {
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        self2.currentChunk = chunk;
        self2.position = self2.position + 1;
        callback(err, self2.currentChunk.getc());
      });
    } else {
      self2.position = self2.position + 1;
      callback(null, self2.currentChunk.getc());
    }
  };
  GridStore.prototype.puts = function(string, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    var finalString = string.match(/\n$/) == null ? string + "\n" : string;
    return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options, callback], {skipSessions: true});
  };
  GridStore.prototype.stream = function() {
    return new GridStoreStream(this);
  };
  GridStore.prototype.write = function write(data, close2, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options, callback], {skipSessions: true});
  };
  GridStore.prototype.destroy = function destroy() {
    if (!this.writable)
      return;
    this.readable = false;
    if (this.writable) {
      this.writable = false;
      this._q.length = 0;
      this.emit("close");
    }
  };
  GridStore.prototype.writeFile = function(file, options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {
      skipSessions: true
    });
  };
  var writeFile = function(self2, file, options, callback) {
    if (typeof file === "string") {
      fs.open(file, "r", function(err, fd) {
        if (err)
          return callback(err);
        self2.writeFile(fd, callback);
      });
      return;
    }
    self2.open(function(err, self3) {
      if (err)
        return callback(err, self3);
      fs.fstat(file, function(err2, stats) {
        if (err2)
          return callback(err2, self3);
        var offset = 0;
        var index = 0;
        var writeChunk = function() {
          var _buffer = Buffer2.alloc(self3.chunkSize);
          fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
            if (err3)
              return callback(err3, self3);
            offset = offset + bytesRead;
            var chunk = new Chunk(self3, {n: index++}, self3.writeConcern);
            chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
              if (err4)
                return callback(err4, self3);
              chunk2.save({}, function(err5) {
                if (err5)
                  return callback(err5, self3);
                self3.position = self3.position + bytesRead;
                self3.currentChunk = chunk2;
                if (offset >= stats.size) {
                  fs.close(file, function(err6) {
                    if (err6)
                      return callback(err6);
                    self3.close(function(err7) {
                      if (err7)
                        return callback(err7, self3);
                      return callback(null, self3);
                    });
                  });
                } else {
                  return process.nextTick(writeChunk);
                }
              });
            });
          });
        };
        process.nextTick(writeChunk);
      });
    });
  };
  GridStore.prototype.close = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {
      skipSessions: true
    });
  };
  var close = function(self2, options, callback) {
    if (self2.mode[0] === "w") {
      options = Object.assign({}, self2.writeConcern, options);
      if (self2.currentChunk != null && self2.currentChunk.position > 0) {
        self2.currentChunk.save({}, function(err) {
          if (err && typeof callback === "function")
            return callback(err);
          self2.collection(function(err2, files) {
            if (err2 && typeof callback === "function")
              return callback(err2);
            if (self2.uploadDate != null) {
              buildMongoObject(self2, function(err3, mongoObject) {
                if (err3) {
                  if (typeof callback === "function")
                    return callback(err3);
                  else
                    throw err3;
                }
                files.save(mongoObject, options, function(err4) {
                  if (typeof callback === "function")
                    callback(err4, mongoObject);
                });
              });
            } else {
              self2.uploadDate = new Date();
              buildMongoObject(self2, function(err3, mongoObject) {
                if (err3) {
                  if (typeof callback === "function")
                    return callback(err3);
                  else
                    throw err3;
                }
                files.save(mongoObject, options, function(err4) {
                  if (typeof callback === "function")
                    callback(err4, mongoObject);
                });
              });
            }
          });
        });
      } else {
        self2.collection(function(err, files) {
          if (err && typeof callback === "function")
            return callback(err);
          self2.uploadDate = new Date();
          buildMongoObject(self2, function(err2, mongoObject) {
            if (err2) {
              if (typeof callback === "function")
                return callback(err2);
              else
                throw err2;
            }
            files.save(mongoObject, options, function(err3) {
              if (typeof callback === "function")
                callback(err3, mongoObject);
            });
          });
        });
      }
    } else if (self2.mode[0] === "r") {
      if (typeof callback === "function")
        callback(null, null);
    } else {
      if (typeof callback === "function")
        callback(MongoError.create({message: f("Illegal mode %s", self2.mode), driver: true}));
    }
  };
  GridStore.prototype.chunkCollection = function(callback) {
    if (typeof callback === "function")
      return this.db.collection(this.root + ".chunks", callback);
    return this.db.collection(this.root + ".chunks");
  };
  GridStore.prototype.unlink = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {
      skipSessions: true
    });
  };
  var unlink = function(self2, options, callback) {
    deleteChunks(self2, function(err) {
      if (err !== null) {
        err.message = "at deleteChunks: " + err.message;
        return callback(err);
      }
      self2.collection(function(err2, collection) {
        if (err2 !== null) {
          err2.message = "at collection: " + err2.message;
          return callback(err2);
        }
        collection.remove({_id: self2.fileId}, self2.writeConcern, function(err3) {
          callback(err3, self2);
        });
      });
    });
  };
  GridStore.prototype.collection = function(callback) {
    if (typeof callback === "function")
      this.db.collection(this.root + ".files", callback);
    return this.db.collection(this.root + ".files");
  };
  GridStore.prototype.readlines = function(separator, options, callback) {
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    separator = args.length ? args.shift() : "\n";
    separator = separator || "\n";
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options, callback], {skipSessions: true});
  };
  var readlines = function(self2, separator, options, callback) {
    self2.read(function(err, data) {
      if (err)
        return callback(err);
      var items = data.toString().split(separator);
      items = items.length > 0 ? items.splice(0, items.length - 1) : [];
      for (var i = 0; i < items.length; i++) {
        items[i] = items[i] + separator;
      }
      callback(null, items);
    });
  };
  GridStore.prototype.rewind = function(options, callback) {
    if (typeof options === "function")
      callback = options, options = {};
    options = options || {};
    return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {
      skipSessions: true
    });
  };
  var rewind = function(self2, options, callback) {
    if (self2.currentChunk.chunkNumber !== 0) {
      if (self2.mode[0] === "w") {
        deleteChunks(self2, function(err) {
          if (err)
            return callback(err);
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.position = 0;
          callback(null, self2);
        });
      } else {
        self2.currentChunk(0, function(err, chunk) {
          if (err)
            return callback(err);
          self2.currentChunk = chunk;
          self2.currentChunk.rewind();
          self2.position = 0;
          callback(null, self2);
        });
      }
    } else {
      self2.currentChunk.rewind();
      self2.position = 0;
      callback(null, self2);
    }
  };
  GridStore.prototype.read = function(length, buffer, options, callback) {
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    length = args.length ? args.shift() : null;
    buffer = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, read, [this, length, buffer, options, callback], {skipSessions: true});
  };
  var read = function(self2, length, buffer, options, callback) {
    var finalLength = length == null ? self2.length - self2.position : length;
    var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
    finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
    if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
      var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
      slice.copy(finalBuffer, finalBuffer._index);
      self2.position = self2.position + finalBuffer.length;
      if (finalLength === 0 && finalBuffer.length === 0)
        return callback(MongoError.create({message: "File does not exist", driver: true}), null);
      return callback(null, finalBuffer);
    }
    slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
    slice.copy(finalBuffer, finalBuffer._index);
    finalBuffer._index += slice.length;
    nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
      if (err)
        return callback(err);
      if (chunk.length() > 0) {
        self2.currentChunk = chunk;
        self2.read(length, finalBuffer, callback);
      } else {
        if (finalBuffer._index > 0) {
          callback(null, finalBuffer);
        } else {
          callback(MongoError.create({
            message: "no chunks found for file, possibly corrupt",
            driver: true
          }), null);
        }
      }
    });
  };
  GridStore.prototype.tell = function(callback) {
    var self2 = this;
    if (typeof callback === "function")
      return callback(null, this.position);
    return new self2.promiseLibrary(function(resolve) {
      resolve(self2.position);
    });
  };
  GridStore.prototype.seek = function(position, seekLocation, options, callback) {
    var args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    seekLocation = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options, callback], {skipSessions: true});
  };
  var seek = function(self2, position, seekLocation, options, callback) {
    if (self2.mode !== "r") {
      return callback(MongoError.create({message: "seek is only supported for mode r", driver: true}));
    }
    var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
    var finalPosition = position;
    var targetPosition = 0;
    if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
      targetPosition = self2.position + finalPosition;
    } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
      targetPosition = self2.length + finalPosition;
    } else {
      targetPosition = finalPosition;
    }
    var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
    var seekChunk = function() {
      nthChunk(self2, newChunkNumber, function(err, chunk) {
        if (err)
          return callback(err, null);
        if (chunk == null)
          return callback(new Error("no chunk found"));
        self2.currentChunk = chunk;
        self2.position = targetPosition;
        self2.currentChunk.position = self2.position % self2.chunkSize;
        callback(err, self2);
      });
    };
    seekChunk();
  };
  var _open = function(self2, options, callback) {
    var collection = self2.collection();
    var query = self2.referenceBy === REFERENCE_BY_ID ? {_id: self2.fileId} : {filename: self2.filename};
    query = self2.fileId == null && self2.filename == null ? null : query;
    options.readPreference = self2.readPreference;
    if (query != null) {
      collection.findOne(query, options, function(err, doc) {
        if (err) {
          return error(err);
        }
        if (doc != null) {
          self2.fileId = doc._id;
          self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
          self2.contentType = doc.contentType;
          self2.internalChunkSize = doc.chunkSize;
          self2.uploadDate = doc.uploadDate;
          self2.aliases = doc.aliases;
          self2.length = doc.length;
          self2.metadata = doc.metadata;
          self2.internalMd5 = doc.md5;
        } else if (self2.mode !== "r") {
          self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
          self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
          self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
          self2.length = 0;
        } else {
          self2.length = 0;
          var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
          return error(MongoError.create({
            message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
            driver: true
          }), self2);
        }
        if (self2.mode === "r") {
          nthChunk(self2, 0, options, function(err2, chunk) {
            if (err2)
              return error(err2);
            self2.currentChunk = chunk;
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w" && doc) {
          deleteChunks(self2, options, function(err2) {
            if (err2)
              return error(err2);
            self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w") {
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
          self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = 0;
          callback(null, self2);
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options, function(err2, chunk) {
            if (err2)
              return error(err2);
            self2.currentChunk = chunk == null ? new Chunk(self2, {n: 0}, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      });
    } else {
      self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
      self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
      self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
      self2.length = 0;
      if (self2.mode === "w") {
        deleteChunks(self2, options, function(err) {
          if (err)
            return error(err);
          self2.currentChunk = new Chunk(self2, {n: 0}, self2.writeConcern);
          self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
          self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = 0;
          callback(null, self2);
        });
      } else if (self2.mode === "w+") {
        nthChunk(self2, lastChunkNumber(self2), options, function(err, chunk) {
          if (err)
            return error(err);
          self2.currentChunk = chunk == null ? new Chunk(self2, {n: 0}, self2.writeConcern) : chunk;
          self2.currentChunk.position = self2.currentChunk.data.length();
          self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
          self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
          self2.position = self2.length;
          callback(null, self2);
        });
      }
    }
    function error(err) {
      if (error.err)
        return;
      callback(error.err = err);
    }
  };
  var writeBuffer = function(self2, buffer, close2, callback) {
    if (typeof close2 === "function") {
      callback = close2;
      close2 = null;
    }
    var finalClose = typeof close2 === "boolean" ? close2 : false;
    if (self2.mode !== "w") {
      callback(MongoError.create({
        message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
        driver: true
      }), null);
    } else {
      if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
        var previousChunkNumber = self2.currentChunk.chunkNumber;
        var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
        var firstChunkData = buffer.slice(0, leftOverDataSize);
        var leftOverData = buffer.slice(leftOverDataSize);
        var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
        while (leftOverData.length >= self2.chunkSize) {
          var newChunk = new Chunk(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
          firstChunkData = leftOverData.slice(0, self2.chunkSize);
          leftOverData = leftOverData.slice(self2.chunkSize);
          previousChunkNumber = previousChunkNumber + 1;
          newChunk.write(firstChunkData);
          chunksToWrite.push(newChunk);
        }
        self2.currentChunk = new Chunk(self2, {n: previousChunkNumber + 1}, self2.writeConcern);
        if (leftOverData.length > 0)
          self2.currentChunk.write(leftOverData);
        self2.position = self2.position + buffer.length;
        var numberOfChunksToWrite = chunksToWrite.length;
        for (var i = 0; i < chunksToWrite.length; i++) {
          chunksToWrite[i].save({}, function(err) {
            if (err)
              return callback(err);
            numberOfChunksToWrite = numberOfChunksToWrite - 1;
            if (numberOfChunksToWrite <= 0) {
              if (finalClose) {
                return self2.close(function(err2) {
                  callback(err2, self2);
                });
              }
              return callback(null, self2);
            }
          });
        }
      } else {
        self2.position = self2.position + buffer.length;
        self2.currentChunk.write(buffer);
        if (finalClose) {
          return self2.close(function(err) {
            callback(err, self2);
          });
        }
        return callback(null, self2);
      }
    }
  };
  var buildMongoObject = function(self2, callback) {
    var mongoObject = {
      _id: self2.fileId,
      filename: self2.filename,
      contentType: self2.contentType,
      length: self2.position ? self2.position : 0,
      chunkSize: self2.chunkSize,
      uploadDate: self2.uploadDate,
      aliases: self2.aliases,
      metadata: self2.metadata
    };
    var md5Command = {filemd5: self2.fileId, root: self2.root};
    self2.db.command(md5Command, function(err, results) {
      if (err)
        return callback(err);
      mongoObject.md5 = results.md5;
      callback(null, mongoObject);
    });
  };
  var nthChunk = function(self2, chunkNumber, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || self2.writeConcern;
    options.readPreference = self2.readPreference;
    self2.chunkCollection().findOne({files_id: self2.fileId, n: chunkNumber}, options, function(err, chunk) {
      if (err)
        return callback(err);
      var finalChunk = chunk == null ? {} : chunk;
      callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
    });
  };
  var lastChunkNumber = function(self2) {
    return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
  };
  var deleteChunks = function(self2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || self2.writeConcern;
    if (self2.fileId != null) {
      self2.chunkCollection().remove({files_id: self2.fileId}, options, function(err) {
        if (err)
          return callback(err, false);
        callback(null, true);
      });
    } else {
      callback(null, true);
    }
  };
  GridStore.DEFAULT_ROOT_COLLECTION = "fs";
  GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
  GridStore.IO_SEEK_SET = 0;
  GridStore.IO_SEEK_CUR = 1;
  GridStore.IO_SEEK_END = 2;
  GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    rootCollection = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options, callback], {skipSessions: true});
  };
  var exists = function(db, fileIdObject, rootCollection, options, callback) {
    var readPreference = options.readPreference || ReadPreference.PRIMARY;
    var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
    db.collection(rootCollectionFinal + ".files", function(err, collection) {
      if (err)
        return callback(err);
      var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? {filename: fileIdObject} : {_id: fileIdObject};
      if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
        query = fileIdObject;
      }
      collection.findOne(query, {readPreference}, function(err2, item) {
        if (err2)
          return callback(err2);
        callback(null, item == null ? false : true);
      });
    });
  };
  GridStore.list = function(db, rootCollection, options, callback) {
    var args = Array.prototype.slice.call(arguments, 1);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    rootCollection = args.length ? args.shift() : null;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {
      skipSessions: true
    });
  };
  var list = function(db, rootCollection, options, callback) {
    if (rootCollection != null && typeof rootCollection === "object") {
      options = rootCollection;
      rootCollection = null;
    }
    var readPreference = options.readPreference || ReadPreference.primary;
    var byId = options["id"] != null ? options["id"] : false;
    var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
    var items = [];
    db.collection(rootCollectionFinal + ".files", function(err, collection) {
      if (err)
        return callback(err);
      collection.find({}, {readPreference}, function(err2, cursor) {
        if (err2)
          return callback(err2);
        cursor.each(function(err3, item) {
          if (item != null) {
            items.push(byId ? item._id : item.filename);
          } else {
            callback(err3, items);
          }
        });
      });
    });
  };
  GridStore.read = function(db, name, length, offset, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    length = args.length ? args.shift() : null;
    offset = args.length ? args.shift() : null;
    options = args.length ? args.shift() : null;
    options = options || {};
    return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options, callback], {skipSessions: true});
  };
  var readStatic = function(db, name, length, offset, options, callback) {
    new GridStore(db, name, "r", options).open(function(err, gridStore) {
      if (err)
        return callback(err);
      if (offset && offset >= gridStore.length)
        return callback("offset larger than size of file", null);
      if (length && length > gridStore.length)
        return callback("length is larger than the size of the file", null);
      if (offset && length && offset + length > gridStore.length)
        return callback("offset and length is larger than the size of the file", null);
      if (offset != null) {
        gridStore.seek(offset, function(err2, gridStore2) {
          if (err2)
            return callback(err2);
          gridStore2.read(length, callback);
        });
      } else {
        gridStore.read(length, callback);
      }
    });
  };
  GridStore.readlines = function(db, name, separator, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    separator = args.length ? args.shift() : null;
    options = args.length ? args.shift() : null;
    options = options || {};
    return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options, callback], {skipSessions: true});
  };
  var readlinesStatic = function(db, name, separator, options, callback) {
    var finalSeperator = separator == null ? "\n" : separator;
    new GridStore(db, name, "r", options).open(function(err, gridStore) {
      if (err)
        return callback(err);
      gridStore.readlines(finalSeperator, callback);
    });
  };
  GridStore.unlink = function(db, names, options, callback) {
    var args = Array.prototype.slice.call(arguments, 2);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    options = args.length ? args.shift() : {};
    options = options || {};
    return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {
      skipSessions: true
    });
  };
  var unlinkStatic = function(self2, db, names, options, callback) {
    var writeConcern = _getWriteConcern(db, options);
    if (names.constructor === Array) {
      var tc = 0;
      for (var i = 0; i < names.length; i++) {
        ++tc;
        GridStore.unlink(db, names[i], options, function() {
          if (--tc === 0) {
            callback(null, self2);
          }
        });
      }
    } else {
      new GridStore(db, names, "w", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        deleteChunks(gridStore, function(err2) {
          if (err2)
            return callback(err2);
          gridStore.collection(function(err3, collection) {
            if (err3)
              return callback(err3);
            collection.remove({_id: gridStore.fileId}, writeConcern, function(err4) {
              callback(err4, self2);
            });
          });
        });
      });
    }
  };
  var _writeNormal = function(self2, data, close2, options, callback) {
    if (Buffer2.isBuffer(data)) {
      return writeBuffer(self2, data, close2, callback);
    } else {
      return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
    }
  };
  var _setWriteConcernHash = function(options) {
    var finalOptions = {};
    if (options.w != null)
      finalOptions.w = options.w;
    if (options.journal === true)
      finalOptions.j = options.journal;
    if (options.j === true)
      finalOptions.j = options.j;
    if (options.fsync === true)
      finalOptions.fsync = options.fsync;
    if (options.wtimeout != null)
      finalOptions.wtimeout = options.wtimeout;
    return finalOptions;
  };
  var _getWriteConcern = function(self2, options) {
    var finalOptions = {w: 1};
    options = options || {};
    if (options.w != null || typeof options.j === "boolean" || typeof options.journal === "boolean" || typeof options.fsync === "boolean") {
      finalOptions = _setWriteConcernHash(options);
    } else if (options.safe != null && typeof options.safe === "object") {
      finalOptions = _setWriteConcernHash(options.safe);
    } else if (typeof options.safe === "boolean") {
      finalOptions = {w: options.safe ? 1 : 0};
    } else if (self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
      finalOptions = _setWriteConcernHash(self2.options);
    } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
      finalOptions = _setWriteConcernHash(self2.safe);
    } else if (typeof self2.safe === "boolean") {
      finalOptions = {w: self2.safe ? 1 : 0};
    }
    if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
      throw MongoError.create({
        message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
        driver: true
      });
    return finalOptions;
  };
  var GridStoreStream = function(gs) {
    Duplex.call(this);
    this.gs = gs;
    this.endCalled = false;
    this.totalBytesToRead = this.gs.length - this.gs.position;
    this.seekPosition = this.gs.position;
  };
  inherits(GridStoreStream, Duplex);
  GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
  GridStoreStream.prototype.pipe = function(destination) {
    var self2 = this;
    if (!self2.gs.isOpen) {
      self2.gs.open(function(err) {
        if (err)
          return self2.emit("error", err);
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      });
    } else {
      self2.totalBytesToRead = self2.gs.length - self2.gs.position;
      self2._pipe.apply(self2, [destination]);
    }
    return destination;
  };
  GridStoreStream.prototype._read = function() {
    var self2 = this;
    var read2 = function() {
      self2.gs.read(length, function(err, buffer) {
        if (err && !self2.endCalled)
          return self2.emit("error", err);
        if (self2.endCalled || buffer == null)
          return self2.push(null);
        if (buffer.length <= self2.totalBytesToRead) {
          self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
          self2.push(buffer);
        } else if (buffer.length > self2.totalBytesToRead) {
          self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
          self2.push(buffer.slice(0, buffer._index));
        }
        if (self2.totalBytesToRead <= 0) {
          self2.endCalled = true;
        }
      });
    };
    var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
    if (!self2.gs.isOpen) {
      self2.gs.open(function(err) {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        if (err)
          return self2.emit("error", err);
        read2();
      });
    } else {
      read2();
    }
  };
  GridStoreStream.prototype.destroy = function() {
    this.pause();
    this.endCalled = true;
    this.gs.close();
    this.emit("end");
  };
  GridStoreStream.prototype.write = function(chunk) {
    var self2 = this;
    if (self2.endCalled)
      return self2.emit("error", MongoError.create({message: "attempting to write to stream after end called", driver: true}));
    if (!self2.gs.isOpen) {
      self2.gs.open(function() {
        self2.gs.isOpen = true;
        self2.gs.write(chunk, function() {
          process.nextTick(function() {
            self2.emit("drain");
          });
        });
      });
      return false;
    } else {
      self2.gs.write(chunk, function() {
        self2.emit("drain");
      });
      return true;
    }
  };
  GridStoreStream.prototype.end = function(chunk, encoding, callback) {
    var self2 = this;
    var args = Array.prototype.slice.call(arguments, 0);
    callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
    chunk = args.length ? args.shift() : null;
    encoding = args.length ? args.shift() : null;
    self2.endCalled = true;
    if (chunk) {
      self2.gs.write(chunk, function() {
        self2.gs.close(function() {
          if (typeof callback === "function")
            callback();
          self2.emit("end");
        });
      });
    }
    self2.gs.close(function() {
      if (typeof callback === "function")
        callback();
      self2.emit("end");
    });
  };
  module2.exports = GridStore;
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require("stream");
  var util = require("util");
  module2.exports = GridFSBucketReadStream;
  function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
    this.s = {
      bytesRead: 0,
      chunks,
      cursor: null,
      expected: 0,
      files,
      filter,
      init: false,
      expectedEnd: 0,
      file: null,
      options,
      readPreference
    };
    stream.Readable.call(this);
  }
  util.inherits(GridFSBucketReadStream, stream.Readable);
  GridFSBucketReadStream.prototype._read = function() {
    var _this = this;
    if (this.destroyed) {
      return;
    }
    waitForFile(_this, function() {
      doRead(_this);
    });
  };
  GridFSBucketReadStream.prototype.start = function(start) {
    throwIfInitialized(this);
    this.s.options.start = start;
    return this;
  };
  GridFSBucketReadStream.prototype.end = function(end) {
    throwIfInitialized(this);
    this.s.options.end = end;
    return this;
  };
  GridFSBucketReadStream.prototype.abort = function(callback) {
    var _this = this;
    this.push(null);
    this.destroyed = true;
    if (this.s.cursor) {
      this.s.cursor.close(function(error) {
        _this.emit("close");
        callback && callback(error);
      });
    } else {
      if (!this.s.init) {
        _this.emit("close");
      }
      callback && callback();
    }
  };
  function throwIfInitialized(self2) {
    if (self2.s.init) {
      throw new Error("You cannot change options after the stream has enteredflowing mode!");
    }
  }
  function doRead(_this) {
    if (_this.destroyed) {
      return;
    }
    _this.s.cursor.next(function(error, doc) {
      if (_this.destroyed) {
        return;
      }
      if (error) {
        return __handleError(_this, error);
      }
      if (!doc) {
        _this.push(null);
        process.nextTick(() => {
          _this.s.cursor.close(function(error2) {
            if (error2) {
              __handleError(_this, error2);
              return;
            }
            _this.emit("close");
          });
        });
        return;
      }
      var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
      var expectedN = _this.s.expected++;
      var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
        return __handleError(_this, new Error(errmsg));
      }
      if (doc.n < expectedN) {
        errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
        return __handleError(_this, new Error(errmsg));
      }
      var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.length !== expectedLength) {
        if (bytesRemaining <= 0) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
          return __handleError(_this, new Error(errmsg));
        }
        errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
        return __handleError(_this, new Error(errmsg));
      }
      _this.s.bytesRead += buf.length;
      if (buf.length === 0) {
        return _this.push(null);
      }
      var sliceStart = null;
      var sliceEnd = null;
      if (_this.s.bytesToSkip != null) {
        sliceStart = _this.s.bytesToSkip;
        _this.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
      const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
      if (atEndOfStream && _this.s.bytesToTrim != null) {
        sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
      } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
      }
      _this.push(buf);
    });
  }
  function init(self2) {
    var findOneOptions = {};
    if (self2.s.readPreference) {
      findOneOptions.readPreference = self2.s.readPreference;
    }
    if (self2.s.options && self2.s.options.sort) {
      findOneOptions.sort = self2.s.options.sort;
    }
    if (self2.s.options && self2.s.options.skip) {
      findOneOptions.skip = self2.s.options.skip;
    }
    self2.s.files.findOne(self2.s.filter, findOneOptions, function(error, doc) {
      if (error) {
        return __handleError(self2, error);
      }
      if (!doc) {
        var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
        var errmsg = "FileNotFound: file " + identifier + " was not found";
        var err = new Error(errmsg);
        err.code = "ENOENT";
        return __handleError(self2, err);
      }
      if (doc.length <= 0) {
        self2.push(null);
        return;
      }
      if (self2.destroyed) {
        self2.emit("close");
        return;
      }
      try {
        self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
      } catch (error2) {
        return __handleError(self2, error2);
      }
      var filter = {files_id: doc._id};
      if (self2.s.options && self2.s.options.start != null) {
        var skip = Math.floor(self2.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = {$gte: skip};
        }
      }
      self2.s.cursor = self2.s.chunks.find(filter).sort({n: 1});
      if (self2.s.readPreference) {
        self2.s.cursor.setReadPreference(self2.s.readPreference);
      }
      self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      self2.s.file = doc;
      try {
        self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
      } catch (error2) {
        return __handleError(self2, error2);
      }
      self2.emit("file", doc);
    });
  }
  function waitForFile(_this, callback) {
    if (_this.s.file) {
      return callback();
    }
    if (!_this.s.init) {
      init(_this);
      _this.s.init = true;
    }
    _this.once("file", function() {
      callback();
    });
  }
  function handleStartOption(stream2, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new Error("Stream start (" + options.start + ") must not be more than the length of the file (" + doc.length + ")");
      }
      if (options.start < 0) {
        throw new Error("Stream start (" + options.start + ") must not be negative");
      }
      if (options.end != null && options.end < options.start) {
        throw new Error("Stream start (" + options.start + ") must not be greater than stream end (" + options.end + ")");
      }
      stream2.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream2.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream2.s.bytesRead;
    }
  }
  function handleEndOption(stream2, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new Error("Stream end (" + options.end + ") must not be more than the length of the file (" + doc.length + ")");
      }
      if (options.start < 0) {
        throw new Error("Stream end (" + options.end + ") must not be negative");
      }
      var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream2.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
  }
  function __handleError(_this, error) {
    _this.emit("error", error);
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS((exports2, module2) => {
  "use strict";
  var core = require_core();
  var crypto = require("crypto");
  var stream = require("stream");
  var util = require("util");
  var Buffer2 = require_safe_buffer().Buffer;
  var ERROR_NAMESPACE_NOT_FOUND = 26;
  module2.exports = GridFSBucketWriteStream;
  function GridFSBucketWriteStream(bucket, filename, options) {
    options = options || {};
    this.bucket = bucket;
    this.chunks = bucket.s._chunksCollection;
    this.filename = filename;
    this.files = bucket.s._filesCollection;
    this.options = options;
    this.done = false;
    this.id = options.id ? options.id : core.BSON.ObjectId();
    this.chunkSizeBytes = this.options.chunkSizeBytes;
    this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
    this.length = 0;
    this.md5 = !options.disableMD5 && crypto.createHash("md5");
    this.n = 0;
    this.pos = 0;
    this.state = {
      streamEnd: false,
      outstandingRequests: 0,
      errored: false,
      aborted: false,
      promiseLibrary: this.bucket.s.promiseLibrary
    };
    if (!this.bucket.s.calledOpenUploadStream) {
      this.bucket.s.calledOpenUploadStream = true;
      var _this = this;
      checkIndexes(this, function() {
        _this.bucket.s.checkedIndexes = true;
        _this.bucket.emit("index");
      });
    }
  }
  util.inherits(GridFSBucketWriteStream, stream.Writable);
  GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
    var _this = this;
    return waitForIndexes(this, function() {
      return doWrite(_this, chunk, encoding, callback);
    });
  };
  GridFSBucketWriteStream.prototype.abort = function(callback) {
    if (this.state.streamEnd) {
      var error = new Error("Cannot abort a stream that has already completed");
      if (typeof callback === "function") {
        return callback(error);
      }
      return this.state.promiseLibrary.reject(error);
    }
    if (this.state.aborted) {
      error = new Error("Cannot call abort() on a stream twice");
      if (typeof callback === "function") {
        return callback(error);
      }
      return this.state.promiseLibrary.reject(error);
    }
    this.state.aborted = true;
    this.chunks.deleteMany({files_id: this.id}, function(error2) {
      if (typeof callback === "function")
        callback(error2);
    });
  };
  GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
    var _this = this;
    if (typeof chunk === "function") {
      callback = chunk, chunk = null, encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding, encoding = null;
    }
    if (checkAborted(this, callback)) {
      return;
    }
    this.state.streamEnd = true;
    if (callback) {
      this.once("finish", function(result) {
        callback(null, result);
      });
    }
    if (!chunk) {
      waitForIndexes(this, function() {
        writeRemnant(_this);
      });
      return;
    }
    this.write(chunk, encoding, function() {
      writeRemnant(_this);
    });
  };
  function __handleError(_this, error, callback) {
    if (_this.state.errored) {
      return;
    }
    _this.state.errored = true;
    if (callback) {
      return callback(error);
    }
    _this.emit("error", error);
  }
  function createChunkDoc(filesId, n, data) {
    return {
      _id: core.BSON.ObjectId(),
      files_id: filesId,
      n,
      data
    };
  }
  function checkChunksIndex(_this, callback) {
    _this.chunks.listIndexes().toArray(function(error, indexes) {
      if (error) {
        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
          var index = {files_id: 1, n: 1};
          _this.chunks.createIndex(index, {background: false, unique: true}, function(error2) {
            if (error2) {
              return callback(error2);
            }
            callback();
          });
          return;
        }
        return callback(error);
      }
      var hasChunksIndex = false;
      indexes.forEach(function(index2) {
        if (index2.key) {
          var keys = Object.keys(index2.key);
          if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
            hasChunksIndex = true;
          }
        }
      });
      if (hasChunksIndex) {
        callback();
      } else {
        index = {files_id: 1, n: 1};
        var indexOptions = getWriteOptions(_this);
        indexOptions.background = false;
        indexOptions.unique = true;
        _this.chunks.createIndex(index, indexOptions, function(error2) {
          if (error2) {
            return callback(error2);
          }
          callback();
        });
      }
    });
  }
  function checkDone(_this, callback) {
    if (_this.done)
      return true;
    if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
      _this.done = true;
      var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {
        if (error) {
          return __handleError(_this, error, callback);
        }
        _this.emit("finish", filesDoc);
      });
      return true;
    }
    return false;
  }
  function checkIndexes(_this, callback) {
    _this.files.findOne({}, {_id: 1}, function(error, doc) {
      if (error) {
        return callback(error);
      }
      if (doc) {
        return callback();
      }
      _this.files.listIndexes().toArray(function(error2, indexes) {
        if (error2) {
          if (error2.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index = {filename: 1, uploadDate: 1};
            _this.files.createIndex(index, {background: false}, function(error3) {
              if (error3) {
                return callback(error3);
              }
              checkChunksIndex(_this, callback);
            });
            return;
          }
          return callback(error2);
        }
        var hasFileIndex = false;
        indexes.forEach(function(index2) {
          var keys = Object.keys(index2.key);
          if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
            hasFileIndex = true;
          }
        });
        if (hasFileIndex) {
          checkChunksIndex(_this, callback);
        } else {
          index = {filename: 1, uploadDate: 1};
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          _this.files.createIndex(index, indexOptions, function(error3) {
            if (error3) {
              return callback(error3);
            }
            checkChunksIndex(_this, callback);
          });
        }
      });
    });
  }
  function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
    var ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date(),
      filename
    };
    if (md5) {
      ret.md5 = md5;
    }
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  }
  function doWrite(_this, chunk, encoding, callback) {
    if (checkAborted(_this, callback)) {
      return false;
    }
    var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
    _this.length += inputBuf.length;
    if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
      inputBuf.copy(_this.bufToStore, _this.pos);
      _this.pos += inputBuf.length;
      callback && callback();
      return true;
    }
    var inputBufRemaining = inputBuf.length;
    var spaceRemaining = _this.chunkSizeBytes - _this.pos;
    var numToCopy = Math.min(spaceRemaining, inputBuf.length);
    var outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      var inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
      _this.pos += numToCopy;
      spaceRemaining -= numToCopy;
      if (spaceRemaining === 0) {
        if (_this.md5) {
          _this.md5.update(_this.bufToStore);
        }
        var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
        ++_this.state.outstandingRequests;
        ++outstandingRequests;
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
          if (error) {
            return __handleError(_this, error);
          }
          --_this.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            _this.emit("drain", doc);
            callback && callback();
            checkDone(_this);
          }
        });
        spaceRemaining = _this.chunkSizeBytes;
        _this.pos = 0;
        ++_this.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
    return false;
  }
  function getWriteOptions(_this) {
    var obj = {};
    if (_this.options.writeConcern) {
      obj.w = _this.options.writeConcern.w;
      obj.wtimeout = _this.options.writeConcern.wtimeout;
      obj.j = _this.options.writeConcern.j;
    }
    return obj;
  }
  function waitForIndexes(_this, callback) {
    if (_this.bucket.s.checkedIndexes) {
      return callback(false);
    }
    _this.bucket.once("index", function() {
      callback(true);
    });
    return true;
  }
  function writeRemnant(_this, callback) {
    if (_this.pos === 0) {
      return checkDone(_this, callback);
    }
    ++_this.state.outstandingRequests;
    var remnant = Buffer2.alloc(_this.pos);
    _this.bufToStore.copy(remnant, 0, 0, _this.pos);
    if (_this.md5) {
      _this.md5.update(remnant);
    }
    var doc = createChunkDoc(_this.id, _this.n, remnant);
    if (checkAborted(_this, callback)) {
      return false;
    }
    _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
      if (error) {
        return __handleError(_this, error);
      }
      --_this.state.outstandingRequests;
      checkDone(_this);
    });
  }
  function checkAborted(_this, callback) {
    if (_this.state.aborted) {
      if (typeof callback === "function") {
        callback(new Error("this stream has been aborted"));
      }
      return true;
    }
    return false;
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Emitter = require("events").EventEmitter;
  var GridFSBucketReadStream = require_download();
  var GridFSBucketWriteStream = require_upload();
  var shallowClone = require_utils4().shallowClone;
  var toError = require_utils4().toError;
  var util = require("util");
  var executeLegacyOperation = require_utils4().executeLegacyOperation;
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };
  module2.exports = GridFSBucket;
  function GridFSBucket(db, options) {
    Emitter.apply(this);
    this.setMaxListeners(0);
    if (options && typeof options === "object") {
      options = shallowClone(options);
      var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
      for (var i = 0; i < keys.length; ++i) {
        if (!options[keys[i]]) {
          options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
        }
      }
    } else {
      options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
    }
    this.s = {
      db,
      options,
      _chunksCollection: db.collection(options.bucketName + ".chunks"),
      _filesCollection: db.collection(options.bucketName + ".files"),
      checkedIndexes: false,
      calledOpenUploadStream: false,
      promiseLibrary: db.s.promiseLibrary || Promise
    };
  }
  util.inherits(GridFSBucket, Emitter);
  GridFSBucket.prototype.openUploadStream = function(filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    options.id = id;
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openDownloadStream = function(id, options) {
    var filter = {_id: id};
    options = {
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.delete = function(id, callback) {
    return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
      skipSessions: true
    });
  };
  function _delete(_this, id, callback) {
    _this.s._filesCollection.deleteOne({_id: id}, function(error, res) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.deleteMany({files_id: id}, function(error2) {
        if (error2) {
          return callback(error2);
        }
        if (!res.result.n) {
          var errmsg = "FileNotFound: no file with id " + id + " found";
          return callback(new Error(errmsg));
        }
        callback();
      });
    });
  }
  GridFSBucket.prototype.find = function(filter, options) {
    filter = filter || {};
    options = options || {};
    var cursor = this.s._filesCollection.find(filter);
    if (options.batchSize != null) {
      cursor.batchSize(options.batchSize);
    }
    if (options.limit != null) {
      cursor.limit(options.limit);
    }
    if (options.maxTimeMS != null) {
      cursor.maxTimeMS(options.maxTimeMS);
    }
    if (options.noCursorTimeout != null) {
      cursor.addCursorFlag("noCursorTimeout", options.noCursorTimeout);
    }
    if (options.skip != null) {
      cursor.skip(options.skip);
    }
    if (options.sort != null) {
      cursor.sort(options.sort);
    }
    return cursor;
  };
  GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
    var sort = {uploadDate: -1};
    var skip = null;
    if (options && options.revision != null) {
      if (options.revision >= 0) {
        sort = {uploadDate: 1};
        skip = options.revision;
      } else {
        skip = -options.revision - 1;
      }
    }
    var filter = {filename};
    options = {
      sort,
      skip,
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.rename = function(id, filename, callback) {
    return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
      skipSessions: true
    });
  };
  function _rename(_this, id, filename, callback) {
    var filter = {_id: id};
    var update = {$set: {filename}};
    _this.s._filesCollection.updateOne(filter, update, function(error, res) {
      if (error) {
        return callback(error);
      }
      if (!res.result.n) {
        return callback(toError("File with id " + id + " not found"));
      }
      callback();
    });
  }
  GridFSBucket.prototype.drop = function(callback) {
    return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
      skipSessions: true
    });
  };
  GridFSBucket.prototype.getLogger = function() {
    return this.s.db.s.logger;
  };
  function _drop(_this, callback) {
    _this.s._filesCollection.drop(function(error) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.drop(function(error2) {
        if (error2) {
          return callback(error2);
        }
        return callback();
      });
    });
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS((exports2, module2) => {
  "use strict";
  var core = require_core();
  var Instrumentation = require_apm2();
  var connect = require_mongo_client().connect;
  connect.MongoError = core.MongoError;
  connect.MongoNetworkError = core.MongoNetworkError;
  connect.MongoTimeoutError = core.MongoTimeoutError;
  connect.MongoServerSelectionError = core.MongoServerSelectionError;
  connect.MongoParseError = core.MongoParseError;
  connect.MongoWriteConcernError = core.MongoWriteConcernError;
  connect.MongoBulkWriteError = require_common3().BulkWriteError;
  connect.BulkWriteError = connect.MongoBulkWriteError;
  connect.Admin = require_admin();
  connect.MongoClient = require_mongo_client();
  connect.Db = require_db();
  connect.Collection = require_collection();
  connect.Server = require_server3();
  connect.ReplSet = require_replset2();
  connect.Mongos = require_mongos2();
  connect.ReadPreference = core.ReadPreference;
  connect.GridStore = require_grid_store();
  connect.Chunk = require_chunk();
  connect.Logger = core.Logger;
  connect.AggregationCursor = require_aggregation_cursor();
  connect.CommandCursor = require_command_cursor();
  connect.Cursor = require_cursor2();
  connect.GridFSBucket = require_gridfs_stream();
  connect.CoreServer = core.Server;
  connect.CoreConnection = core.Connection;
  connect.Binary = core.BSON.Binary;
  connect.Code = core.BSON.Code;
  connect.Map = core.BSON.Map;
  connect.DBRef = core.BSON.DBRef;
  connect.Double = core.BSON.Double;
  connect.Int32 = core.BSON.Int32;
  connect.Long = core.BSON.Long;
  connect.MinKey = core.BSON.MinKey;
  connect.MaxKey = core.BSON.MaxKey;
  connect.ObjectID = core.BSON.ObjectID;
  connect.ObjectId = core.BSON.ObjectID;
  connect.Symbol = core.BSON.Symbol;
  connect.Timestamp = core.BSON.Timestamp;
  connect.BSONRegExp = core.BSON.BSONRegExp;
  connect.Decimal128 = core.BSON.Decimal128;
  connect.connect = connect;
  connect.instrument = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    const instrumentation = new Instrumentation();
    instrumentation.instrument(connect.MongoClient, callback);
    return instrumentation;
  };
  module2.exports = connect;
});

// node_modules/d3-time/dist/d3-time.js
var require_d3_time = __commonJS((exports2, module2) => {
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
  })(exports2, function(exports3) {
    "use strict";
    var t0 = new Date(), t1 = new Date();
    function newInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }
      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };
      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };
      interval.round = function(date) {
        var d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };
      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };
      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0))
          return range;
        do
          range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };
      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date)
            while (floori(date), !test(date))
              date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0)
              while (++step <= 0) {
                while (offseti(date, -1), !test(date)) {
                }
              }
            else
              while (--step >= 0) {
                while (offseti(date, 1), !test(date)) {
                }
              }
          }
        });
      };
      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
            return field(d) % step === 0;
          } : function(d) {
            return interval.count(0, d) % step === 0;
          });
        };
      }
      return interval;
    }
    var millisecond = newInterval(function() {
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0))
        return null;
      if (!(k > 1))
        return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;
    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;
    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;
    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });
    var minutes = minute.range;
    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });
    var hours = hour.range;
    var day = newInterval((date) => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date) => date.getDate() - 1);
    var days = day.range;
    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);
    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;
    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });
    var months = month.range;
    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;
    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;
    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;
    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;
    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }
    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);
    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;
    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;
    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;
    exports3.timeDay = day;
    exports3.timeDays = days;
    exports3.timeFriday = friday;
    exports3.timeFridays = fridays;
    exports3.timeHour = hour;
    exports3.timeHours = hours;
    exports3.timeInterval = newInterval;
    exports3.timeMillisecond = millisecond;
    exports3.timeMilliseconds = milliseconds;
    exports3.timeMinute = minute;
    exports3.timeMinutes = minutes;
    exports3.timeMonday = monday;
    exports3.timeMondays = mondays;
    exports3.timeMonth = month;
    exports3.timeMonths = months;
    exports3.timeSaturday = saturday;
    exports3.timeSaturdays = saturdays;
    exports3.timeSecond = second;
    exports3.timeSeconds = seconds;
    exports3.timeSunday = sunday;
    exports3.timeSundays = sundays;
    exports3.timeThursday = thursday;
    exports3.timeThursdays = thursdays;
    exports3.timeTuesday = tuesday;
    exports3.timeTuesdays = tuesdays;
    exports3.timeWednesday = wednesday;
    exports3.timeWednesdays = wednesdays;
    exports3.timeWeek = sunday;
    exports3.timeWeeks = sundays;
    exports3.timeYear = year;
    exports3.timeYears = years;
    exports3.utcDay = utcDay;
    exports3.utcDays = utcDays;
    exports3.utcFriday = utcFriday;
    exports3.utcFridays = utcFridays;
    exports3.utcHour = utcHour;
    exports3.utcHours = utcHours;
    exports3.utcMillisecond = millisecond;
    exports3.utcMilliseconds = milliseconds;
    exports3.utcMinute = utcMinute;
    exports3.utcMinutes = utcMinutes;
    exports3.utcMonday = utcMonday;
    exports3.utcMondays = utcMondays;
    exports3.utcMonth = utcMonth;
    exports3.utcMonths = utcMonths;
    exports3.utcSaturday = utcSaturday;
    exports3.utcSaturdays = utcSaturdays;
    exports3.utcSecond = second;
    exports3.utcSeconds = seconds;
    exports3.utcSunday = utcSunday;
    exports3.utcSundays = utcSundays;
    exports3.utcThursday = utcThursday;
    exports3.utcThursdays = utcThursdays;
    exports3.utcTuesday = utcTuesday;
    exports3.utcTuesdays = utcTuesdays;
    exports3.utcWednesday = utcWednesday;
    exports3.utcWednesdays = utcWednesdays;
    exports3.utcWeek = utcSunday;
    exports3.utcWeeks = utcSundays;
    exports3.utcYear = utcYear;
    exports3.utcYears = utcYears;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// index.js
var import_dotenv2 = __toModule(require_main());
var import_discord2 = __toModule(require_src3());

// commands/index.js
var import_discord = __toModule(require_src3());

// commands/Command.js
var Command = class {
  constructor(name, alias = [], description = "") {
    this._name = name;
    if (Array.isArray(alias)) {
      this._alias = alias;
    } else {
      this._alias = [];
      if (typeof alias === "string") {
        description = alias;
      }
    }
    this._description = description;
  }
  get name() {
    return this._name;
  }
  get alias() {
    return this._alias;
  }
  get description() {
    return this._description;
  }
  execute(msg, args) {
    console.error("WARNING: Abstract Command.execute() called");
  }
};
var Command_default = Command;

// commands/scrummy/ping.js
var PingCommand = class extends Command_default {
  constructor() {
    super("!ping", "Ping the bot, responds with pong");
  }
  execute(msg, args) {
    msg.reply("pong");
  }
};
var ping = new PingCommand();
var ping_default = ping;

// commands/DBCommand.js
var import_debug2 = __toModule(require_src4());

// commands/DBCommandBase.js
var import_mongodb = __toModule(require_mongodb());
var import_dotenv = __toModule(require_main());
var import_debug = __toModule(require_src4());
var debug = import_debug.default("bot:db_command_base");
import_dotenv.default.config();
var PROD_DB_URL = `mongodb+srv://${process.env.DB_USER}:${process.env.DB_PW}@profberriercluster.zzyhu.mongodb.net/ScrummyData?retryWrites=true&w=majority`;
var DBCommandBase = class extends Command_default {
  constructor(name, alias, description) {
    super(name, alias, description);
    this.checkConnection();
  }
  async checkConnection() {
    if (!DBCommandBase.CLIENT_HANDLE && !DBCommandBase.CONNECTING) {
      DBCommandBase.CONNECTING = true;
      try {
        await DBCommandBase.connect();
      } catch (err) {
        console.error("Something went wrong during DB connection");
        console.error(err);
      }
      DBCommandBase.CONNECTING = false;
    }
  }
  static get db() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      throw new Error("Can't retrieve database handle, no connection to Server.");
    }
    return DBCommandBase.CLIENT_HANDLE.db("ScrummyData");
  }
  static connect() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      return new Promise((resolve, reject) => {
        const URL = false ? DEV_DB_URL : PROD_DB_URL;
        debug(`Connecting to MongoDB '${false ? "DEV server" : "PROD server"}'`);
        const connectPromise = import_mongodb.MongoClient.connect(URL, {useUnifiedTopology: true, useNewUrlParser: true});
        connectPromise.then((result) => {
          DBCommandBase.CLIENT_HANDLE = result;
          debug("Connected to database");
        }).catch((err) => {
          console.error("CRITICAL: Database connection failed");
          return reject(err);
        });
      });
    }
    debug("Reusing existing MongoDB connection");
    return Promise.resolve(DBCommandBase.CLIENT_HANDLE);
  }
  static disconnect() {
    if (!DBCommandBase.CLIENT_HANDLE) {
      return Promise.resolve(false);
    }
    return new Promise((resolve, reject) => {
      debug("Closing mongoDB database ...");
      const closePromise = DBCommandBase.CLIENT_HANDLE.close();
      closePromise.then(() => {
        DBCommandBase.CLIENT_HANDLE = null;
        debug("MongoDB connection closed.");
        return resolve(true);
      }).catch((err) => {
        debug("Failed to close MongoDB connection");
        debug(err);
        return reject(err);
      });
    });
  }
};
DBCommandBase.CLIENT_HANDLE = null;
DBCommandBase.CONNECTING = false;
var DBCommandBase_default = DBCommandBase;

// commands/DBCommand.js
var debug2 = import_debug2.default("bot:db_command");
var DBCommand = class extends DBCommandBase_default {
  checkIfUserExists(discordID) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").findOne({discordID}, (err, result) => {
        if (err) {
          debug2("Error checking for user");
          debug2(err);
          return reject(err);
        }
        if (!result) {
          return resolve(false);
        }
        return resolve(result._id);
      });
    });
  }
  createUser(discordID, discordName) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").insertOne({discordID, discordName}, (err, result) => {
        if (err) {
          debug2("Error creating user");
          debug2(err);
          return reject(err);
        }
        return resolve(result.insertedId);
      });
    });
  }
  getUserTimeCard(dbID, serverID) {
    return new Promise((resolve, reject) => {
      DBCommandBase_default.db.collection("Users").aggregate([
        {$match: {_id: dbID}},
        {
          $project: {
            timeCard: {
              $filter: {
                input: "$timeCard",
                as: "punch",
                cond: {$eq: ["$$punch.serverID", serverID]}
              }
            }
          }
        }
      ], (err, cursor) => {
        if (err || !cursor) {
          debug2("Error getting user's last punch");
          debug2(err);
          return reject(err);
        }
        cursor.toArray((err2, doc) => {
          if (err2) {
            debug2("Error converting to array");
            debug2(err2);
            return reject(err2);
          }
          if (!doc || !doc[0] || !doc[0].timeCard) {
            return resolve([]);
          }
          return resolve(doc[0].timeCard);
        });
      });
    });
  }
  getLastPunch(dbID, serverID) {
    return new Promise((resolve, reject) => {
      this.getUserTimeCard(dbID, serverID).then((timeCard) => {
        if (timeCard.length > 0) {
          return resolve(timeCard[timeCard.length - 1]);
        }
        return resolve({});
      }).catch((err) => {
        return reject(err);
      });
    });
  }
  punchUserTimeCard(dbID, serverID, punchStr) {
    return new Promise((resolve, reject) => {
      const punchObj = {serverID, punch: punchStr, time: new Date()};
      DBCommandBase_default.db.collection("Users").updateOne({_id: dbID}, {$push: {timeCard: punchObj}}, (err, result) => {
        if (err) {
          debug2("Error punching time card");
          debug2(err);
          return reject(err);
        }
        if (result.modifiedCount !== 1) {
          return reject(new Error("Time Card Punch failed to modify an entry"));
        }
        return resolve(true);
      });
    });
  }
};
var DBCommand_default = DBCommand;

// commands/util.js
var d3 = __toModule(require_d3_time());
var dateFormatter = Intl.DateTimeFormat("en-US", {
  weekday: "short",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric"
});
function formatDate(date) {
  return dateFormatter.format(date);
}
function formatDuration(start, end = Date.now()) {
  let minutes = start;
  if (typeof start === "object" && start instanceof Date) {
    minutes = minutesBetween(start, end);
  }
  return `${Math.floor(minutes / 60)}h ${minutes % 60}m`;
}
function minutesBetween(start, end = Date.now()) {
  return d3.timeMinute.range(start, end).length;
}
function mondaysBetween(start, end = Date.now()) {
  return d3.timeMonday.range(start, end).length;
}
function sumPunches(punches) {
  let minutes = 0;
  let lastPunchIn = 0;
  punches.forEach((entry) => {
    if (entry.punch === "in") {
      lastPunchIn = entry.time;
    } else {
      if (lastPunchIn instanceof Date) {
        minutes += minutesBetween(lastPunchIn, entry.time);
        lastPunchIn = 0;
      }
    }
  });
  if (lastPunchIn instanceof Date) {
    minutes += minutesBetween(lastPunchIn, Date.now());
  }
  return minutes;
}

// commands/scrummy/clockIn.js
var ClockInCommand = class extends DBCommand_default {
  constructor() {
    super("!clockin", ["!ci"], "Clock in and begin tracking your time");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      let dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply(`Creating new ScrummyBot entry for ${msg.author.tag}`);
        dbId = await this.createUser(msg.author.id, msg.author.tag);
      } else {
        const lastPunch = await this.getLastPunch(dbId, msg.guild.id);
        if (lastPunch.punch === "in") {
          msg.reply(`You already clocked in to this server on ${formatDate(lastPunch.time)}. Try !clockout first.`);
          return;
        }
      }
      msg.reply(`Clocking in for ${msg.author.username}`);
      await this.punchUserTimeCard(dbId, msg.guild.id, "in");
    } catch (err) {
      console.error("Error clocking in");
      console.error(err);
    }
  }
};
var clockIn = new ClockInCommand();
var clockIn_default = clockIn;

// commands/scrummy/clockOut.js
var ClockOutCommand = class extends DBCommand_default {
  constructor() {
    super("!clockout", ["!co"], "Clock out and stop tracking your time");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      let lastPunch = {};
      let dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply(`Creating new ScrummyBot entry for ${msg.author.tag}`);
        dbId = await this.createUser(msg.author.id, msg.author.tag, msg.guild.id);
      } else {
        lastPunch = await this.getLastPunch(dbId, msg.guild.id);
        if (lastPunch.punch === "out") {
          msg.reply(`You clocked out of this server on ${formatDate(lastPunch.time)}. Try !clockin first.`);
          return;
        }
      }
      msg.reply(`Clocking out for ${msg.author.username}.
You worked for ${formatDuration(lastPunch.time)}`);
      await this.punchUserTimeCard(dbId, msg.guild.id, "out");
    } catch (err) {
      console.error("Error clocking out");
      console.error(err);
    }
  }
};
var clockOut = new ClockOutCommand();
var clockOut_default = clockOut;

// commands/scrummy/status.js
var StatusCommand = class extends DBCommand_default {
  constructor() {
    super("!status", ["!stat", "!st"], "Report time tacking status for this server.");
  }
  async execute(msg, args) {
    if (!msg.guild) {
      msg.reply("This command only works in a specific server channel");
      return;
    }
    try {
      const dbId = await this.checkIfUserExists(msg.author.id);
      if (!dbId) {
        msg.reply("You haven't used ScrummyBot to track time yet. Try !clockin first.");
        return;
      }
      const timeCard = await this.getUserTimeCard(dbId, msg.guild.id);
      if (!timeCard || timeCard.length === 0) {
        msg.reply("You haven't clocked in on this server yet. Try !clockin first.");
        return;
      }
      let mondayIndex = timeCard.length - 1;
      while (mondayIndex > 0 && mondaysBetween(timeCard[mondayIndex].time) === 0) {
        mondayIndex--;
      }
      const timeCardWeek = timeCard.slice(mondayIndex + 1);
      let message = "";
      const lastPunch = timeCard[timeCard.length - 1];
      if (lastPunch.punch === "out") {
        message += `You are currently clocked out. You clocked out on ${formatDate(lastPunch.time)}.`;
      } else {
        message += `You are currently clocked in and have been working for ${formatDuration(lastPunch.time)}.`;
      }
      if (timeCardWeek.length === 0) {
        message += "\nYou have not clocked any hours since Monday.";
      } else {
        const minutesWeek = sumPunches(timeCardWeek);
        message += `
Since Monday, you have worked for ${formatDuration(minutesWeek)}`;
      }
      msg.reply(message);
    } catch (err) {
      console.error("Error reporting status");
      console.error(err);
    }
  }
};
var Status = new StatusCommand();
var status_default = Status;

// commands/index.js
var commands = [ping_default, clockIn_default, clockOut_default, status_default];
var BotCommands = new import_discord.default.Collection();
commands.forEach((cmd) => {
  BotCommands.set(cmd.name, cmd);
  cmd.alias.forEach((aliasName) => {
    BotCommands.set(aliasName, cmd);
  });
});
var commands_default = BotCommands;

// index.js
import_dotenv2.default.config();
var TOKEN = process.env.TOKEN;
var bot = new import_discord2.default.Client();
bot.login(TOKEN);
bot.commands = commands_default;
bot.on("ready", () => {
  console.info(`Logged in as ${bot.user.tag}!`);
});
bot.on("message", (msg) => {
  const args = msg.content.split(/\s+/);
  const command = args.shift().toLowerCase();
  if (!bot.commands.has(command))
    return;
  console.info(`Called command: ${command}`);
  try {
    bot.commands.get(command).execute(msg, args);
  } catch (error) {
    console.error(error);
    msg.reply("there was an error trying to execute that command!");
  }
});
